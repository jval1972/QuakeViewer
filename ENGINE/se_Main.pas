//------------------------------------------------------------------------------
//
//  Surfaces Engine (SE) - Gaming engine for Windows based on DirectX & DelphiX
//  Copyright (C) 1999-2004, 2018 by Jim Valavanis
//
//  This program is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation; either version 2
//  of the License, or (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, inc., 59 Temple Place - Suite 330, Boston, MA
//  02111-1307, USA.
//
// DESCRIPTION:
//  Surfaces Engine (SE) Main Classes
//
//------------------------------------------------------------------------------
//  E-Mail: jimmyvalavanis@yahoo.gr
//------------------------------------------------------------------------------

{$I defs.inc}

{
  Surfaces Engine (SE) Main Classes
  ---------------------------------
  TD3DScene: Main Object
  TD3DObject: Draw Object
  TD3DBaseSound: Sound Object

  The engine uses DirectDraw and DirectSound.
  Script Engine (ifs script, interpreted)

  (c) 1999-2004, Jim Valavanis
}


unit se_Main;

interface

uses
  Windows, Messages, Classes, Graphics, SysUtils, se_DXDraws,
  se_DXClasses,
{$IFNDEF NO_DXMESHES}
  se_DXMeshes,
{$ENDIF}
{$IFNDEF NO_D3DSOUNDS}
  se_DXSounds,
{$ENDIF}
{$IFNDEF NO_TEXTUREEFFECTS}
  se_DXTextureEffects,
{$ENDIF}
{$IFNDEF NO_DUKE3DSUPPORT}
  se_Duke3DTypes,
{$ENDIF}
{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_DOOMSUPPORT}
  se_DoomTypes,
{$ENDIF}
{$IFNDEF NO_QUAKESUPPORT}
  se_QuakeTypes,
{$ENDIF}
{$ENDIF}
  se_DirectX,
  se_D3DUtils, se_MyD3DUtils, se_WADS,
  binarydata, zLib,
  zBitmap, xWZ, JPEG, xGIF, pcximage, xPPM, xM8, xTGA, dibimage, xStubGraphic,
{$IFNDEF NO_D3DSOUNDS}
  se_DXWave, se_tonegen,
{$ENDIF}
{$IFNDEF NO_SCRIPTS}
  IfsPas, ifs_var,
{$ENDIF}
{$IFNDEF NO_D3DACTORS}
  se_DXModels,
{$ENDIF}
  Forms, Dialogs, ExtCtrls,
{$IFDEF DESIGNER}
  se_UndoMngr,
  se_DXDsngUtils,
{$ENDIF}
{$IFNDEF NO_AVI}
  se_SSAVI,
{$ENDIF}
  se_DXDUtils;

{$IFNDEF NO_D3DTEXTS}
{$R FONTDATA.RES}  // Font resources
{$ENDIF}

var
  D3DDXFVF_VERTEX: integer;

const
  flg_SingleSided = 0; // Single Sided (CULL_CCW)
  flg_DoubleSided = 1; // Double Sided
  flg_CullCW = 2; // Single Sided (CULL_CW)

// Surface types
  ID3D_All        = -1;
  ID3D_Abstract   =  0;
{$IFNDEF NO_D3DTRIANGLES}
  ID3D_Triangle   =  1;
{$ENDIF}
  ID3D_Quadrangle =  2;
{$IFNDEF NO_D3DSTUBOBJECTS}
  ID3D_StubObject =  3;
{$ENDIF}
  ID3D_Polygon    =  4;
{$IFNDEF NO_D3DEXOBJECTS}
  ID3D_ExObject   =  5;
{$ENDIF}
{$IFNDEF NO_D3DBILLBOARDS}
  ID3D_Billboard  =  6;
{$ENDIF}
  ID3D_Scene      =  7;
{$IFNDEF NO_D3DCUBES}
  ID3D_Cube       =  8;
{$ENDIF}
{$IFNDEF NO_D3DSPHERES}
  ID3D_Sphere     =  9;
{$ENDIF}
{$IFNDEF NO_D3DCONES}
  ID3D_Cone       =  10;
{$ENDIF}
{$IFNDEF NO_D3DCYLINDERS}
  ID3D_Cylinder   =  11;
{$ENDIF}
{$IFNDEF NO_D3DPLUGINS}
  ID3D_PlugIn     =  12;
{$ENDIF}
{$IFNDEF NO_D3DRINGS}
  ID3D_Ring       =  13;
{$ENDIF}
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
  ID3D_SectorCollection = 14;
{$ENDIF}
{$IFNDEF NO_D3DTEXTS}
  ID3D_Text       = 15;
{$ENDIF}
{$IFNDEF NO_D3DPROCEDURALOBJECTS}
  ID3D_ProceduralObject = 16;
{$ENDIF}
{$IFNDEF NO_D3DACTORS}
  ID3D_Actor = 17;
{$ENDIF}
{$IFNDEF NO_D3DEXTRARTLPOLYGONS}
  ID3D_ExtraRTLPolygon = 95;
{$ENDIF}
{$IFNDEF NO_D3DGENERICRTLPOLYGONS}
  ID3D_GenericRTLPolygon = 96;
{$ENDIF}
{$IFNDEF NO_D3DSTUBOBJECTS}
  {$IFNDEF NO_D3DEXOBJECTS}
  ID3D_ExObjectToStubObject = 97;
  {$ENDIF}
{$ENDIF}
  ID3D_GenericQuadrangle = 98;
  ID3D_GenericTriangle = 99;
  ID3D_MAXSURFACE =  100;
{$IFNDEF NO_D3DSOUNDS}
  ID3D_Sound      =  101;
  ID3D_Tone       =  102;
{$ENDIF}
  ID3D_Custom     =  201;
{$IFNDEF NO_SCRIPTS}
  ID3D_Script     =  202;
{$ENDIF}
  ID3D_Rotator    =  210;
  ID3D_Mover      =  211;
  ID3D_RotatorAround =  212;
  ID3D_Light      = 213;

  TmpFileName = 'MAP01';

  zoBilboard = 200000;
  zoSky = 100000;
  zoFloor = 95000;
  zoCeiling = 90000;

  // File version
  FILEVERSION_000: integer =   0;
  FILEVERSION_100: integer = 100;
  FILEVERSION_101: integer = 101;
  FILEVERSION_102: integer = 102;
  FILEVERSION_103: integer = 103;
  FILEVERSION_104: integer = 104;
  FILEVERSION_105: integer = 105;
  FILEVERSION_106: integer = 106;
  FILEVERSION_107: integer = 107;
  FILEVERSION_108: integer = 108;
  FILEVERSION_109: integer = 109;
  FILEVERSION_110: integer = 110;
  FILEVERSION_111: integer = 111;
  FILEVERSION_112: integer = 112;
  FILEVERSION_113: integer = 113;
  FILEVERSION_114: integer = 114;
  FILEVERSION_115: integer = 115;
  FILEVERSION_116: integer = 116;
  FILEVERSION_117: integer = 117;
  FILEVERSION_118: integer = 118;
  FILEVERSION_119: integer = 119;
  FILEVERSION_120: integer = 120;
{***Changes to FILEVERSION requieres changes to unitshelp.txt***}
  FILEVERSION    : integer = 120;

// Maximum number of Animated Textures for TD3DStubObject & TD3DPolygon
{$IFDEF QUAKEVIEWER}
  MAXTEXTURES = 2;
{$ELSE}
{$IFDEF TOMBVIEWER}
  MAXTEXTURES = 2;
{$ELSE}
{$IFDEF MD2VIEWER}
  MAXTEXTURES = 2;
{$ELSE}
{$IFDEF DOOMVIEWER}
  MAXTEXTURES = 32;
{$ELSE}
{$IFDEF DUKEVIEWER}
  MAXTEXTURES = 2;
{$ELSE}
  MAXTEXTURES = 192;
{$ENDIF}
{$ENDIF}
{$ENDIF}
{$ENDIF}
{$ENDIF}

// Maximum number of polygon vertexes
  MAXVERTEXES = 32767;

// Complexity for sphere's generation 
  MAXRINGS = 128;
  MAXSEGMENTS = 250;
// Complexity for ring's generation 
  MAXRINGRINGS = 160;
  MAXRINGSEGMENTS = 100;
// (2 * MAXRINGS * (MAXSEGMENTS + 1) - 1) -> must be < $FFFF,
// due to ::DrawPrimitive restriction

const
  rsVersion = '1.36';

type
  PCharArray = ^TCharArray;
  TCharArray = array[0..$FFFF] of char;

{$IFNDEF NO_D3DCONES}
  TD3DConeStyle = (csFull, csBottom, csTop);
{$ENDIF}

// csFull -> Whole cone
// csBottom -> Only buttom
// csTop -> Only the curved section

// textures uv
  TD3DConstantUVType = (cuv_XY, cuv_XZ, cuv_YZ);

const
// Maximum number of DrawPrimitive calls (with appropriate values of
// D3DRENDERSTATE_SRCBLEND & D3DRENDERSTATE_DESTBLEND) to draw the
// transparent effect. Using bigger values of MAXTRANSPARENCYREPLICATION,
// draws fully transparent objects, using the mask generated at construction 
  MAXTRANSPARENCYREPLICATION = 16;

const
  MAXFPSHISTORY = 32;

type
  TSceneFPSReporter = class(TObject)
  private
    fFPS: TD3DValue;
    fFPSArray: array[0..MAXFPSHISTORY - 1] of TD3DValue;
    icount: integer;
    fInitialized: boolean;
    function fCalcFPS(History: integer): TD3DValue;
  public
    constructor Create; virtual;
    procedure AddFPS(aFPS: TD3DValue);
    function FPS: TD3DValue;
  end;

type
  TAttachedEventInfo =  record
    ID: byte;
    Description: string;
    ProcName: string;
  end;

const
  ID3D_EVENTNONE = 0;
  ID3D_EVENTMAIN = 1;
  ID3D_EVENTONCREATE = 2;
  ID3D_EVENTONEXIT = 3;
  ID3D_EVENTONBEFOREDRAW = 4;
  ID3D_EVENTONAFTERDRAW = 5;
  ID3D_EVENTONBEFOREBEGINSCENE = 6;
  ID3D_EVENTONAFTERENDSCENE = 7;
  ID3D_EVENTONPOSITIONCHANGE = 8;
  ID3D_EVENTONROTATIONCHANGE = 9;
  AttachedEventsCount = 10;
  AttachedEventsTable: array[0..AttachedEventsCount - 1] of TAttachedEventInfo = (
    (ID: ID3D_EVENTNONE; Description: '--'; ProcName: ''),
    (ID: ID3D_EVENTMAIN; Description: 'Main programm'; ProcName: 'OnMain'),
    (ID: ID3D_EVENTONCREATE; Description: 'At scene creation'; ProcName: 'OnSceneCreate'),
    (ID: ID3D_EVENTONEXIT; Description: 'At scene Exit'; ProcName: 'OnSceneExit'),
    (ID: ID3D_EVENTONBEFOREDRAW; Description: 'Before drawing'; ProcName: 'OnSceneBeforeDraw'),
    (ID: ID3D_EVENTONAFTERDRAW; Description: 'After drawing'; ProcName: 'OnSceneAfterDraw'),
    (ID: ID3D_EVENTONBEFOREBEGINSCENE; Description: 'Before scene begin'; ProcName: 'OnSceneBeforeBeginScene'),
    (ID: ID3D_EVENTONAFTERENDSCENE; Description: 'After scene begin'; ProcName: 'OnSceneAfterEndScene'),
    (ID: ID3D_EVENTONPOSITIONCHANGE; Description: 'When view position changes'; ProcName: 'OnScenePositionChanged'),
    (ID: ID3D_EVENTONROTATIONCHANGE; Description: 'When view rotation changes'; ProcName: 'OnSceneRotationChanged'));

type
  PFutureProcInfo = ^TFutureProcInfo;
  TFutureProcInfo = record
    EventID: byte;
    TimeToExecute: double;
    ProcName: string;
  end;

  PFutureProcNode = ^TFutureProcNode;
  TFutureProcNode = record
    Proc: TFutureProcInfo;
    left, middle, right: PFutureProcNode;
  end;

  TFutureProcTree = PFutureProcNode;

  TFutureProcTreeEnum = procedure(Proc: TFutureProcInfo) of object;

function FutureProcTree_Create: TFutureProcTree;

procedure FutureProcTree_Insert(var Root: TFutureProcTree; const Proc: TFutureProcInfo);

procedure FutureProcTree_DeletePast(var Root: TFutureProcTree; Time: double; enum: TFutureProcTreeEnum);

procedure FutureProcTree_Destroy(var Root: TFutureProcTree);

type
  TFutureProcList = class(TObject)
  private
    fCount: integer;
    fDeleteEnum: TFutureProcTreeEnum;
    fRoot: TFutureProcTree;
    procedure fDeleteEnumInternal(Proc: TFutureProcInfo);
  public
    constructor Create(aDeleteEnum: TFutureProcTreeEnum); virtual;
    destructor Destroy; override;
    procedure Insert(const Proc: TFutureProcInfo); virtual;
    procedure Execute(const Time: double); virtual;
    procedure Clear; virtual;
    property Count: integer read fCount;
  end;

const
  rsBlack = '$black';
  rsWhite = '$white';
  rsGray1 = '$gray1';
  rsGray2 = '$gray2';
  rsGray3 = '$gray3';
  rsGray4 = '$gray4';
  rsGray5 = '$gray5';
  rsGray6 = '$gray6';
  rsGray7 = '$gray7';
  rsGray8 = '$gray8';
  rsGray9 = '$gray9';
  rsGray10 = '$gray10';
  rsGray11 = '$gray11';
  rsGray12 = '$gray12';
  rsGray13 = '$gray13';
  rsGray14 = '$gray14';
  rsGray15 = '$gray15';
  rsInvalid = '$invalid';
  rsParentDir = '..\';
  rsDefaultD3DExtention = '.D3D';
  rsD3DBackupExtention = '.~D3D';
  rsD3D = 'D3D';
  rsDefaultWADExtention = '.WAD';
  rsWADBackupExtention = '.~WAD';
{$IFNDEF NO_D3DACTORS}
  rsExtVrt = '.vrt';
{$ENDIF}
  rsTone = 'Tone';
{$IFNDEF NO_SCRIPTS}
  rsExtScript = '.ifs';
  rsExtPData = '.ifu';
{$ENDIF}
  rsFmtRC = '%s %s "%s"';
  rsRESWave = 'WAVE';
  rsRESModel = 'MODEL';
  rsRESData = 'DATA';
  rsSIGNATURE = 'D3DWORLD';
  rsInvalidGraphic = 'Unknown image type: %s';
  rsErrScriptEngineFree = 'Error: Unknown error while shutting down script engine.';
  rsFmtInvalidWAD = 'File %s is invalid';
  rsInvalidUVType = 'Internal Error: Texture UV is invalid!';

const
  rsGExtBMZ  = 'BMZ';
  rsGExtWZ1  = 'WZ1';
  rsGExtWZ2  = 'WZ2';
  rsGExtBMP  = 'BMP';
  rsGExtPPM  = 'PPM';
  rsGExtJPG  = 'JPG';
  rsGExtTIF  = 'TIF';
  rsGExtTIFF = 'TIFF';
  rsGExtJPEG = 'JPEG';
  rsGExtDIB  = 'DIB';
  rsGExtGIF  = 'GIF';
  rsGExtWMF  = 'WMF';
  rsGExtEMF  = 'EMF';
  rsGExtICO  = 'ICO';
  rsGExtPCX  = 'PCX';
  rsGExtM8   = 'M8';
  rsGExtTGA  = 'TGA';

  rsGExtWAD  = 'WAD';
//{$IFNDEF NO_IDSOFTGAMESSUPPORT}
  rsGExtPAK  = 'PAK';
  rsGExtBSP  = 'BSP';
  rsGExtPK3  = 'PK3';

  rsExtPAK  = '.pak';
  rsExtBSP  = '.bsp';
  rsExtMD2  = '.md2';
//{$ENDIF}

//{$IFNDEF NO_DUKE3DSUPPORT}
  rsGExtGRP  = 'GRP';
//{$ENDIF}

type
  TD3DTextureQuality = (tq100, tq50, tq25, tqDouble, tqOnlyColors, tqWireframe, tqPoint);
                       { 100%,  50%,   25%,    200%, color only  , lines only , points only}

// item #[0] is the actual Texture
// item #[1] is the mask
  PDirect3DTextures2 = ^TDirect3DTextures2;
  TDirect3DTextures2 = array[0..MAXTEXTURES - 1, 0..1] of TDirect3DTexture2;

  TDirect3DPictures = array[0..MAXTEXTURES - 1, 0..1] of TPicture;

// item #[0] is the actual Texture
// item #[1] is the mask
  PTextureNames = ^TTextureNames;
  TTextureNames = array[0..MAXTEXTURES - 1, 0..1] of string;

  TD3DLightType = (
    ltLinear, // Linear descease 
    ltFixed   // Fixed intensity
  );

  PD3DLightInfo = ^TD3DLightInfo;
  TD3DLightInfo = record
    Key: integer;            // Primary search key
    Color: TColor;           // ambient color
    Specular: TColor;        // specular color
    distance: TD3DValue;     // distance that the color applies
    SearchFactor:TD3DValue;  // search distance multiplier
    x, y, z: TD3DValue;      // position
    LightType: TD3DLightType;// type
  end;

  TD3DSceneLight = class(TPersistent)
  private
    fSearchDistance: TD3DValue;  // search distance
    fSearchDistance_sqr: TD3DValue;  // sqr of search distance
{$IFNDEF NO_OLDSTREAMINGRUTINES}
    procedure OldLoadFromStream(s: TStream; version: integer);
{$ENDIF}
  public
    Info: TD3DLightInfo;
    Enabled: boolean;
    constructor Create(aInfo: TD3DLightInfo);
    constructor CreateFromStream(s: TStream; version: integer);
    procedure ApplyToVertex(var v: TD3DLVertex; C: TColor);
    function IsAppliable(pos: TD3DVector): boolean;
    procedure SaveToStream(s: TStream); virtual;
    procedure LoadFromStream(s: TStream; version: integer); virtual;
    function GetTypeID: byte; virtual;  // Type
    function GetKeyID: integer; virtual;// שהיךע (key)
    function Description: string;
    procedure Move(vM: TD3DVector); overload; virtual;     
    procedure Move(x, y, z: TD3DValue); overload; virtual; 
  end;

  TOnAfterDXDrawEvent = procedure(aDXDraw: TDXDraw) of object;
  TOnBeforeDXDrawEvent = function(aDXDraw: TDXDraw): boolean of object;

const
  flag_GoingToDelete = 1;
  flag_NonAcceptMerge = 2;

type
// Base Abstract Class for each draw object
  TD3DObject = class(TPersistent)
  protected
{$IFNDEF NO_DXMESHES}
    fMesh: TRTLMesh;
    fMeshRenderProc: TRenderMeshProc;
{$ENDIF}
    fSafeMode: boolean;
    fDidDraw: boolean; // True if drawned
    fMustFreeTexture: boolean;
    Texture: array[0..1] of TDirect3DTexture2;
    Graphic: TPicture;
    fCulled: boolean; // do not draw if True
    fNeedsRadiusAndCenterRecalc: boolean;
    fRadius: TD3DValue;
    fCenter: TD3DVector;
{$IFNDEF NO_OBJECTDRAWINGNOTIFY}
    fOnBeforeDraw: TOnBeforeDXDrawEvent;
    fOnAfterDraw: TOnAfterDXDrawEvent;
{$ENDIF}
    fBoundingCube: TBoundingCube;
{$IFNDEF NO_TEXTUREEFFECTS}
    fTexEffect: TTextureEffect;
{$ENDIF}
{$IFNDEF NO_DXMESHES}
    fHasRenderMesh: boolean;
{$ENDIF}
    procedure fCalcCenterAndRadius; virtual; abstract;  // for ComputeSphereVisiblility
    procedure InitParams; virtual; abstract;
    function DefaultRTLQuery: boolean; virtual;
    procedure SetCulled(Value: boolean); virtual;
    procedure SetSafeMode(Value: boolean); virtual;
{$IFNDEF NO_DXMESHES}
    procedure AdjustMeshData; virtual;
{$ENDIF}
  public
    DXDraw: TDXDraw;
    RunTimeOnly: boolean;
    Saveable: boolean;
    Distance: TD3DValue;
    Tag: integer;
    Flags: integer;
    constructor Create(aDXDraw: TDXDraw; aTexture: TDirect3DTexture2); virtual;
    constructor CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTexture: TDirect3DTexture2; version: integer); virtual;
    destructor Destroy; override;
    function CanMergeWith(SurfaceType: byte; pInfo: Pointer): boolean; virtual;
    function MergeWith(SurfaceType: byte; pInfo: Pointer): boolean; virtual;
    function Top: TD3DValue; virtual;
    function Bottom: TD3DValue; virtual;
    function BoundingCube: TBoundingCube; virtual;
    function Radius: TD3DValue; virtual;  // for ComputeSphereVisiblility
    function Center: TD3DVector; virtual; // for ComputeSphereVisiblility
    procedure ReduceMemory; virtual;
    function IsIntersectWith(aObject: TD3DObject): boolean; overload; virtual;
    function IsIntersectWith(aRadius: TD3DValue; aCenter: TD3DVector): boolean; overload; virtual;
    function IsIntersectWith(aRadius: TD3DValue; aStart, aEnd: TD3DVector; var InterSectPoint: TD3DVector): boolean; overload; virtual;
    function GetTypeID: byte; virtual;  // Object type
    function GetKeyID: integer; virtual;// Primary key
    procedure DoDraw; virtual;
{$IFNDEF NO_DXMESHES}
    procedure DoDrawMesh; virtual;      // Draw
    procedure DoDrawMeshAtDevice(dev: IDirect3DDevice7); virtual;      // Draw
{$ENDIF}
    procedure Draw; virtual;            // Draw
    procedure Move(vM: TD3DVector); overload; virtual;
    procedure Move(x, y, z: TD3DValue); overload; virtual; 
    procedure MoveTo(vM: TD3DVector); overload; virtual;   
    procedure MoveTo(x, y, z: TD3DValue); overload; virtual;
    procedure Rotate(vM: TD3DVector); overload; virtual;   
    procedure Rotate(x, y, z: TD3DValue); overload; virtual;
    procedure GetTextureNames(var s: TDXStringList); virtual; abstract;
    function IsIdentical(D3DSurface: TObject): boolean; virtual; // Check similarity
    procedure SaveToStream(s: TStream); virtual;
    procedure LoadFromStream(s: TStream; version: integer); virtual;
    function CalcDistance(const Position: TD3DVector): TD3DValue; virtual; abstract;
    function TextureName: string; virtual; abstract;
    procedure GetInfo(p: Pointer); overload; virtual; abstract;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; virtual; abstract;
    procedure ApplyLight(l: TD3DSceneLight); virtual; abstract;
    procedure ApplyLights(s: TDXStringList); virtual;
    function Version: integer; virtual;
    function HasStubSurface: boolean; virtual;
    procedure GetCurrentTextures(var tex1, tex2:  TDirect3DTexture2); virtual;
{$IFNDEF NO_DXMESHES}
    function CanGetMesh: boolean; virtual;
{$ENDIF}
{$IFDEF DESIGNER}
    function CanSaveVertexes: boolean; virtual; abstract;
    procedure SaveVertexes(fName: string); virtual; abstract;
    function RTL_CanBeRuntime: boolean; virtual; abstract; // Can it be in runtime viewer? (code template)
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); virtual;
    procedure RTL_GetRunTimeCodeTemplate(
      out DeclareSession, InitSession, DrawSession, DoneSession: string;
      doTexture: boolean; var curCull: TD3DCull;
      tGlobalName: string;
      tVX: PD3DLVertexArray;
      tNumVertexes: integer;
      tCull: TD3DCULL;
      tPrimitive: TD3DPrimitiveType;
      ComplexityLevel: integer;
      ComplexityDistance: TD3DValue;
      Lights: TDXStringList;
      pVertexName: PString = nil;
      pTextureName: PString = nil); virtual;
{$ENDIF}
// Texture Effects
{$IFNDEF NO_TEXTUREEFFECTS}
    procedure ClearTextureEffect; virtual;
    procedure SetTextureAlphaEffect(const TE_ALPHA: TTextureAlphaEffect); virtual;
    procedure SetTextureStageEffect(const TE_STAGE: TTextureStageEffect); virtual;
{$ENDIF}
    // Stats
    function GetNumVertexes: integer; virtual; abstract;
    function GetNumTriangles: integer; virtual; abstract;
    property Culled: boolean read fCulled write SetCulled;
{$IFNDEF NO_OBJECTDRAWINGNOTIFY}
    // Before and After draw
    property OnBeforeDraw: TOnBeforeDXDrawEvent read fOnBeforeDraw write fOnBeforeDraw;
    property OnAfterDraw: TOnAfterDXDrawEvent read fOnAfterDraw write fOnAfterDraw;
{$ENDIF}
    property SafeMode: boolean read fSafeMode write SetSafeMode;
    property DidDraw: boolean read fDidDraw;
{$IFNDEF NO_DXMESHES}
    property Mesh: TRTLMesh read fMesh;
{$ENDIF}
{$IFNDEF NO_TEXTUREEFFECTS}
    property TexEffect: TTextureEffect read fTexEffect write fTexEffect;
{$ENDIF}
  end;

type
  TRTLPolygonDrawMethod = (rpd_Normal, rpd_Indexed);

{$IFNDEF NO_D3DGENERICRTLPOLYGONS}
type
  PGenericRTLPolygonInfo = ^TGenericRTLPolygonInfo;
  TGenericRTLPolygonInfo = record
    Key: integer;
    Vertexes: array[0..MAXVERTEXES - 1] of TD3DLVertex;
    NumVertexes: integer;
    Indices: packed array[0..MAXVERTEXES - 1] of word;
    PrimitiveType: TD3DPrimitiveType;
    VertexTypeDesc: DWORD;
    DrawMethod: TRTLPolygonDrawMethod;
    Texture1,
    Texture2: string;
  end;

  TD3DGenericRTLPolygon = class(TD3DObject)
  private
    fTextureName: string;
    fTextureName2: string;
    fNumVertexes: integer;
    fNumIndices: integer;
    fVertexes: PD3DLVertexArray;
    fIndices: PIndexesArray;
    fPrimitiveType: TD3DPrimitiveType;
    fVertexTypeDesc: DWORD;
    fDrawMethod: TRTLPolygonDrawMethod;
    fName: string;
  protected
    procedure InitParams; override;
    procedure fCalcCenterAndRadius; override;
    procedure SetNumVertexes(value: integer);
    procedure SetNumIndices(value: integer);
{$IFNDEF NO_DXMESHES}
    procedure AdjustMeshData; override;
{$ENDIF}
  public
    constructor Create(aDXDraw: TDXDraw; const aTexture: TDirect3DTexture2;
      const aTextureName: string); reintroduce; virtual;
    destructor Destroy; override;
    procedure SetTexture2(const aTextureName2: string; aTexture2: TDirect3DTexture2); overload; virtual;
    procedure SetTexture2(aTexture2: TDirect3DTexture2); overload; virtual;
    procedure ReduceMemory; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    procedure GetTextureNames(var s: TDXStringList); override;
    function CalcDistance(const Position: TD3DVector): TD3DValue; override;
    function TextureName: string; override;
    function TextureName2: string; virtual;
    procedure SetTextureName(const txname: string); virtual;
    procedure GetInfo(p: Pointer); override;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; override;
    procedure ApplyLight(l: TD3DSceneLight); override;
    function GetTypeID: byte; override;
    procedure Move(vM: TD3DVector); override;     
    procedure Rotate(vM: TD3DVector); override;   
{$IFDEF DESIGNER}
    function CanSaveVertexes: boolean; override;
    procedure SaveVertexes(fName: string); override;
    function RTL_CanBeRuntime: boolean; override;
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); override;
{$ENDIF}
    function GetNumVertexes: integer; override;
    function GetNumTriangles: integer; override;
    procedure Draw; override;            
    property NumVertexes: integer read fNumVertexes write SetNumVertexes;
    property NumIndices: integer read fNumIndices write SetNumIndices;
    property Vertexes: PD3DLVertexArray read fVertexes write fVertexes;
    property Indices: PIndexesArray read fIndices write fIndices;
    property PrimitiveType: TD3DPrimitiveType read fPrimitiveType write fPrimitiveType;
    property VertexTypeDesc: DWORD read fVertexTypeDesc write fVertexTypeDesc;
    property DrawMethod: TRTLPolygonDrawMethod read fDrawMethod write fDrawMethod;
    property Name: string read fName write fName;
  end;
{$ENDIF}

  TD3DTimingObject = class(TD3DObject)
  private
    Textures: TDirect3DTextures2;
    fTime: single; // for texture animation
    fStartTime: single;
  protected
  public
    constructor CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTexture: TDirect3DTexture2; version: integer); override;
    procedure GetCurrentTextures(var tex1, tex2:  TDirect3DTexture2); override;
    property  Time: single read fTime write fTime;
    property  StartTime: single read fStartTime write fStartTime;
    constructor Create(aDXDraw: TDXDraw; aTexture: TDirect3DTexture2); override;
    function CurTextureName: string; virtual; abstract;
    function CurTextureIndex: integer; virtual; abstract;
  end;

{$IFNDEF NO_D3DEXTRARTLPOLYGONS}
type
  PExtraRTLPolygonInfo = ^TExtraRTLPolygonInfo;
  TExtraRTLPolygonInfo = record
    Key: integer;
    Vertexes: array[0..MAXVERTEXES - 1] of TD3DLVertex;
    NumVertexes: integer;
    Indices: packed array[0..MAXVERTEXES - 1] of word;
    Cull: TD3DCull;
    PrimitiveType: TD3DPrimitiveType;
    VertexTypeDesc: DWORD;
    DrawMethod: TRTLPolygonDrawMethod;
    ddu, ddv: TD3DValue;
    interval: TD3DValue;
    NumTextures: integer;
    TextureNames: TTextureNames;
  end;

  TD3DExtraRTLPolygon = class(TD3DTimingObject)
  private
    fTextureNames: TTextureNames;
    fNumVertexes: integer;
    fNumIndices: integer;
    fVertexes: PD3DLVertexArray;
    fIndices: PIndexesArray;
    fPrimitiveType: TD3DPrimitiveType;
    fCull: TD3DCull;
    fVertexTypeDesc: DWORD;
    fDrawMethod: TRTLPolygonDrawMethod;
    fddu, fddv: TD3DValue;
    fInterval: TD3DValue;
    fName: string;
    fNumTextures: integer;
  protected
    procedure InitParams; override;
    procedure fCalcCenterAndRadius; override;
    procedure SetNumVertexes(value: integer); virtual;
    procedure SetNumIndices(value: integer); virtual;
    procedure SetTextureNames(value: TTextureNames); virtual;
    procedure CalcNumTextureNames; virtual;
{$IFNDEF NO_DXMESHES}
    procedure AdjustMeshData; override;
{$ENDIF}
  public
    constructor Create(aDXDraw: TDXDraw; const aTextures: TDirect3DTextures2;
      const aTextureNames: TTextureNames); reintroduce; virtual;
    constructor CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; version: integer);
      reintroduce; virtual;
    destructor Destroy; override;
    procedure ReduceMemory; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    procedure GetTextureNames(var s: TDXStringList); override;
    function CalcDistance(const Position: TD3DVector): TD3DValue; override;
    function TextureName: string; override;
    procedure GetInfo(p: Pointer); override;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; override;
    procedure ApplyLight(l: TD3DSceneLight); override;
    function GetTypeID: byte; override;
    procedure Move(vM: TD3DVector); override;
    procedure Rotate(vM: TD3DVector); override;
    function CurTextureName: string; override;
    function CurTextureIndex: integer; override;
{$IFDEF DESIGNER}
    function CanSaveVertexes: boolean; override;
    procedure SaveVertexes(fName: string); override;
    function RTL_CanBeRuntime: boolean; override;
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); override;
{$ENDIF}
    function GetNumVertexes: integer; override;
    function GetNumTriangles: integer; override;
    procedure Draw; override;           
    property NumVertexes: integer read fNumVertexes write SetNumVertexes;
    property NumIndices: integer read fNumIndices write SetNumIndices;
    property Vertexes: PD3DLVertexArray read fVertexes write fVertexes;
    property Indices: PIndexesArray read fIndices write fIndices;
    property PrimitiveType: TD3DPrimitiveType read fPrimitiveType write fPrimitiveType;
    property VertexTypeDesc: DWORD read fVertexTypeDesc write fVertexTypeDesc;
    property DrawMethod: TRTLPolygonDrawMethod read fDrawMethod write fDrawMethod;
    property Name: string read fName write fName;
    property TextureNames: TTextureNames read fTextureNames write SetTextureNames;
    property ddu: TD3DValue read fddu write fddu;
    property ddv: TD3DValue read fddv write fddv;
    property Interval: TD3DValue read fInterval write fInterval;
    property NumTextures: integer read fNumTextures;
    property Cull: TD3DCull read fCull write fCull;
  end;
{$ENDIF}


  TOnEndAnimation = procedure of object;
  TOnNewFrame = procedure(frame: string) of object;
  TOnEveryFrame = procedure(frame: string) of object;

  TD3DAnimatingObject = class(TD3DTimingObject)
  public
    OnEndAnimation: TOnEndAnimation;
    OnNewFrame: TOnNewFrame;
    OnEveryFrame: TOnEveryFrame;
    function SwitchToAnimation(anim: string): boolean; virtual; abstract;
    function CurrentAnimationDuration: double; virtual; abstract;
    constructor Create(aDXDraw: TDXDraw; aTexture: TDirect3DTexture2); override;
  end;

// Simple sprite
{$IFNDEF NO_D3DSTUBOBJECTS}
  PD3DStubObjectInfo = ^TD3DStubObjectInfo;
  TD3DStubObjectInfo = record
    Key: integer;          // Primary key
    x, y, z: single;       // Position
    Width, Height: single; // Dimentions
    zOrder: integer;
    C: TColor;
    Transparency: byte;
    NumTextures: SmallInt;
    Interval: single;
    SimpleRotation: boolean;
    u, v: single;
    du, dv: single;
    TextureNames: TTextureNames;
  end;

  TD3DStubObject = class(TD3DTimingObject)
  private
{$IFNDEF NO_OLDSTREAMINGRUTINES}
    procedure OldLoadFromStream(s: TStream; version: integer);
{$ENDIF}
  protected
    procedure InitParams; override;
    procedure fCalcCenterAndRadius; override;
  public
    Vertexes: array[0..3] of TD3DLVertex;
    Info: TD3DStubObjectInfo;
    constructor Create(aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; aInfo: TD3DStubObjectInfo); reintroduce; virtual;
    constructor CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; version: integer); reintroduce;
    procedure Draw; override;
    procedure Move(vM: TD3DVector); override;
    procedure Rotate(vM: TD3DVector); override;
    procedure GetTextureNames(var s: TDXStringList); override;
    function IsIdentical(D3DSurface: TObject): boolean; override;
    function GetTypeID: byte; override;
    function GetKeyID: integer; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    function CalcDistance(const Position: TD3DVector): TD3DValue; override;
    function TextureName: string; override;
    function CurTextureName: string; override;
    function CurTextureIndex: integer; override;
    procedure GetInfo(p: Pointer); override;
    procedure PerspectiveRotate(aPosition, aRotation: TD3DVector); virtual;
    procedure SimpleRotate(angle: single); virtual;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; override;
    procedure ApplyLight(l: TD3DSceneLight); override;
{$IFDEF DESIGNER}
    function CanSaveVertexes: boolean; override;
    procedure SaveVertexes(fName: string); override;
    function RTL_CanBeRuntime: boolean; override;
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); override;
{$ENDIF}
    function GetNumVertexes: integer; override;
    function GetNumTriangles: integer; override;
  end;
{$ENDIF}

{$IFNDEF NO_D3DEXOBJECTS}
  PD3DExObjectInfo = ^TD3DExObjectInfo;
  TD3DExObjectInfo = record
    Key: integer;
    x, y, z: single;
    angle: single;
    Width, Height: single;
    zOrder: integer;
    C: TColor;
    Transparency: byte;
    NumTextures: SmallInt;
    Interval: single;
    u, v: single;
    du, dv: single;
    TextureNames: TTextureNames;
    AnimStart, AnimEnd: char;
  end;

  TD3DExObject = class(TD3DAnimatingObject)
  private
    fVangle: single; // Observer's viewing angle
    fVPos: TD3DVector; // Observer's position
    fMirror: boolean;
    frameChar: char;
    fLastFrameChar: char;
    fLastFrameFromOtherAnimation: boolean;
{$IFNDEF NO_OLDSTREAMINGRUTINES}
    procedure OldLoadFromStream(s: TStream; version: integer);
{$ENDIF}    
  protected
    procedure InitParams; override;
    procedure fCalcCenterAndRadius; override;
  public
    Vertexes: array[0..3] of TD3DLVertex;
    Info: TD3DExObjectInfo;
    constructor Create(aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; aInfo: TD3DExObjectInfo); reintroduce; virtual;
    constructor CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; version: integer); reintroduce;
    procedure Draw; override;
    procedure Move(vM: TD3DVector); override;
    procedure Rotate(vM: TD3DVector); override;
    procedure GetTextureNames(var s: TDXStringList); override;
    function IsIdentical(D3DSurface: TObject): boolean; override;
    function GetTypeID: byte; override;
    function GetKeyID: integer; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    function CalcDistance(const Position: TD3DVector): TD3DValue; override;
    function TextureName: string; override;
    function CurTextureName: string; override;
    function CurTextureIndex: integer; override;
    function SwitchToAnimation(animStart, animEnd: char): boolean; reintroduce; overload; virtual;
    function SwitchToAnimation(anim: string): boolean; overload; override;
    function CurrentAnimationDuration: double; override;
    procedure GetInfo(p: Pointer); override;
    // SimpleRotate: No perspective
    procedure SimpleRotate(vPos: TD3DVector; vAngle: single); overload; virtual;
    procedure MakeTheVertexes; virtual;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; override;
    procedure ApplyLight(l: TD3DSceneLight); override;
{$IFDEF DESIGNER}
    function CanSaveVertexes: boolean; override;
    procedure SaveVertexes(fName: string); override;
    function RTL_CanBeRuntime: boolean; override;
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); override;
{$ENDIF}
    function GetNumVertexes: integer; override;
    function GetNumTriangles: integer; override;
  end;
{$ENDIF}

  PD3DGenericTriangleInfo = ^TD3DGenericTriangleInfo;
  TD3DGenericTriangleInfo = record
    Vertexes: array[0..2] of TD3DLVertex;
    TextureName: string;
  end;

// Triangle Strip
  PD3DGenericQuadrangleInfo = ^TD3DGenericQuadrangleInfo;
  TD3DGenericQuadrangleInfo = record
    Vertexes: array[0..3] of TD3DLVertex;
    TextureName: string;
  end;


{$IFNDEF NO_D3DTRIANGLES}
// Triangle
  PD3DTriangleInfo = ^TD3DTriangleInfo;
  TD3DTriangleInfo = record
    Key: integer;          // Primary key
    x1, y1, z1,
    x2, y2, z2,
    x3, y3, z3: single;
    zOrder: integer;
    flags: byte;
    u, v: single;
    du, dv: single;
    C: TColor;
    TextureName: string;
  end;

  TD3DSTriangle = class(TD3DObject)
  private
{$IFNDEF NO_OLDSTREAMINGRUTINES}
    procedure OldLoadFromStream(s: TStream; version: integer);
{$ENDIF}
  protected
    procedure InitParams; override;
    procedure fCalcCenterAndRadius; override;
{$IFNDEF NO_DXMESHES}
    procedure AdjustMeshData; override;
{$ENDIF}
  public
    pVertexes: PD3DLVertexArray;
    Vertexes: array[0..2] of TD3DLVertex;
    Info: TD3DTriangleInfo;
    constructor Create(aDXDraw: TDXDraw; aTexture: TDirect3DTexture2; aInfo: TD3DTriangleInfo); reintroduce; virtual;
    destructor Destroy; override;
    procedure MakeTheVertexes; virtual;
    procedure Draw; override;
    procedure Move(vM: TD3DVector); override;
    procedure Rotate(vM: TD3DVector); override;
    procedure GetTextureNames(var s: TDXStringList); override;
    function IsIdentical(D3DSurface: TObject): boolean; override;
    function GetTypeID: byte; override;
    function GetKeyID: integer; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    function CalcDistance(const Position: TD3DVector): TD3DValue; override;
    function TextureName: string; override;
    procedure GetInfo(p: Pointer); override;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; override;
    procedure ApplyLight(l: TD3DSceneLight); override;
{$IFDEF DESIGNER}
    function CanSaveVertexes: boolean; override;
    procedure SaveVertexes(fName: string); override;
    function RTL_CanBeRuntime: boolean; override;
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); override;
{$ENDIF}
    function GetNumVertexes: integer; override;
    function GetNumTriangles: integer; override;
  end;
{$ENDIF}

// Quad
  PD3DQuadrangleInfo = ^TD3DQuadrangleInfo;
  TD3DQuadrangleInfo = record
    Key: integer;          // Primary key
    x1, y1, z1,
    x2, y2, z2,
    x3, y3, z3,
    x4, y4, z4: single;
    zOrder: integer;
    flags: byte;
    u, v: single;
    du, dv: single;
    ddu, ddv: single; // scrolling animation
    C1, C2, C3, C4: TColor;
    Transparent: boolean;
    TextureName: string;
  end;

  TD3DQuadrAngle = class(TD3DTimingObject)
  private
{$IFNDEF NO_OLDSTREAMINGRUTINES}
    procedure OldLoadFromStream(s: TStream; version: integer);
{$ENDIF}
  protected
    procedure InitParams; override;
    procedure fCalcCenterAndRadius; override;
{$IFNDEF NO_DXMESHES}
    procedure AdjustMeshData; override;
{$ENDIF}
  public
    pVertexes: PD3DLVertexArray;
    Vertexes: array[0..3] of TD3DLVertex;
    Info: TD3DQuadrangleInfo;
    constructor Create(aDXDraw: TDXDraw; aTexture: TDirect3DTexture2; aInfo: TD3DQuadrangleInfo); reintroduce; virtual;
    destructor Destroy; override;
    procedure MakeTheVertexes; virtual;
    procedure Draw; override;
    procedure Move(vM: TD3DVector); override;
    procedure Rotate(vM: TD3DVector); override;
    procedure GetTextureNames(var s: TDXStringList); override;
    function IsIdentical(D3DSurface: TObject): boolean; override;
    function GetTypeID: byte; override;
    function GetKeyID: integer; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    function CalcDistance(const Position: TD3DVector): TD3DValue; override;
    function TextureName: string; override;
    procedure GetInfo(p: Pointer); override;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; override;
    procedure ApplyLight(l: TD3DSceneLight); override;
{$IFDEF DESIGNER}                  
    function CanSaveVertexes: boolean; override;
    procedure SaveVertexes(fName: string); override;
    function RTL_CanBeRuntime: boolean; override;
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); override;
{$ENDIF}
    function GetNumVertexes: integer; override;
    function GetNumTriangles: integer; override;
    function CurTextureName: string; override;
    function CurTextureIndex: integer; override;
  end;

const
  POLYGON_ALLOCATION_FACTOR = 512;

type
  PD3DPolygonInfo= ^TD3DPolygonInfo;
  TD3DPolygonInfo = record
    key: integer;       // Primary key
    C: TColor;
    u,v: single;
    du, dv: single;
    UseFlatUV: boolean;
    NumVertexes: SmallInt;
    NumTextures: SmallInt;
    zOrder: integer;
    Interval: single;  
    PrimitiveType: TD3DPrimitiveType;
    Transparency: byte;
    Cull: TD3DCull;
    Vertexes: array[0..MAXVERTEXES - 1] of TD3DVector;
    TextureNames: TTextureNames;
  end;

  TD3DPolygonInfo2 = record
    key: integer;      
    C: TColor;
    u,v: single;
    du, dv: single;
    UseFlatUV: boolean;
    NumVertexes: SmallInt;
    NumTextures: SmallInt;
    zOrder: integer;
    Interval: single;   
    PrimitiveType: TD3DPrimitiveType;
    Transparency: byte;
    Cull: TD3DCull;
    Vertexes: PD3DVectorArray;
    TextureNames: TTextureNames;
  end;

  PD3DPolygonInfoArray = ^TD3DPolygonInfoArray;
  TD3DPolygonInfoArray = array[0..MAXVERTEXES - 1] of PD3DPolygonInfo;

  TD3DPolygon = class(TD3DTimingObject)
  private
    fTessalationRoll: integer;
    fRealArraySize: integer;
    fNumVertexes: integer;
    LoadedRunTime: boolean;
    fMaxPolygonVertexes: integer;
{$IFNDEF NO_OLDSTREAMINGRUTINES}
    procedure OldLoadFromStream(s: TStream; version: integer);
{$ENDIF}
  protected
    procedure InitParams; override;
    function DefaultRTLQuery: boolean; override;
    procedure CreateVertexes(KeepUV: boolean = False); virtual;
    procedure fCalcCenterAndRadius; override;
{$IFNDEF NO_DXMESHES}
    procedure AdjustMeshData; override;
{$ENDIF}
  public
    TheVertexes: PD3DLVertexArray;
    Info2: TD3DPolygonInfo2;
    constructor Create(aDXDraw: TDXDraw; aTextures: TDirect3DTextures2;
      const aInfo: TD3DPolygonInfo); reintroduce; overload; virtual;
    constructor Create(aDXDraw: TDXDraw; const aVertexes: PD3DLVertexArray;
      const aNumVertexes: integer; const prtype: TD3DPrimitiveType;
      const aTexture: TDirect3DTexture2; const aTextureName: string); reintroduce; overload; virtual;
    constructor CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2;
      version: integer); reintroduce;
    destructor Destroy; override;
    procedure InfoToInfo2(const inf: TD3DPolygonInfo);
    procedure Info2ToInfo(var inf: TD3DPolygonInfo);
    function Tessalate: boolean; virtual;
    procedure Roll; virtual;
    procedure SizeNumVertexes(const NewSize: integer); virtual;
    procedure ReduceMemory; override;
    procedure Draw; override;
    procedure Move(vM: TD3DVector); override;
    procedure Rotate(vM: TD3DVector); override;
    procedure GetTextureNames(var s: TDXStringList); override;
    function IsIdentical(D3DSurface: TObject): boolean; override;
    function GetTypeID: byte; override;
    function GetKeyID: integer; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    function CurTextureName: string; override;
    function CurTextureIndex: integer; override;
    function CalcDistance(const Position: TD3DVector): TD3DValue; override;
    function TextureName: string; override;
    procedure GetInfo(p: Pointer); override;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; override;
    procedure GetSplitData(var A: PD3DPolygonInfoArray; var Count: integer);
    procedure ApplyLight(l: TD3DSceneLight); override;
{$IFDEF DESIGNER}
    function CanSaveVertexes: boolean; override;
    procedure SaveVertexes(fName: string); override;
    function RTL_CanBeRuntime: boolean; override;
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); override;
{$ENDIF}
    function GetNumVertexes: integer; override;
    function GetNumTriangles: integer; override;
    function ConvertToTriangleList: boolean; virtual;
    function CanMergeWith(SurfaceType: byte; pInfo: Pointer): boolean; override;
    function CanMergeWithPolygon(p: TD3DPolygon): boolean; virtual;
    function MergeWith(SurfaceType: byte; pInfo: Pointer): boolean; override;
    function MergeWithPolygon(const inf: TD3DPolygonInfo): boolean; overload; virtual;
    function MergeWithPolygon(const poly: TD3DPolygon): boolean; overload; virtual;
{$IFNDEF NO_D3DTRIANGLES}
    function MergeWithTriangle(const inf: TD3DTriangleInfo): boolean; virtual;
{$ENDIF}
    function MergeWithQuadrangle(const inf: TD3DQuadrangleInfo): boolean; virtual;
    function MergeWithGenericTriangle(const inf: TD3DGenericTriangleInfo): boolean; virtual;
    function MergeWithGenericQuadrangle(const inf: TD3DGenericQuadrangleInfo): boolean; virtual;
    function BoundingCube: TBoundingCube; override;
    property MaxPolygonVertexes: integer read fMaxPolygonVertexes write fMaxPolygonVertexes;
  end;

{$IFNDEF NO_D3DBILLBOARDS}
  PD3DBillBoardInfo = ^TD3DBillBoardInfo;
  TD3DBillBoardInfo = record
    key: integer;         
    C: TColor;
    StartH, EndH: single; // values in [0..1] - Horizont cover percent
    Interval: single;     
    zOrder: integer;
    NumTextures: SmallInt;
    TextureNames: TTextureNames;
  end;

  TD3DBillBoard = class(TD3DTimingObject)
  private
    fTexture: TBitmap;
    Textures: TDirect3DPictures;
    fAngle: single; // To avoid recreating the fTexture
{$IFNDEF NO_OLDSTREAMINGRUTINES}
    procedure OldLoadFromStream(s: TStream; version: integer);
{$ENDIF}
  protected
    procedure InitParams; override;
    procedure fCalcCenterAndRadius; override;
  public
    Info: TD3DBillBoardInfo;
    constructor Create(aDXDraw: TDXDraw; aTextures: TDirect3DPictures; aInfo: TD3DBillBoardInfo); reintroduce; virtual;
    constructor CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DPictures; version: integer); reintroduce;
    destructor Destroy; override;
    function IsIntersectWith(aObject: TD3DObject): boolean; override;
    function IsIntersectWith(aRadius: TD3DValue; aCenter: TD3DVector): boolean; override;
    procedure Draw; override;
    procedure GetTextureNames(var s: TDXStringList); override;
    function IsIdentical(D3DSurface: TObject): boolean; override;
    function GetTypeID: byte; override;
    function GetKeyID: integer; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    function CalcDistance(const Position: TD3DVector): TD3DValue; override;
    function TextureName: string; override;
    function CurTextureName: string; override;
    function CurTextureIndex: integer; override;
    procedure GetInfo(p: Pointer); override;
    procedure SimpleRotate(angle: single); virtual;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; override;
    procedure ApplyLight(l: TD3DSceneLight); override;
{$IFDEF DESIGNER}
    function CanSaveVertexes: boolean; override;
    procedure SaveVertexes(fName: string); override;
    function RTL_CanBeRuntime: boolean; override;
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); override;
{$ENDIF}
    function GetNumVertexes: integer; override;
    function GetNumTriangles: integer; override;
  end;
{$ENDIF}

{$IFNDEF NO_D3DCUBES}
  PD3DCubeInfo = ^TD3DCubeInfo;
  TD3DCubeInfo = record
    key: integer;                     
    C: TColor;                        
    u,v: single;                      
    du,dv: single;
    NumTextures: SmallInt;            
    zOrder: integer;
    Interval: single;
    x, y, z: TD3DValue;
    dx, dy, dz: TD3DValue;
    Width, Height, Depth: TD3DValue;  
    Transparency: byte;
    Cull: TD3DCull;
    VisibleSides: array[0..5] of boolean;
    TextureNames: TTextureNames;
  end;

  TD3DCube = class(TD3DTimingObject)
  private
{$IFNDEF NO_OLDSTREAMINGRUTINES}
    procedure OldLoadFromStream(s: TStream; version: integer);
{$ENDIF}
  protected
    procedure InitParams; override;
    procedure CreateVertexes; virtual;
    procedure fCalcCenterAndRadius; override;
  public
    TheVertexes: array[0..23] of TD3DLVertex;
    Info: TD3DCubeInfo;
    constructor Create(aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; aInfo: TD3DCubeInfo); reintroduce; virtual;
    constructor CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; version: integer); reintroduce;
    procedure Draw; override;
    procedure Move(vM: TD3DVector); override;
    procedure Rotate(vM: TD3DVector); override;
    procedure GetTextureNames(var s: TDXStringList); override;
    function IsIdentical(D3DSurface: TObject): boolean; override;
    function GetTypeID: byte; override;
    function GetKeyID: integer; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    function CurTextureName: string; override;
    function CurTextureIndex: integer; override;
    function CalcDistance(const Position: TD3DVector): TD3DValue; override;
    function TextureName: string; override;
    procedure GetInfo(p: Pointer); override;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; override;
    procedure ApplyLight(l: TD3DSceneLight); override;
{$IFDEF DESIGNER}
    function CanSaveVertexes: boolean; override;
    procedure SaveVertexes(fName: string); override;
    function RTL_CanBeRuntime: boolean; override;
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); override;
{$ENDIF}
    function GetNumVertexes: integer; override;
    function GetNumTriangles: integer; override;
  end;
{$ENDIF}

  TD3DVariableComplexityTimingObject = class(TD3DTimingObject)
  protected
    NumVertexes: integer;
    TheInitialVertexes: PD3DLVertexArray;
    procedure SetComplexityLevel(Curlevel, ComplexityLevel: integer); virtual; abstract;
    procedure SaveComplexityLevel; virtual;
    procedure RestoreComplexityLevel; virtual;
    function GetBoundFactor: TD3DValue; virtual; abstract; // for bounded rectangle
    procedure SizeNumVertexes(const NewSize: integer); virtual;
{$IFNDEF NO_DXMESHES}
    procedure AdjustMeshData; override;
{$ENDIF}    
  public
    TheVertexes: PD3DLVertexArray;
{$IFDEF DESIGNER}
    procedure RTL_GetRunTimeCodeTemplate(
      out DeclareSession, InitSession, DrawSession, DoneSession: string;
      doTexture: boolean; var curCull: TD3DCull;
      tGlobalName: string;
      tVX: PD3DLVertexArray;
      tNumVertexes: integer;
      tCull: TD3DCULL;
      tPrimitive: TD3DPrimitiveType;
      ComplexityLevel: integer;
      ComplexityDistance: TD3DValue;
      Lights: TDXStringList;
      pVertexName: PString = nil;
      pTextureName: PString = nil); override;
{$ENDIF}
    function GetNumVertexes: integer; override;
  end;

{$IFNDEF NO_D3DSPHERES}
  PD3DSphereInfo = ^TD3DSphereInfo;
  TD3DSphereInfo = record
    key: integer;                     
    C: TColor;                        
    u,v: single;                      
    du,dv: single;
    NumTextures: SmallInt;            
    zOrder: integer;
    Interval: single;                 
    x, y, z: TD3DValue;               
    dx, dy, dz: TD3DValue;            
    Width, Height, Depth: TD3DValue;  
    Transparency: byte;
    Cull: TD3DCull;
    NumRings, NumSegments: byte;
    TextureNames: TTextureNames;
  end;

  TD3DSphere = class(TD3DVariableComplexityTimingObject)
  private
    OriginalRings, OriginalSegs: byte;
{$IFNDEF NO_OLDSTREAMINGRUTINES}
    procedure OldLoadFromStream(s: TStream; version: integer);
{$ENDIF}
  protected
    procedure InitParams; override;
    procedure ApplyInfoToVertexes; virtual;
    procedure CreateInitialVertexes; virtual;
    procedure SetComplexityLevel(Curlevel, ComplexityLevel: integer); override;
    function GetBoundFactor: TD3DValue; override; // for bounded rectangle
    procedure fCalcCenterAndRadius; override;
  public
    Info: TD3DSphereInfo;
    constructor Create(aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; aInfo: TD3DSphereInfo); reintroduce; virtual;
    constructor CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; version: integer); reintroduce;
    destructor Destroy; override;
    procedure SetQuality(nRings, nSegments: byte);
    procedure GetQuality(var nRings, nSegments: byte);
    procedure Draw; override;
    procedure Move(vM: TD3DVector); override;
    procedure Rotate(vM: TD3DVector); override;
    procedure GetTextureNames(var s: TDXStringList); override;
    function IsIdentical(D3DSurface: TObject): boolean; override;
    function GetTypeID: byte; override;
    function GetKeyID: integer; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    function CurTextureName: string; override;
    function CurTextureIndex: integer; override;
    function CalcDistance(const Position: TD3DVector): TD3DValue; override;
    function TextureName: string; override;
    procedure GetInfo(p: Pointer); override;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; override;
    procedure ApplyLight(l: TD3DSceneLight); override;
{$IFDEF DESIGNER}
    function CanSaveVertexes: boolean; override;
    procedure SaveVertexes(fName: string); override;
    function RTL_CanBeRuntime: boolean; override;
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); override;
{$ENDIF}
    function GetNumVertexes: integer; override;
    function GetNumTriangles: integer; override;
  end;
{$ENDIF}

{$IFNDEF NO_D3DRINGS}
  PD3DRingInfo = ^TD3DRingInfo;
  TD3DRingInfo = record
    key: integer;                     
    C: TColor;                        
    u, v: single;                     
    du, dv: single;                   
    NumTextures: SmallInt;            
    zOrder: integer;
    Interval: single;                 
    x, y, z: TD3DValue;               
    dx, dy, dz: TD3DValue;            
    Width, Height, Depth: TD3DValue;  
    Transparency: byte;
    Cull: TD3DCull;
    UVType: TD3DConstantUVType;       
    InnerOuterFactor: TD3DValue;      // outer to inner factor
    NumRings, NumSegments: byte;      // complexity
    TextureNames: TTextureNames;
  end;

  TD3DRing = class(TD3DVariableComplexityTimingObject)
  private
    OriginalRings, OriginalSegs: byte;
  protected
    procedure InitParams; override;
    procedure ApplyInfoToVertexes; virtual;
    procedure CreateInitialVertexes; virtual;
    procedure SetComplexityLevel(Curlevel, ComplexityLevel: integer); override;
    function GetBoundFactor: TD3DValue; override; 
    procedure fCalcCenterAndRadius; override;
  public
    Info: TD3DRingInfo;
    constructor Create(aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; aInfo: TD3DRingInfo); reintroduce; virtual;
    constructor CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; version: integer); reintroduce;
    destructor Destroy; override;
    procedure SetQuality(nRings, nSegments: byte);
    procedure GetQuality(var nRings, nSegments: byte);
    procedure Draw; override;
    procedure Move(vM: TD3DVector); override;
    procedure Rotate(vM: TD3DVector); override;
    procedure GetTextureNames(var s: TDXStringList); override;
    function IsIdentical(D3DSurface: TObject): boolean; override;
    function GetTypeID: byte; override;
    function GetKeyID: integer; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    function CurTextureName: string; override;
    function CurTextureIndex: integer; override;
    function CalcDistance(const Position: TD3DVector): TD3DValue; override;
    function TextureName: string; override;
    procedure GetInfo(p: Pointer); override;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; override;
    procedure ApplyLight(l: TD3DSceneLight); override;
{$IFDEF DESIGNER}
    function CanSaveVertexes: boolean; override;
    procedure SaveVertexes(fName: string); override;
    function RTL_CanBeRuntime: boolean; override;
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); override;
{$ENDIF}
    function GetNumVertexes: integer; override;
    function GetNumTriangles: integer; override;
  end;
{$ENDIF}

{$IFNDEF NO_D3DCONES}
  PD3DConeInfo = ^TD3DConeInfo;
  TD3DConeInfo = record
    key: integer;                    
    C: TColor;                        
    u,v: TD3DValue;                 
    du,dv: TD3DValue;
    NumTextures: SmallInt;           
    zOrder: integer;
    Interval: single;                
    x, y, z: TD3DValue;             
    dx, dy, dz: TD3DValue;          
    Width, Height, Depth: TD3DValue; 
    Transparency: byte;
    Cull: TD3DCull;
    NumSegments: byte;
    Style: TD3DConeStyle;
    TextureNames: TTextureNames;
  end;

  TD3DCone = class(TD3DVariableComplexityTimingObject)
  private
    OriginalSegs: byte;
{$IFNDEF NO_OLDSTREAMINGRUTINES}
    procedure OldLoadFromStream(s: TStream; version: integer);
{$ENDIF}
  protected
    procedure InitParams; override;
    procedure ApplyInfoToVertexes; virtual;
    procedure CreateInitialVertexes; virtual;
    procedure SetComplexityLevel(Curlevel, ComplexityLevel: integer); override;
    function GetBoundFactor: TD3DValue; override; 
    procedure fCalcCenterAndRadius; override;
  public
    Info: TD3DConeInfo;
    constructor Create(aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; aInfo: TD3DConeInfo); reintroduce; virtual;
    constructor CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; version: integer); reintroduce;
    destructor Destroy; override;
    procedure SetQuality(nSegments: byte);
    procedure GetQuality(var nSegments: byte);
    procedure Draw; override;
    procedure Move(vM: TD3DVector); override;
    procedure Rotate(vM: TD3DVector); override;
    procedure GetTextureNames(var s: TDXStringList); override;
    function IsIdentical(D3DSurface: TObject): boolean; override;
    function GetTypeID: byte; override;
    function GetKeyID: integer; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    function CurTextureName: string; override;
    function CurTextureIndex: integer; override;
    function CalcDistance(const Position: TD3DVector): TD3DValue; override;
    function TextureName: string; override;
    procedure GetInfo(p: Pointer); override;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; override;
    procedure ApplyLight(l: TD3DSceneLight); override;
{$IFDEF DESIGNER}
    function CanSaveVertexes: boolean; override;
    procedure SaveVertexes(fName: string); override;
    function RTL_CanBeRuntime: boolean; override;
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); override;
{$ENDIF}
    function GetNumVertexes: integer; override;
    function GetNumTriangles: integer; override;
  end;
{$ENDIF}

{$IFNDEF NO_D3DCYLINDERS}
  PD3DCylinderInfo = ^TD3DCylinderInfo;
  TD3DCylinderInfo = record
    key: integer;                    
    C: TColor;        
    u,v: TD3DValue;   
    du,dv: TD3DValue;
    NumTextures: SmallInt; 
    zOrder: integer;
    Interval: single;         
    x, y, z: TD3DValue;             
    dx, dy, dz: TD3DValue;          
    Width, Height, Depth: TD3DValue;  
    Transparency: byte;
    Cull: TD3DCull;
    NumSegments: byte;
    DrawBottom,
    DrawTop,
    DrawCylinder: boolean;
    TextureNames: TTextureNames;
  end;

  TD3DCylinder = class(TD3DVariableComplexityTimingObject)
  private
    OriginalRings: byte;
{$IFNDEF NO_OLDSTREAMINGRUTINES}
    procedure OldLoadFromStream(s: TStream; version: integer);
{$ENDIF}    
  protected
    procedure InitParams; override;
    procedure ApplyInfoToVertexes; virtual;
    procedure CreateInitialVertexes; virtual;
    procedure SetComplexityLevel(Curlevel, ComplexityLevel: integer); override;
    function GetBoundFactor: TD3DValue; override; 
    procedure fCalcCenterAndRadius; override;
  public
    Info: TD3DCylinderInfo;
    constructor Create(aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; aInfo: TD3DCylinderInfo); reintroduce; virtual;
    constructor CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; version: integer); reintroduce;
    destructor Destroy; override;
    procedure SetQuality(nSegments: byte);
    procedure GetQuality(var nSegments: byte);
    procedure Draw; override;
    procedure Move(vM: TD3DVector); override;
    procedure Rotate(vM: TD3DVector); override;
    procedure GetTextureNames(var s: TDXStringList); override;
    function IsIdentical(D3DSurface: TObject): boolean; override;
    function GetTypeID: byte; override;
    function GetKeyID: integer; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    function CurTextureName: string; override;
    function CurTextureIndex: integer; override;
    function CalcDistance(const Position: TD3DVector): TD3DValue; override;
    function TextureName: string; override;
    procedure GetInfo(p: Pointer); override;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; override;
    procedure ApplyLight(l: TD3DSceneLight); override;
{$IFDEF DESIGNER}
    function CanSaveVertexes: boolean; override;
    procedure SaveVertexes(fName: string); override;
    function RTL_CanBeRuntime: boolean; override;
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); override;
{$ENDIF}
    function GetNumVertexes: integer; override;
    function GetNumTriangles: integer; override;
  end;
{$ENDIF}

{$IFNDEF NO_D3DTEXTS}
  PD3DTextInfo = ^TD3DTextInfo;
  TD3DTextInfo = record
    key: integer;                    
    frontC,
    backC: TColor;                   
    u, v: single;                     
    du, dv: single;                  
    backU, backV: single;            
    NumTextures: SmallInt;        
    zOrder: integer;
    Interval: single;               
    x, y, z: TD3DValue;              
    dx, dy, dz: TD3DValue;          
    Width, Height, Depth: TD3DValue;  
    Transparency: byte;
    ConnectBackWithFront: boolean;
    ItalicLevelH,                     // Italic factor (0.0 to 1.0) , 0.5 is normal
    ItalicLevelV: TD3DValue;
    filled: boolean;
    Text: string;
    TextureNames: TTextureNames;
  end;

  TD3DText = class(TD3DTimingObject)
  private
    NumVertexes: integer;
    TheInitialVertexes: PD3DLVertexArray;
    procedure SizeNumVertexes(const NewSize: integer); virtual;
{$IFNDEF NO_OLDSTREAMINGRUTINES}
    procedure OldLoadFromStream(s: TStream; version: integer);
{$ENDIF}    
  protected
    procedure InitParams; override;
    procedure ApplyInfoToVertexes; virtual;
    procedure CreateInitialVertexes; virtual;
    function GetText: string; virtual;
    procedure SetText(Value: string); virtual;
    procedure fCalcCenterAndRadius; override;
  public
    TheVertexes: PD3DLVertexArray;
    Info: TD3DTextInfo;
    constructor Create(aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; aInfo: TD3DTextInfo); reintroduce; virtual;
    constructor CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; version: integer); reintroduce;
    destructor Destroy; override;
    procedure Draw; override;
    procedure Move(vM: TD3DVector); override;
    procedure Rotate(vM: TD3DVector); override;
    procedure GetTextureNames(var s: TDXStringList); override;
    function IsIdentical(D3DSurface: TObject): boolean; override;
    function GetTypeID: byte; override;
    function GetKeyID: integer; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    function CurTextureName: string; override;
    function CurTextureIndex: integer; override;
    function CalcDistance(const Position: TD3DVector): TD3DValue; override;
    function TextureName: string; override;
    procedure GetInfo(p: Pointer); override;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; override;
    procedure ApplyLight(l: TD3DSceneLight); override;
{$IFDEF DESIGNER}
    function CanSaveVertexes: boolean; override;
    procedure SaveVertexes(fName: string); override;
    function RTL_CanBeRuntime: boolean; override;
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); override;
{$ENDIF}
    function GetNumVertexes: integer; override;
    function GetNumTriangles: integer; override;
    property Text: string read GetText write SetText;
  end;
{$ENDIF}

{$IFNDEF NO_D3DPLUGINS}
  PD3DPlugInInfo = ^TD3DPlugInInfo;
  TD3DPlugInInfo = record
    key: integer;         
    x, y, z: TD3DValue;   
    dx, dy, dz: TD3DValue;
    zOrder: integer;
    DLL: string;    
    Params: string;
    TextureName: string;
  end;

const
  rsDPlugIn_Initialize = 'DPlugIn_Initialize';
  rsDPlugIn_ReInitialize = 'DPlugIn_ReInitialize';
  rsDPlugIn_Finalize = 'DPlugIn_Finalize';
  rsDPlugIn_BeforeDraw = 'DPlugIn_BeforeDraw';
  rsDPlugIn_Draw = 'DPlugIn_Draw';
  rsDPlugIn_AfterDraw = 'DPlugIn_AfterDraw';
  rsDPlugIn_GetHelpText = 'DPlugIn_GetHelpText';
  rsDPlugIn_GetParamsText = 'DPlugIn_GetParamsText';
  rsDPlugIn_Move = 'DPlugIn_Move';
  rsDPlugIn_Rotate = 'DPlugIn_Rotate';
  rsDPlugIn_ApplyLight = 'DPlugIn_ApplyLight';
  rsDPlugIn_GetFriendlyName = 'DPlugIn_GetFriendlyName';
  rsDPlugIn_AcceptPosition = 'DPlugIn_AcceptPosition';
  rsDPlugIn_AcceptRotation = 'DPlugIn_AcceptRotation';
  rsDPlugIn_NotifyPosition = 'DPlugIn_NotifyPosition';
  rsDPlugIn_NotifyRotation = 'DPlugIn_NotifyRotation';
  rsDPlugIn_RequestResTexture = 'DPlugIn_RequestResTexture';
  rsDPlugIn_AcceptTexture = 'DPlugIn_AcceptTexture';
  rsDPlugIn_TransparentTexture = 'DPlugIn_TransparentTexture';
  rsDPlugIn_NeedsParams = 'DPlugIn_NeedsParams';
  rsDPlugIn_NeedsTexture = 'DPlugIn_NeedsTexture';
  rsDPlugIn_GetVertex = 'DPlugIn_GetVertex';
  rsDPlugIn_SetVertex = 'DPlugIn_SetVertex';
  rsDPlugIn_GetNumVertexes = 'DPlugIn_GetNumVertexes';
  rsDPlugIn_GetNumTriangles = 'DPlugIn_GetNumTriangles';
{$ENDIF}

type
  TD3DScene = class; // Forward declaration

{$IFNDEF NO_D3DPROCEDURALOBJECTS}
  PD3DProceduralObjectInfo= ^TD3DProceduralObjectInfo;
  TD3DProceduralObjectInfo = record
    key: integer;      
    zOrder: integer;
    Interval: single;
    PrimitiveType: TD3DPrimitiveType;
    Transparency: byte;
    Cull: TD3DCull;
    x, y, z: TD3DValue;               
    dx, dy, dz: TD3DValue;            
    NumTextures: SmallInt;
    TextureNames: TTextureNames;
    ModuleName: string;
  end;

  PD3DProceduralObject = ^TD3DProceduralObject;
  TD3DProceduralObject = class(TD3DTimingObject)
  private
    fNumVertexes: integer;
    fNumSpherePoints: integer;
  // If assigned we ignore script
    fProc: procedure; stdcall;
  protected
    fScene: TD3DScene;
    VertexIndex: integer;
    SpherePointIndex: integer;
    SpherePoints: P2DVectorArray;
    SpherePointsComplexity: integer;
    flatUVParam: string;
    procedure InitParams; override;
    function DefaultRTLQuery: boolean; override;
    procedure Execute; virtual;
    procedure fCalcCenterAndRadius; override;
  public
    TheVertexes: PD3DLVertexArray;
    Info: TD3DProceduralObjectInfo;
    constructor Create(aScene: TD3DScene; aTextures: TDirect3DTextures2; const aInfo: TD3DProceduralObjectInfo); reintroduce; virtual;
    constructor CreateFromStream(s: TStream; aScene: TD3DScene; aTextures: TDirect3DTextures2; version: integer); reintroduce;
    destructor Destroy; override;
    procedure StartVertexIndex(index: integer = 0); virtual;
    procedure StopVertexIndex; virtual;
    procedure StartSpherePointIndex(index: integer = 0); virtual;
    procedure StopSpherePointIndex; virtual;
    procedure ScaleX(fx: TD3DValue); virtual;
    procedure ScaleY(fy: TD3DValue); virtual;
    procedure ScaleZ(fz: TD3DValue); virtual;
    procedure Scale(fV: TD3DVector); overload; virtual;
    procedure Scale(fx, fy, fz: TD3DValue); overload; virtual;
    procedure MoveX(fx: TD3DValue); virtual;
    procedure MoveY(fy: TD3DValue); virtual;
    procedure MoveZ(fz: TD3DValue); virtual;
    procedure AddSpherePoint(v: T2DVector); virtual;
    procedure SizeNumSpherePoints(NewSize: integer); virtual;
    procedure AddVertex(v: TD3DLVertex); virtual;
    procedure SizeNumVertexes(const NewSize: integer); virtual;
    procedure Draw; override;
    procedure Move(vM: TD3DVector); override;
    procedure Rotate(vM: TD3DVector); override;
    procedure RotateX(dx: TD3DValue); virtual;
    procedure RotateY(dy: TD3DValue); virtual;
    procedure RotateZ(dz: TD3DValue); virtual;
    procedure GetTextureNames(var s: TDXStringList); override;
    function IsIdentical(D3DSurface: TObject): boolean; override;
    function GetTypeID: byte; override;
    function GetKeyID: integer; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    function CurTextureName: string; override;
    function CurTextureIndex: integer; override;
    function CalcDistance(const Position: TD3DVector): TD3DValue; override;
    function TextureName: string; override;
    procedure GetInfo(p: Pointer); override;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; override;
    procedure ApplyLight(l: TD3DSceneLight); override;
    procedure LoadVertexes(fName: string); virtual;
{$IFDEF DESIGNER}
    function CanSaveVertexes: boolean; override;
    procedure SaveVertexes(fName: string); override;
    function RTL_CanBeRuntime: boolean; override;
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); override;
{$ENDIF}
    function GetNumVertexes: integer; override;
    function GetNumTriangles: integer; override;
  end;
{$ENDIF}

{$IFNDEF NO_D3DPLUGINS}
  TD3DPlugIn = class(TD3DObject)
  private
    v: TD3DLVertex;
    ID: integer; // return value of DPlugIn_Initialize
  protected
    DLL_Instance: THandle;
    DPlugIn_Initialize: function(params: PChar): integer; stdcall;
    DPlugIn_ReInitialize: procedure(id: integer); stdcall;
    DPlugIn_Finalize: procedure(id: integer); stdcall;
    DPlugIn_Draw: procedure(id: integer; D3DDevice7: IDirect3DDevice7); stdcall;
    DPlugIn_BeforeDraw: procedure(id: integer; D3DDevice7: IDirect3DDevice7); stdcall;
    DPlugIn_AfterDraw: procedure(id: integer; D3DDevice7: IDirect3DDevice7); stdcall;
    DPlugIn_Move: procedure(id: integer; x, y, z: TD3DValue); stdcall;
    DPlugIn_Rotate: procedure(id: integer; x, y, z: TD3DValue); stdcall;
    DPlugIn_ApplyLight: procedure(id: integer; lC, lS: TD3DColor); stdcall;
    DPlugIn_GetFriendlyName: function(P: PChar): integer; stdcall;
    DPlugIn_AcceptPosition: procedure(id: integer; var x, y, z: TD3DValue); stdcall;
    DPlugIn_AcceptRotation: procedure(id: integer; var dx, dy, dz: TD3DValue); stdcall;
    DPlugIn_NotifyPosition: procedure(id: integer; x, y, z: TD3DValue); stdcall;
    DPlugIn_NotifyRotation: procedure(id: integer; dx, dy, dz: TD3DValue); stdcall;
    DPlugIn_RequestResTexture: function(id: integer; ResName: PChar): integer; stdcall;
    DPlugIn_AcceptTexture: procedure(id: integer; ResName: PChar; txtr: IDirectDrawSurface7); stdcall;
    DPlugIn_TransparentTexture: function(id: integer): boolean; stdcall;
    DPlugIn_GetVertex: function(id: integer; index: integer; var x, y, z: TD3DValue; var c, s: TD3DColor): boolean; stdcall;
    DPlugIn_SetVertex: function(id: integer; index: integer; x, y, z: TD3DValue; c, s: TD3DColor): boolean; stdcall;
    DPlugIn_GetNumVertexes: function(id: integer): integer; stdcall;
    DPlugIn_GetNumTriangles: function(id: integer): integer; stdcall;
    fTransparent: boolean;
    fScene: TD3DScene;
    procedure SetInvalid; virtual;
    procedure InitParams; override;
    procedure fCalcCenterAndRadius; override;
  public
    Info: TD3DPlugInInfo;
    constructor Create(aScene: TD3DScene; aTexture: TDirect3DTexture2; aInfo: TD3DPlugInInfo); reintroduce; virtual;
    constructor CreateFromStream(s: TStream; aScene: TD3DScene; aTexture: TDirect3DTexture2; version: integer); reintroduce;
    destructor Destroy; override;
    procedure BeforeDraw; virtual;
    procedure Draw; override;
    procedure AfterDraw; virtual;
    function ReInitialize: boolean; virtual;
    procedure Move(vM: TD3DVector); override;
    procedure Rotate(vM: TD3DVector); override;
    procedure GetTextureNames(var s: TDXStringList); override;
    function IsIdentical(D3DSurface: TObject): boolean; override;
    function GetTypeID: byte; override;
    function GetKeyID: integer; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    function CalcDistance(const Position: TD3DVector): TD3DValue; override;
    function TextureName: string; override;
    procedure GetInfo(p: Pointer); override;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; override;
    procedure ApplyLight(l: TD3DSceneLight); override;
    procedure AcceptPosition(var pos: TD3DVector); virtual;
    procedure AcceptRotation(var rot: TD3DVector); virtual;
    procedure NotifyPosition(pos: TD3DVector); virtual;
    procedure NotifyRotation(rot: TD3DVector); virtual;
    procedure LoadLibTextures; virtual;
{$IFDEF DESIGNER}
    function CanSaveVertexes: boolean; override;
    procedure SaveVertexes(fName: string); override;
    function RTL_CanBeRuntime: boolean; override;
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); override;
{$ENDIF}      
    function GetNumVertexes: integer; override;
    function GetNumTriangles: integer; override;
  end;
{$ENDIF}  

{$IFNDEF NO_D3DSOUNDS}
  TD3DBaseAudio = class(TPersistent)
  private
    fPosition : TD3DVector;
    fRotation : TD3DVector;
  protected
    procedure SetPosition(Value: TD3DVector); virtual;
    procedure SetRotation(Value: TD3DVector); virtual;
  public
    procedure SaveToStream(s: TStream); virtual; abstract;
    procedure LoadFromStream(s: TStream; version: integer); virtual; abstract;
    procedure Play; virtual; abstract;
    procedure Pause; virtual; abstract;
    procedure Stop; virtual; abstract;
    procedure Rewind; virtual; abstract;
    procedure Move(vM: TD3DVector); overload; virtual; abstract;
    procedure Move(x, y, z: TD3DValue); overload; virtual;
    procedure MoveTo(vM: TD3DVector); overload; virtual;
    procedure MoveTo(x, y, z: TD3DValue); overload; virtual;
    procedure Rotate(vM: TD3DVector); overload; virtual; abstract;
    procedure Rotate(x, y, z: TD3DValue); overload; virtual;
    property Position:TD3DVector read fPosition write SetPosition;
    property Rotation:TD3DVector read fRotation write SetRotation;
    function GetKeyID: integer; virtual;
    function GetTypeID: integer; virtual;
    function GetDistance(aPosition: TD3DVector): TD3DValue; virtual; abstract; // Distance from listener
  end;

  PD3DSoundInfo = ^TD3DSoundInfo;
  TD3DSoundInfo = record
    Key: integer;             
    x, y, z: TD3DValue;       
    DopplerEffectEnabled: boolean;
    SoundSpeed: TD3DValue;
    MaxHearAbility: TD3DValue; // max distance we can hear the sound
    Loop: boolean;
    Enabled: boolean;
    SoundName: string;
  end;

  TD3DSound = class(TD3DBaseAudio)
  protected
    fOriginalFrequence: integer;
    fOldDistance: TD3DValue;
    fDistance: TD3DValue;
    fOldTime: double;
    fStartTime: double;
    DXSound: TDXSound;
    procedure DoRecalc;
    function Time: Double;
    procedure SetPosition(Value: TD3DVector); override;
    procedure SetRotation(Value: TD3DVector); override;
  public
    Info: TD3DSoundInfo;
    Audio: TAudioStream;
    constructor Create(aDXSound: TDXSound; aWave: TWaveStream; aInfo: TD3DSoundInfo; muted: boolean=False); virtual;
    constructor CreateFromStream(s: TStream; aDXSound: TDXSound; aWave: TWaveStream; version: integer; muted: boolean=False); virtual;
    destructor Destroy; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    procedure Play; override;
    procedure Pause; override;
    procedure Stop; override;
    procedure Rewind; override;
    procedure Move(vM: TD3DVector); overload; override;
    procedure Rotate(vM: TD3DVector); overload; override;
    function GetKeyID: integer; override;
    function GetTypeID: integer; override;
    function GetDistance(aPosition: TD3DVector): TD3DValue; override; // listener distance
  end;

  PD3DToneInfo = ^TD3DToneInfo;
  TD3DToneInfo = record
    Key: integer;              
    x, y, z: TD3DValue;        
    MaxHearAbility: TD3DValue; 
    Loop: boolean;
    Enabled: boolean;
    Frequency: Smallint;
    Duration: Smallint;
    Waveform: TTGWave;
    Attack: Smallint;
    Decay: Smallint;
    Sustain: Smallint;
    Release: Smallint;
    Resolution: TTGResolution;
    Quality: TTGQuality;
  end;

  TD3DTone = class(TD3DBaseAudio)
  protected
    procedure SetPosition(Value: TD3DVector); override;
    procedure SetRotation(Value: TD3DVector); override;
  public
    Info: TD3DToneInfo;
    ToneGenerator: TToneGen;
    constructor Create(aInfo: TD3DToneInfo; muted: boolean=False); virtual;
    constructor CreateFromStream(s: TStream; version: integer; muted: boolean=False); virtual;
    destructor Destroy; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    procedure Play; override;
    procedure Pause; override;
    procedure Stop; override;
    procedure Rewind; override;
    procedure Move(vM: TD3DVector); overload; override;
    procedure Rotate(vM: TD3DVector); overload; override;
    function GetKeyID: integer; override;
    function GetTypeID: integer; override;
    function GetDistance(aPosition: TD3DVector): TD3DValue; override; 
    procedure Prepare; virtual;
  end;
{$ENDIF}

  PCustomDataInfo = ^TCustomDataInfo;
  TCustomDataInfo = record
    PathToStream: string;
    key: integer;
  end;

  TCustomData = class(TPersistent)
  private
    fStream: TStream;
    fInfo: TCustomDataInfo;
  public
    property Info: TCustomDataInfo read fInfo write fInfo;
    property Stream: TStream read fStream write fStream;
    constructor Create(aInfo: TCustomDataInfo; aStream: TStream); virtual;
    constructor CreateFromStream(s: TStream; aStream: TStream; aPathToStream: string; version: integer); virtual;
    procedure SaveToStream(s: TStream);
    procedure LoadFromStream(s: TStream; version: integer); virtual;
    function GetTypeID: byte; virtual;
    function GetKeyID: integer; virtual;
  end;

  PD3DScriptInfo = ^TD3DScriptInfo;
  TD3DScriptInfo = record
    PathToStream: string;
    AttachedEvent: word;
    key: integer;
  end;

{$IFNDEF NO_SCRIPTS}

  TIStatus = (iStopped, iRunning, iStepOver, iStepOverWaiting);

  TScript = class(TPersistent)
  private
    fText: AnsiString;
    fInfo: TD3DScriptInfo;
  public
    property Info: TD3DScriptInfo read fInfo write fInfo;
    property Text: AnsiString read fText write fText;
    constructor Create(aInfo: TD3DScriptInfo; var aStream: TStream); virtual;
    constructor CreateFromStream(s: TStream; aStream: TStream; version: integer); virtual;
    procedure SaveToStream(s: TStream); virtual;
    procedure LoadFromStream(s: TStream; version: integer); virtual;
    function GetTypeID: byte; virtual;
    function GetKeyID: integer; virtual;
  end;

// For the debuging & documentation information of TD3DSceneScriptEngine
// TTextStringList is a TDXStringList with objects as TDXStringList
// Class functions Text return the text of the TDXStringList as TTextStringList.Objects[..]
  TTextStringList = class(TDXStringList)
  public
    destructor Destroy; override;
    function AddText(s: string; t: string): boolean;
    function Text(i: integer): string; overload;
    function Text(s: string): string; overload;
  end;

  TD3DSceneScriptEngine = class(TIFPasScript)
  private
    fScene: TD3DScene;
    // For debug & documentation purposes
{$IFDEF DESIGNER}
    fVariablesDeclarations,
    fConstantsDeclarations,
    fFunctionsDeclarations,
    fClassFunctionsDeclarations,
    fTypesDeclarations,
    fTypesExDeclarations,
    fClassesDeclarations: TTextStringList;
{$ENDIF}
    fParent: TD3DSceneScriptEngine;
    fRequiredUses: TDXStringList;
    procedure DoRunCode(code: string);
    function PreProcessCode(var data: string): integer;
  protected
    function ProcessUses: Boolean; override;
  public
    LastLine: integer;
    Script: string;
    Yield: integer;
    property Scene: TD3DScene read fScene write fScene;
    constructor Create(id: Pointer; aScene: TD3DScene; aParent: TD3DSceneScriptEngine = nil); virtual;
    constructor CreateAttached(id: Pointer; aD3DSceneScriptEngine: TD3DSceneScriptEngine); virtual;
    destructor Destroy; override;
    procedure SetText(const Data: string); override;
    procedure RunUnit(name: string); virtual;
    procedure RunCode(code: string); virtual;
    procedure RunProcedure(procName: string; DispatchError: boolean); virtual;
    procedure StepOverUnit(name: string); virtual;
    procedure StepOverCode(code: string); virtual;
    procedure StopRun; virtual;
    procedure SyntaxCheckUnit(name: string); virtual;
    procedure SyntaxCheckCode(code: string); virtual;
    procedure RegisterIntegerConstants(const ModuleName: string);
{$IFDEF DESIGNER}
    function GetVariableValue(VarName: string): string;
    function GetVariableType(VarName: string): string;
    function GetConstantValue(VarName: string): string;
    function GetConstantType(VarName: string): string;
    // Adds to s the var declarations
    procedure GetVariablesDeclarations(s: TDXStringList); virtual;
    // Returns the s var declaration
    function GetVariableDeclaration(s: string): string;
    // Add to s the constants declarations
    procedure GetConstantsDeclarations(s: TDXStringList); virtual;
    // Returns the s const declaration
    function GetConstantDeclaration(s: string): string;
    // Add to s the declarations of procedures & functions
    procedure GetFunctionsDeclarations(s: TDXStringList); virtual;
    // Return the function s declaration
    function GetFunctionDeclaration(s: string): string;
    procedure GetClassFunctionsDeclarations(s: TDXStringList); virtual;
    // Adds to s the types declarations
    procedure GetTypesDeclarations(s: TDXStringList); virtual;
    // Return the data type s declaration
    function GetTypeDeclaration(s: string): string;
    procedure GetTypesExDeclarations(s: TDXStringList); virtual;
    // Adds to s the classes declarations
    procedure GetClassesDeclarations(s: TDXStringList); virtual;
    // Return the class s declaration
    function GetClassDeclaration(s: string): string;
    function AddVariable(Name, FType: string; Constant: Boolean): PIfVariant; override;
    function AddFunction(proc: Pointer; Decl: string; Ext: Pointer): PProcedure; override;
    function AddClassFunction(Proc: TRegisteredProcObject; Decl: string; Ext: Pointer): PProcedure; override;
    function AddType(const Name, Decl: string): PTypeRec; override;
    function AddTypeEx(const Name: string): PTypeRec; override;
    function AddClass(const Name, Decl: string; RegProc: Pointer): PTypeRec; override;
{$ENDIF}
  end;
{$ENDIF}

  PD3DSceneInfo = ^TD3DSceneInfo;
  TD3DSceneInfo = record
    Key: integer;       
    x, y, z: TD3DValue; 
    dx, dy, dz: TD3DValue; 
    PathToScene: string;       // must be last at Scene.LoadFromStream
  end;

{$IFNDEF NO_SCRIPTS}
  TOnScriptMessage = procedure(Sender: TObject; Message: string) of object;
  TOnScriptError = procedure(Sender: TObject;
    Module: string; ErrorPos: integer; ErrorString: string) of object;
  TOnRunLine = procedure(Sender: TObject; Position: integer) of object;
{$ENDIF}

  PD3DActionInfo = ^TD3DActionInfo;
  TD3DActionInfo = record
    ActionID: byte;  // Action type
    ActionKey: integer; // Action key
    ID: integer;     // data type
    Key: integer;    // data key
    PositionVector: TD3DVector;
    RotationVector: TD3DVector;
    Secs: double;  // move/rotate interval
    RunTimeOnly: boolean; // must be last (Hack, see TD3DAction.LoadFromStream & SaveToStream)
  end;

// Rotation object
  PD3DAction = ^TD3DAction;
  TD3DAction = class(TObject)
  protected
    fInfo: TD3DActionInfo;
    fOldTime: double; // last rotation time
    fScene: TD3DScene;
    fLastRotationVector: TD3DVector;
    fLastPositionVector: TD3DVector;
    factor: TD3DValue;              
    fHasExecute: boolean; // False only at the beginning
    function GetRunTime: boolean;
  public
    constructor Create(aInfo: TD3DActionInfo; aScene: TD3DScene);
    constructor CreateFromStream(s: TStream; aScene: TD3DScene; version: integer);
    function GetTypeID: integer; virtual;
    function GetKeyID: integer; virtual;
    procedure Execute; virtual;
    property RunTimeOnly: boolean read GetRunTime;
    procedure LoadFromStream(s: TStream; version: integer); virtual;
    procedure SaveToStream(s: TStream); virtual;
  end;

{$IFDEF DESIGNER}
  TOnSceneLoadFrom = procedure(Sender: TObject; const FileName: string; out AllowLoad: boolean) of object;
{$ENDIF}

  PD3DTessalationInfo = ^TD3DTessalationInfo;
  TD3DTessalationInfo = record
    NumVertexes: integer;
    TextureName: string;
    PrimitiveType: TD3DPrimitiveType;
    Cull: TD3DCull;
    Vertexes: array[0..MAXVERTEXES - 1] of TD3DLVertex;
  end;

  TD3DScene = class(TD3DObject)
  private
    fImageLoader: TImage;
    fDoSquareBitmaps: boolean;
    fPauseDelta: double;
    fPaused: boolean;
    fPausedStartTime: double;
    fLastMergeIndex: integer;
    fMaxPolygonVertexes: integer;
    FPSReporter: TSceneFPSReporter;
{$IFNDEF NO_D3DSOUNDS}
    fMute: boolean;
{$ENDIF}
    fModified: boolean;
{$IFNDEF NO_SCRIPTS}
    fOnScriptMessage: TOnScriptMessage;
    fOnScriptWarning,
    fOnScriptError: TOnScriptError;
    fOnRunLine: TOnRunLine;
    fEventsEnabled: boolean;
{$ENDIF}
    fNeedsRecalc: byte;
    fPosition: TD3DVector;    // current pos
    fOldPosition: TD3DVector; // last pos
    fOlderPosition: TD3DVector; // before last pos
    fRotation: TD3DVector;    // current rotation
    fOldRotation: TD3DVector; // last rotation
    fTextureQuality : TD3DTextureQuality;
    fOldTime: double;   // last draw time
    fLastTime: double;   // last Update time (<=>UpdateTolerance)
    fStartTime: double; // creation time
    fSpeed: double;
    fFileName: TFileName;
    fAttached: boolean; // True if is SubScene
    fThreadLevel: byte; // 0 in design mode and Application Thread
    fParent: TD3DScene;
    fIsDrawing: boolean; // True between BeginScene & EndScene
    fNearClippingPlane: TD3DValue;
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
    _CurrentSectorIndex: integer;
    _NeedsPositionRecalcFromSectorCollection: boolean;
    _CacheSectorCollections,
{$ENDIF}
    _CacheNestedScenes,
{$IFNDEF NO_D3DBILLBOARDS}
    _CacheBillBoards,
{$ENDIF}
{$IFNDEF NO_D3DPLUGINS}
    _CachePlugIns,
{$ENDIF}
    _CacheRotatingObjects: TDXStringList;
// update interval in secs
    fUpdateTolerance: double;
// frames/sec
    fFps: TD3DValue;
{$IFDEF DESIGNER}
    fOnSceneLoadFrom: TOnSceneLoadFrom;
    fOnSceneNotifyLoad: TNotifyEvent;
{$ENDIF}
  protected
    DXDraw: TDXDraw;
{$IFNDEF NO_D3DSOUNDS}
    DXSound: TDXSound;
    fForceWavesInMemory: boolean;
{$ENDIF}
    InvokeWAD: boolean; // True, if we open a WAD file
    InvokeResource: boolean; // True, if we open a D3D file from resource
    WAD: TWad;
{$IFDEF DESIGNER}
    UndoStack: TUndoStack;
    RedoStack: TRedoStack;
{$ENDIF}
{$IFNDEF NO_D3DPROCEDURALOBJECTS}
    CurrentProceduralObject: TD3DProceduralObject;
{$ENDIF}
{$IFNDEF NO_AVI}
    AVIPlayer: TSilleXAVI;
{$ENDIF}
{$IFNDEF NO_SCRIPTS}
    IsScriptStarting,
    IsScriptFinishing: boolean;
{$ENDIF}
    FutureProcList: array[0..AttachedEventsCount - 1] of TFutureProcList;
    procedure FutureProcEnum(Proc: TFutureProcInfo);
{$IFNDEF NO_AVI}
    procedure OnFreeAVIPlayer(sender: TObject);
{$ENDIF}
{$IFNDEF NO_GLOBALID}
    procedure AdjustGlobalID; virtual;
{$ENDIF}
    procedure SetPosition(Value: TD3DVector); virtual;
    procedure SetRotation(Value: TD3DVector); virtual;
    function GetPosition: TD3DVector; virtual;
    function GetRotation: TD3DVector; virtual;
    procedure SetTextureQuality(Value: TD3DTextureQuality); virtual;
    function LoadTexture(var TextureName: string): boolean; virtual;
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
    procedure AdjustSectorsPositioning(const oldpos: TD3DVector;
      var newPos: TD3DVector);
{$ENDIF}
{$IFNDEF NO_D3DSOUNDS}
    procedure SetMute(Value: boolean); virtual;
{$ENDIF}
{$IFNDEF NO_SCRIPTS}
    procedure SetEventsEnabled(Value: boolean); virtual;
{$ENDIF}
{$IFNDEF NO_MESSAGESCAN}
    procedure MessageScan; virtual; // To dispatch WM_SCENE_SETCURSOR & WM_PAINT messages
{$ENDIF}
    procedure OnWadProgress(Sender: TObject; Stage: TZProgressStage;
      PercentDone: Byte); virtual;
    procedure InitParams; override;
{$IFNDEF NO_SCRIPTS}
    procedure DoScriptMessage(Sender: TObject; Message: string); virtual;
    procedure DoScriptError(Sender: TObject;
      Module: string; ErrorPos: integer; ErrorString: string); virtual;
    procedure DoScriptWarning(Sender: TObject;
      Module: string; ErrorPos: integer; ErrorString: string); virtual;
    procedure DoRunLine(Sender: TObject; Position: integer); virtual;
{$ENDIF}
    function  GetIsDrawing: boolean; virtual;
    procedure SetNearClippingPlane(Value: TD3DValue);
    function GetFps: TD3DValue; // frames/sec, if attached, returns the parent's FPS
    function GetFpsSmooth: TD3DValue;
    procedure ClearCache; virtual;
    procedure SetCulled(Value: boolean); override;
    function GetThreadLevel: byte; virtual;
    procedure fCalcCenterAndRadius; override;
    procedure SetSafeMode(Value: boolean); override;
    procedure SetMaxPolygonVertexes(Value: integer); virtual;
  public
{$IFDEF DESIGNER}
    CanSaveUndo: boolean;
{$ENDIF}
{$IFNDEF NO_SCRIPTS}
    ScriptEngine: TD3DSceneScriptEngine;
    CurrentScriptEngine: TD3DSceneScriptEngine;
    iStatus: TIStatus;
{$ENDIF}
    Surfaces: TDXStringList;
    Textures: TDXStringList;
{$IFNDEF NO_D3DSOUNDS}
    Sounds: TDXStringList;
    Waves: TDXStringList;
{$ENDIF}
    CustomData: TDXStringList;
{$IFNDEF NO_SCRIPTS}
    Scripts: TDXStringList;
{$ENDIF}
    Streams: TDXStringList;
    SearchPaths: TDXStringList;
    Actions: TDXStringList;
    Lights: TDXStringList;
{$IFNDEF NO_D3DACTORS}
    Models: TDXStringList;
{$ENDIF}

    Info: TD3DSceneInfo;
    constructor Create(aDXDraw: TDXDraw; {$IFNDEF NO_D3DSOUNDS}aDXSound: TDXSound; {$ENDIF}aAttached: boolean = False); reintroduce; virtual;
    constructor CreateAttached(aInfo: TD3DSceneInfo; aScene: TD3DScene); virtual;
    destructor Destroy; override;
    procedure CreateCache; virtual;
    function AddToCache(const s: string; item: TObject): boolean; virtual;
    function GetExistedFileName(s: TFileName): TFileName; virtual;
    function GetExistedResourceEntry(s: TFileName): TFileName; virtual;
    function GetExistedWadEntry(s: TFileName): TFileName; virtual;
    procedure AddSearchPath(const PathName: string; const doPrime: boolean = False); virtual;
// Fog support
    procedure StopFog;
    function StartFog(color: TColor; Alfa: byte;
      fStart, fEnd: TD3DValue; fDensity: TD3DValue): boolean; // tries TABLE_EXP, TABLE_LINEAR and finally VERTEXFOG
    function StartVertexFog(color: TColor; Alfa: byte;
      fStart, fEnd: TD3DValue): boolean;
    function StartTableFog(color: TColor; Alfa: byte;
      fStart, fEnd: TD3DValue; fDensity: TD3DValue; mode: TD3DFogMode): boolean;
{$IFNDEF NO_AVI}
    function PlayAVI(const FileName: string): boolean;
    procedure StopAVI;
    function IsPlayingAVI: boolean;
{$ENDIF}
    procedure AddFutureProc(ProcName: string; EventID: byte;
      TimeDelta: double); virtual;

    function IsIntersectWith(aObject: TD3DObject): boolean; override;
    function IsIntersectWith(aRadius: TD3DValue; aCenter: TD3DVector): boolean; override;

    function ReplaceTexture(const index: integer; TextureName: string): boolean; overload; virtual;
    function ReplaceTexture(oldTextureName: string; TextureName: string): boolean; overload; virtual;
    function SearchDeepIndexOfTexture(const TextureName: string): integer;
    function GetNameForTexture(t: TDirect3DTexture2): string;
    function AddTextureToCollection(const TextureName: string; bmp: TBitmap):TDirect3DTexture2; overload; virtual;
    function AddTextureToCollectionFromGraphic(const TextureName: string; grp: TGraphic):TDirect3DTexture2; virtual;
    function AddDoom3TextureToCollection(var TextureName: string; doTransparent: boolean = True):TDirect3DTexture2; virtual;
    function AddTextureToCollection(var TextureName: string; doTransparent: boolean = True):TDirect3DTexture2; overload; virtual;
    function AddTextureToCollectionConst(TextureName: string; doTransparent: boolean = True):TDirect3DTexture2; virtual;
    function AddTexturesToCollection(var TextureNames: TTextureNames; doTransparent: boolean = True):TDirect3DTextures2; overload; virtual;
    function AddTexturesToCollection(var TextureName: string; doTransparent: boolean = True):TDirect3DTextures2; overload; virtual;
    procedure AddTexturesToCollection(TextureNames: TDXStringList; doTransparent: boolean = True); overload; virtual;
    function CacheDLLTexture(DllFileName: string; TextureName: string): TDirect3DTexture2; virtual;
    function GetDLLTextureBmp(DllFileName: string; TextureName: string): TBitmap; overload; virtual;
    function GetDLLTextureBmp(EntryName: string): TBitmap; overload; virtual;
{$IFNDEF NO_DUKE3DSUPPORT}
    function CacheDuke3DTextures(GRPFile: TFileName; TextureNames: TDXStringList;
      var sprdim: PDuke3DSprDimentions; doSquare: boolean = True;
      DIR: PDuke3DDirectories = nil; numEntries: integer = -1;
      lightboost: integer = 0): boolean; overload; virtual;
    function CacheDuke3DTextures(GRPFile: TFileName;
      pb: PBooleanArray; maxtex: integer;
      var sprdim: PDuke3DSprDimentions; doSquare: boolean = True;
      DIR: PDuke3DDirectories = nil; numEntries: integer = -1;
      lightboost: integer = 0): boolean; overload; virtual;
    function CacheDuke3DTextures(GRPFile: TFileName; TextureNames: TDXStringList;
      doSquare: boolean = True;
      DIR: PDuke3DDirectories = nil; numEntries: integer = -1;
      lightboost: integer = 0): boolean; overload; virtual;
    function CacheDuke3DTexture(GRPFile: TFileName; TextureName: string): boolean; virtual;
    function GetDuke3DTextureBmp(const EntryName: string): TBitmap; overload; virtual;
    function GetDuke3DTextureBmp(const GRPFile: string; const EntryName: string): TBitmap; overload; virtual;
{$ENDIF}
{$IFNDEF NO_IDSOFTGAMESSUPPORT}

{$IFNDEF NO_DOOMSUPPORT}
    function CacheIDWADTextures(MainWAD, PWAD: TFileName; TextureNames: TDXStringList;
      doSquare: boolean = True; {$IFNDEF DOOMVIEWER} defaultExt: string = ''; {$ENDIF}
      DIR: PDoomDirectory = nil; numEntries: integer = -1;
      wadType: TIDSoftWADType = idUnknown;
      lCachedTexturesInfo: PDoomTexturesInfo = nil; numCachedTextures: integer = -1;
      doompal: PDoomPalette = nil; doStubBmps: boolean = True): boolean; virtual;
    function CacheIDWADTexture(MainWAD: TFileName; TextureName: string; doSquare: boolean = True
      {$IFNDEF DOOMVIEWER}; defaultExt: string = '' {$ENDIF}): boolean; virtual;
    function GetIDWADTextureBmp(MainWAD: TFileName; TextureName: string): TBitmap; overload; virtual;
    function GetIDWADTextureBmp(EntryName: string): TBitmap; overload; virtual;
{$ENDIF}

{$IFNDEF NO_QUAKESUPPORT}
    function CacheIDPAKTextures(PAK: TFileName; TextureNames: TDXStringList;
      PakVer: integer = -1; BspVer: integer = -1;
      QDir: TPakDir = nil; defaultExt: string = ''): boolean; virtual;
    function CacheIDPAKTexture(PAK: TFileName; TextureName: string; defaultExt: string = ''): boolean; virtual;
    function GetIDPAKTextureBmp(PAK: TFileName; TextureName: string): TBitmap; overload; virtual;
    function GetIDPAKTextureBmp(EntryName: string): TBitmap; overload; virtual;
{$ENDIF}

{$ENDIF}
{$IFNDEF NO_TOMBRAIDERSUPPORT}
    function CacheTrTextures(MainLevel: TFileName; TextureNames: TDXStringList): boolean; virtual;
    function CacheTrTexture(MainLevel: TFileName; TextureName: string): boolean; virtual;
    function GetTrTextureBmp(MainLevel: TFileName; TextureName: string): TBitmap; overload; virtual;
    function GetTrTextureBmp(EntryName: string): TBitmap; overload; virtual;
{$ENDIF}

    function GetTextureBmp(EntryName: string): TBitmap; overload; virtual;
    function GetTextureBmp(EntryID: integer): TBitmap; overload; virtual;
{$IFNDEF NO_D3DBILLBOARDS}
    function AddPictureToCollection(var TextureName: string):TPicture; virtual;
    function AddPicturesToCollection(var TextureNames: TTextureNames):TDirect3DPictures; virtual;
{$ENDIF}
{$IFNDEF NO_D3DSOUNDS}
    function AddWaveToCollection(var SoundName: string; forceMemory: boolean = False):TWaveStream; virtual;
{$ENDIF}
{$IFNDEF NO_D3DACTORS}
    function AddModelToCollection(var ModelName: string): TModel; virtual; // return: TModel@@@@
{$ENDIF}
    function AddStreamToCollection(var StreamName: string):TStream; virtual;
    procedure GetTextureNames(var s: TDXStringList); override;
    procedure InitialMove(vM: TD3DVector); overload; virtual;   // only if fAttached at beginning and at script 
    procedure InitialRotate(vM: TD3DVector); overload; virtual; // only if fAttached at beginning and at script 
    procedure InitialMove(x, y, z: TD3DValue); overload; virtual;  // only if fAttached at beginning and at script 
    procedure InitialRotate(x, y, z: TD3DValue); overload; virtual; // only if fAttached at beginning and at script 
    procedure Move(vM: TD3DVector); override;
    procedure Rotate(vM: TD3DVector); override;
    procedure MoveObjects(ID, key: integer; x, y, z: TD3DValue); 
    procedure MoveObjectsTo(ID, key: integer; x, y, z: TD3DValue); 
    procedure RotateObjects(ID, key: integer; dx, dy, dz: TD3DValue); overload; // Rotate objects around their position
    procedure RotateObjectsAround(ID, key: integer; x, y, z: TD3DValue; dx, dy, dz: TD3DValue); // Rotate objects around the given point
    procedure MoveSurface(index: integer; x, y, z: TD3DValue); // Move object
    procedure RotateSurface(index: integer; dx, dy, dz: TD3DValue); // Rotate object around it's position
    procedure RotateSurfaceAround(index: integer; x, y, z: TD3DValue; dx, dy, dz: TD3DValue); // Rotate object around the given point
    procedure LoadFromStream(s: TStream; version: integer); override;
    procedure FastLoadFromStream(s: TStream); virtual; // Does not free textures
    procedure LoadFromResource(const resName: string); virtual;
{$IFNDEF NO_D3DPROCEDURALOBJECTS}
    procedure RunProceduralObjects; virtual;
    function GetCurrentProceduralObject: TD3DProceduralObject;
{$ENDIF}
    function GetFileVersion(fName: string): integer;
    procedure AppendFromStream(s: TStream;
      x: TD3DValue=0; y:TD3DValue=0; z: TD3DValue=0;
      dx: TD3DValue=0; dy:TD3DValue=0; dz: TD3DValue=0); virtual;
    procedure OldAppendFromStream(s: TStream;
      x: TD3DValue=0; y:TD3DValue=0; z: TD3DValue=0;
      dx: TD3DValue=0; dy:TD3DValue=0; dz: TD3DValue=0); virtual;
{$IFDEF DESIGNER}
    procedure TransferToDirectory(FileName: string; picExt: string); virtual;
{$ENDIF}
    procedure SaveToStream(s: TStream); override;
    procedure SaveSignatureToStream(s: TStream); virtual;
    procedure SaveTextureNamesToStream(s: TStream); virtual;
{$IFDEF DESIGNER}
    procedure SaveTextureNamesToDirectory(s: TStream; path: string; defExt: string = ''; doBackup: boolean = True); virtual;
{$ENDIF}
    procedure SaveDataToStream(s: TStream); virtual;
    procedure LoadFromFile(s: string); virtual;
    procedure AppendFromFile(s: string;
      x: TD3DValue=0; y:TD3DValue=0; z: TD3DValue=0;
      dx: TD3DValue=0; dy:TD3DValue=0; dz: TD3DValue=0); virtual;
    procedure SaveToFile(s: string); virtual;
    function LoadFrom(s: string): boolean; virtual;
    procedure LoadFromWADFile(s: string; map: string = TmpFileName); virtual;
    procedure LoadFromWADStream(strm: TStream; const pos, size: integer; map: string = TmpFileName); virtual;
    procedure GetDefaultWADEntries(s: TDXStringList); virtual;
    procedure GetNested3DEntries(s: TDXStringList); virtual;
    procedure SaveToWADFile(s: string; map: string = TmpFileName;
      cmp: TCompressionLevel = clDefault; EntriesToSave: TDXStringList = nil); virtual;
    procedure AppendToWADFile(s: string; map: string = TmpFileName;
      cmp: TCompressionLevel = clDefault; EntriesToSave: TDXStringList = nil); virtual;
    procedure AppendFromWADFile(s: string;
      x: TD3DValue=0; y:TD3DValue=0; z: TD3DValue=0;
      dx: TD3DValue=0; dy:TD3DValue=0; dz: TD3DValue=0;
      map: string = TmpFileName); virtual;
    function AddTessalatedPolygon(pInfo: PD3DTessalationInfo): TD3DObject; virtual;
    function MergeTessalation(pInfo: PD3DTessalationInfo): boolean; virtual;
    function MergeTriangeTessalation2(const inf: TD3DGenericTriangleInfo;
      const level: integer = 2): boolean; virtual;
    function MergeTriangeTessalation3(const inf: TD3DGenericTriangleInfo;
      const level: integer = 2): boolean; virtual;
    function MergeQuadTessalation4(const inf: TD3DGenericQuadrangleInfo;
      const level: integer = 2): boolean; overload; virtual;
    function MergeQuadTessalation4(const inf: TD3DGenericTriangleInfo;
      const v: TD3DLVertex; const idx: integer;
      const level: integer = 2): boolean; overload; virtual;
    function MergeQuadTessalationH(const inf: TD3DGenericTriangleInfo;
      const v: TD3DLVertex; const idx: integer;
      const level: integer = 2): boolean; overload; virtual;
    function MergeQuadTessalationH(const inf: TD3DGenericQuadrangleInfo;
      const level: integer = 2): boolean; overload; virtual;
    function MergePolygonTessalation(pInfo: PD3DPolygonInfo): boolean; virtual;
    function MergePolygonData(SurfaceType: byte; pInfo: Pointer): boolean; overload; virtual;
    function MergePolygonData(var d3dobj: TD3DObject): boolean; overload; virtual;
    function AddPolygonData(const aVertexes: PD3DLVertexArray; const aNumVertexes: integer;
      const prtype: TD3DPrimitiveType;
      const aTexturename: string; const aTexture: TDirect3DTexture2 = nil): TD3DObject;
    function MergePolygonData(const aVertexes: PD3DLVertexArray; const aNumVertexes: integer;
      const prtype: TD3DPrimitiveType;
      const aTexturename: string; const aTexture: TDirect3DTexture2 = nil): boolean; overload;
    function AddSurface(SurfaceType: byte; pInfo: Pointer): TD3DObject; overload; virtual;
    function AddSurface(obj: TD3DObject): TD3DObject; overload; virtual;
    procedure DeleteSurface(index: integer); virtual;
    function ReplaceSurface(index: integer; SurfaceType: byte; pInfo: Pointer): TD3DObject; virtual;
    procedure AddLight(pInfo: PD3DLightInfo); virtual;
    procedure DeleteLight(index: integer); virtual;
    procedure ReplaceLight(index: integer; pInfo: PD3DLightInfo); virtual;

    procedure AddAction(pInfo: PD3DActionInfo); virtual;
    procedure DeleteAction(index: integer); virtual;
    procedure DeleteActionByKey(key: integer); virtual;
    procedure ReplaceAction(index: integer; pInfo: PD3DActionInfo); virtual;
    procedure DeleteNonSaveAbleObjects; virtual;
    procedure DeleteRunTimeActions; virtual; // Clean up runtime actions that may be left from code

    procedure TessalatePolygon(index: integer;
      doDeleteSource: boolean = True; doRecalculate: boolean = True); virtual;
    procedure SplitPolygon(index: integer;
      doDeleteSource: boolean = True; doRecalculate: boolean = True); virtual;
    procedure SplitAllPolygons; virtual;
    procedure ReduceMemory; override;
{$IFNDEF NO_D3DSOUNDS}
    function  AddSound(pInfo: PD3DSoundInfo): TD3DSound; virtual;
    function  AddTone(pInfo: PD3DToneInfo): TD3DTone; virtual;
    procedure ReplaceSound(index: integer; pInfo: PD3DSoundInfo); virtual;
    procedure ReplaceTone(index: integer; pInfo: PD3DToneInfo); virtual;
    procedure DeleteSound(index: integer); virtual;
{$ENDIF}
    procedure AddCustomData(pInfo: PCustomDataInfo); virtual;
    procedure DeleteCustomData(index: integer); virtual;
    procedure ReplaceCustomData(index: integer; pInfo: PCustomDataInfo); virtual;
{$IFNDEF NO_SCRIPTS}
    procedure AddScript(pInfo: PD3DScriptInfo); virtual;
    procedure DeleteScript(index: integer); virtual;
    procedure ReplaceScript(index: integer; pInfo: PD3DScriptInfo); virtual;
{$ENDIF}
    procedure Clear; virtual;
    procedure FastClear; virtual; // does not free textures
    procedure New; virtual;
    procedure Reload; virtual;
    procedure OptimizeZOrder; virtual;
{$IFNDEF NO_D3DBILLBOARDS}
    procedure OptimizeBillBoards; virtual;
{$ENDIF}    
    function GetParentPositionVector: TD3DVector; virtual;
    function GetParentRotationVector: TD3DVector; virtual;
    function CalcDistance(const aPosition: TD3DVector): TD3DValue; override;
    procedure DrawWithBackColor(c: TColor); virtual;
    procedure Draw; override;
{$IFNDEF NO_DXMESHES}
    procedure DoDrawMesh; override;
{$ENDIF}    
    procedure ThreadDraw(level: byte = 1); virtual;
    procedure BeforeDraw; virtual;
    procedure AfterDraw; virtual;
    procedure ReInitialize; virtual;
    procedure DrawLoop; virtual;
    procedure RotateObjects; overload; virtual;
    procedure CalculateView; virtual;
    procedure CalculatePosition; virtual;
    // Make a Recalc request
    procedure ReCalc; virtual;
    // Perform the recalc request
    procedure DoReCalc; virtual;
    function NeedsRecalc: boolean; virtual;
    procedure ForceRecalc; virtual;
{$IFNDEF NO_D3DSOUNDS}
    procedure Update3DSounds; virtual;
{$ENDIF}
    procedure UpdateObjectsTime; virtual;
{$IFNDEF NO_D3DSOUNDS}
    procedure PauseSounds; overload; virtual;
    procedure RestartSounds; virtual;
{$ENDIF}
    procedure Pause; virtual;
    procedure Resume; virtual;
    function  Time: Double;
    procedure Locate(obj: TD3DObject; distance: TD3DValue); virtual;
    procedure GetInfo(p: Pointer); override;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; override;
    function DistanceFrom(aPos: TD3DVector): TD3DValue; overload; virtual;
    function DistanceFrom(aPosX, aPosY, aPosZ: TD3DValue): TD3DValue; overload; virtual;
    function AdjustImageDimentions(var w, h: integer): boolean;
    procedure MakeSquareBitmap(bmp: TBitmap; hasImage: boolean);
    procedure MakePowerOf2Bitmap(bmp: TBitmap);
    procedure MakePowerOf2BitmapFast(var bmp: TBitmap); overload;
    procedure MakePowerOf2BitmapFast(var tga: TTGABitmap); overload;
    function MakePowerOf2TGAToBitmap(var tga: TTGABitmap): TBitmap;
    function GetNewGraphicFromFileName(var NewGraphic: TGraphic; const fName: string): boolean;

    procedure SortSurfacesAtSize; virtual;
    procedure SortSurfacesAtKey; virtual;
    procedure SortSurfacesAtName; virtual;
    procedure SortSurfacesAtDistance; virtual;
{$IFNDEF NO_D3DSOUNDS}
    procedure SortSoundsAtKey; virtual;
    procedure SortSoundsAtName; virtual;
    procedure SortSoundsAtDistance; virtual;
{$ENDIF}
    procedure ForcePosition(Value: TD3DVector); virtual;
    procedure ForceRotation(Value: TD3DVector); virtual;

    procedure ReleaseUnusedObjects; virtual;
    procedure ReleaseUnusedTextures(const exclude: TDXStringList = nil); overload; virtual;
    procedure ReleaseUnusedTextures(const exclude: string); overload; virtual;
// Prepares a polygon sequence with TextureNames and set
// default values, so we can later call MergePolygonData
    procedure PrepareRTLOptimizer(TextureNames: TDXStringList;
      flatUV: boolean; Transparent: boolean; Cull: TD3DCull;
      doAddTextures: boolean = True); overload; virtual;
    function PrepareRTLOptimizer(var TextureName: string;
      flatUV: boolean; Transparent: boolean; Cull: TD3DCull;
      doAddTextures: boolean = True): TD3DObject; overload; virtual;

// The following functions add to list the objects with ID=key
// Return the number of objects added to the list
    function  GetObjects(key: integer; list: TList): integer; virtual;
{$IFNDEF NO_D3DSOUNDS}
    function  GetSounds(key: integer; list: TList): integer; virtual;
    function  GetTones(key: integer; list: TList): integer; virtual;
{$ENDIF}
{$IFNDEF NO_D3DSTUBOBJECTS}
    function  GetStubObjects(key: integer; list: TList): integer; virtual;
{$ENDIF}
{$IFNDEF NO_D3DEXOBJECTS}
    function  GetExObjects(key: integer; list: TList): integer; virtual;
{$ENDIF}    
{$IFNDEF NO_D3DTRIANGLES}
    function  GetTriangles(key: integer; list: TList): integer; virtual;
{$ENDIF}
    function  GetQuadrangles(key: integer; list: TList): integer; virtual;
    function  GetPolygons(key: integer; list: TList): integer; virtual;

{$IFNDEF NO_D3DPROCEDURALOBJECTS}
    function  GetProceduralObjects(key: integer; list: TList): integer; virtual;
    function SetCurrentPrObject(key: integer): boolean; virtual;
    function  GetCurrentPrObject: integer; virtual;
{$ENDIF}

{$IFNDEF NO_D3DCUBES}
    function  GetCubes(key: integer; list: TList): integer; virtual;
{$ENDIF}
{$IFNDEF NO_D3DSPHERES}
    function  GetSpheres(key: integer; list: TList): integer; virtual;
{$ENDIF}    
{$IFNDEF NO_D3DCONES}
    function  GetCones(key: integer; list: TList): integer; virtual;
{$ENDIF}
{$IFNDEF NO_D3DCYLINDERS}
    function  GetCylinders(key: integer; list: TList): integer; virtual;
{$ENDIF}
{$IFNDEF NO_D3DPLUGINS}
    function  GetPlugIns(key: integer; list: TList): integer; virtual;
{$ENDIF}
{$IFNDEF NO_D3DRINGS}
    function  GetRings(key: integer; list: TList): integer; virtual;
{$ENDIF}
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
    function  GetSectorCollections(key: integer; list: TList): integer; virtual;
{$ENDIF}
{$IFNDEF NO_D3DTEXTS}
    function  GetTexts(key: integer; list: TList): integer; virtual;
{$ENDIF}    
{$IFNDEF NO_SCRIPTS}
    function  GetScripts(key: integer; list: TList): integer; virtual;
    function  GetScriptUnitName(ScriptName: string): string;
    function  GetScriptText(UnitName: string): AnsiString;
    function  GetScriptPData(UnitName: string): AnsiString;
    function  ScriptTextExists(UnitName: string): boolean;
{$ENDIF}
    function  GetCustomData(key: integer; list: TList): integer; virtual;
{$IFNDEF NO_D3DBILLBOARDS}
    function  GetBillBoards(key: integer; list: TList): integer; virtual;
{$ENDIF}    
    function  GetScenes(key: integer; list: TList): integer; virtual;
    function  GetObjectsByID(ID: integer; key: integer; list: TList): integer; virtual;
    function  GetNumObjectsByID(ID: integer): integer; virtual;

    procedure ShowSurfaces(ID: integer; key: integer); virtual;
    procedure HideSurfaces(ID: integer; key: integer); virtual;

    function TextureName: string; override;
    function GetTypeID: byte; override;
    function GetKeyID: integer; override;

{$IFNDEF NO_SCRIPTS}
    procedure RunUnit(name: string); virtual;
    procedure RunCode(code: string); virtual;
    // run procedure
    procedure RunProcedure(procName: string; DispatchError: boolean); virtual;
     // run event
    procedure RunEvent(ID: integer; DispatchError: boolean); virtual;
    // run event at nested TD3DScenes
    procedure RunChildsEvent(ID: integer; DispatchError: boolean); virtual;
    procedure SyntaxCheckUnit(name: string); virtual;
    procedure SyntaxCheckCode(code: string); virtual;
    procedure StepOverUnit(name: string); virtual;
    procedure StepOverCode(code: string); virtual;
    procedure ScriptStopRun; virtual;
    procedure StartScriptEngine; virtual;
    procedure StopScriptEngine; virtual;
    procedure RestartScriptEngine; virtual;
{$ENDIF}

    procedure ApplyLight(l: TD3DSceneLight); override;
    procedure ApplyLights; reintroduce;

{$IFNDEF NO_D3DSOUNDS}
    procedure PlaySounds(fKey: integer); overload; virtual;
    procedure PlaySounds(fKey: integer; aPosition: TD3DVector); overload; virtual;
    procedure PauseSounds(fKey: integer); overload; virtual;
    procedure StopSounds(fKey: integer); overload; virtual;
    procedure RewindSounds(fKey: integer); overload; virtual;

    procedure PlaySounds(SoundName: string); overload; virtual;
    procedure PlaySounds(SoundName: string; aPosition: TD3DVector); overload; virtual;
    procedure PauseSounds(SoundName: string); overload; virtual;
    procedure StopSounds(SoundName: string); overload; virtual;
    procedure RewindSounds(SoundName: string); overload; virtual;

    procedure PlaySound(ASound: TD3DSound); overload; virtual;
    procedure PlaySound(ASound: TD3DSound; aPosition: TD3DVector); overload; virtual;
    procedure PauseSound(ASound: TD3DSound); virtual;
    procedure StopSound(ASound: TD3DSound); virtual;
    procedure RewindSound(ASound: TD3DSound); virtual;

    procedure PlayTones(fKey: integer); virtual;
    procedure PauseTones(fKey: integer); virtual;
    procedure StopTones(fKey: integer); virtual;
    procedure RewindTones(fKey: integer); virtual;
{$ENDIF}

    procedure PlayOldStyleSound(SoundName: string; doLoop: boolean = False); virtual;
    procedure StopOldStyleSound; virtual;

{$IFDEF DESIGNER}
    function CanSaveVertexes: boolean; override;
    procedure SaveVertexes(fName: string); override;
    function RTL_CanBeRuntime: boolean; override;
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); override;
    procedure RTL_GetRCEntries(Path, Prefix: string; ID: integer; var sl: TDXStringList); virtual;
    procedure RTL_CreateViewer(Path, Prefix: string; ID: integer; doProgramSource: boolean;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue); virtual;
    procedure RTL_CreatePlugIn(Path, Prefix: string); virtual;
{$ENDIF}

    function BoundingCube: TBoundingCube; override;
{$IFDEF DESIGNER}
    procedure ClearUndoRedo;
    procedure Undo;
    procedure Redo;
    function CanUndo: boolean;
    function CanRedo: boolean;
    procedure SaveUndo;
{$ENDIF}

{$IFNDEF NO_D3DSECTORCOLLECTIONS}
    property CurrentSectorIndex: integer read _CurrentSectorIndex;
    property CacheSectorCollections: TDXStringList read _CacheSectorCollections;
{$ENDIF}
    // Observer position
    property  Position: TD3DVector read GetPosition write SetPosition;
    // Observer last position
    property  OldPosition: TD3DVector read fOldPosition;
    // Observer rotation
    property  Rotation: TD3DVector read GetRotation write SetRotation;
    // Observer last rotation
    property  OldRotation: TD3DVector read fOldRotation;
    property  TextureQuality :TD3DTextureQuality read fTextureQuality write SetTextureQuality;
    property  OldTime: Double read fOldTime write fOldTime;
    property  Speed: double read fSpeed write fSpeed;
{$IFNDEF NO_D3DSOUNDS}
    property  Muted: boolean read fMute write SetMute;
    property  ForceWavesInMemory: boolean read fForceWavesInMemory write fForceWavesInMemory;
{$ENDIF}
    property  Modified: boolean read fModified write fModified;
    property  Attached: boolean read fAttached;
    property  FileName: TFileName read fFileName write fFileName;
{$IFNDEF NO_SCRIPTS}
    property  OnScriptMessage: TOnScriptMessage read fOnScriptMessage write fOnScriptMessage;
    property  OnScriptError: TOnScriptError read fOnScriptError write fOnScriptError;
    property  OnScriptWarning: TOnScriptError read fOnScriptWarning write fOnScriptWarning;
    property  OnRunLine: TOnRunLine read fOnRunLine write fOnRunLine;
{$ENDIF}
    property  StartTime: double read fStartTime;
{$IFNDEF NO_SCRIPTS}
    property  EventsEnabled: boolean read fEventsEnabled write SetEventsEnabled;
{$ENDIF}
    property  IsDrawing: boolean read GetIsDrawing write fIsDrawing;
    property  NearClippingPlane: TD3DValue read fNearClippingPlane write SetNearClippingPlane;
    property  UpdateTolerance: double read fUpdateTolerance write fUpdateTolerance;
    property  FPS: TD3DValue read GetFps;
    property  FPS_Smooth: TD3DValue read GetFpsSmooth;

    function  GetNumVertexes: integer; override;
    function  GetNumTriangles: integer; override;
    function  GetNumDrawnVertexes: integer; virtual;
    function  GetNumDrawnTriangles: integer; virtual;

{$IFDEF DESIGNER}
// Draws a point of where we are looking in distance = dist
    procedure DrawPointOfView(const dist: TD3DValue); virtual;
{$ENDIF}

    procedure CullSurfaces(const culldistance: TD3DValue); virtual;


    property ThreadLevel: byte read GetThreadLevel write fThreadLevel;
    property DoSquareBitmaps: boolean read fDoSquareBitmaps write fDoSquareBitmaps;
    property IsPaused: boolean read fPaused;
{$IFDEF DESIGNER}
    property OnSceneLoadFrom: TOnSceneLoadFrom read fOnSceneLoadFrom write fOnSceneLoadFrom;
    property OnSceneNotifyLoad: TNotifyEvent read fOnSceneNotifyLoad write fOnSceneNotifyLoad;
{$ENDIF}
    property MaxPolygonVertexes: integer read fMaxPolygonVertexes write SetMaxPolygonVertexes;
  end;

{$IFNDEF NO_D3DSECTORCOLLECTIONS}
  TSectorPoint = record
    x, y: TD3DValue;
    top, bottom: TD3DValue;
    topColor, bottomColor: TD3DColor;
  end;
  PSectorPoint = ^TSectorPoint;

  TSectorLineDef = record
    case integer of
      0: (
          start, _end: word;
          SideDef1, SideDef2: word;
          Transparent: boolean;
         );
      1: (
          start_end: integer;
          sidedefs: integer;
          foo: boolean;
         ); 
  end;

  PSectorLineDef = ^TSectorLineDef;

  TNavigationType = (ntStop, ntSlide, ntReflect);

{$IFDEF DOOMVIEWER}
const SCTEXTURELEN = 32;
{$ELSE}
const SCTEXTURELEN = 255;
{$ENDIF}

type
  TSectorSideDef = record
    xoff: TD3DValue; // X offset for texture
    yoff: TD3DValue; // Y offset for texture
    LineDef: word;
    Sector: word;
    NavigationType: TNavigationType;
    TexturePixelsPerUnit: TD3DValue;
    tex1,                       // texture name for the part above
    tex2,                       // texture name for the part below
    tex3: string[SCTEXTURELEN]; // texture name for the regular part
  end;

  PSectorSideDef = ^TSectorSideDef;

  TSector = record
    floorh, ceilh: TD3DValue;  // Floor & ceiling height
    floorC, ceilC: TD3DColor;  // Floor & ceiling color
  // If True we have a flat sector, otherwise the
  // floor and ceiling heights are caclulated from TSectorPoint
    AbsoluteFlat: boolean;
    floort, ceilt: string[SCTEXTURELEN];    // Floor & ceiling texture
    DrawSideDefs: boolean;                  // True if draws the sides
    AllowWalkThru: boolean;                 // True if we can allow navigatio inside it
    ifInsideCullOtherCollections: boolean;  //True we do not draw other sector collections if viewer is inside it
    GravityBehaviour: boolean;              // True if has gravity
    CheckFloorNavigation: boolean;          // True if checks the floor movement
    CheckCeilingNavigation: boolean;        // True if checks the ceiling movement
    CheckWallsNavigation: boolean;          // True if checks the walls movement
    MinDistanceFromFloor: TD3DValue;        //
    MinDistanceFromCeiling: TD3DValue;      //
    MinDistanceFromWalls: TD3DValue;        //
    BoundingCube: TBoundingCube;            // Bounding Cube (Calculated)
    SideStart,
    SideEnd: integer;                       // start and finish of TSideNavigationInfo
    SubSectorStart,
    SubSectorEnd: integer;                  // start and finish of subsectors (They are continous)
    TexturePixelsPerUnit: TD3DValue;
  end;
  PSector = ^TSector;

  PSectorPoints = ^TSectorPoints;
  TSectorPoints = array[0..$FFFE] of TSectorPoint;

  PSectorLineDefs = ^TSectorLineDefs;
  TSectorLineDefs = array[0..$FFFE] of TSectorLineDef;

  PSectorSideDefs = ^TSectorSideDefs;
  TSectorSideDefs = array[0..$FFFE] of TSectorSideDef;

  PSectors = ^TSectors;
  TSectors = array[0..$FFFE] of TSector;

// Created at runtime
// See GetSectorsLines, GetSectorLines, ...
  PSectorCollectionLine = ^TSectorCollectionLine;
  TSectorCollectionLine = record
    case integer of
      0: (
          start: word;    // from this vertex ...
          _end: word;     // ... to this vertex
          sector: word;   // The line's sector
          segment: word;  // line segment (for not continous sectors)
         );
      1: (
          start_end: integer;
          sector_segment: integer;);
  end;
  PSectorCollectionLines = ^TSectorCollectionLines;
  TSectorCollectionLines = array[0..$FFFE] of TSectorCollectionLine;
  PSectorCollectionLinesArray = ^TSectorCollectionLinesArray;
  TSectorCollectionLinesArray = record
    NumSectors: word;
    Sectors: array[0..$FFFE] of PSectorCollectionLines;
    NumSectorsLines: array[0..$FFFE] of integer;
  end;

  PD3DSectorCollectionInfo = ^TD3DSectorCollectionInfo;
  TD3DSectorCollectionInfo = record
    Key: integer;
    x, y, z: TD3DValue;
    dx, dy, dz: TD3DValue;
    // How many pixels of the texture equals a world distance unit
    TexturePixelsPerUnit: TD3DValue;

    // ֱסקיךע ךבי פוכיךע ךשהיךע בםפיךוילםשם נןץ ףקוהיזוי ן פןלבע
    // ּםן בם גסיףךלבףפו לףב פןץ ףקוהיזןץלו פב בםפיךולוםב לו ךשהיךן‎ע בנ
    // InsideDrawStart שע InsideDrawEnd, בם גסיףךלבףפו לףב ףו פןלב נןץ
    // בנןסנפוי פןץע ככןץע פןלוע (ifInsideCullOtherCollections = True)
    /// הום ףקוהיזןץלו פב בםפיךולוםב פשם ככשם ףץככןד‏ם לו ךשהיךן‎ע בנ
    // OutSideDrawStart שע OutSideDrawEnd
    InSideDrawStart, InSideDrawEnd: integer;
    OutSideDrawStart, OutSideDrawEnd: integer;

    CheckNavigation: boolean;
    DrawTheObjects: boolean;

    numPoints: word;
    Points: TSectorPoints;

    numLinedefs: word;
    LineDefs: TSectorLineDefs;

    numSideDefs: word;
    SideDefs: TSectorSideDefs;

    numSectors: word;
    Sectors: TSectors;
  end;

  PD3DSectorCollectionInfo2 = ^TD3DSectorCollectionInfo2;
  TD3DSectorCollectionInfo2 = record
    Key: integer;               // ׀סשפו‎ןם ךכויה בםבזפחףחע
    x, y, z: TD3DValue;         // ָףח
    dx, dy, dz: TD3DValue;      // ׀וסיףפסןצ

    // ׀ףוע ונבםבכרויע פןץ texture בםפיףפןיקן‎ם ףו לב לןםהב בנףפבףחע
    TexturePixelsPerUnit: TD3DValue;

    // ֱסקיךע ךבי פוכיךע ךשהיךע בםפיךוילםשם נןץ ףקוהיזוי ן פןלבע
    // ּםן בם גסיףךלבףפו לףב פןץ ףקוהיזןץלו פב בםפיךולוםב לו ךשהיךן‎ע בנ
    // InsideDrawStart שע InsideDrawEnd, בם גסיףךלבףפו לףב ףו פןלב נןץ
    // בנןסנפוי פןץע ככןץע פןלוע (ifInsideCullOtherCollections = True)
    /// הום ףקוהיזןץלו פב בםפיךולוםב פשם ככשם ףץככןד‏ם לו ךשהיךן‎ע בנ
    // OutSideDrawStart שע OutSideDrawEnd
    InSideDrawStart, InSideDrawEnd: integer;
    OutSideDrawStart, OutSideDrawEnd: integer;

    CheckNavigation: boolean;
    DrawTheObjects: boolean;

    numPoints: word;
    Points: PSectorPoints;

    numLinedefs: word;
    LineDefs: PSectorLineDefs;

    numSideDefs: word;
    SideDefs: PSectorSideDefs;

    numSectors: word;
    Sectors: PSectors;
  end;

// ׀כחסןצןסוע דיב פן navigation לףב ףפן sub sector
// sub sector -> טו sector קשסזופבי ףו subsectors פב ןנןב וםבי ךץספ
  PSubSectorNavigationInfo = ^TSubSectorNavigationInfo;
  TSubSectorNavigationInfo = record
    Sector: word;                             // װן index פןץ בםפףפןיקןץ sector
    BoundingCube: TBoundingCube;              // BoundingCube פחע טףחע פןץ subsector
    NumFloorTriangles: word;                  // ֱסיטלע פסיד‏םשם וכדקןץ נבפ‏לבפןע
    FloorTriangles: PD3DFloatTriangleArray;   // װסדשםב וכדקןץ נבפ‏לבפןע
    NumCeilingTriangles: word;                // ֱסיטלע פסיד‏םשם וכדקןץ נבפ‏לבפןע
    CeilingTriangles: PD3DFloatTriangleArray; // װסדשםב וכדקןץ נבפ‏לבפןע
  end;
  PSubSectorNavigationInfos = ^TSubSectorNavigationInfos;
  TSubSectorNavigationInfos = array[0..$FFFE] of TSubSectorNavigationInfo;

  PSideNavigationInfo = ^TSideNavigationInfo;
  TSideNavigationInfo = record
    sector: word;                     // ֱםפףפןיקןע פןלבע
    start,
    _end: TFloatPoint;
    NavigationType: TNavigationType;
    BoundingRect: TFloatRect;         // BoundingRect פחע טףחע פחע נכוץסע
  end;
  PSideNavigationInfos = ^TSideNavigationInfos;
  TSideNavigationInfos = array[0..$FFFE] of TSideNavigationInfo;

  TD3DSectorCollection = class(TD3DScene)
  protected
  // ֱם ח נבסבךפש לופבגכחפ וםבי True, פפו ףקוהיזןץלו לםן פחם ףץככןד,
  // ךבי פב בםפיךולוםב לו ךשהיך InsideDrawStart שע InsideDrawEnd
  // ֱם גדן‎לו וךפע ףץככןדע וםפוכ‏ע הום ףקוהיזןץלו פב InsideDrawStart שע InsideDrawEnd
    fIsInsideClosedSector: boolean;
    fIsInsideSector: boolean;
//    fBoundingCube: TBoundingCube;                   // BoundingCube פחע ףץככןדע
    fSideNavigationInfos: PSideNavigationInfos;
    fNumSides: integer;
    fSubSectorNavigationInfos: PSubSectorNavigationInfos; // ׀כחסןצןסוע navigation דיב פןם ךטו subsector
    fNumSubSectors: integer;
    fNeedsAcceptRotationY: boolean;
    fNewRotationY: TD3DValue;
    fGravityVelocity: TD3DValue;
    procedure MakeTheSurfaces; virtual;
{$IFNDEF NO_OLDSTREAMINGRUTINES}
    procedure OldLoadFromStream(s: TStream; version: integer);
    procedure OldLoadFromStream2(s: TStream; version: integer);
{$ENDIF}
    procedure PreCreate; virtual;
    procedure SetCulled(Value: boolean); override;
    procedure SetIsInsideClosedSector(Value: boolean); virtual;
    procedure SetIsInsideSector(Value: boolean); virtual;
    procedure fCalcCenterAndRadius; override;
  public
    CurrentSector: integer;
    Info2: TD3DSectorCollectionInfo2;
    gravityFactor: TD3DValue;
    constructor Create(aInfo: TD3DSectorCollectionInfo2; aScene: TD3DScene; active: boolean = True); reintroduce;
    constructor CreateFromStream(s: TStream; aScene: TD3DScene; version: integer; active: boolean = True); reintroduce;
    procedure ReplaceImageEntry(const oldEntry, newEntry: TFileName);
    function AddSurface(SurfaceType: byte; pInfo: Pointer): TD3DObject; override;
    destructor Destroy; override;
    procedure GetInfo(p: Pointer); override;
    function GetTypeID: byte; override;
    function TextureName: string; override;
    procedure CopyCollectionInfo(source, dest: PD3DSectorCollectionInfo);
    procedure CopyCollectionInfoFromInfo2(source: PD3DSectorCollectionInfo2;
      var dest: PD3DSectorCollectionInfo);
    procedure CopyCollectionInfo2FromInfo(source: PD3DSectorCollectionInfo;
      var dest: PD3DSectorCollectionInfo2);
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    function LineDefLength(ld: word): TD3DValue; virtual;
    function SideDefHeight(sd: word): TD3DValue; virtual;
  // ֵניפסצוי True בם ךבםו בככבדע ףפחם טףח pos
    function AcceptPosition(const oldPos: TD3DVector; var pos: TD3DVector): integer; virtual;
    function AcceptRotation(var rot: TD3DVector): boolean; virtual;
    function AcceptFloorProjection(var pos: TD3DVector): boolean; overload; virtual;
    function AcceptFloorProjection(const pos: TFloatPoint; var y: TD3DValue): boolean; overload; virtual;
    function AcceptFloorProjection(const pos: TFloatPoint; var y: TD3DValue; var aSubSector: integer; var aTriangle: integer): boolean; overload; virtual;

    function AcceptCeilingProjection(var pos: TD3DVector): boolean; overload; virtual;
    function AcceptCeilingProjection(const pos: TFloatPoint; var y: TD3DValue): boolean; overload; virtual;
    function AcceptCeilingProjection(const pos: TFloatPoint; var y: TD3DValue; var aSubSector: integer; var aTriangle: integer): boolean; overload; virtual;
    function BoundingCube: TBoundingCube; override; // BoundingCube פחע ףץככןדע

    procedure AdjustMovementNavigationInfo(x, y, z: TD3DValue); virtual;
    function GetNumVertexes: integer; override;
    function GetNumTriangles: integer; override;
    procedure DrawLoop; override;
    procedure InitialMove(vM: TD3DVector); overload; override;   // ּםן פבם וםבי fAttached ףפחם בסק ךבי ףפן script
    procedure InitialRotate(vM: TD3DVector); overload; override; // ּםן פבם וםבי fAttached ףפחם בסק ךבי ףפן script
    procedure InitialMove(x, y, z: TD3DValue); overload; override;  // ּםן פבם וםבי fAttached ףפחם בסק ךבי ףפן script
    procedure InitialRotate(x, y, z: TD3DValue); overload; override; // ּםן פבם וםבי fAttached ףפחם בסק ךבי ףפן script
    property IsInsideClosedSector: boolean read fIsInsideClosedSector;
    property IsInsideSector: boolean read fIsInSideSector;
    property SideNavigationInfos: PSideNavigationInfos read fSideNavigationInfos;
    property NumSides: integer read fNumSides;
    property SubSectorNavigationInfos: PSubSectorNavigationInfos read fSubSectorNavigationInfos;
    property NumSubSectors: integer read fNumSubSectors;
//    property BoundingCube: TBoundingCube read fBoundingCube; // BoundingCube פחע ףץככןדע
  end;
{$ENDIF}

type
  PStackNode = ^TStackNode;
  TStackNode = record
    data: integer;
    next,
    pred: PStackNode;
  end;

  PStack = ^TStack;
  TStack = class(TObject)
  private
    top  : PStackNode;       
  public
    constructor Create; virtual;
    function Empty: boolean;
    procedure Push(i: integer);
    procedure Pop(var i: integer); overload;
    function Pop: integer; overload;
    destructor Destroy; override;
  end;

function IsMap(m: string): boolean;

function GenGlobalID: integer;

// ֵניףפסצוי פןם בסיטל דסבללע ףפחם טףח pos
function GetLine(const text: string; pos: integer): integer;

// ֵניףפסצוי פחם טףח ףפחם בסק פחע דסבללע line
function GetPos(const text: string; line: integer): integer;

function DXImageExists(const s: string): boolean;

function DXImageLoad(const s: string): TGraphic; overload;

function DXImageLoad(Image: TImage; const s: string):boolean; overload;

{$IFNDEF NO_D3DSECTORCOLLECTIONS}
procedure NewSectorCollectionInfo2(var inf: PD3DSectorCollectionInfo2);

procedure DisposeSectorCollectionInfo2(var inf: PD3DSectorCollectionInfo2);

procedure DoneSectorCollectionInfo2(var inf: TD3DSectorCollectionInfo2);

procedure CopySectorCollectionInfo(source: PD3DSectorCollectionInfo;
  dest: PD3DSectorCollectionInfo);

procedure CopySectorCollectionInfo2(source: PD3DSectorCollectionInfo2;
  dest: PD3DSectorCollectionInfo2);

procedure CopySectorCollectionInfoFromInfo2(source: PD3DSectorCollectionInfo2;
  dest: PD3DSectorCollectionInfo);
                           
procedure CopySectorCollectionInfo2FromInfo(source: PD3DSectorCollectionInfo;
  dest: PD3DSectorCollectionInfo2);

function LineDefLength(inf: PD3DSectorCollectionInfo2; ld: word): TD3DValue;

function SideDefHeight(inf: PD3DSectorCollectionInfo2; sd: word): TD3DValue;
{$ENDIF}

function TextureNamesEqual(const tNames1, tNames2: TTextureNames; const numTextures: integer = MAXTEXTURES): boolean;

{$IFNDEF NO_D3DACTORS}
type
  PD3DActorInfo = ^TD3DActorInfo;
  TD3DActorInfo = record
    key: integer;       // ׀סשפו‎ןם ךכויה בםבזפחףחע
    zOrder: integer;
    Interval: single;   // טו נףב sec ונבםבכבלגםןםפבי פב texturenames
    x, y, z: TD3DValue; // Position
    dx, dy, dz: TD3DValue; // Rotation
    C: TColor;
    Scale: TD3DValue;
    AnimStart,
    AnimEnd: word;
    AnimSpeed: TD3DValue; // טו נףב sec ונבםבכבלגםןםפבי פב animations
    UseInterpolation: boolean; // ׳סףח נבסולגןכע
    MinFramesPerSec: byte;
    HideDistance: TD3DValue; // ֱנףפבףח בנךסירחע
    UpdateDistance: TD3DValue; // ּדיףפח בנףפבףח נןץ דםופבי ונבםבץנןכןדיףלע פןץ ךבס
    NumTextures: SmallInt;
    TextureNames: TTextureNames;
    PathToModel: string;
  end;

  TActorAnimation = class(TObject)
  public
    Name: string;
    AnimStart, AnimEnd: word;
  end;

  PD3DActor = ^TD3DActor;
  TD3DActor = class(TD3DAnimatingObject)
  private
    fNumVertexes: integer;
    fModel: TModel;
    fLastUpdateTime: double;
    fNeedsUpdate: boolean;
    fLastFrameIndexFloat: TD3DValue;
    fLastFrameFromOtherAnimation: boolean;
  protected
    fStartTime: double; // ַ ףפידל פחע ... ִחליןץסדבע!
    fScene: TD3DScene;
    CalcedStatus: PBoolArray;
    procedure InitParams; override;
    procedure ApplyInfoToVertexes; virtual;
    procedure DoCalcDistance; virtual;
    procedure fCalcCenterAndRadius; override;
  public
    TheVertexes: PD3DLVertexArray;
    Info,
    AppliedInfo: TD3DActorInfo;
    constructor Create(aScene: TD3DScene; aTextures: TDirect3DTextures2; const aInfo: TD3DActorInfo); reintroduce; virtual;
    constructor CreateFromStream(s: TStream; aScene: TD3DScene; aTextures: TDirect3DTextures2; version: integer); reintroduce;
    destructor Destroy; override;
    procedure Draw; override;
    procedure Scale(factor: TD3DValue); virtual;
    procedure Move(vM: TD3DVector); override;
    procedure Rotate(vM: TD3DVector); override;
    procedure SetPosition(vM: TD3DVector); virtual;
    procedure SetRotation(vM: TD3DVector); virtual;
    procedure GetTextureNames(var s: TDXStringList); override;
    function IsIdentical(D3DSurface: TObject): boolean; override;
    function GetTypeID: byte; override;
    function GetKeyID: integer; override;
    procedure SaveToStream(s: TStream); override;
    procedure LoadFromStream(s: TStream; version: integer); override;
    function CurTextureName: string; override;
    function CurTextureIndex: integer; override;
    function CurFrameIndex: word; virtual;
    function CurFrameIndexFloat: TD3DValue; virtual;
    function CalcDistance(const Position: TD3DVector): TD3DValue; override;
    function TextureName: string; override;
    procedure GetInfo(p: Pointer); override;
    function GetLocatePosition(aDistance: TD3DValue): TD3DVector; override;
    procedure ApplyLight(l: TD3DSceneLight); override;
    function SwitchToAnimation(animName: string): boolean; overload; override;
    function SwitchToAnimation(animID: integer): boolean; reintroduce; overload; virtual;
    function CurrentAnimationDuration: double; override;
{$IFDEF DESIGNER}
    function CanSaveVertexes: boolean; override;
    procedure SaveVertexes(fName: string); override;
    function RTL_CanBeRuntime: boolean; override;
    procedure RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull); override;
{$ENDIF}
    function GetNumVertexes: integer; override;
    function GetNumTriangles: integer; override;
    property Model: TModel read fModel;
  end;
{$ENDIF}

function IsIntersect2D(obj: TD3DObject; aRadius: TD3DValue; aCenter: TD3DVector): boolean;

function IsSpecialTextureName(const tex: string): boolean;

implementation

uses
  Math,
  se_TempDXDraw,
  se_DXTables,
{$IFNDEF NO_DUKE3DSUPPORT}
  se_Duke3DUtils,
{$ENDIF}
{$IFNDEF NO_SCRIPTS}
  ifs_utl,
  ifs_obj,
  ifpsdll,
  ifpsdelphi,
  ifpsdll2,
  ifsctrlstd,
  ifsMath,
  ifpslib,
  ifsdfrm,
  ifpscom,
  ifpstrans,
  ifpsdate,
  IFSLibraryModule,
  se_DXTextToSpeech,
  se_DXCDAudio,
  se_DXMidiPlayer,
  {$IFDEF DESIGNER}
  se_DXMediaPlayer,
  {$ELSE}
  se_DXRTLMediaPlayer,
  {$ENDIF}
{$ENDIF}
{$IFDEF DESIGNER}
  se_RTLLibraryModule,
{$ENDIF}
{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_DOOMSUPPORT}
  se_DoomUtils,
{$ENDIF}
{$IFNDEF NO_QUAKESUPPORT}
  se_Quake2Utils,
{$ENDIF}
  se_IDSoftData,
{$ENDIF}
{$IFNDEF NO_TOMBRAIDERSUPPORT}
  se_TombRaider,
{$ENDIF}
  SyncObjs,
  MMSystem;

const
  fNeedsPositionRecalc: byte = 1;
  fNeedsRotationRecalc: byte = 2;
  fNeedsLightRecalc: byte = 4;
  NL = #13#10;

{$IFDEF NO_DOOMSUPPORT}
const
  rsFmtDOOMLINKDESCRIPTION1 = '->';
  rsFmtDOOMLINKDESCRIPTION2 = '::';

function GetWadLinkInfo(const inf: string; var WADFileName: string; var Entry: string): boolean;
// םוי split פן inf נןץ וםבי פחע לןסצע נק  '->C:\DOOM.WAD::FLAT_1' ףפב 'C:\DOOM.WAD' & 'FLAT_1'
var
  sEntry: string;
  i, j: integer;
begin
  Result := False;
  if Length(inf) >= Length(rsFmtDOOMLINKDESCRIPTION1) + Length(rsFmtDOOMLINKDESCRIPTION2) + 2 then
  begin
    if inf[1] + inf[2] = rsFmtDOOMLINKDESCRIPTION1 then
    begin
      sEntry := '';
      i := Length(inf);
      while (i > Length(rsFmtDOOMLINKDESCRIPTION1)) and
           (inf[i] + inf[i - 1] <> rsFmtDOOMLINKDESCRIPTION2[Length(rsFmtDOOMLINKDESCRIPTION2) - 1] + rsFmtDOOMLINKDESCRIPTION2[Length(rsFmtDOOMLINKDESCRIPTION2)]) do
      begin
        sEntry := inf[i] + sEntry;
        dec(i);
      end;
      if i > Length(rsFmtDOOMLINKDESCRIPTION1) then
      begin
        WADFileName := '';
        for j := Length(rsFmtDOOMLINKDESCRIPTION1) + 1 to i - Length(rsFmtDOOMLINKDESCRIPTION2) do WADFileName := WADFileName + inf[j];
        Entry := sEntry;
        Result := True;
      end;
    end;
  end;
end;
{$ENDIF}

function TextureNamesEqual(const tNames1, tNames2: TTextureNames; const numTextures: integer = MAXTEXTURES): boolean;
var
  i: integer;
begin
  Result := True;
  for i := 0 to numTextures - 1 do
  begin
    Result := (UpperCase(tNames1[i, 0]) = UpperCase(tNames2[i, 0])) and
              (UpperCase(tNames1[i, 1]) = UpperCase(tNames2[i, 1]));
    if not Result then
      break;
  end;
end;

function FutureProcTree_Create: TFutureProcTree;
begin
  Result := nil;
end;

procedure FutureProcTree_Insert(var Root: TFutureProcTree; const Proc: TFutureProcInfo);
begin
  if Root = nil then
  begin
    new(Root);
    Root.Proc := Proc;
    Root.left := nil;
    Root.middle := nil;
    Root.right := nil;
  end
  else if Proc.TimeToExecute < Root.Proc.TimeToExecute then
    FutureProcTree_Insert(Root.left, Proc)
  else if Proc.TimeToExecute > Root.Proc.TimeToExecute then
    FutureProcTree_Insert(Root.right, Proc)
  else
    FutureProcTree_Insert(Root.middle, Proc)
end;

//TFutureProcTreeEnum = procedure(TFutureProcInfo) of object;

procedure FutureProcTree_DeletePast(var Root: TFutureProcTree; Time: double; enum: TFutureProcTreeEnum);
var
  rr: TFutureProcTree;
begin
  if Root <> nil then
  begin
    if Root.left <> nil then
      FutureProcTree_DeletePast(Root.left, Time, enum);
    if Root.Proc.TimeToExecute <= Time then
    begin
      if Root.middle <> nil then
        FutureProcTree_DeletePast(Root.middle, Time, enum);
      if Root.right <> nil then
        FutureProcTree_DeletePast(Root.right, Time, enum);
      if Assigned(enum) then
        enum(Root.Proc);
      if Root.right = nil then
      begin
        dispose(Root);
        Root := nil;
      end
      else
      begin
        rr := Root;
        Root := Root.right;
        Dispose(rr);
      end;
    end;
  end;
end;

procedure FutureProcTree_Destroy(var Root: TFutureProcTree);
begin
  if Root <> nil then
  begin
    FutureProcTree_Destroy(Root.left);
    FutureProcTree_Destroy(Root.middle);
    FutureProcTree_Destroy(Root.right);
    dispose(Root);
    Root := nil;
  end;
end;

constructor TFutureProcList.Create(aDeleteEnum: TFutureProcTreeEnum);
begin
  Inherited Create;
  fCount := 0;
  fDeleteEnum := aDeleteEnum;
  fRoot := FutureProcTree_Create;
end;

procedure TFutureProcList.fDeleteEnumInternal(Proc: TFutureProcInfo);
begin
  if Assigned(fDeleteEnum) then
    fDeleteEnum(Proc);
  dec(fCount);
end;

procedure TFutureProcList.Insert(const Proc: TFutureProcInfo);
begin
  FutureProcTree_Insert(fRoot, Proc);
  inc(fCount);
end;

procedure TFutureProcList.Execute(const Time: double);
begin
  FutureProcTree_DeletePast(fRoot, Time, fDeleteEnumInternal);
end;

procedure TFutureProcList.Clear;
begin
  FutureProcTree_Destroy(fRoot);
end;

destructor TFutureProcList.Destroy;
begin
  Clear;
  Inherited;
end;

function IsIntersect2D(obj: TD3DObject; aRadius: TD3DValue; aCenter: TD3DVector): boolean;
begin
  Result := sqrt(sqr(obj.Center.x - aCenter.x) + sqr(obj.Center.z - aCenter.z)) <= obj.Radius + aRadius;
end;

function DXImageExists(const s: string): boolean;
begin
  Result := True;
  if FileExists(s) then
    Exit;
{$IFNDEF NO_IDSOFTGAMESSUPPORT}

{$IFNDEF NO_DOOMSUPPORT}
  if IsWadLinkInfo(s) then
    Exit;
{$ENDIF}

{$IFNDEF NO_QUAKESUPPORT}
  if IsPakLinkInfo(s) then
    Exit;
{$ENDIF}

{$ENDIF}

{$IFNDEF NO_DUKE3DSUPPORT}
  if IsDuke3DLinkInfo(s) then
    Exit;
{$ENDIF}
{$IFNDEF NO_TOMBRAIDERSUPPORT}
  if IsTRLinkInfo(s) then
    Exit;
{$ENDIF}
  if IsDLLLinkInfo(s) then
    Exit;
  Result := False;
end;

function GetNewGraphicFromFile(var NewGraphic: TGraphic; const fName: string): boolean;
var
  Ext, tmp: string;
begin
  tmp := ExtractFileExt(fName);

  if Length(tmp) < 2 then
  begin
    Result := False;
    Exit;
  end;

  if tmp[1] <> '.' then
  begin
    Result := False;
    Exit;
  end;

  Delete(tmp, 1, 1);
  Ext := UpperCase(TrimStr(tmp));
  Result := True;
  if (Ext = rsGExtBMP) then
    NewGraphic := TBitmap.Create
  else if (Ext = rsGExtGIF) then
    NewGraphic := TGifBitmap.Create
  else if (Ext = rsGExtJPG) or (Ext = rsGExtJPEG) then // <--------
    NewGraphic := jpeg.TJpegImage.Create
  else if (Ext = rsGExtWZ1) then
    NewGraphic := TWZ1Bitmap.Create
  else if (Ext = rsGExtWZ2) then
    NewGraphic := TWZ2Bitmap.Create
  else if (Ext = rsGExtBMZ) then
    NewGraphic := TZBitmap.Create
  else if (Ext = rsGExtPPM) then
    NewGraphic := TPPMBitmap.Create
  else if (Ext = rsGExtDIB) then
    NewGraphic := TDIB.Create
  else if (Ext = rsGExtWMF) or (Ext = rsGExtEMF) then
    NewGraphic := TMetafile.Create
  else if (Ext = rsGExtICO) then
    NewGraphic := TIcon.Create
  else if (Ext = rsGExtPCX) then
    NewGraphic := TPCXImage.Create
  else if (Ext = rsGExtM8) then
    NewGraphic := TM8Bitmap.Create
  else if (Ext = rsGExtTGA) then
  begin
    NewGraphic := TTGABitmap.Create;
    (NewGraphic as TTGABitmap).AllowExceptions := False;  // Added 21/10/2005
  end
  else if (Ext = rsGExtWAD) then
    NewGraphic := TStubWADBitmap.Create
//{$IFNDEF NO_IDSOFTGAMESSUPPORT}
  else if (Ext = rsGExtPAK) then
    NewGraphic := TStubPAKBitmap.Create
  else if (Ext = rsGExtBSP) then
    NewGraphic := TStubBSPBitmap.Create
  else if (Ext = rsGExtPK3) then
    NewGraphic := TStubBSPBitmap.Create
//{$ENDIF}
//{$IFNDEF NO_DUKE3DSUPPORT}
  else if (Ext = rsGExtGRP) then
    NewGraphic := TStubGRPBitmap.Create
//{$ENDIF}
  else
    Result := False;
end;

var fDXDrawForm: TTempDXDrawForm = nil;

function GetDXDrawForm: TTempDXDrawForm;
begin
  if fDXDrawForm = nil then
  begin
    fDXDrawForm := TTempDXDrawForm.Create(Application);
    fDXDrawForm.DXDraw.Initialize;
  end;
  Result := fDXDrawForm;
end;

function DXImageLoad(const s: string): TGraphic;
var
  aScene: TD3DScene;
begin
  Result := nil;
  if FileExists(s) then
  begin
    if GetNewGraphicFromFile(Result, s) then
      if Result <> nil then
      begin
        Result.LoadFromFile(s);
        Exit;
      end;
  end;
{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_DOOMSUPPORT}
  if IsWadLinkInfo(s) then
  begin
    aScene :=  TD3DScene.Create(GetDXDrawForm.DXDraw{$IFNDEF NO_D3DSOUNDS}, nil{$ENDIF});
    try
      Result := aScene.GetIDWADTextureBmp(s);
    finally
      aScene.Free;
    end
  end
  else {$ENDIF} {$IFNDEF NO_QUAKESUPPORT} if IsPAKLinkInfo(s) then
  begin
    aScene :=  TD3DScene.Create(GetDXDrawForm.DXDraw{$IFNDEF NO_D3DSOUNDS}, nil{$ENDIF});
    try
      Result := aScene.GetIDPAKTextureBmp(s);
    finally
      aScene.Free;
    end
  end
  else {$ENDIF}{$ENDIF} {$IFNDEF NO_DUKE3DSUPPORT} if IsDuke3DLinkInfo(s) then
  begin
    aScene :=  TD3DScene.Create(GetDXDrawForm.DXDraw{$IFNDEF NO_D3DSOUNDS}, nil{$ENDIF});
    try
      Result := aScene.GetDuke3DTextureBmp(s);
    finally
      aScene.Free;
    end
  end
  else {$ENDIF} {$IFNDEF NO_TOMBRAIDERSUPPORT} if IsTrLinkInfo(s) then
  begin
    aScene :=  TD3DScene.Create(GetDXDrawForm.DXDraw{$IFNDEF NO_D3DSOUNDS}, nil{$ENDIF});
    try
      Result := aScene.GetTrTextureBmp(s);
    finally
      aScene.Free;
    end
  end else {$ENDIF} if IsDllLinkInfo(s) then
  begin
    aScene :=  TD3DScene.Create(GetDXDrawForm.DXDraw{$IFNDEF NO_D3DSOUNDS}, nil{$ENDIF});
    try
      Result := aScene.GetDLLTextureBmp(s);
    finally
      aScene.Free;
    end
  end
end;

function DXImageLoad(Image: TImage; const s: string): boolean;
var
  g: TGraphic;
begin
  Result := False;
  if Image = nil then
    Exit;
  g := DXImageLoad(s);
  if g = nil then
    Exit;
  try
    Image.Picture.Bitmap.Width := g.Width;
    Image.Picture.Bitmap.Height := g.Height;
    Image.Picture.Bitmap.Canvas.Draw(0, 0, g);
  finally
    g.Free;
  end;
  Result := True;
end;

function GetNumTextures(TexNames: PTextureNames): SmallInt;
begin
  if TexNames = nil then
    Result := 0
  else
  begin
    Result := MAXTEXTURES;
    repeat
      dec(Result);
    until (TexNames[Result, 0] <> '') or (Result = 0);
    if (Result = 0) then
    begin
      if TexNames[0, 0] = '' then
        Result := 0
      else
        Result := 1
    end
    else
      inc(Result);
  end;
end;

function IsValidInteger(s: string): boolean;
var
  v: Double;
  Code: integer;
begin
  Val(s, v, Code);
  Result := (code = 0) and (Frac(v) = 0.0);
end;

{procedure ClearMemoryStream(var m: TMemoryStream);
begin
  if m <> nil then
  begin
    m.Free;
    m := nil;
  end;
end;}

function RTLGetExistedResourceEntry(s: TFileName): TFileName;
var
  tmp: string;
  i: integer;
begin
  tmp := ExtractFileName(s);
  Result := '';
  if Length(tmp) > 0 then
  begin
    i := 0;
    repeat
      inc(i);
      if not (tmp[i] in ['.', ' ', '-']) then
        Result := Result + tmp[i];
    until (i = Length(tmp)) or (tmp[i] = '.');
  end;
end;

function ExtractFileExtention(const s: TFileName): string;
var
  i: integer;
begin
  Result := ExtractFileExt(s);
  for i := 1 to Length(Result) - 1 do
    Result[i] := Result[i + 1];
  SetLength(Result, Length(Result) - 1);
end;

{ *** TD3DSceneLight *** }
// ִחליןץסדב נחדע צשפויףלן‎, ךבפבק‏סחףח פןץ Info
constructor TD3DSceneLight.Create(aInfo: TD3DLightInfo);
begin
  Inherited Create;
  Enabled := True;
  Info := aInfo;
  fSearchDistance := Info.distance * Info.SearchFactor;
  fSearchDistance_sqr := fSearchDistance * fSearchDistance;
end;

// ִחליןץסדב נחדע צשפויףלן‎ לו בםדםשףח פןץ Info בנ Stream
constructor TD3DSceneLight.CreateFromStream(s: TStream; version: integer);
begin
  LoadFromStream(s, version);
  Create(Info);
end;

// True, בם ח נחד צשפויףלן‎ לנןסו םב וצבסלןףטו (כדש נוסיןסיףלן‎ בנףפבףחע)
// ףפן Vector pos. ַ בנףפבףח בנ פן Vector pos נסנוי םב וםבי < בנ פחם
// לדיףפח בנףפבףח הסףחע פחע נחדע צשפויףלן‎ (Info.Distance)
function TD3DSceneLight.IsAppliable(pos: TD3DVector): boolean;
begin
  Result := VectorSquareMagnitude(
              VectorSub(
                pos,
                MakeD3DVector(Info.x, Info.y, Info.z))) < fSearchDistance_sqr;
end;

// ֵצבסלןד פחע נחדע צשפויףלן‎ ףו םב TD3DLVertex. ׃פחם נבסלופסן C ץנסקוי
// פן original קס‏לב פןץ TD3DLVertex. ַ וצבסלןד וםבי בםכןדח פחע בנףפבףחע,
// פב נין ךןםפים TD3DLVertex וניסוזןםפבי נוסיףףפוסן, בץפ נןץ וםבי נין
// לבךסץ וניסוזןםפבי כידפוסן & בץפ ףו בנףפבףח > Info.distance ךבטכןץ
procedure TD3DSceneLight.ApplyToVertex(var v: TD3DLVertex; C: TColor);
var
  dist: TD3DValue;
  factor, factor1: TD3DValue;
  _iC, _iS: TColor;
begin
  dist := VectorMagnitude(
            VectorSub(
              MakeD3DVector(v),
              MakeD3DVector(Info.x, Info.y, Info.z)));
  if (Info.distance > 0.0) and (dist <= Info.distance) and Enabled then
  begin
    case Info.LightType of
      ltLinear: // ֳסבלליך לושףח וניסובףלן‎ צשפויםע נחדע
        begin
          // ֲבטלע נןץ וניסוזופבי פן TD3DLVertex בםכןדב לו פחם בנףפבףח בנ פחם נחד צשפויףלן‎
          factor := dist / Info.distance;
          factor1 := 1.0 - factor;
          _iC := Info.Color;
          v.Color := RGB_MAKE(
            round(factor1 * GetRValue(C) + factor * GetRValue(_iC)),
            round(factor1 * GetGValue(C) + factor * GetGValue(_iC)),
            round(factor1 * GetBValue(C) + factor * GetBValue(_iC)));
{            GetGValue(C) - round(factor * (GetGValue(C) - GetGValue(Info.Color))),
            GetBValue(C) - round(factor * (GetBValue(C) - GetBValue(Info.Color))));}
{          v.Specular := RGB_MAKE(
            255 - GetRValue(C) + round(factor * (GetRValue(C) - GetRValue(Info.S))),
            255 - GetGValue(C) + round(factor * (GetGValue(C) - GetGValue(Info.S))),
            255 - GetBValue(C) + round(factor * (GetBValue(C) - GetBValue(Info.S))));}
          _iS := Info.Specular;
          v.Specular := RGB_MAKE(
            round(factor1 * (GetRValue(_iS))),
            round(factor1 * (GetGValue(_iS))),
            round(factor1 * (GetBValue(_iS))));
        end;
      ltFixed: // ׀סןךבטןסיףלםןע וניסובףלע פחע צשפויםע נחדע לקסי בנףפבףח Info.Distance
        begin
          v.Color := CA_MAKE(Info.Color, 0);
          v.Specular := CA_MAKE(Info.Specular, 0);
        end;
      else
      begin
      end;
    end;
  end
  else
  begin
    v.Color := CA_MAKE(C, 0);
    v.Specular := 0;
  end;
end;

// ֱנןטךוץףח הוהןלםשם ףו stream
procedure TD3DSceneLight.SaveToStream(s: TStream);
begin
  with Info do
  begin
    s.Write(Key, SizeOf(Key));
    s.Write(Color, SizeOf(Color));
    s.Write(Specular, SizeOf(Specular));
    s.Write(distance, SizeOf(distance));
    s.Write(SearchFactor, SizeOf(SearchFactor));
    s.Write(x, SizeOf(x));
    s.Write(y, SizeOf(y));
    s.Write(z, SizeOf(z));
    s.Write(LightType, SizeOf(LightType));
  end;
end;

{$IFNDEF NO_OLDSTREAMINGRUTINES}
procedure TD3DSceneLight.OldLoadFromStream(s: TStream; version: integer);
begin
  with Info do
  begin
    s.Read(Key, SizeOf(Key));
    s.Read(Color, SizeOf(Color));
    s.Read(Specular, SizeOf(Specular));
    if version < FILEVERSION_102 then
      Specular := RGB(0, 0, 0);
    s.Read(distance, SizeOf(distance));
    if version >= FILEVERSION_116 then
      s.Read(SearchFactor, SizeOf(SearchFactor));
    s.Read(x, SizeOf(x));
    s.Read(y, SizeOf(y));
    s.Read(z, SizeOf(z));
    s.Read(LightType, SizeOf(LightType));
  end;
end;
{$ENDIF}

// ֱםדםשףח הוהןלםשם בנ stream
procedure TD3DSceneLight.LoadFromStream(s: TStream; version: integer);
begin
{$IFNDEF NO_OLDSTREAMINGRUTINES}
  if version < FILEVERSION_117 then
    OldLoadFromStream(s, version)
  else {$ENDIF} with Info do
  begin
    s.Read(Key, SizeOf(Key));
    s.Read(Color, SizeOf(Color));
    s.Read(Specular, SizeOf(Specular));
    s.Read(distance, SizeOf(distance));
    s.Read(SearchFactor, SizeOf(SearchFactor));
    s.Read(x, SizeOf(x));
    s.Read(y, SizeOf(y));
    s.Read(z, SizeOf(z));
    s.Read(LightType, SizeOf(LightType));
  end;
end;

function TD3DSceneLight.GetTypeID: byte;
begin
  Result := ID3D_Light;
end;

function TD3DSceneLight.GetKeyID: integer;
begin
  Result := Info.Key;
end;

const
  rsFmtLight = 'Color: (%3d,%3d,%3d), Specular: (%3d,%3d,%3d)';

function TD3DSceneLight.Description: string;
var
  C, S: TColor;
begin
  C := Info.Color;
  S := Info.Specular;
  Result := Format(rsFmtLight, [GetRValue(C),
                                GetGValue(C),
                                GetBValue(C),
                                GetRValue(S),
                                GetGValue(S),
                                GetBValue(S)]);
end;

// ּופבךםחףח פחע נחדע צשפויףלן‎
procedure TD3DSceneLight.Move(vM: TD3DVector);
begin
  with Info do
  begin
    x := x + vM.x;
    y := y + vM.y;
    z := z + vM.z;
  end;
end;

// ּופבךםחףח פחע נחדע צשפויףלן‎
procedure TD3DSceneLight.Move(x, y, z: TD3DValue);
begin
  Move(MakeD3DVector(x, y, z));
end;

{ *** }

{ --- TStack --- }

constructor TStack.Create;
begin
  Inherited;
  top := nil;
end;

function TStack.Empty;
begin
  Empty := (top=nil)
end;

procedure TStack.Push(i: integer);
var
  temp: PStackNode;
begin
  new(temp);
  temp^.data := i;
  temp^.next := nil;
  temp^.pred := top;
  top := temp
end;

procedure TStack.Pop(var i: integer);
var
  temp: PStackNode;
begin
  if not Empty then
  begin
    i := top^.data;
    temp := top;
    top := top^.pred;
    dispose(temp);
    if top <> nil then
      top^.next := nil;
  end;
end;

function TStack.Pop: integer;
begin
  Pop(Result);
end;

destructor TStack.Destroy;
begin
  while not Empty do Pop;
  Inherited;
end;

// ּופבגכחפ דיב פןם ךבטןסיףל פחע לןםבהיךפחפבע ךטו D3DSurface
// ּנןסו םב קסחףילןנןיחטו ףבם נסשפו‎ןם ךכויה
var
  GlobalID: integer;
  ActiveScene: TD3DScene;

function GenGlobalID: integer;
begin
  inc(GlobalID);
  Result := GlobalID
end;

// Optimize a bitmap by making a mean value calculation
// Convert bitmap to 24bit!
procedure OptimizeBitmap(b: TBitmap);
var
  x3, x, y, i: integer;
  tmp: TBitmap;
  P1, P2, P3: PByteArray;
  pixel: integer;
begin
  tmp := TBitmap.Create;
  try
    tmp.Width := b.Width;
    tmp.Height := b.Height;
    tmp.Canvas.Draw(0, 0, b);
    tmp.PixelFormat := pf24bit;
    b.PixelFormat := pf24bit;
    y := 0;
    while y < tmp.Height - 1 do
    begin
      P1 := tmp.ScanLine[y];
      P2 := tmp.ScanLine[y + 1];
      P3 := b.ScanLine[y];
      x := 0;
      while x < tmp.Width - 1 do
      begin
        // If black may be transparent Information.
        // Just leave it that way, not much to loose from quality
        x3 := 3 * x;
        if (P3[x3] * P3[x3 + 1] * P3[x3 + 2]) <> 0 then
        begin
        // Prosses all 3 bytes of pixel
          for i := 0 to 2 do
          begin
            pixel := P1[x3];
            pixel := pixel + P1[x3 + 3];
            pixel := pixel + P2[x3];
            pixel := pixel + P2[x3 + 3];
//            pixel := P1[x3] + P1[x3 + 3] + P2[x3] + P2[x3 + 3];
            P3[x3] := pixel div 4;
            inc(x3);
          end;
        end;
        inc(x);
      end;
      inc(y);
    end;
  finally
    tmp.Free;
  end;
end;

// *** TD3DObject ***
constructor TD3DObject.Create(aDXDraw: TDXDraw; aTexture: TDirect3DTexture2);
begin
{$IFNDEF NO_DXMESHES}
   fHasRenderMesh := False;
{$ENDIF}
  fSafeMode := False;
  fNeedsRadiusAndCenterRecalc := True;
  MakeEmptyBoundingCube(fBoundingCube);
  fCulled := False;
  fDidDraw := True;
  Saveable := True;
  Tag := 0;
  Flags := 0;
  fRadius := 0.0;
  fCenter := NULLVECTOR;
{$IFNDEF NO_TEXTUREEFFECTS}
  FillChar(fTexEffect, SizeOf(fTexEffect), Chr(0));;
{$ENDIF}
  Inherited Create;
  RunTimeOnly := DefaultRTLQuery;
  inc(GlobalID);
  Graphic := TPicture.Create;
  DXDraw := aDXDraw;
  Texture[0] := aTexture;
  Texture[1] := nil;
  fMustFreeTexture := aTexture = nil;
  InitParams;
{$IFNDEF NO_DXMESHES}
  AdjustMeshData;
{$ENDIF}
end;

{$IFNDEF NO_DXMESHES}
procedure TD3DObject.AdjustMeshData;
begin
  fMeshRenderProc := RenderMesh;
  FillChar(fMesh, SizeOf(fMesh), Chr(0));
{$IFNDEF NO_TEXTUREEFFECTS}
  fMesh.TexEffect := @fTexEffect;
  fMesh.BoundingCube := @fBoundingCube;
  fMesh.Center := @fCenter;
  fMesh.Radius := @fRadius;
  fMesh.VertexTypeDesc := @D3DDXFVF_VERTEX;
  fMesh.NumVertexes := @ZERO;
  fMesh.NumIndices := @ZERO;
  GetCurrentTextures(fMesh.Tex1, fMesh.Tex2);
{$ENDIF}
end;
{$ENDIF}

procedure TD3DObject.GetCurrentTextures(var tex1, tex2:  TDirect3DTexture2);
begin
  tex1 := Texture[0];
  tex2 := Texture[1];
end;

{$IFNDEF NO_TEXTUREEFFECTS}
procedure TD3DObject.ClearTextureEffect;
begin
  fTexEffect.EffectType := TE_EFFECT_NONE;
  fMeshRenderProc := RenderMesh;
end;

procedure TD3DObject.SetTextureAlphaEffect(const TE_ALPHA: TTextureAlphaEffect);
begin
  fTexEffect.EffectType := TE_EFFECT_ALPHA;
  fTexEffect.TE_ALPHA := TE_ALPHA;
  fMeshRenderProc := RenderMeshWithAlphaEffect;
end;

procedure TD3DObject.SetTextureStageEffect(const TE_STAGE: TTextureStageEffect);
begin
  fTexEffect.EffectType := TE_EFFECT_STAGE;
  fTexEffect.TE_STAGE := TE_STAGE;
  fMeshRenderProc := RenderMeshWithStageEffect;
end;
{$ENDIF}

function TD3DObject.Top: TD3DValue;
begin
  Result := Center.y + Radius;
end;

function TD3DObject.Bottom: TD3DValue;
begin
  Result := Center.y - Radius;
end;

function TD3DObject.BoundingCube: TBoundingCube;
begin
  if fNeedsRadiusAndCenterRecalc then
  begin
    fBoundingCube.minX := Center.x - Radius;
    fBoundingCube.maxX := fCenter.x + fRadius;

    fBoundingCube.minY := fCenter.y - fRadius;
    fBoundingCube.maxY := fCenter.y + fRadius;

    fBoundingCube.minZ := fCenter.z - fRadius;
    fBoundingCube.maxZ := fCenter.z + fRadius;
  end;

  Result := fBoundingCube
end;

function TD3DObject.Radius: TD3DValue;   // דיב ComputeSphereVisiblility
begin
  if fNeedsRadiusAndCenterRecalc then
  begin
    fCalcCenterAndRadius;
    fNeedsRadiusAndCenterRecalc := False;
  end;
  Result := fRadius;
end;

function TD3DObject.Center: TD3DVector;  // דיב ComputeSphereVisiblility
begin
  if fNeedsRadiusAndCenterRecalc then
  begin
    fCalcCenterAndRadius;
    fNeedsRadiusAndCenterRecalc := False;
  end;
  Result := fCenter;
end;

procedure TD3DObject.ReduceMemory;
begin
end;

function TD3DObject.IsIntersectWith(aObject: TD3DObject): boolean;
var
  aRadius: TD3DValue;
  aCenter: TD3DVector;
begin
  if aObject.InheritsFrom(TD3DScene) then
    Result := (aObject as TD3DScene).IsIntersectWith(self)
{$IFNDEF NO_D3DBILLBOARDS}
  else if aObject.InheritsFrom(TD3DBillBoard) then
    Result := (aObject as TD3DBillBoard).IsIntersectWith(self)
{$ENDIF}
  else
  begin
    aRadius := aObject.Radius;
    aCenter := aObject.Center;
    Result := IsIntersectWith(aRadius, aCenter);
  end;
end;

function TD3DObject.IsIntersectWith(aRadius: TD3DValue; aCenter: TD3DVector): boolean;
begin
  Result := VectorMagnitude(VectorSub(Center, aCenter)) < Radius + aRadius;
end;

// Check Intersection with line (aStart, aEnd)
function TD3DObject.IsIntersectWith(aRadius: TD3DValue; aStart, aEnd: TD3DVector; var InterSectPoint: TD3DVector): boolean;
var l: TD3DValue;
    i, k: integer;
    line, step: TD3DVector;
    lastPoint, checkPoint: TD3DVector;
begin
  line := VectorSub(aEnd, aStart);
  l := VectorMagnitude(line); // לךןע דסבללע
  if l < g_EPSILON then
  begin
    Result := IsIntersectWith(aRadius, aStart);
    if Result then
      InterSectPoint := aStart
    else
      InterSectPoint := aEnd;
  end
  else
  begin
    Result := False;
    k := trunc(l / (abs(aRadius) + Radius + g_EPSILON)) + 1;
    step := VectorDivS(line, k);
    lastPoint := aStart;
    checkPoint := aStart;
    for i := 0 to k do
    begin
      Result := IsIntersectWith(aRadius, checkPoint);
      if Result then
      begin
        InterSectPoint := lastPoint;
        Exit;
      end;
      checkPoint := VectorAdd(checkPoint, step);
      lastPoint := checkPoint;
    end;
    InterSectPoint := aEnd;
  end;
end;

procedure TD3DObject.SetCulled(Value: boolean);
begin
  fCulled := Value;
end;

procedure TD3DObject.SetSafeMode(Value: boolean);
begin
  fSafeMode := Value;
end;

function TD3DObject.DefaultRTLQuery: boolean;
begin
  Result := False;
end;

{$IFDEF DESIGNER}
procedure TD3DObject.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
  ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
  doTexture: boolean; var curCull: TD3DCull);
begin
  DeclareSession := '';
  InitSession := '';
  DrawSession := '';
  DoneSession := '';
  RTL_GetRunTimeCodeTemplate(
    DeclareSession, InitSession, DrawSession, DoneSession,
    doTexture, curCull,
    '',                 // GlobalName
    nil,                // Vertexes Array
    -1,                 // Number of Vertexes
    D3DCULL_INVALID_0,  // CULL
    D3DPT_INVALID_0,    // Primitive Type
    ComplexityLevel,
    ComplexityDistance,
    tLights);
end;

procedure TD3DObject.RTL_GetRunTimeCodeTemplate(
  out DeclareSession, InitSession, DrawSession, DoneSession: string;
  doTexture: boolean; var curCull: TD3DCull;
  tGlobalName: string;
  tVX: PD3DLVertexArray;
  tNumVertexes: integer;
  tCull: TD3DCULL;
  tPrimitive: TD3DPrimitiveType;
  ComplexityLevel: integer;
  ComplexityDistance: TD3DValue;
  Lights: TDXStringList;
  pVertexName: PString = nil;
  pTextureName: PString = nil);
var
  GlobalName, prim_str, str_tmp: string;
  i: integer;
begin
  GlobalName := tGlobalName + IntToStr4(GetKeyID) + '_ID_' + IntToStr4(GenGlobalID);
  if pVertexName <> nil then
    pVertexName^ := GlobalName;

  DeclareSession := '';
  if doTexture then
    DeclareSession := DeclareSession +
 '    Texture_' + RTLGetExistedResourceEntry(TextureName) + ': TDirect3DTexture2;' + NL;
  if pTextureName <> nil then
    pTextureName^ := 'Texture_' + RTLGetExistedResourceEntry(TextureName);

  DeclareSession := DeclareSession +
 '    ' + GlobalName + '_Vertexes: PD3DLVertexArray;' + NL;

  InitSession := '';

  if doTexture then
    InitSession := InitSession +
 '    Texture_' + RTLGetExistedResourceEntry(TextureName) +
   ' := Scene.AddTextureToCollectionConst(''' +
          RTLGetExistedResourceEntry(TextureName) +
          ExtractFileExt(TextureName) + ''');' + NL +
 '    Texture_' + RTLGetExistedResourceEntry(TextureName) + '.Surface.TransparentColor := 0;' + NL;
  InitSession := InitSession +
 '    GetMem(' + GlobalName + '_Vertexes, ' + IntToStr(tNumVertexes) + ' * SizeOf(TD3DLVertex));' + NL;
  for i := 0 to tNumVertexes - 1 do
  begin
    str_tmp := '    ' + GlobalName + '_Vertexes[' + IntToStr(i) + '] := MakeD3DLVERTEX(';
    InitSession := InitSession +
      str_tmp + FloatToStr(tVX[i].x) + ', ' +
                FloatToStr(tVX[i].y) + ', ' +
                FloatToStr(tVX[i].z) + ', ' +
                'D3DCOLOR(' + IntToStr(tVX[i].color) + '), ' +
                'D3DCOLOR(' + IntToStr(tVX[i].specular) + '), ' +
                FloatToStr(tVX[i].tu) + ', ' +
                FloatToStr(tVX[i].tv) + ');' + NL;
  end;

  DrawSession := '';

  if (curCull <> tCull) and (tCull in [D3DCULL_NONE, D3DCULL_CW, D3DCULL_CCW]) then
  begin
    case tCull of
      D3DCULL_NONE:
        DrawSession := DrawSession +
 '    Scene.DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(D3DCULL_NONE));' + NL;
      D3DCULL_CCW:
        DrawSession := DrawSession +
 '    Scene.DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(D3DCULL_CCW));' + NL;
      D3DCULL_CW:
        DrawSession := DrawSession +
 '    Scene.DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(D3DCULL_CW));' + NL;
    else
    end;
    curCull := tCull;
  end;

  if tPrimitive = D3DPT_TRIANGLELIST then
    prim_str := 'D3DPT_TRIANGLELIST'
  else if tPrimitive = D3DPT_TRIANGLESTRIP then
    prim_str := 'D3DPT_TRIANGLESTRIP'
  else
    prim_str := 'D3DPT_TRIANGLEFAN';

  if doTexture then
    DrawSession := DrawSession +
 '    Scene.DXDraw.D3DDevice7.SetTexture(0, Texture_' + RTLGetExistedResourceEntry(TextureName) + '.Surface.IDDSurface7);' + NL;
    DrawSession := DrawSession +
 '    Scene.DXDraw.D3DDevice7.DrawPrimitive(' + prim_str + ', D3DDXFVF_VERTEX, ' + GlobalName + '_Vertexes[0], ' + IntToStr(tNumVertexes) + ', 0);' + NL;

  DoneSession :=
 '    FreeMem(' + GlobalName + '_Vertexes, ' + IntToStr(tNumVertexes) + ' * SizeOf(TD3DLVertex));' + NL;

end;
{$ENDIF}

constructor TD3DObject.CreateFromStream(s: TStream; aDXDraw: TDXDraw;
  aTexture: TDirect3DTexture2; version: integer);
begin
  fNeedsRadiusAndCenterRecalc := True;
  LoadFromStream(s, version);
  Create(aDXDraw, aTexture);
end;

destructor TD3DObject.destroy;
begin
  Graphic.Free;
  if fMustFreeTexture then
    Texture[0].Free;
  inherited;
end;

function TD3DObject.GetTypeID: byte;
begin
  Result := ID3D_Abstract;
end;

function TD3DObject.GetKeyID: integer;
begin
  Result := 0;
end;

{$IFNDEF NO_DXMESHES}
function TD3DObject.CanGetMesh: boolean;
begin
  Result := fMesh.NumVertexes^ <> 0;
end;
{$ENDIF}

function TD3DObject.CanMergeWith(SurfaceType: byte; pInfo: Pointer): boolean;
begin
  Result := False;
end;

function TD3DObject.MergeWith(SurfaceType: byte; pInfo: Pointer): boolean;
begin
  Result := False;
end;

procedure TD3DObject.DoDraw;
begin
{$IFNDEF NO_OBJECTDRAWINGNOTIFY}
  if Assigned(fOnBeforeDraw) then
  begin
    if fOnBeforeDraw(DXDraw) then
      if not fCulled then
        Draw
  end
  else {$ENDIF}if not fCulled then
    Draw;
{$IFNDEF NO_OBJECTDRAWINGNOTIFY}
  if Assigned(fOnAfterDraw) then
    fOnAfterDraw(DXDraw);
{$ENDIF}
end;

{$IFNDEF NO_DXMESHES}
procedure TD3DObject.DoDrawMesh;
begin
  if fMesh.NumVertexes^ = 0 then
    DoDraw
  else
  begin
    if not fHasRenderMesh then
      AdjustMeshData;
{$IFNDEF NO_OBJECTDRAWINGNOTIFY}
    if Assigned(fOnBeforeDraw) then
    begin
      if fOnBeforeDraw(DXDraw) then
        if not fCulled then
          fMeshRenderProc(DXDraw.D3DDevice7, @fMesh);
    end
    else {$ENDIF}if not fCulled then
      fMeshRenderProc(DXDraw.D3DDevice7, @fMesh);
{$IFNDEF NO_OBJECTDRAWINGNOTIFY}
    if Assigned(fOnAfterDraw) then
      fOnAfterDraw(DXDraw);
{$ENDIF}
    fHasRenderMesh := True;
  end;
end;

procedure TD3DObject.DoDrawMeshAtDevice(dev: IDirect3DDevice7);
begin
  if fMesh.NumVertexes^ <> 0 then
    fMeshRenderProc(dev, @fMesh);
end;
{$ENDIF}

procedure TD3DObject.Draw;
begin
end;

procedure TD3DObject.Move(vM: TD3DVector);
begin
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DObject.Move(x, y, z: TD3DValue);
begin
  fNeedsRadiusAndCenterRecalc := True;
  Move(MakeD3DVector(x, y, z));
end;

procedure TD3DObject.MoveTo(vM: TD3DVector);
begin
  fNeedsRadiusAndCenterRecalc := True;
  Move(VectorSub(vM, GetLocatePosition(0.0)));
end;

procedure TD3DObject.MoveTo(x, y, z: TD3DValue);
begin
  fNeedsRadiusAndCenterRecalc := True;
  MoveTo(MakeD3DVector(x, y, z));
end;

procedure TD3DObject.Rotate(vM: TD3DVector);
begin
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DObject.Rotate(x, y, z: TD3DValue);
begin
  Rotate(MakeD3DVector(x, y, z));
  fNeedsRadiusAndCenterRecalc := True;
end;

function TD3DObject.IsIdentical(D3DSurface: TObject): boolean;
begin
  Result := False;
  if D3DSurface.InheritsFrom(TD3DObject) then
    Result := ((D3DSurface as TD3DObject).GetKeyID = GetKeyID) and
              ((D3DSurface as TD3DObject).GetTypeID = GetTypeID);
end;

procedure TD3DObject.SaveToStream(s: TStream);
{$IFDEF NO_TEXTUREEFFECTS}
var stubid: integer;
{$ENDIF}
begin
{$IFNDEF NO_TEXTUREEFFECTS}
  SaveEffectToStream(s, fTexEffect);
{$ELSE}
  stubid := 0;
  s.Write(stubid, SizeOf(stubid));
{$ENDIF}
end;

procedure TD3DObject.LoadFromStream(s: TStream; version: integer);
{$IFDEF NO_TEXTUREEFFECTS}
var stubid: integer;
{$ENDIF}
begin
  if version >= FILEVERSION_120 then
{$IFNDEF NO_TEXTUREEFFECTS}
    LoadEffectFromStream(s, fTexEffect);
{$ELSE}
    s.Read(stubid, SizeOf(stubid));
{$ENDIF}
end;

function TD3DObject.Version: integer;
begin
  Result := FILEVERSION
end;

function TD3DObject.HasStubSurface: boolean;
begin
  if Texture[0] = nil then
    Result := True
  else
    Result := Texture[0].Surface.Width <= 2;
end;

procedure TD3DObject.ApplyLights(s: TDXStringList);
var i: integer;
    obj: TObject;
begin
  for i := 0 to s.Count - 1 do
  begin
    obj := s.Objects[i];
    if obj <> nil then
      ApplyLight(obj as TD3DSceneLight);
  end;
end;

// *** TD3DGenericRTLPolygon ***

{$IFNDEF NO_D3DGENERICRTLPOLYGONS}
constructor TD3DGenericRTLPolygon.Create(aDXDraw: TDXDraw; const aTexture: TDirect3DTexture2;
  const aTextureName: string);
begin
  fName := '';
  fTextureName := aTextureName;
  fTextureName2 := '';
  fNumVertexes := 0;
  fNumIndices := 0;
  fVertexes := nil;
  fIndices := nil;
  fPrimitiveType := D3DPT_TRIANGLELIST;
  fVertexTypeDesc := D3DFVF_LVERTEX;
  fDrawMethod := rpd_Normal;
  Inherited Create(aDXDraw, aTexture);
end;

destructor TD3DGenericRTLPolygon.Destroy;
begin
  ReAllocMem(fIndices, 0);
  ReAllocMem(fVertexes, 0);
  fNumVertexes := 0;
  fNumIndices := 0;
  Inherited;
end;

procedure TD3DGenericRTLPolygon.SetTexture2(const aTextureName2: string; aTexture2: TDirect3DTexture2);
begin
  fTextureName2 := aTextureName2;
  Texture[1] := aTexture2;
{$IFNDEF NO_DXMESHES}
  fMesh.Tex2 := Texture[1];
{$ENDIF}
end;

procedure TD3DGenericRTLPolygon.SetTexture2(aTexture2: TDirect3DTexture2);
begin
  Texture[1] := aTexture2;
{$IFNDEF NO_DXMESHES}
  fMesh.Tex2 := Texture[1];
{$ENDIF}  
end;

procedure TD3DGenericRTLPolygon.ReduceMemory;
var
  i: integer;
begin
  if fDrawMethod = rpd_Indexed then
  begin
    for i := 0 to fNumIndices - 1 do
      if fIndices[i] <> i then
        Exit;
    fDrawMethod := rpd_Normal;
    NumIndices := 0;
  end;
end;

{$IFNDEF NO_DXMESHES}
procedure TD3DGenericRTLPolygon.AdjustMeshData;
begin
  Inherited AdjustMeshData;
  fMesh.VertexTypeDesc := @fVertexTypeDesc;
  fMesh.Cull := @CULL_NONE;
  fMesh.PrimitiveType := @fPrimitiveType;
  fMesh.NumVertexes := @fNumVertexes;
  fMesh.Vertexes := @fVertexes;
  fMesh.NumIndices := @fNumIndices;
  fMesh.Indices := @fIndices;
end;
{$ENDIF}

procedure TD3DGenericRTLPolygon.SaveToStream(s: TStream);
begin
  Inherited SaveToStream(s);
  s.Write(fPrimitiveType, SizeOf(fPrimitiveType));
  s.Write(fVertexTypeDesc, SizeOf(fVertexTypeDesc));
  s.Write(fDrawMethod, SizeOf(fDrawMethod));
  s.Write(fNumVertexes, SizeOf(fNumVertexes));
  s.Write(fVertexes^, fNumVertexes * SizeOf(fVertexes[0]));
  s.Write(fNumIndices, SizeOf(fNumIndices));
  s.Write(fIndices^, fNumIndices * SizeOf(fIndices[0]));
//  WriteStringToStream(s, fTextureName2);
end;

procedure TD3DGenericRTLPolygon.LoadFromStream(s: TStream; version: integer);
var tmp: integer;
begin
  Inherited LoadFromStream(s, version);
  s.Read(fPrimitiveType, SizeOf(fPrimitiveType));
  s.Read(fVertexTypeDesc, SizeOf(fVertexTypeDesc));
  s.Read(fDrawMethod, SizeOf(fDrawMethod));
  s.Read(tmp, SizeOf(tmp));
  NumVertexes := tmp;
  s.Read(fVertexes^, fNumVertexes * SizeOf(fVertexes[0]));
  s.Read(tmp, SizeOf(tmp));
  NumIndices := tmp;
  s.Read(fIndices^, fNumIndices * SizeOf(fIndices[0]));
//  fTextureName2 := ReadStringFromStream(s);
end;

procedure TD3DGenericRTLPolygon.InitParams;
var
  canv: TCanvas;
begin
  if Texture[0] = nil then
  begin
    Graphic.Bitmap.Width := 2;
    Graphic.Bitmap.Height := 2;
    Graphic.Bitmap.PixelFormat := pf24bit;
    canv := Graphic.Bitmap.Canvas;
    canv.Pixels[0, 0] := $FFFFFF;
    canv.Pixels[1, 0] := $FFFFFF;
    canv.Pixels[0, 1] := $FFFFFF;
    canv.Pixels[1, 1] := $FFFFFF;
    Texture[0] := TDirect3DTexture2.Create(DXDraw, Graphic, False);
  end;
  Texture[0].Transparent := True;
end;

procedure TD3DGenericRTLPolygon.Draw;
var
  dev: IDirect3DDevice7;
  i: integer;
  Vertexes3: array[0..2] of TD3DLVertex;
begin
  dev := DXDraw.D3DDevice7;
  dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(D3DCULL_NONE));

  dev.SetTexture(0, Texture[0].Surface.IDDSurface7);
  if fDrawMethod = rpd_Normal then
  begin
    if fSafeMode and (fPrimitiveType = D3DPT_TRIANGLELIST) then
    begin
      i := 0;
      while i < fNumVertexes do
      begin
        dev.DrawPrimitive(D3DPT_TRIANGLELIST, fVertexTypeDesc, fVertexes[i], 3, 0);
        inc(i, 3);
      end;
    end
    else
      dev.DrawPrimitive(fPrimitiveType, fVertexTypeDesc, fVertexes[0], fNumVertexes, 0)
  end
  else
  begin
    if fSafeMode and (fPrimitiveType = D3DPT_TRIANGLELIST) then
    begin
      i := 0;
      while i < fNumIndices do
      begin
        Vertexes3[0] := fVertexes[fIndices[i]];
        inc(i);
        Vertexes3[1] := fVertexes[fIndices[i]];
        inc(i);
        Vertexes3[2] := fVertexes[fIndices[i]];
        inc(i);
        dev.DrawPrimitive(D3DPT_TRIANGLELIST, fVertexTypeDesc, Vertexes3, 3, 0);
      end;

    end
    else
      dev.DrawIndexedPrimitive(fPrimitiveType, fVertexTypeDesc,
        fVertexes[0], fNumVertexes, fIndices[0], fNumIndices, 0)
  end;
end;

function TD3DGenericRTLPolygon.GetTypeID: byte;
begin
  Result := ID3D_GenericRTLPolygon;
end;

procedure TD3DGenericRTLPolygon.fCalcCenterAndRadius;
begin
  CalcCenterAndRadius(Vertexes, fNumVertexes, fRadius, fCenter);
end;

procedure TD3DGenericRTLPolygon.Move(vM: TD3DVector);
var
  i: integer;
  pV: PD3DLVertex;
begin
  pV := @Vertexes[0];
  for i := 0 to fNumVertexes - 1 do
  begin
    pV.x := pV.x + vM.x;
    pV.y := pV.y + vM.y;
    pV.z := pV.z + vM.z;
    inc(pV);
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DGenericRTLPolygon.Rotate(vM: TD3DVector);
var
  mat: TD3DMatrix;
  v1, v2: TD3DVector;
  i: integer;
  pV: PD3DLVertex;
begin
  GetRotationMatrix(mat, vM.x, vM.y, vM.z);
  pV := @Vertexes[0];
  for i := 0 to fNumVertexes - 1 do
  begin
    v1 := MakeD3DVector(pV^);
    D3DMath_VectorMatrixMultiply(v2, v1, mat);
    pV.x := v2.x;
    pV.y := v2.y;
    pV.z := v2.z;
    inc(pV);
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DGenericRTLPolygon.GetTextureNames(var s: TDXStringList);
begin
  if fTextureName <> '' then
    if s.IndexOf(fTextureName) = -1 then
      s.Add(fTextureName);
  if fTextureName2 <> '' then
    if s.IndexOf(fTextureName2) = -1 then
      s.Add(fTextureName2);
end;

function TD3DGenericRTLPolygon.CalcDistance(const Position: TD3DVector): TD3DValue;
begin
  if fNumVertexes > 0 then
    Result := VectorMagnitude(MakeD3DVector(
      fVertexes[0].x - Position.X,
      fVertexes[0].y - Position.Y,
      fVertexes[0].z - Position.Z))
  else
    Result := 0;
end;

function TD3DGenericRTLPolygon.TextureName: string;
begin
  Result := fTextureName;
end;

function TD3DGenericRTLPolygon.TextureName2: string;
begin
  Result := fTextureName2;
end;

procedure TD3DGenericRTLPolygon.SetTextureName(const txname: string);
begin
  fTextureName := txname
end;

procedure TD3DGenericRTLPolygon.GetInfo(p: Pointer);
var
  i: integer;
begin
  PGenericRTLPolygonInfo(p).Key := 0;
  for i := 0 to fNumVertexes - 1 do
    PGenericRTLPolygonInfo(p).Vertexes[i] := fVertexes[i];
  PGenericRTLPolygonInfo(p).NumVertexes := fNumVertexes;
  for i := 0 to fNumIndices - 1 do
    PGenericRTLPolygonInfo(p).Indices[i] := fIndices[i];
  PGenericRTLPolygonInfo(p).PrimitiveType := fPrimitiveType;
  PGenericRTLPolygonInfo(p).VertexTypeDesc := fVertexTypeDesc;
  PGenericRTLPolygonInfo(p).DrawMethod := fDrawMethod;
  PGenericRTLPolygonInfo(p).Texture1 := TextureName;
  PGenericRTLPolygonInfo(p).Texture2 := '';
end;

function TD3DGenericRTLPolygon.GetLocatePosition(aDistance: TD3DValue): TD3DVector;
begin
  if fNumVertexes > 0  then
    Result := MakeD3DVector(
      fVertexes[0].x,
      fVertexes[0].y,
      fVertexes[0].z - aDistance)
  else
    Result := NULLVECTOR;
end;

procedure TD3DGenericRTLPolygon.ApplyLight(l: TD3DSceneLight);
var
  i: integer;
begin
  if fVertexTypeDesc = D3DFVF_LVERTEX then
    if l.IsAppliable(GetLocatePosition(0.0)) then
      for i := 0 to fNumVertexes do
        l.ApplyToVertex(fVertexes[i], $FFFFFF);
end;

function TD3DGenericRTLPolygon.GetNumVertexes: integer;
begin
  Result := fNumVertexes;
end;

function TD3DGenericRTLPolygon.GetNumTriangles: integer;
var
  xx: integer;
begin
  if fDrawMethod = rpd_Normal then
    xx := fNumVertexes
  else
    xx := fNumIndices;

  case fPrimitiveType of
    D3DPT_TRIANGLELIST: Result := xx div 3;
    D3DPT_TRIANGLESTRIP,
    D3DPT_TRIANGLEFAN: Result := Max(xx - 2, 0);
  else
    begin
      Result := 0;
      Exit;
    end;
  end;
end;

procedure TD3DGenericRTLPolygon.SetNumVertexes(value: integer);
begin
  if fNumVertexes <> value then
  begin
    fNumVertexes := value;
    ReAllocMem(fVertexes, value * SizeOf(TD3DLVertex));
  end;
end;

procedure TD3DGenericRTLPolygon.SetNumIndices(value: integer);
begin
  if fNumIndices <> value then
  begin
    fNumIndices := value;
    ReAllocMem(fIndices, value * SizeOf(word));
  end;
end;

{$IFDEF DESIGNER}
function TD3DGenericRTLPolygon.RTL_CanBeRuntime: boolean;
begin
  Result := False;
end;

procedure TD3DGenericRTLPolygon.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull);
begin
  DeclareSession := '';
  InitSession := '';
  DrawSession := '';
  DoneSession := '';
end;

function TD3DGenericRTLPolygon.CanSaveVertexes: boolean;
begin
  Result := True;
end;

procedure TD3DGenericRTLPolygon.SaveVertexes(fName: string);
var f: TFileStream;
    cc: TD3DCull;
    pp: TD3DPrimitiveType;
    i: integer;
begin
  f := TFileStream.Create(fName, fmCreate or fmShareDenyWrite);
  try
    cc := D3DCULL_NONE;
    pp := fPrimitiveType;
    f.Write(cc, SizeOf(cc));
    f.Write(pp, SizeOf(pp));
    for i := 0 to fNumIndices do
      f.Write(fVertexes[fIndices[i]], SizeOf(TD3DLVertex));
  finally
    f.Free;
  end;
end;

{$ENDIF}
{$ENDIF}

// *** TD3DTimingObject ***
constructor TD3DTimingObject.Create(aDXDraw: TDXDraw; aTexture: TDirect3DTexture2);
begin
  Textures[0, 0] := aTexture;
  Inherited Create(aDXDraw, aTexture);
end;

constructor TD3DTimingObject.CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTexture: TDirect3DTexture2; version: integer);
begin
  Textures[0, 0] := aTexture;
  Inherited CreateFromStream(s, aDXDraw, aTexture, version);
end;

procedure TD3DTimingObject.GetCurrentTextures(var tex1, tex2:  TDirect3DTexture2);
var
  idx: integer;
begin
  idx := CurTextureIndex;
  tex1 := Textures[idx, 0];
  tex2 := Textures[idx, 1];
  if tex2 = tex1 then
    tex2 := nil;
end;

// *** TD3DExtraRTLPolygon ***

{$IFNDEF NO_D3DEXTRARTLPOLYGONS}
constructor TD3DExtraRTLPolygon.Create(aDXDraw: TDXDraw; const aTextures: TDirect3DTextures2;
  const aTextureNames: TTextureNames);
begin
  fName := '';
  fTextureNames := aTextureNames;
  Textures := aTextures;
  fddu := 0.0;
  fddv := 0.0;
  fInterval := 0.0;
  fNumVertexes := 0;
  fNumIndices := 0;
  fVertexes := nil;
  fIndices := nil;
  fPrimitiveType := D3DPT_TRIANGLELIST;
  fVertexTypeDesc := D3DFVF_LVERTEX;
  fDrawMethod := rpd_Normal;
  Inherited Create(aDXDraw, aTextures[0, 0]);
end;

destructor TD3DExtraRTLPolygon.Destroy;
begin
  ReAllocMem(fIndices, 0);
  ReAllocMem(fVertexes, 0);
  fNumVertexes := 0;
  fNumIndices := 0;
  Inherited;
end;

constructor TD3DExtraRTLPolygon.CreateFromStream(s: TStream; aDXDraw: TDXDraw;
  aTextures: TDirect3DTextures2; version: integer);
begin
  LoadFromStream(s, version);
  fName := '';
  Textures := aTextures;
  Inherited Create(aDXDraw, aTextures[0, 0]);
end;

procedure TD3DExtraRTLPolygon.SetTextureNames(value: TTextureNames);
begin
  fTextureNames := value;
  CalcNumTextureNames;
end;

procedure TD3DExtraRTLPolygon.CalcNumTextureNames;
begin
  fNumTextures := 0;
  while fNumTextures < MAXTEXTURES do
  begin
    if fTextureNames[fNumTextures, 0] = '' then
      Exit;
    inc(fNumTextures);
  end;
end;

procedure TD3DExtraRTLPolygon.ReduceMemory;
var i: integer;
begin
  if fDrawMethod = rpd_Indexed then
  begin
    for i := 0 to fNumIndices - 1 do
      if fIndices[i] <> i then
        Exit;
    fDrawMethod := rpd_Normal;
    NumIndices := 0;
  end;
end;

{$IFNDEF NO_DXMESHES}
procedure TD3DExtraRTLPolygon.AdjustMeshData;
begin
  Inherited AdjustMeshData;
  fMesh.VertexTypeDesc := @fVertexTypeDesc;
  fMesh.Cull := @fCull;
  fMesh.PrimitiveType := @fPrimitiveType;
  fMesh.NumVertexes := @fNumVertexes;
  fMesh.Vertexes := @fVertexes;
  fMesh.NumIndices := @fNumIndices;
  fMesh.Indices := @fIndices;
end;
{$ENDIF}

procedure TD3DExtraRTLPolygon.SaveToStream(s: TStream);
begin
  Inherited SaveToStream(s);
  s.Write(fPrimitiveType, SizeOf(fPrimitiveType));
  s.Write(fVertexTypeDesc, SizeOf(fVertexTypeDesc));
  s.Write(fDrawMethod, SizeOf(fDrawMethod));
  s.Write(fNumVertexes, SizeOf(fNumVertexes));
  s.Write(fVertexes^, fNumVertexes * SizeOf(fVertexes[0]));
  s.Write(fNumIndices, SizeOf(fNumIndices));
  s.Write(fIndices^, fNumIndices * SizeOf(fIndices[0]));
  s.Write(fcull, SizeOf(fcull));
  s.Write(fddu, SizeOf(fddu));
  s.Write(fddv, SizeOf(fddv));
  s.Write(fInterval, SizeOf(fInterval));
end;

procedure TD3DExtraRTLPolygon.LoadFromStream(s: TStream; version: integer);
var tmp: integer;
begin
  Inherited LoadFromStream(s, version);
  s.Read(fPrimitiveType, SizeOf(fPrimitiveType));
  s.Read(fVertexTypeDesc, SizeOf(fVertexTypeDesc));
  s.Read(fDrawMethod, SizeOf(fDrawMethod));
  s.Read(tmp, SizeOf(tmp));
  NumVertexes := tmp;
  s.Read(fVertexes^, fNumVertexes * SizeOf(fVertexes[0]));
  s.Read(tmp, SizeOf(tmp));
  NumIndices := tmp;
  s.Read(fIndices^, fNumIndices * SizeOf(fIndices[0]));
  s.Read(fcull, SizeOf(fcull));
  s.Read(fddu, SizeOf(fddu));
  s.Read(fddv, SizeOf(fddv));
  s.Read(fInterval, SizeOf(fInterval));
end;

procedure TD3DExtraRTLPolygon.InitParams;
var
  canv: TCanvas;
begin
  if Texture[0] = nil then
  begin
    Graphic.Bitmap.Width := 2;
    Graphic.Bitmap.Height := 2;
    Graphic.Bitmap.PixelFormat := pf24bit;
    canv := Graphic.Bitmap.Canvas;
    canv.Pixels[0, 0] := $FFFFFF;
    canv.Pixels[1, 0] := $FFFFFF;
    canv.Pixels[0, 1] := $FFFFFF;
    canv.Pixels[1, 1] := $FFFFFF;
    Texture[0] := TDirect3DTexture2.Create(DXDraw, Graphic, False);
  end;
  Texture[0].Transparent := True;
  CalcNumTextureNames;
end;

procedure TD3DExtraRTLPolygon.Draw;
var
  dev: IDirect3DDevice7;
  i: integer;
  Vertexes3: array[0..2] of TD3DLVertex;
  idx: integer;
  _ddu, _ddv: TD3DValue;
begin
  dev := DXDraw.D3DDevice7;
  dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(fCull));

  if (fddu <> 0.0) or (fddv <> 0.0) then
  begin
    if fddu = 0 then
    begin
    	_ddv := fddv * (fTime);
    	for i := 0 to fNumVertexes - 1 do
    	begin
    		fVertexes[i].tv := fVertexes[i].tv + _ddv;
    	end;
    end
    else if fddv = 0 then
    begin
    	_ddu := fddu * (fTime);
    	for i := 0 to fNumVertexes - 1 do
    	begin
	    	fVertexes[i].tu := fVertexes[i].tu + _ddu;
    	end;
    end
    else
    begin
    	_ddu := fddu * (fTime);
    	_ddv := fddv * (fTime);
    	for i := 0 to fNumVertexes - 1 do
    	begin
	    	fVertexes[i].tu := fVertexes[i].tu + _ddu;
    		fVertexes[i].tv := fVertexes[i].tv + _ddv;
    	end;
    end;
  end;


  idx := CurTextureIndex;
  
  dev.SetTexture(0, Textures[idx, 0].Surface.IDDSurface7);
  if fDrawMethod = rpd_Normal then
  begin
    if fSafeMode and (fPrimitiveType = D3DPT_TRIANGLELIST) then
    begin
      i := 0;
      while i < fNumVertexes do
      begin
        dev.DrawPrimitive(D3DPT_TRIANGLELIST, fVertexTypeDesc, fVertexes[i], 3, 0);
        inc(i, 3);
      end;
    end
    else
      dev.DrawPrimitive(fPrimitiveType, fVertexTypeDesc, fVertexes[0], fNumVertexes, 0)
  end
  else
  begin
    if fSafeMode and (fPrimitiveType = D3DPT_TRIANGLELIST) then
    begin
      i := 0;
      while i < fNumIndices do
      begin
        Vertexes3[0] := fVertexes[fIndices[i]];
        inc(i);
        Vertexes3[1] := fVertexes[fIndices[i]];
        inc(i);
        Vertexes3[2] := fVertexes[fIndices[i]];
        inc(i);
        dev.DrawPrimitive(D3DPT_TRIANGLELIST, fVertexTypeDesc, Vertexes3, 3, 0);
      end;

    end
    else
      dev.DrawIndexedPrimitive(fPrimitiveType, fVertexTypeDesc,
        fVertexes[0], fNumVertexes, fIndices[0], fNumIndices, 0)
  end;
end;

function TD3DExtraRTLPolygon.GetTypeID: byte;
begin
  Result := ID3D_ExtraRTLPolygon;
end;

procedure TD3DExtraRTLPolygon.fCalcCenterAndRadius;
begin
  CalcCenterAndRadius(Vertexes, fNumVertexes, fRadius, fCenter);
end;

procedure TD3DExtraRTLPolygon.Move(vM: TD3DVector);
var
  i: integer;
  pV: PD3DLVertex;
begin
  pV := @Vertexes[0];
  for i := 0 to fNumVertexes - 1 do
  begin
    pV.x := pV.x + vM.x;
    pV.y := pV.y + vM.y;
    pV.z := pV.z + vM.z;
    inc(pV);
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DExtraRTLPolygon.Rotate(vM: TD3DVector);
var
  mat: TD3DMatrix;
  v1, v2: TD3DVector;
  i: integer;
  pV: PD3DLVertex;
begin
  GetRotationMatrix(mat, vM.x, vM.y, vM.z);
  pV := @Vertexes[0];
  for i := 0 to fNumVertexes - 1 do
  begin
    v1 := MakeD3DVector(pV^);
    D3DMath_VectorMatrixMultiply(v2, v1, mat);
    pV.x := v2.x;
    pV.y := v2.y;
    pV.z := v2.z;
    inc(pV);
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DExtraRTLPolygon.GetTextureNames(var s: TDXStringList);
var
  i: integer;
begin
  for i := 0 to fNumTextures - 1 do
  begin
    if s.IndexOf(fTextureNames[i, 0]) = -1 then
      s.Add(fTextureNames[i, 0]);
    if s.IndexOf(fTextureNames[i, 1]) = -1 then
      s.Add(fTextureNames[i, 1]);
  end;
end;

function TD3DExtraRTLPolygon.CalcDistance(const Position: TD3DVector): TD3DValue;
begin
  if fNumVertexes > 0 then
    Result := VectorMagnitude(MakeD3DVector(
      fVertexes[0].x - Position.X,
      fVertexes[0].y - Position.Y,
      fVertexes[0].z - Position.Z))
  else
    Result := 0.0;
end;

function TD3DExtraRTLPolygon.TextureName: string;
begin
  Result := fTextureNames[0, 0];
end;

procedure TD3DExtraRTLPolygon.GetInfo(p: Pointer);
var
  i: integer;
begin
  PExtraRTLPolygonInfo(p).Key := 0;
  for i := 0 to fNumVertexes - 1 do
    PExtraRTLPolygonInfo(p).Vertexes[i] := fVertexes[i];
  PExtraRTLPolygonInfo(p).NumVertexes := fNumVertexes;
  for i := 0 to fNumIndices - 1 do
  	PExtraRTLPolygonInfo(p).Indices[i] := fIndices[i];
  PExtraRTLPolygonInfo(p).PrimitiveType := fPrimitiveType;
  PExtraRTLPolygonInfo(p).VertexTypeDesc := fVertexTypeDesc;
  PExtraRTLPolygonInfo(p).DrawMethod := fDrawMethod;
  PExtraRTLPolygonInfo(p).ddu := fddu;
  PExtraRTLPolygonInfo(p).ddv := fddv;
  PExtraRTLPolygonInfo(p).Cull := fCull;
  PExtraRTLPolygonInfo(p).Interval := fInterval;
  PExtraRTLPolygonInfo(p).NumTextures := fNumTextures;
  PExtraRTLPolygonInfo(p).TextureNames := TextureNames;
end;

function TD3DExtraRTLPolygon.GetLocatePosition(aDistance: TD3DValue): TD3DVector;
begin
  if fNumVertexes > 0  then
    Result := MakeD3DVector(
      fVertexes[0].x,
      fVertexes[0].y,
      fVertexes[0].z - aDistance)
  else
    Result := NULLVECTOR;
end;

procedure TD3DExtraRTLPolygon.ApplyLight(l: TD3DSceneLight);
var
  i: integer;
begin
  if fVertexTypeDesc = D3DFVF_LVERTEX then
    if l.IsAppliable(GetLocatePosition(0.0)) then
      for i := 0 to fNumVertexes do
        l.ApplyToVertex(fVertexes[i], $FFFFFF);
end;

function TD3DExtraRTLPolygon.GetNumVertexes: integer;
begin
  Result := fNumVertexes;
end;

function TD3DExtraRTLPolygon.GetNumTriangles: integer;
var
  xx: integer;
begin
  if fDrawMethod = rpd_Normal then
    xx := fNumVertexes
  else
    xx := fNumIndices;

  case fPrimitiveType of
    D3DPT_TRIANGLELIST: Result := xx div 3;
    D3DPT_TRIANGLESTRIP,
    D3DPT_TRIANGLEFAN: Result := Max(xx - 2, 0);
  else
    begin
      Result := 0;
      Exit;
    end;
  end;
end;

procedure TD3DExtraRTLPolygon.SetNumVertexes(value: integer);
begin
  if fNumVertexes <> value then
  begin
    fNumVertexes := value;
    ReAllocMem(fVertexes, value * SizeOf(TD3DLVertex));
  end;
end;

procedure TD3DExtraRTLPolygon.SetNumIndices(value: integer);
begin
  if fNumIndices <> value then
  begin
    fNumIndices := value;
    ReAllocMem(fIndices, value * SizeOf(word));
  end;
end;

function TD3DExtraRTLPolygon.CurTextureName: string;
begin
  Result := TextureNames[CurTextureIndex, 0];
end;

function TD3DExtraRTLPolygon.CurTextureIndex: integer;
begin
  if (fInterval = 0) or (fNumTextures = 0) then
    Result := 0
  else
    Result := trunc(fTime * fNumTextures / fInterval) mod fNumTextures;
end;


{$IFDEF DESIGNER}
function TD3DExtraRTLPolygon.RTL_CanBeRuntime: boolean;
begin
  Result := False;
end;

procedure TD3DExtraRTLPolygon.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull);
begin
  DeclareSession := '';
  InitSession := '';
  DrawSession := '';
  DoneSession := '';
end;

function TD3DExtraRTLPolygon.CanSaveVertexes: boolean;
begin
  Result := True;
end;

procedure TD3DExtraRTLPolygon.SaveVertexes(fName: string);
var
  f: TFileStream;
  cc: TD3DCull;
  pp: TD3DPrimitiveType;
  i: integer;
begin
  f := TFileStream.Create(fName, fmCreate or fmShareDenyWrite);
  try
    cc := fCull;
    pp := fPrimitiveType;
    f.Write(cc, SizeOf(cc));
    f.Write(pp, SizeOf(pp));
    for i := 0 to fNumIndices do
      f.Write(fVertexes[fIndices[i]], SizeOf(TD3DLVertex));
  finally
    f.Free;
  end;
end;

{$ENDIF}
{$ENDIF}

// *** TD3DAnimatingObject ***
constructor TD3DAnimatingObject.Create(aDXDraw: TDXDraw; aTexture: TDirect3DTexture2);
begin
  OnEndAnimation := nil;
  OnNewFrame := nil;
  OnEveryFrame := nil;
  Inherited Create(aDXDraw, aTexture);
end;

{$IFNDEF NO_D3DSTUBOBJECTS}
// *** TD3DStubObject ***
constructor TD3DStubObject.Create(aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; aInfo: TD3DStubObjectInfo);
begin
  Info := aInfo;
  Textures := aTextures;
  Inherited Create(aDXDraw, aTextures[0, 0]);
end;

{$IFDEF DESIGNER}
function TD3DStubObject.CanSaveVertexes: boolean;
begin
  Result := True;
end;

procedure TD3DStubObject.SaveVertexes(fName: string);
var
  f: TFileStream;
  cc: TD3DCull;
  pp: TD3DPrimitiveType;
begin
  f := TFileStream.Create(fName, fmCreate or fmShareDenyWrite);
  try
    cc := D3DCULL_NONE;
    pp := D3DPT_TRIANGLESTRIP;
    f.Write(cc, SizeOf(cc));
    f.Write(pp, SizeOf(pp));
    f.Write(Vertexes, 4 * SizeOf(TD3DLVertex));
  finally
    f.Free;
  end;
end;

function TD3DStubObject.RTL_CanBeRuntime: boolean;
begin
  Result := False;
end;

procedure TD3DStubObject.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull);
begin
  DeclareSession := '';
  InitSession := '';
  DrawSession := '';
  DoneSession := '';
end;
{$ENDIF}

constructor TD3DStubObject.CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; version: integer);
begin
  LoadFromStream(s, version);
  Create(aDXDraw, aTextures, Info);
end;

procedure TD3DStubObject.fCalcCenterAndRadius;
begin
  fRadius := Max(Info.Width, Info.Height) / 2;
  fCenter := MakeD3DVector(Info.x, Info.y, Info.z);
end;

procedure TD3DStubObject.ApplyLight(l: TD3DSceneLight);
var
  C: TColor;
begin
  if l.IsAppliable(GetLocatePosition(0.0)) then
  begin
    C := Info.C;
    l.ApplyToVertex(Vertexes[0], C);
    l.ApplyToVertex(Vertexes[1], C);
    l.ApplyToVertex(Vertexes[2], C);
    l.ApplyToVertex(Vertexes[3], C);
  end;
end;

procedure TD3DStubObject.InitParams;
var
  C: TColor;
  canv: TCanvas;
begin
  PerspectiveRotate(NULLVECTOR, NULLVECTOR);
{ ֱם פן texture וםבי nil פפו פן Info.C ךסבפוי פן קס‏לב פחע וניצםויבע
  היבצןסופיך ךסבפוי transparency  lighting information. }
  if Texture[0] = nil then
  begin
    Graphic.Bitmap.Width := 2;
    Graphic.Bitmap.Height := 2;
    Graphic.Bitmap.PixelFormat := pf24bit;
    C := Info.C;
    canv := Graphic.Bitmap.Canvas;
    canv.Pixels[0, 0] := C;
    canv.Pixels[1, 0] := C;
    canv.Pixels[0, 1] := C;
    canv.Pixels[1, 1] := C;
    Texture[0] := TDirect3DTexture2.Create(DXDraw, Graphic, False);
    Info.NumTextures := 0; // ֱם פן נס‏פן Texture וםבי nil ץנןטפןץלו נשע הום קןץלו ככב Textures
  end
{ ִםןץלו לחהוםיךע פילע ףפיע היבףפףויע פןץ Graphic.Bitmap
  ָב פן קסחףילןנןיףןץלו דיב כודקן ךבפ פן Draw ‏ףפו םב וניכמןץלו:
    1. Transparent Draw פןץ Texture
    2. Non transparent Draw, בנכ‏ע לב ךטופח וניצםויב לו קס‏לב Info.C }
  else
  begin
    Texture[0].Transparent := True;
//    Texture.Surface.TransparentColor := Info.C;
    Graphic.Bitmap.Width := 0;
    Graphic.Bitmap.Height := 0;
  end;
end;

// ׀וסיףפסןצ לו perspective (ךבפ פחם בככבד טףחע פןץ נבסבפחסחפ)
procedure TD3DStubObject.PerspectiveRotate(aPosition, aRotation: TD3DVector);
var
  cosa, sina: single;
  r: TD3DVector;
  aC: TD3DColor;
  H2, W2: TD3DValue;
  pV: PD3DLVertex;
begin
  with Info do
  begin
  // ֱם הום ךםןץלו נוסיףפסןצ לו perspective ךבכן‎לו פחם SimpleRotate()
    if SimpleRotation or fSafeMode then
      SimpleRotate(aRotation.Y)
    else
    begin
      aC := CA_MAKE(Info.C, 0);
      W2 := Width / 2;
      r := VectorNormalize(VectorSub(aPosition, MakeD3DVector(x, y, z)));
      cosa := cos(aRotation.y) * W2 * abs(cos(r.x - aRotation.x));
      sina := sin(aRotation.y) * W2;

      H2 := Height / 2;

      pV := @Vertexes[0];
      pV^ := MakeD3DLVERTEX(
        x - cosa, y + H2, z + sina,
          aC, 0,
            du, dv);

      inc(pV);
      pV^ := MakeD3DLVERTEX(
        x + cosa, y + H2, z - sina,
          aC, 0,
            u + du, dv);

      inc(pV);
      pV^ := MakeD3DLVERTEX(
        x - cosa, y - H2, z + sina,
          aC, 0,
            du, v + dv);

      inc(pV);
      pV^ := MakeD3DLVERTEX(
        x + cosa, y - H2, z - sina,
          aC, 0,
            u + du, v + dv);
    end;
  end;
end;

// ׀וסיףפסןצ קשסע perspective (ךבפ פחם בככבד דשםבע טבףחע פןץ נבסבפחסחפ)
procedure TD3DStubObject.SimpleRotate(angle: single);
var
  cosa, sina: single;
  aC: TD3DColor;
  W2, H2: TD3DValue;
  pV: PD3DLVertex;
begin
  with Info do
  begin
    SinCosS(angle, sina, cosa);
    W2 := Width / 2;
    cosa := cosa * W2;
    sina := sina * W2;
    aC := CA_MAKE(C, 0);
    H2 := Height / 2;

    pV := @Vertexes[0];

{    pV^ := MakeD3DLVERTEX(
      x + cosa, y + H2, z - sina,
        aC, 0,
          du, dv);

    inc(pV);
    pV^ := MakeD3DLVERTEX(
      x - cosa, y + H2, z + sina,
        aC, 0,
          u + du, dv);

    inc(pV);
    pV^ := MakeD3DLVERTEX(
      x + cosa, y - H2, z - sina,
        aC, 0,
          du, v + dv);

    inc(pV);
    pV^ := MakeD3DLVERTEX(
      x - cosa, y - H2, z + sina,
        aC, 0,
          u + du, v + dv);}

    pV^ := MakeD3DLVERTEX(
      x - cosa, y + H2, z + sina,
        aC, 0,
          du, dv);

    inc(pV);
    pV^ := MakeD3DLVERTEX(
      x + cosa, y + H2, z - sina,
        aC, 0,
          u + du, dv);

    inc(pV);
    pV^ := MakeD3DLVERTEX(
      x - cosa, y - H2, z + sina,
        aC, 0,
          du, v + dv);

    inc(pV);
    pV^ := MakeD3DLVERTEX(
      x + cosa, y - H2, z - sina,
        aC, 0,
          u + du, v + dv);
  end;
end;

procedure TD3DStubObject.Draw;
var
  i, CurIndex: integer;
  dev: IDirect3DDevice7;
begin
  dev := DXDraw.D3DDevice7;
// ֲזןץלו D3DCULL_NONE דיבפ פבם קןץלו pi נוסיףפסןצ, הום צבםןםפבם פן בםפיךולוםן
  dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(D3DCULL_NONE));
  if (Info.Transparency <> 0) and (Graphic.Bitmap.Width = 0) then // Transparent Draw (ךןפב TD3DStubObject.InitParams;)
  begin
    CurIndex := CurTextureIndex;
    if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    begin
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
      dev.SetTexture( 0, Textures[CurIndex, 0].Surface.IDDSurface7);
      dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
      dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
    // ֲכיק, לנןסו םב קסויבףפו םב ךבכףןץלו פחם DrawPrimitive נןככע צןסע
    // בככ נסםןץלו םב חליהיבצבםע Texture.
      for i := 1 to Info.Transparency do
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, Vertexes[0], 4, 0);
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
    end
    else
    begin
    // ױנסקוי לףךב, פחם קסחףילןנןין‎לו.
    // ¼פבם הום ץנסקוי לףךב ףפן Textures[CurIndex, 1] ץנסקוי ן הוךפחע
    // פןץ Textures[CurIndex, 0] (ךןפב ::AddTexturesToCollection)
      if Textures[CurIndex, 1] <> Textures[CurIndex, 0] then
      begin
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
        // ׃קוהיזןץלו פחם לףךב...
        dev.SetTexture( 0, Textures[CurTextureIndex, 1].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, Vertexes[0], 4, 0);
        // ...ךבי פחם נופלו בנ נםש פחם ויךםב
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVDESTCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetTexture( 0, Textures[CurTextureIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, Vertexes[0], 4, 0);
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
      end
      else // ִום ץנסקוי לףךב
      begin
{   // The following gives a very good transparent effect!
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_SRCBLEND, ord(D3DBLEND_SRCCOLOR));
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_DESTBLEND, ord(D3DBLEND_ONE));
}
      // Disable D3DRENDERSTATE_ALPHABLENDENABLE before setting transparent color
        Textures[CurIndex, 0].Surface.TransparentColor := 0;
        dev.SetTexture(0, Textures[CurIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, Vertexes[0], 4, 0);

      end;

    end;
    dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
  end
  else if Graphic.Bitmap.Width = 0 then
  begin
    CurIndex := CurTextureIndex;
    Textures[CurIndex, 0].Surface.TransparentColor := 0;
    dev.SetTexture( 0, Textures[CurIndex, 0].Surface.IDDSurface7);
    dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, Vertexes[0], 4, 0);
  end
  else
  begin
  // ¸קןץלו םב stub Bitmap 2x2, הום קןץלו animation! (=הום קוי ןסיףטו Texture)
  //  הום קןץלו Transparent DRAW
    dev.SetTexture(0, Texture[0].Surface.IDDSurface7);
    dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, Vertexes[0], 4, 0);
  end;
end;

procedure TD3DStubObject.Move(vM: TD3DVector);
begin
  with Info do
  begin
    x := x + vM.x;
    y := y + vM.y;
    z := z + vM.z;
  end;
  PerspectiveRotate(NULLVECTOR, NULLVECTOR);
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DStubObject.Rotate(vM: TD3DVector);
var
  mat: TD3DMatrix;
  v1,v2: TD3DVector;
begin
  GetRotationMatrix(mat, vM.x, vM.y, vM.z);
  with Info do
  begin
    v1 := MakeD3DVector(x, y, z);
    D3DMath_VectorMatrixMultiply(v2, v1, mat);
    x := v2.x;
    y := v2.y;
    z := v2.z;
  end;
  PerspectiveRotate(NULLVECTOR, NULLVECTOR);
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DStubObject.GetTextureNames(var s: TDXStringList);
var
  i: integer;
begin
  for i := 0 to Info.NumTextures - 1 do
  begin
    if Info.TextureNames[i, 0] <> '' then
      if s.IndexOf(Info.TextureNames[i, 0]) = -1 then
         s.Add(Info.TextureNames[i, 0]);
    if Info.TextureNames[i, 1] <> '' then
      if s.IndexOf(Info.TextureNames[i, 1]) = -1 then
         s.Add(Info.TextureNames[i, 1]);
  end;
end;

function TD3DStubObject.IsIdentical(D3DSurface: TObject): boolean;
var
  inf: TD3DStubObjectInfo;
begin
  Result := False;
  if not Inherited IsIdentical(D3DSurface) then
    Exit;
  if D3DSurface is TD3DStubObject then
  begin
    (D3DSurface as TD3DStubObject).GetInfo(@inf);
    Result := (
      (inf.x = Info.x) and
      (inf.y = Info.y) and
      (inf.z = Info.z) and
      (inf.Width = Info.Width) and
      (inf.Height = Info.Height) and
      (inf.zOrder = Info.zOrder) and
      (inf.C = Info.C) and
      (inf.Transparency = Info.Transparency) and
      (inf.NumTextures = Info.NumTextures) and
      (inf.u = Info.u) and
      (inf.v = Info.v) and
      (inf.du = Info.du) and
      (inf.dv = Info.dv) and
      TextureNamesEqual(inf.TextureNames, Info.TextureNames, Info.NumTextures));
  end;
end;

function TD3DStubObject.GetTypeID: byte;
begin
  Result := ID3D_StubObject;
end;

function TD3DStubObject.GetKeyID: integer;
begin
  Result := Info.Key;
end;

procedure TD3DStubObject.SaveToStream(s: TStream);
begin
  Inherited SaveToStream(s);
  with Info do
  begin
    s.Write(Key,SizeOf(Key));
    s.Write(x, SizeOf(x));
    s.Write(y, SizeOf(y));
    s.Write(z, SizeOf(z));
    s.Write(Width, SizeOf(Width));
    s.Write(Height, SizeOf(Height));
    s.Write(zOrder, SizeOf(zOrder));
    s.Write(C, SizeOf(C));
    s.Write(Transparency, SizeOf(Transparency));
    s.Write(NumTextures, SizeOf(NumTextures));
    s.Write(Interval, SizeOf(Interval)); // טו נףב sec ונבםבכבלגםןםפבי פב TextureNames ?
    s.Write(u, SizeOf(u));
    s.Write(v, SizeOf(v));
    s.Write(du, SizeOf(du));
    s.Write(dv, SizeOf(dv));
    s.Write(SimpleRotation, SizeOf(SimpleRotation));
  end;
end;

{$IFNDEF NO_OLDSTREAMINGRUTINES}
procedure TD3DStubObject.OldLoadFromStream(s: TStream; version: integer);
var
  si: shortInt;
  intd: double;
begin
  with Info do
  begin
    s.Read(Key,SizeOf(Key));
    s.Read(x, SizeOf(x));
    s.Read(y, SizeOf(y));
    s.Read(z, SizeOf(z));
    s.Read(Width, SizeOf(Width));
    s.Read(Height, SizeOf(Height));
    s.Read(zOrder, SizeOf(zOrder));
    s.Read(C, SizeOf(C));
    s.Read(Transparency, SizeOf(Transparency));
    if version >= FILEVERSION_100 then
    begin
      s.Read(NumTextures, SizeOf(NumTextures));
      s.Read(Interval, SizeOf(Interval)); // טו נףב sec ונבםבכבלגםןםפבי פב TextureNames ?
    end
    else
    begin
      s.Read(si, SizeOf(si));
      NumTextures := si;
      s.Read(intd, SizeOf(intd));
      Interval := intd;
    end;
    if version >= FILEVERSION_119 then
    begin
      s.Read(u, SizeOf(u));
      s.Read(v, SizeOf(v));
      s.Read(du, SizeOf(du));
      s.Read(dv, SizeOf(dv));
    end
    else
    begin
      u := 1.0;
      v := 1.0;
      du := 0.0;
      dv := 0.0;
    end;
    s.Read(SimpleRotation, SizeOf(SimpleRotation));
    PerspectiveRotate(NULLVECTOR, NULLVECTOR);
  end;
end;
{$ENDIF}

procedure TD3DStubObject.LoadFromStream(s: TStream; version: integer);
begin
  Inherited LoadFromStream(s, version);
{$IFNDEF NO_OLDSTREAMINGRUTINES}
  if version < FILEVERSION_119 then
    OldLoadFromStream(s, version)
  else {$ENDIF} with Info do
  begin
    s.Read(Key,SizeOf(Key));
    s.Read(x, SizeOf(x));
    s.Read(y, SizeOf(y));
    s.Read(z, SizeOf(z));
    s.Read(Width, SizeOf(Width));
    s.Read(Height, SizeOf(Height));
    s.Read(zOrder, SizeOf(zOrder));
    s.Read(C, SizeOf(C));
    s.Read(Transparency, SizeOf(Transparency));
    s.Read(NumTextures, SizeOf(NumTextures));
    s.Read(Interval, SizeOf(Interval)); // טו נףב sec ונבםבכבלגםןםפבי פב TextureNames ?
    s.Read(u, SizeOf(u));
    s.Read(v, SizeOf(v));
    s.Read(du, SizeOf(du));
    s.Read(dv, SizeOf(dv));
    s.Read(SimpleRotation, SizeOf(SimpleRotation));
    PerspectiveRotate(NULLVECTOR, NULLVECTOR);
  end;
end;

function TD3DStubObject.CalcDistance(const Position: TD3DVector): TD3DValue; register;
begin
  if Info.zOrder > 50000 then // ֿץסבםע, פבגםי, נפשלב
    Distance := Info.zOrder
  else
    Distance := VectorMagnitude(MakeD3DVector(
      Info.x - Position.X,
      Info.y - Position.Y,
      Info.z - Position.Z));
  Result := Distance;
end;

function TD3DStubObject.TextureName: string;
begin
  Result := Info.TextureNames[0, 0];
end;

function TD3DStubObject.CurTextureName: string;
{
Info.Interval -> Info.NumTextures
fTime         -> ?
? = (Info.NumTextures * fTime / Info.Iterval )
}
begin
  Result := Info.TextureNames[CurTextureIndex, 0];
end;

function TD3DStubObject.CurTextureIndex: integer;
begin
  if (Info.Interval = 0) or (Info.NumTextures = 0) then
    Result := 0
  else
    Result := trunc(fTime * Info.NumTextures / Info.Interval) mod Info.NumTextures;
end;

procedure TD3DStubObject.GetInfo(p: Pointer);
begin
  PD3DStubObjectInfo(p)^ := Info;
end;

// ֵםפןניףלע פןץ בםפיךוילםןץ
// ֵניףפסצוי פחם טףח נבסבפסחףחע ףו בנףפבףח distance
function TD3DStubObject.GetLocatePosition(aDistance: TD3DValue): TD3DVector;
begin
  with info do
    Result := MakeD3DVector(x, y, z - aDistance);
end;

// ֱסיטלע Vertexes פןץ בםפיךוילםןץ
function TD3DStubObject.GetNumVertexes: integer;
begin
  if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    Result := 4 * Info.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := 4 * 2
  else
    Result := 4;
end;

// ֱסיטלע װסיד‏םשם פןץ בםפיךוילםןץ
function TD3DStubObject.GetNumTriangles: integer;
begin
  if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    Result := 2 * Info.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := 2 * 2
  else
    Result := 2
end;
{$ENDIF}

{$IFNDEF NO_D3DEXOBJECTS}
// *** TD3DExObject
constructor TD3DExObject.Create(aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; aInfo: TD3DExObjectInfo);
begin
  fMirror := False;
  fVangle := 0.0;
  fVPos := NULLVECTOR;
  Info := aInfo;
  Textures := aTextures;
  frameChar := Info.AnimStart;
  fLastFrameChar := Info.AnimStart;
  fLastFrameFromOtherAnimation := False;
  Inherited Create(aDXDraw, aTextures[0, 0]);
end;

{$IFDEF DESIGNER}
function TD3DExObject.CanSaveVertexes: boolean;
begin
  Result := True;
end;

procedure TD3DExObject.SaveVertexes(fName: string);
var
  f: TFileStream;
  cc: TD3DCull;
  pp: TD3DPrimitiveType;
begin
  f := TFileStream.Create(fName, fmCreate  or fmShareDenyWrite);
  try
    cc := D3DCULL_NONE;
    pp := D3DPT_TRIANGLESTRIP;
    f.Write(cc, SizeOf(cc));
    f.Write(pp, SizeOf(pp));
    f.Write(Vertexes, 4 * SizeOf(TD3DLVertex));
  finally
    f.Free;
  end;
end;

function TD3DExObject.RTL_CanBeRuntime: boolean;
begin
  Result := False;
end;

procedure TD3DExObject.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull);
begin
  DeclareSession := '';
  InitSession := '';
  DrawSession := '';
  DoneSession := '';
end;
{$ENDIF}

constructor TD3DExObject.CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; version: integer);
begin
  LoadFromStream(s, version);
  Create(aDXDraw, aTextures, Info);
end;

procedure TD3DExObject.fCalcCenterAndRadius;
begin
  fRadius := Max(Info.Width, Info.Height) / 2;
  fCenter := MakeD3DVector(Info.x, Info.y, Info.z);
end;

procedure TD3DExObject.InitParams;
var C: TColor;
    canv: TCanvas;
begin
  MakeTheVertexes;
{ ֱם פן texture וםבי nil פפו פן Info.C ךסבפוי פן קס‏לב פחע וניצםויבע
  היבצןסופיך ךסבפוי transparency information. }
  if Texture[0] = nil then
  begin
    Graphic.Bitmap.Width := 2;
    Graphic.Bitmap.Height := 2;
    Graphic.Bitmap.PixelFormat := pf24bit;
    C := Info.C;
    canv := Graphic.Bitmap.Canvas;
    canv.Pixels[0, 0] := C;
    canv.Pixels[1, 0] := C;
    canv.Pixels[0, 1] := C;
    canv.Pixels[1, 1] := C;
    Texture[0] := TDirect3DTexture2.Create(DXDraw, Graphic, False);
    Info.NumTextures := 0; // ֱם פן נס‏פן Texture וםבי nil ץנןטפןץלו נשע הום קןץלו ככב Textures
  end
{ ִםןץלו לחהוםיךע פילע ףפיע היבףפףויע פןץ Graphic.Bitmap
  ָב פן קסחףילןנןיףןץלו דיב כודקן ךבפ פן Draw ‏ףפו םב וניכמןץלו:
    1. Transparent Draw פןץ Texture
    2. Non transparent Draw, בנכ‏ע לב ךטופח וניצםויב לו קס‏לב Info.C }
  else
  begin
    Texture[0].Transparent := True;
//    Texture.Surface.TransparentColor := Info.C;
    Graphic.Bitmap.Width := 0;
    Graphic.Bitmap.Height := 0;
  end;
end;

procedure TD3DExObject.SimpleRotate(vPos: TD3DVector; vAngle: single);
//procedure TD3DExObject.SimpleRotate(vAngle: single);
var ang: TD3DValue;
begin
  fVPos := vPos;
//  ang :=  {vAngle + }-GetHorizontalProjectionAngle(vPos, MakeD3DVector(Info.x, Info.y, Info.z)) + g_PI_DIV_2;
  ang := GetHorizontalProjectionAngle(vPos, MakeD3DVector(Info.x, Info.y, Info.z));
  ang := GetNormalizeAngle(g_PI_DIV_2 - ang);
  if ang <> fVAngle then
  begin
    fVAngle := ang;
    MakeTheVertexes;
  end;

{  if vAngle <> fVAngle then
  begin
    fVAngle := vAngle;
    MakeTheVertexes;
  end;}
end;

{procedure TD3DExObject.SimpleRotate(vPos: TD3DVector);
var vAngle: single;
begin
  if vPos.x = Info.x then
  begin
    if Info.z < vPos.z then
      vAngle := g_PI_DIV_2
    else if Info.z > vPos.z then
      vAngle := g_3_PI_DIV_2
    else
      vAngle := 0.0
  end
  else
  begin
    vAngle := ArcTan2S(vPos.z - Info.z, vPos.x - Info.x);
    if vAngle < 0 then
      vAngle := vAngle + g_2_PI;
  end;
  SimpleRotate(vAngle);
end;
}
// ׀וסיףפסןצ קשסע perspective (ךבפ פחם בככבד טףחע פןץ נבסבפחסחפ)
procedure TD3DExObject.MakeTheVertexes;
var cosa, sina: single;
    aC: TD3DColor;
    Width2, Height2: TD3DValue;
    pV: PD3DLVertex;
begin
  with Info do
  begin
    aC := CA_MAKE(C, 0);

    SinCosS(fVAngle, sina, cosa);
    Width2 := Width / 2;
    cosa := cosa * Width2;
    sina := sina * Width2;
    Height2 := Height / 2;

    pV := @Vertexes[0];
    pV^ := MakeD3DLVERTEX(
      x - cosa, y + Height2, z + sina,
        aC, 0,
          du, dv);

    inc(pV);
    pV^ := MakeD3DLVERTEX(
      x + cosa, y + Height2, z - sina,
        aC, 0,
          u + du, dv);

    inc(pV);
    pV^ := MakeD3DLVERTEX(
      x - cosa, y - Height2, z + sina,
        aC, 0,
          du, v + dv);

    inc(pV);
    pV^ := MakeD3DLVERTEX(
      x + cosa, y - Height2, z - sina,
        aC, 0,
          u + du, v + dv);
  end;
end;

{      mtrl: TD3DMaterial7;
begin
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
  DXDraw.D3DDevice7.GetMaterial(mtrl);
  mtrl.emissive.r := 0.2;
  mtrl.emissive.g := 0.5;
  DXDraw.D3DDevice7.SetMaterial(mtrl);
}

procedure TD3DExObject.Draw;
var
  i, CurIndex: integer;
  dev: IDirect3DDevice7;
begin
  dev := DXDraw.D3DDevice7;
  if Assigned(OnEveryFrame) then
    OnEveryFrame(frameChar);

  if fLastFrameChar <> frameChar then
    if Assigned(OnNewFrame) then
      OnNewFrame(frameChar);

  if fLastFrameFromOtherAnimation then
    fLastFrameFromOtherAnimation := False
  else if (fLastFrameChar > frameChar) then
    if Assigned(OnEndAnimation) then
      OnEndAnimation;

  CurIndex := CurTextureIndex;

// ֲזןץלו D3DCULL_NONE דיבפ פבם קןץלו pi נוסיףפסןצ, הום צבםןםפבם פן בםפיךולוםן
  dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(D3DCULL_NONE));
  if fMirror then
  begin
    Vertexes[0].tu := - Info.du;
    Vertexes[1].tu := - Info.u - Info.du;
    Vertexes[2].tu := Vertexes[0].tu;
    Vertexes[3].tu := Vertexes[1].tu;
  end
  else
  begin
    Vertexes[0].tu := Info.du;
    Vertexes[1].tu := Info.u + Info.du;
    Vertexes[2].tu := Vertexes[0].tu;
    Vertexes[3].tu := Vertexes[1].tu;
  end;

  if (Info.Transparency <> 0) and (Graphic.Bitmap.Width = 0) then // Transparent Draw (ךןפב TD3DStubObject.InitParams;)
  begin
    if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    begin
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
      dev.SetTexture( 0, Textures[CurIndex, 0].Surface.IDDSurface7);
      dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
      dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
    // ֲכיק, לנןסו םב קסויבףפו םב ךבכףןץלו פחם DrawPrimitive נןככע צןסע
    // בככ נסםןץלו םב חליהיבצבםע Texture.
      for i := 1 to Info.Transparency do
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, Vertexes[0], 4, 0);
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
    end
    else
    begin
    // ױנסקוי לףךב, פחם קסחףילןנןין‎לו.
    // ¼פבם הום ץנסקוי לףךב ףפן Textures[CurIndex, 1] ץנסקוי ן הוךפחע
    // פןץ Textures[CurIndex, 0] (ךןפב ::AddTexturesToCollection
      if Textures[CurIndex, 1] <> Textures[CurIndex, 0] then
      begin
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
        // ׃קוהיזןץלו פחם לףךב...
        dev.SetTexture( 0, Textures[CurIndex, 1].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, Vertexes[0], 4, 0);
        // ...ךבי פחם נופלו בנ נםש פחם ויךםב
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVDESTCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetTexture( 0, Textures[CurIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, Vertexes[0], 4, 0);
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
      end
      else // ִום ץנסקוי לףךב
      begin
{   // The following gives a very good transparent effect!
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_SRCBLEND, ord(D3DBLEND_SRCCOLOR));
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_DESTBLEND, ord(D3DBLEND_ONE));
}
      // Disable D3DRENDERSTATE_ALPHABLENDENABLE before setting transparent color
      // ************
      // ֳיב םב יףק‎וי ףו 8bpp ויךםוע, נסנוי ח נבכפב פןץע םב קוי פב קס‏לבפב פשם Windows!!
      // ************
//        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_COLORKEYENABLE, 1);
        Textures[CurIndex, 0].Surface.TransparentColor := 0;
        dev.SetTexture(0, Textures[CurIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, Vertexes[0], 4, 0);

      end;
    end;
  end
  else if Graphic.Bitmap.Width = 0 then
  begin
{      DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
{        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_SRCBLEND, ord(D3DBLEND_ONE));
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_DESTBLEND, ord(D3DBLEND_ONE));}
    Textures[CurIndex, 0].Surface.TransparentColor := 0;
    dev.SetTexture( 0, Textures[CurIndex, 0].Surface.IDDSurface7);
    dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, Vertexes[0], 4, 0);
  end
  else
  begin
  // ¸קןץלו םב stub Bitmap 2x2, הום קןץלו animation! (=הום קוי ןסיףטו Texture)
  //  הום קןץלו Transparent DRAW
    dev.SetTexture(0, Texture[0].Surface.IDDSurface7);
    dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, Vertexes[0], 4, 0);
    Exit; // <--- //////////////////////////////////
  end;

  fLastFrameChar := frameChar;
end;

procedure TD3DExObject.Move(vM: TD3DVector);
begin
  with Info do
  begin
    x := x + vM.x;
    y := y + vM.y;
    z := z + vM.z;
  end;
  SimpleRotate(fVPos, fVangle);
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DExObject.Rotate(vM: TD3DVector);
var
  mat: TD3DMatrix;
  v1, v2: TD3DVector;
begin
  GetRotationMatrix(mat, vM.x, vM.y, vM.z);
  with Info do
  begin
    v1 := MakeD3DVector(x, y, z);
    D3DMath_VectorMatrixMultiply(v2, v1, mat);
    x := v2.x;
    y := v2.y;
    z := v2.z;
  end;
  SimpleRotate(fVPos, fVangle);
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DExObject.GetTextureNames(var s: TDXStringList);
var
  i: integer;
begin
  for i := 0 to Info.NumTextures - 1 do
  begin
    if Info.TextureNames[i, 0] <> '' then
      if s.IndexOf(Info.TextureNames[i, 0]) = -1 then
         s.Add(Info.TextureNames[i, 0]);
    if Info.TextureNames[i, 1] <> '' then
      if s.IndexOf(Info.TextureNames[i, 1]) = -1 then
         s.Add(Info.TextureNames[i, 1]);
  end;
end;

function TD3DExObject.IsIdentical(D3DSurface: TObject): boolean;
var
  inf: TD3DExObjectInfo;
begin
  Result := False;
  if not Inherited IsIdentical(D3DSurface) then
    Exit;
  if D3DSurface is TD3DExObject then
  begin
    (D3DSurface as TD3DExObject).GetInfo(@inf);
    Result := (
      (inf.x = Info.x) and
      (inf.y = Info.y) and
      (inf.z = Info.z) and
      (inf.angle = Info.angle) and
      (inf.Width = Info.Width) and
      (inf.Height = Info.Height) and
      (inf.zOrder = Info.zOrder) and
      (inf.C = Info.C) and
      (inf.u = Info.u) and
      (inf.v = Info.v) and
      (inf.du = Info.du) and
      (inf.dv = Info.dv) and
      (inf.Transparency = Info.Transparency) and
      TextureNamesEqual(inf.TextureNames, Info.TextureNames, Info.NumTextures));
  end;
end;

function TD3DExObject.GetTypeID: byte;
begin
  Result := ID3D_ExObject;
end;

function TD3DExObject.GetKeyID: integer;
begin
  Result := Info.Key;
end;

procedure TD3DExObject.SaveToStream(s: TStream);
begin
  Inherited SaveToStream(s);
  with Info do
  begin
    s.Write(Key,SizeOf(Key));
    s.Write(x, SizeOf(x));
    s.Write(y, SizeOf(y));
    s.Write(z, SizeOf(z));
    s.Write(angle, SizeOf(angle));
    s.Write(Width, SizeOf(Width));
    s.Write(Height, SizeOf(Height));
    s.Write(zOrder, SizeOf(zOrder));
    s.Write(C, SizeOf(C));
    s.Write(Transparency, SizeOf(Transparency));
    s.Write(NumTextures, SizeOf(NumTextures));
    s.Write(Interval, SizeOf(Interval)); // טו נףב sec ונבםבכבלגםןםפבי פב TextureNames ?
    s.Write(u, SizeOf(u));
    s.Write(v, SizeOf(v));
    s.Write(du, SizeOf(du));
    s.Write(dv, SizeOf(dv));
    s.Write(AnimStart, SizeOf(AnimStart));
    s.Write(AnimEnd, SizeOf(AnimEnd));
  end;
end;

{$IFNDEF NO_OLDSTREAMINGRUTINES}
procedure TD3DExObject.OldLoadFromStream(s: TStream; version: integer);
var
  si: ShortInt;
  intd: double;
begin
  with Info do
  begin
    s.Read(Key,SizeOf(Key));
    s.Read(x, SizeOf(x));
    s.Read(y, SizeOf(y));
    s.Read(z, SizeOf(z));
    s.Read(angle, SizeOf(angle));
    s.Read(Width, SizeOf(Width));
    s.Read(Height, SizeOf(Height));
    s.Read(zOrder, SizeOf(zOrder));
    s.Read(C, SizeOf(C));
    s.Read(Transparency, SizeOf(Transparency));
    if version >= FILEVERSION_100 then
    begin
      s.Read(NumTextures, SizeOf(NumTextures));
      s.Read(Interval, SizeOf(Interval));
    end
    else
    begin
      s.Read(si, SizeOf(si));
      NumTextures := si;
      s.Read(intd, SizeOf(intd));
      Interval := intd;
    end;
    if version >= FILEVERSION_119 then
    begin
      s.Read(u, SizeOf(u));
      s.Read(v, SizeOf(v));
      s.Read(du, SizeOf(du));
      s.Read(dv, SizeOf(dv));
    end
    else
    begin
      u := 1.0;
      v := 1.0;
      du := 0.0;
      dv := 0.0;
    end;
    s.Read(AnimStart, SizeOf(AnimStart));
    s.Read(AnimEnd, SizeOf(AnimEnd));
    SimpleRotate(fVPos, fVAngle);
  end;
end;
{$ENDIF}

procedure TD3DExObject.LoadFromStream(s: TStream; version: integer);
begin
  Inherited LoadFromStream(s, version);
{$IFNDEF NO_OLDSTREAMINGRUTINES}
  if version < FILEVERSION_119 then
    OldLoadFromStream(s, version)
  else {$ENDIF} with Info do
  begin
    s.Read(Key,SizeOf(Key));
    s.Read(x, SizeOf(x));
    s.Read(y, SizeOf(y));
    s.Read(z, SizeOf(z));
    s.Read(angle, SizeOf(angle));
    s.Read(Width, SizeOf(Width));
    s.Read(Height, SizeOf(Height));
    s.Read(zOrder, SizeOf(zOrder));
    s.Read(C, SizeOf(C));
    s.Read(Transparency, SizeOf(Transparency));
    s.Read(NumTextures, SizeOf(NumTextures));
    s.Read(Interval, SizeOf(Interval));
    s.Read(u, SizeOf(u));
    s.Read(v, SizeOf(v));
    s.Read(du, SizeOf(du));
    s.Read(dv, SizeOf(dv));
    s.Read(AnimStart, SizeOf(AnimStart));
    s.Read(AnimEnd, SizeOf(AnimEnd));
    SimpleRotate(fVPos, fVAngle);
  end;
end;

function TD3DExObject.CalcDistance(const Position: TD3DVector): TD3DValue; register;
begin
  if Info.zOrder > 50000 then // ֿץסבםע, פבגםי, נפשלב
    Distance := Info.zOrder
  else
    Distance := VectorMagnitude(MakeD3DVector(
      Info.x - Position.X,
      Info.y - Position.Y,
      Info.z - Position.Z));
  Result := Distance;
end;

function TD3DExObject.TextureName: string;
begin
  Result := Info.TextureNames[0, 0];
end;

function TD3DExObject.CurTextureName: string;
{
Info.Interval -> Info.NumTextures
fTime         -> ?
? = (Info.NumTextures * fTime / Info.Iterval )
}
begin
  Result := Info.TextureNames[CurTextureIndex, 0];
end;

function TD3DExObject.SwitchToAnimation(animStart, animEnd: char): boolean;
// animName
begin
  fStartTime := fTime;
  Info.AnimStart := animStart;
  Info.AnimEnd := animEnd;
  Result := True;
  fLastFrameFromOtherAnimation := True;
end;

function TD3DExObject.SwitchToAnimation(anim: string): boolean;
begin
  if Length(anim) > 2 then
  begin
    fStartTime := fTime;
    Info.AnimStart := anim[1];
    Info.AnimEnd := anim[2];
    Result := True;
    fLastFrameFromOtherAnimation := True;
  end
  else
    Result := False;
end;

function TD3DExObject.CurrentAnimationDuration: double;
begin
  Result := Info.Interval;
end;

function TD3DExObject.CurTextureIndex: integer;
var
  a: integer; // בםןםיךןנןיחלםן index דשםבע 1-8
  i: integer;
  sTest: string;
  tTest: string;
  ipos, texNameOfs: integer;
  ddpos: integer;
  len, lenofs: integer;
begin
  Result := 0;
  fMirror := False;
  if Info.TextureNames[0, 0] = '' then
    Exit;
  if Info.NumTextures < 2 then
    Exit;
  if (Info.Interval <> 0) and (Info.NumTextures <> 0) then
  begin
    if Info.AnimEnd = Info.AnimStart then
      frameChar := Info.AnimStart
    else
      frameChar := Chr(Ord(Info.AnimStart) +
        (trunc(
           $FFFF * (fTime - fStartTime) * (Ord(Info.AnimEnd) - Ord(Info.AnimStart)) / Info.Interval)
           div $FFFF) mod
         (Ord(Info.AnimEnd) - Ord(Info.AnimStart)));

    a := ((22 + round((Info.angle - fVAngle)*g_RADTODEG)) mod 360) div 45 + 1;

    sTest := frameChar + {$IFNDEF NO_DXTABLES}TABLE_INTTOSTR1[a]{$ELSE}IntToStr(a){$ENDIF};

    for i := 0 to Info.NumTextures - 1 do
    begin
      len := Length(Info.TextureNames[i, 0]);
      ipos := pos('.', Info.TextureNames[i, 0]);
      // ֱם קןץלו :: לףב ףפן םןלב פןץ texture קןץלו texture בנ WAD,
      // ןנפו הום קןץלו extention ףפן filename
      ddpos := pos('::', Info.TextureNames[i, 0]);
      if (ipos > 0) and (ddpos = 0) then
        texNameOfs := len - ipos + 1
      else
        texNameOfs := 0;
      lenofs := len - texNameOfs;
      tTest := Info.TextureNames[i, 0][lenofs - 1] +
               Info.TextureNames[i, 0][lenofs];
      if tTest = sTest then
      begin
        Result := i;
        fMirror := lenofs - 2 > 4;
        if fMirror then
          fMirror := (Info.TextureNames[i, 0][lenofs - 2] in
                      ['1','2','3','4','5','6','7','8']);
        Exit;
      end;
      tTest := Info.TextureNames[i, 0][lenofs - 3] +
               Info.TextureNames[i, 0][lenofs - 2];
      if (tTest = sTest) then
      begin
        Result := i;
        Exit;
      end;
    end;

    sTest[2] := '0';
    for i := 0 to Info.NumTextures - 1 do
    begin
      len := Length(Info.TextureNames[i, 0]);
      ipos := pos('.', Info.TextureNames[i, 0]);
      if (ipos > 0) and (pos('::', Info.TextureNames[i, 0]) = 0) then
        texNameOfs := len - ipos + 1
      else
        texNameOfs := 0;
      lenofs := len - texNameOfs;
      tTest := Info.TextureNames[i, 0][lenofs - 1] +
               Info.TextureNames[i, 0][lenofs];
      if tTest = sTest then
      begin
        Result := i;
        Exit;
      end;
    end;

  end;
end;


(*
function TD3DExObject.CurTextureIndex: integer;
var a: integer; // בםןםיךןנןיחלםן index דשםבע 1-8
    i: integer;
    sTest: TString2;
    tTest: TString2;
    ipos, texNameOfs: integer;
    ddpos: integer;
    len, lenofs: integer;
begin
  Result := 0;
  fMirror := False;
  if Info.NumTextures < 2 then
    Exit;
  if (Info.Interval <> 0) and (Info.NumTextures <> 0) then
  begin
    if Info.AnimEnd = Info.AnimStart then
      frameChar := Info.AnimStart
    else
      frameChar := Chr(Ord(Info.AnimStart) +
        (trunc(
           $FFFF * (fTime - fStartTime) * (Ord(Info.AnimEnd) - Ord(Info.AnimStart)) / Info.Interval)
           div $FFFF) mod
         (Ord(Info.AnimEnd) - Ord(Info.AnimStart)));

    a := ((202 + round((Info.angle - fVAngle) * g_RADTODEG)) mod 360) div 45 + 1;

    sTest.c1 := frameChar;
    sTest.c2 := TABLE_INTTOSTR1[a];

    for i := 0 to Info.NumTextures - 1 do
    begin
      len := Length(Info.TextureNames[i, 0]);
      ipos := pos('.', Info.TextureNames[i, 0]);
      // ֱם קןץלו :: לףב ףפן םןלב פןץ texture קןץלו texture בנ WAD,
      // ןנפו הום קןץלו extention ףפן filename
      ddpos := pos('::', Info.TextureNames[i, 0]);
      if (ipos > 0) and (ddpos = 0) then
        texNameOfs := len - ipos + 1
      else
        texNameOfs := 0;
      lenofs := len - texNameOfs;
      tTest.c1 := Info.TextureNames[i, 0][lenofs - 1];
      tTest.c2 := Info.TextureNames[i, 0][lenofs];
      if tTest.w = sTest.w then
      begin
        Result := i;
        fMirror := lenofs - 2 > 4;
        if fMirror then
          fMirror := Info.TextureNames[i, 0][lenofs - 2] in
                      ['1','2','3','4','5','6','7','8'];
        Exit;
      end;
      tTest.c1 := Info.TextureNames[i, 0][lenofs - 3];
      tTest.c1 := Info.TextureNames[i, 0][lenofs - 2];
      if tTest.w = sTest.w then
      begin
        Result := i;
        Exit;
      end;
    end;

    sTest.c2 := '0';
    for i := 0 to Info.NumTextures - 1 do
    begin
      len := Length(Info.TextureNames[i, 0]);
      ipos := pos('.', Info.TextureNames[i, 0]);
      if (ipos > 0) and (pos('::', Info.TextureNames[i, 0]) = 0) then
        texNameOfs := len - ipos + 1
      else
        texNameOfs := 0;
      tTest.c1 := Info.TextureNames[i, 0][len - 1 - texNameOfs];
      tTest.c2 := Info.TextureNames[i, 0][len - texNameOfs];
      if tTest.w = sTest.w then
      begin
        Result := i;
        Exit;
      end;
    end;

  end;
end;
*)
(*
function TD3DExObject.CurTextureIndex: integer;
var a: integer; // בםןםיךןנןיחלםן index דשםבע 1-8
    i, j: integer;
    sTest,
    sTest2,
    tTest: string;
    EndOfs, StartOfs: integer;
    dAnim: integer;
    loops: single;
    sTmp: string; // Pstring ???
//    tex, wad: string;
begin
  Result := 0;
  fMirror := False;
  if Info.NumTextures < 2 then
    Exit;
  if Info.Interval = 0 then
    frameChar := Info.AnimStart
  else
  begin
    dAnim := Ord(Info.AnimEnd) - Ord(Info.AnimStart) + 1;
    if dAnim <= 1 then
      frameChar := Info.AnimStart
    else
    begin
      loops := (fTime - fStartTime) / Info.Interval * dAnim;
      frameChar := Chr(Ord(Info.AnimStart) + (trunc(loops) mod dAnim));
    end;
  end;


//  a := ((202 + round((Info.angle - fVAngle) * g_RADTODEG)) mod 360) div 45 + 1;
//  a := (({270 + }382 + round((Info.angle - fVAngle) * g_RADTODEG)) mod 360) div 45 + 1;
  a := (({270 + }382 + round((Info.angle - fVAngle) * g_RADTODEG)) mod 360) div 45 + 1;

  sTest := frameChar + TABLE_INTTOSTR1[a];
  sTest2 := frameChar + '0';

  for i := 0 to Info.NumTextures - 1 do
  begin
    StartOfs := 1;
    sTmp := Info.TextureNames[i, 0];
    EndOfs := Length(sTmp);
    j := EndOfs;
    while j > 1 do
    begin
      if sTmp[j] in [':', '/', '\'] then
      begin
        StartOfs := j + 1;
        break;
      end
      else if sTmp[j] = '.' then
      begin
        EndOfs := j - 1;
        break;
      end;
      dec(j);
    end;

    if EndOfs - StartOfs < 5 then
      Exit;

    tTest := sTmp[EndOfs - 1] + sTmp[EndOfs];

    if tTest = sTest then
    begin
      Result := i;

      fMirror := EndOfs - StartOfs >= 7;
      if fMirror then
        fMirror := sTmp[EndOfs - 2] in ['1','2','3','4','5','6','7','8'];
      Exit;
    end
    else if tTest = sTest2 then
    begin
      Result := i;
      Exit;
    end;

    if EndOfs - StartOfs = 7 then
    begin
      tTest := sTmp[EndOfs - 3] + sTmp[EndOfs - 2];
      if (tTest = sTest) then
      begin
        Result := i;
        Exit;
      end;
    end;
  end;

end;
*)

procedure TD3DExObject.GetInfo(p: Pointer);
begin
  PD3DExObjectInfo(p)^ := Info;
end;

// ֵםפןניףלע פןץ בםפיךוילםןץ
// ֵניףפסצוי פחם טףח נבסבפסחףחע ףו בנףפבףח distance
function TD3DExObject.GetLocatePosition(aDistance: TD3DValue): TD3DVector;
begin
  with info do
    Result := MakeD3DVector(x, y, z - aDistance);
end;

procedure TD3DExObject.ApplyLight(l: TD3DSceneLight);
var C: TColor;
begin
  if l.IsAppliable(GetLocatePosition(0.0)) then
  begin
    C := Info.C;
    l.ApplyToVertex(Vertexes[0], C);
    l.ApplyToVertex(Vertexes[1], C);
    l.ApplyToVertex(Vertexes[2], C);
    l.ApplyToVertex(Vertexes[3], C);
  end;
end;

// ֱסיטלע Vertexes פןץ בםפיךוילםןץ
function TD3DExObject.GetNumVertexes: integer;
begin
  if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    Result := 4 * Info.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := 4 * 2
  else
    Result := 4
end;

// ֱסיטלע װסיד‏םשם פןץ בםפיךוילםןץ
function TD3DExObject.GetNumTriangles: integer;
begin
  if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    Result := 2 * Info.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := 2 * 2
  else
    Result := 2
end;
{$ENDIF}

{$IFNDEF NO_D3DTRIANGLES}
// *** TD3DSTriangle ***
constructor TD3DSTriangle.Create(aDXDraw: TDXDraw; aTexture: TDirect3DTexture2; aInfo: TD3DTriangleInfo);
begin
  Info := aInfo;
  Inherited Create(aDXDraw, aTexture);
end;

destructor TD3DSTriangle.Destroy;
begin
  Inherited;
end;

procedure TD3DSTriangle.fCalcCenterAndRadius;
begin
  fCenter := MakeD3DVector( (Info.x1 + Info.x2 + Info.x3) / 3,
                            (Info.y1 + Info.y2 + Info.y3) / 3,
                            (Info.z1 + Info.z2 + Info.z3) / 3);
  fRadius := Max(
    VectorMagnitude(
      VectorSub(MakeD3DVector(Info.x1, Info.y1, Info.z1), fCenter)),
  Max(
    VectorMagnitude(
      VectorSub(MakeD3DVector(Info.x2, Info.y2, Info.z2), fCenter)),
    VectorMagnitude(
      VectorSub(MakeD3DVector(Info.x3, Info.y3, Info.z3), fCenter))));
end;

procedure TD3DSTriangle.MakeTheVertexes;
var aC: TD3DColor;
    pV: PD3DLVertex;
begin
  with Info do
  begin
    aC := CA_MAKE(Info.C, 0);

    pV := @Vertexes[0];
    pV^:= MakeD3DLVERTEX(x1, y1, z1,
      aC, 0,
        du, dv);

    inc(pV);
    pV^:= MakeD3DLVERTEX(x2, y2, z2,
      aC, 0,
        u + du, dv);

    inc(pV);
    pV^:= MakeD3DLVERTEX(x3, y3, z3,
      aC, 0,
        du, v + dv);
  end;
end;

procedure TD3DSTriangle.InitParams;
var
  C: TColor;
  canv: TCanvas;
begin
  MakeTheVertexes;
  if Texture[0] = nil then
  begin
    Graphic.Bitmap.Width := 2;
    Graphic.Bitmap.Height := 2;
    Graphic.Bitmap.PixelFormat := pf24bit;
    C := Info.C;
    canv := Graphic.Bitmap.Canvas;
    canv.Pixels[0, 0] := C;
    canv.Pixels[1, 0] := C;
    canv.Pixels[0, 1] := C;
    canv.Pixels[1, 1] := C;
    Texture[0] := TDirect3DTexture2.Create(DXDraw, Graphic, False);
  end
end;

{$IFDEF DESIGNER}
function TD3DSTriangle.CanSaveVertexes: boolean;
begin
  Result := True;
end;

procedure TD3DSTriangle.SaveVertexes(fName: string);
var
  f: TFileStream;
  cc: TD3DCull;
  pp: TD3DPrimitiveType;
begin
  f := TFileStream.Create(fName, fmCreate  or fmShareDenyWrite);
  try
    if (Info.flags and flg_DoubleSided) <> 0 then
      cc := D3DCULL_NONE
// Added 5/10/2005, needs change in designer (TEditQuadrangeForm)
    else if (Info.flags and flg_CullCW) <> 0 then
      cc := D3DCULL_CW
    else
      cc := D3DCULL_CCW;
    pp := D3DPT_TRIANGLESTRIP;
    f.Write(cc, SizeOf(cc));
    f.Write(pp, SizeOf(pp));
    f.Write(Vertexes, 3 * SizeOf(TD3DLVertex));
  finally
    f.Free;
  end;
end;

function TD3DSTriangle.RTL_CanBeRuntime: boolean;
begin
  Result := TextureName <> '';
end;

procedure TD3DSTriangle.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull);
var cl: TD3DCULL;
begin
  DeclareSession := '';
  InitSession := '';
  DrawSession := '';
  DoneSession := '';
  if (Info.flags and flg_DoubleSided) <> 0 then
    cl := D3DCULL_NONE
  else if (Info.flags and flg_CullCW) <> 0 then
    cl := D3DCULL_CW
  else
    cl := D3DCULL_CCW;
  RTL_GetRunTimeCodeTemplate(
    DeclareSession, InitSession, DrawSession, DoneSession,
    doTexture, curCull,
    'TRIANGLE_',          // GlobalName
    @Vertexes,            // Vertexes Array
    3,                    // Number of Vertexes
    cl,                   // CULL
    D3DPT_TRIANGLESTRIP,  // Primitive Type
    0,
    0,
    tLights);
end;
{$ENDIF}

procedure TD3DSTriangle.Draw;
var
  dev: IDirect3DDevice7;
begin
  dev := DXDraw.D3DDevice7;
  if (Info.Flags and flg_DoubleSided) <> 0 then
    dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(D3DCULL_NONE))
  else if (Info.flags and flg_CullCW) <> 0 then
    dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(D3DCULL_CW))
  else
    dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(D3DCULL_CCW));
  dev.SetTexture(0, Texture[0].Surface.IDDSurface7);
  dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, Vertexes[0], 3, 0);
end;

{$IFNDEF NO_DXMESHES}
procedure TD3DSTriangle.AdjustMeshData;
begin
  Inherited AdjustMeshData;
  fMesh.VertexTypeDesc := @D3DDXFVF_VERTEX;
  if (Info.Flags and flg_DoubleSided) <> 0 then
    fMesh.Cull := @CULL_NONE
  else if (Info.flags and flg_CullCW) <> 0 then
    fMesh.Cull := @CULL_CW
  else
    fMesh.Cull := @CULL_CCW;
  fMesh.PrimitiveType := @PT_TRIANGLELIST;
  fMesh.NumVertexes := @TRHEE;
  pVertexes := @Vertexes;
  fMesh.Vertexes := @pVertexes;
end;
{$ENDIF}

procedure TD3DSTriangle.Move(vM: TD3DVector);
begin
  with Info do
  begin
    x1 := x1 + vM.x;
    x2 := x2 + vM.x;
    x3 := x3 + vM.x;
    y1 := y1 + vM.y;
    y2 := y2 + vM.y;
    y3 := y3 + vM.y;
    z1 := z1 + vM.z;
    z2 := z2 + vM.z;
    z3 := z3 + vM.z;
  end;
  MakeTheVertexes;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DSTriangle.Rotate(vM: TD3DVector);
var
  mat: TD3DMatrix;
  v1, v2: TD3DVector;
begin
  GetRotationMatrix(mat, vM.x, vM.y, vM.z);
  with Info do
  begin
    v1 := MakeD3DVector(x1, y1, z1);
    D3DMath_VectorMatrixMultiply(v2, v1, mat);
    x1 := v2.x;
    y1 := v2.y;
    z1 := v2.z;
    v1 := MakeD3DVector(x2, y2, z2);
    D3DMath_VectorMatrixMultiply(v2, v1, mat);
    x2 := v2.x;
    y2 := v2.y;
    z2 := v2.z;
    v1 := MakeD3DVector(x3, y3, z3);
    D3DMath_VectorMatrixMultiply(v2, v1, mat);
    x3 := v2.x;
    y3 := v2.y;
    z3 := v2.z;
  end;
  MakeTheVertexes;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DSTriangle.GetTextureNames(var s: TDXStringList);
begin
  if Info.TextureName <> '' then
    if s.IndexOf(Info.TextureName) = - 1 then
      s.Add(Info.TextureName);
end;

function TD3DSTriangle.IsIdentical(D3DSurface: TObject): boolean;
var
  inf: TD3DTriangleInfo;
begin
  Result := False;
  if not Inherited IsIdentical(D3DSurface) then
    Exit;
  if (D3DSurface is TD3DSTriangle) then
  begin
    (D3DSurface as TD3DSTriangle) .GetInfo(@inf);
    Result := (
      (inf.x1 = Info.x1) and
      (inf.x2 = Info.x2) and
      (inf.x3 = Info.x3) and
      (inf.y1 = Info.y1) and
      (inf.y2 = Info.y2) and
      (inf.y3 = Info.y3) and
      (inf.z1 = Info.z1) and
      (inf.z2 = Info.z2) and
      (inf.z3 = Info.z3) and
      (inf.u = Info.u) and
      (inf.v = Info.v) and
      (inf.du = Info.du) and
      (inf.dv = Info.dv) and
      (inf.C = Info.C) and
      (inf.Flags = info.Flags) and
      (inf.zOrder = Info.zOrder) and
      (inf.TextureName = Info.TextureName));
  end;
end;

function TD3DSTriangle.GetTypeID: byte;
begin
  Result := ID3D_Triangle;
end;

function TD3DSTriangle.GetKeyID: integer;
begin
  Result := Info.Key;
end;

procedure TD3DSTriangle.SaveToStream(s: TStream);
begin
  Inherited SaveToStream(s);
  with Info do
  begin
    s.Write(Key,SizeOf(Key));
    s.Write(x1, SizeOf(x1));
    s.Write(y1, SizeOf(y1));
    s.Write(z1, SizeOf(z1));
    s.Write(x2, SizeOf(x2));
    s.Write(y2, SizeOf(y2));
    s.Write(z2, SizeOf(z2));
    s.Write(x3, SizeOf(x3));
    s.Write(y3, SizeOf(y3));
    s.Write(z3, SizeOf(z3));
    s.Write(zOrder, SizeOf(zOrder));
    s.Write(flags, SizeOf(flags));
    s.Write(u, SizeOf(u));
    s.Write(v, SizeOf(v));
    s.Write(du, SizeOf(du));
    s.Write(dv, SizeOf(dv));
    s.Write(C, SizeOf(C));
  end;
end;

{$IFNDEF NO_OLDSTREAMINGRUTINES}
procedure TD3DSTriangle.OldLoadFromStream(s: TStream; version: integer);
begin
  with Info do
  begin
    s.Read(Key,SizeOf(Key));
    s.Read(x1, SizeOf(x1));
    s.Read(y1, SizeOf(y1));
    s.Read(z1, SizeOf(z1));
    s.Read(x2, SizeOf(x2));
    s.Read(y2, SizeOf(y2));
    s.Read(z2, SizeOf(z2));
    s.Read(x3, SizeOf(x3));
    s.Read(y3, SizeOf(y3));
    s.Read(z3, SizeOf(z3));
    s.Read(zOrder, SizeOf(zOrder));
    s.Read(flags, SizeOf(flags));
    s.Read(u, SizeOf(u));
    s.Read(v, SizeOf(v));
    if version >= FILEVERSION_100 then
    begin
      s.Read(du, SizeOf(du));
      s.Read(dv, SizeOf(dv));
    end
    else
    begin
      du := 0.0;
      dv := 0.0;
    end;
    s.Read(C, SizeOf(C));
    MakeTheVertexes;
  end;
end;
{$ENDIF}

procedure TD3DSTriangle.LoadFromStream(s: TStream; version: integer);
begin
  Inherited LoadFromStream(s, version);
{$IFNDEF NO_OLDSTREAMINGRUTINES}
  if version < FILEVERSION_107 then
    OldLoadFromStream(s, version)
  else {$ENDIF} with Info do
  begin
    s.Read(Key,SizeOf(Key));
    s.Read(x1, SizeOf(x1));
    s.Read(y1, SizeOf(y1));
    s.Read(z1, SizeOf(z1));
    s.Read(x2, SizeOf(x2));
    s.Read(y2, SizeOf(y2));
    s.Read(z2, SizeOf(z2));
    s.Read(x3, SizeOf(x3));
    s.Read(y3, SizeOf(y3));
    s.Read(z3, SizeOf(z3));
    s.Read(zOrder, SizeOf(zOrder));
    s.Read(flags, SizeOf(flags));
    s.Read(u, SizeOf(u));
    s.Read(v, SizeOf(v));
    s.Read(du, SizeOf(du));
    s.Read(dv, SizeOf(dv));
    s.Read(C, SizeOf(C));
    MakeTheVertexes;
  end;
end;

function TD3DSTriangle.CalcDistance(const Position: TD3DVector): TD3DValue; register;
begin
  if Info.zOrder > 50000 then // ֿץסבםע, פבגםי, נפשלב
    Distance := Info.zOrder
  else
    Distance := Min(Min(Min(Min(Min(
      VectorMagnitude(
        MakeD3DVector(Info.x1 - Position.X, Info.y1 - Position.Y, Info.z1 - Position.Z)),
      VectorMagnitude(
        MakeD3DVector(Info.x2 - Position.X, Info.y2 - Position.Y, Info.z2 - Position.Z))),
      VectorMagnitude(
        MakeD3DVector(Info.x3 - Position.X, Info.y3 - Position.Y, Info.z3 - Position.Z))),
      VectorMagnitude(
        MakeD3DVector((Info.x1 + Info.x2)/2 - Position.X,
                      (Info.y1 + Info.y2)/2 - Position.Y,
                      (Info.z1 + Info.z2)/2 - Position.Z))),
      VectorMagnitude(
        MakeD3DVector((Info.x2 + Info.x3)/2 - Position.X,
                      (Info.y2 + Info.y3)/2 - Position.Y,
                      (Info.z2 + Info.z3)/2 - Position.Z))),
      VectorMagnitude(
        MakeD3DVector((Info.x3 + Info.x1)/2 - Position.X,
                      (Info.y3 + Info.y1)/2 - Position.Y,
                      (Info.z3 + Info.z1)/2 - Position.Z)));
  Result := Distance;
end;

function TD3DSTriangle.GetLocatePosition(aDistance: TD3DValue): TD3DVector;
begin
  with Info do
    Result := MakeD3DVector((x1 + x2 + x3)/3, (y1 + y2 + y3)/3, (z1 + z2 + z3)/3 - aDistance);
end;

procedure TD3DSTriangle.ApplyLight(l: TD3DSceneLight);
var C: TColor;
begin
  if l.IsAppliable(GetLocatePosition(0.0)) then
  begin
    C := Info.C;
    l.ApplyToVertex(Vertexes[0], C);
    l.ApplyToVertex(Vertexes[1], C);
    l.ApplyToVertex(Vertexes[2], C);
  end;
end;

function TD3DSTriangle.TextureName: string;
begin
  Result := Info.TextureName
end;

procedure TD3DSTriangle.GetInfo(p: Pointer);
begin
  PD3DTriangleInfo(p)^ := Info;
end;

// ֱסיטלע Vertexes פןץ בםפיךוילםןץ
function TD3DSTriangle.GetNumVertexes: integer;
begin
  Result := 3
end;

// ֱסיטלע װסיד‏םשם פןץ בםפיךוילםןץ
function TD3DSTriangle.GetNumTriangles: integer;
begin
  Result := 1
end;
{$ENDIF}

// *** TD3DQuadrAngle ***

constructor TD3DQuadrAngle.Create(aDXDraw: TDXDraw; aTexture: TDirect3DTexture2; aInfo: TD3DQuadrangleInfo);
begin
  Info := aInfo;
  Textures[0, 0] := aTexture;
  Inherited Create(aDXDraw, aTexture);
end;

destructor TD3DQuadrAngle.Destroy;
begin
  Inherited;
end;

procedure TD3DQuadrAngle.MakeTheVertexes;
var
  pV: PD3DLVertex;
begin
  with Info do
  begin
    pV := @Vertexes[0];
    pV^ := MakeD3DLVERTEX(x1, y1, z1,
      CA_MAKE(Info.C1, 0), 0,
        du, dv);

    inc(pV);
    pV^ := MakeD3DLVERTEX(x2, y2, z2,
      CA_MAKE(Info.C2, 0), 0,
        u + du, dv);

    inc(pV);
    pV^ := MakeD3DLVERTEX(x3, y3, z3,
      CA_MAKE(Info.C3, 0), 0,
        du, v + dv);

    inc(pV);
    pV^ := MakeD3DLVERTEX(x4, y4, z4,
      CA_MAKE(Info.C4, 0), 0,
        u + du, v + dv);
  end;
end;

procedure TD3DQuadrAngle.fCalcCenterAndRadius;
begin
  fCenter := MakeD3DVector( (Info.x1 + Info.x2 + Info.x3 + Info.x4) / 4,
                            (Info.y1 + Info.y2 + Info.y3 + Info.y4) / 4,
                            (Info.z1 + Info.z2 + Info.z3 + Info.z4) / 4);
  fRadius := Max(
    VectorMagnitude(
      VectorSub(MakeD3DVector(Info.x1, Info.y1, Info.z1), fCenter)),
  Max(
    VectorMagnitude(
      VectorSub(MakeD3DVector(Info.x2, Info.y2, Info.z2), fCenter)),
  Max(
    VectorMagnitude(
      VectorSub(MakeD3DVector(Info.x3, Info.y3, Info.z3), fCenter)),
    VectorMagnitude(
      VectorSub(MakeD3DVector(Info.x4, Info.y4, Info.z4), fCenter)))));
end;

procedure TD3DQuadrAngle.InitParams;
var
  canv: TCanvas;
begin
  MakeTheVertexes;
  if Texture[0] = nil then
  begin
    Graphic.Bitmap.Width := 2;
    Graphic.Bitmap.Height := 2;
    Graphic.Bitmap.PixelFormat := pf24bit;
    canv := Graphic.Bitmap.Canvas;
    canv.Pixels[0, 0] := Info.C1;
    canv.Pixels[1, 0] := Info.C2;
    canv.Pixels[0, 1] := Info.C3;
    canv.Pixels[1, 1] := Info.C4;
    Texture[0] := TDirect3DTexture2.Create(DXDraw, Graphic, False);
  end;
  Textures[0, 0] := Texture[0];
end;

{$IFDEF DESIGNER}
function TD3DQuadrAngle.CanSaveVertexes: boolean;
begin
  Result := True;
end;

procedure TD3DQuadrAngle.SaveVertexes(fName: string);
var
  f: TFileStream;
  cc: TD3DCull;
  pp: TD3DPrimitiveType;
begin
  f := TFileStream.Create(fName, fmCreate or fmShareDenyWrite);
  try
    if (Info.flags and flg_DoubleSided) <>0 then
      cc := D3DCULL_NONE
    else if (Info.flags and flg_CullCW) <> 0 then
      cc := D3DCULL_CW
    else
      cc := D3DCULL_CCW;
    pp := D3DPT_TRIANGLESTRIP;
    f.Write(cc, SizeOf(cc));
    f.Write(pp, SizeOf(pp));
    f.Write(Vertexes, 4 * SizeOf(TD3DLVertex));
  finally
    f.Free;
  end;
end;

function TD3DQuadrAngle.RTL_CanBeRunTime: boolean;
begin
  Result := (TextureName <> '') and (Info.ddu = 0.0) and (Info.ddv = 0.0);
end;

procedure TD3DQuadrAngle.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull);
var
  cl: TD3DCULL;
begin
  DeclareSession := '';
  InitSession := '';
  DrawSession := '';
  DoneSession := '';
  if (Info.flags and flg_DoubleSided) <> 0 then
    cl := D3DCULL_NONE
  else if (Info.flags and flg_CullCW) <> 0 then
    cl := D3DCULL_CW
  else
    cl := D3DCULL_CCW;
  RTL_GetRunTimeCodeTemplate(
    DeclareSession, InitSession, DrawSession, DoneSession,
    doTexture, curCull,
    'QUADRANGLE_',        // GlobalName
    @Vertexes,            // Vertexes Array
    4,                    // Number of Vertexes
    cl,                   // CULL
    D3DPT_TRIANGLESTRIP,  // Primitive Type
    0,
    0,
    tLights);
end;
{$ENDIF}

{$IFNDEF NO_DXMESHES}
procedure TD3DQuadrAngle.AdjustMeshData;
begin
  Inherited AdjustMeshData;
  fMesh.VertexTypeDesc := @D3DDXFVF_VERTEX;
  if (Info.Flags and flg_DoubleSided) <> 0 then
    fMesh.Cull := @CULL_NONE
  else if (Info.flags and flg_CullCW) <> 0 then
    fMesh.Cull := @CULL_CW
  else
    fMesh.Cull := @CULL_CCW;
  fMesh.PrimitiveType := @PT_TRIANGLESTRIP;
  fMesh.NumVertexes := @FOUR;
  pVertexes := @Vertexes;
  fMesh.Vertexes := @pVertexes;
end;
{$ENDIF}

procedure TD3DQuadrAngle.Draw;
var
  _ddu, _ddv: TD3DValue;
  dev: IDirect3DDevice7;
begin
  dev := DXDraw.D3DDevice7;
  if (Info.Flags and flg_DoubleSided) <> 0 then
    dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(D3DCULL_NONE))
  else if (Info.flags and flg_CullCW) <> 0 then
    dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(D3DCULL_CW))
  else
    dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(D3DCULL_CCW));
  if (Info.ddu <> 0.0) or (Info.ddv <> 0.0) then
  begin
    _ddu := Info.ddu * (fTime);// - fStartTime);
    _ddv := Info.ddv * (fTime);// - fStartTime);

    Vertexes[0].tu := Frac(Info.du + _ddu);
    Vertexes[0].tv := Frac(Info.dv + _ddv);
    Vertexes[1].tu := Info.u + Vertexes[0].tu;
    Vertexes[1].tv := Vertexes[0].tv;
    Vertexes[2].tu := Vertexes[0].tu;
    Vertexes[2].tv := Info.v + Vertexes[0].tv;
    Vertexes[3].tu := Vertexes[1].tu;
    Vertexes[3].tv := Vertexes[2].tv;
{    Vertexes[0].tu := Info.du + _ddu;
    Vertexes[0].tv := Info.dv + _ddv;
    Vertexes[1].tu := Info.u + Info.du + _ddu;
    Vertexes[1].tv := Info.dv + _ddv;
    Vertexes[2].tu := Info.du + _ddu;
    Vertexes[2].tv := Info.v + Info.dv + _ddv;
    Vertexes[3].tu := Info.u + Info.du + _ddu;
    Vertexes[3].tv := Info.v + Info.dv + _ddv;}
  end;
  if Info.Transparent then
  begin
    Texture[0].Surface.TransparentColor := 0;
    Texture[0].Transparent := True;
    dev.SetTexture(0, Texture[0].Surface.IDDSurface7);
    dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, Vertexes[0], 4, 0);
    Texture[0].Transparent := False;
  end
  else
  begin
    dev.SetTexture(0, Texture[0].Surface.IDDSurface7);
    dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, Vertexes[0], 4, 0);
  end;
end;

procedure TD3DQuadrAngle.Move(vM: TD3DVector);
begin
  with Info do
  begin
    x1 := x1 + vM.x;
    x2 := x2 + vM.x;
    x3 := x3 + vM.x;
    x4 := x4 + vM.x;
    y1 := y1 + vM.y;
    y2 := y2 + vM.y;
    y3 := y3 + vM.y;
    y4 := y4 + vM.y;
    z1 := z1 + vM.z;
    z2 := z2 + vM.z;
    z3 := z3 + vM.z;
    z4 := z4 + vM.z;
    MakeTheVertexes;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DQuadrAngle.Rotate(vM: TD3DVector);
var
  mat: TD3DMatrix;
  v1, v2: TD3DVector;
begin
  GetRotationMatrix(mat, vM.x, vM.y, vM.z);
  with Info do
  begin
    v1 := MakeD3DVector(x1, y1, z1);
    D3DMath_VectorMatrixMultiply(v2, v1, mat);
    x1 := v2.x;
    y1 := v2.y;
    z1 := v2.z;
    v1 := MakeD3DVector(x2, y2, z2);
    D3DMath_VectorMatrixMultiply(v2, v1, mat);
    x2 := v2.x;
    y2 := v2.y;
    z2 := v2.z;
    v1 := MakeD3DVector(x3, y3, z3);
    D3DMath_VectorMatrixMultiply(v2, v1, mat);
    x3 := v2.x;
    y3 := v2.y;
    z3 := v2.z;
    v1 := MakeD3DVector(x4, y4, z4);
    D3DMath_VectorMatrixMultiply(v2, v1, mat);
    x4 := v2.x;
    y4 := v2.y;
    z4 := v2.z;
  end;
  Move(NULLVECTOR);
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DQuadrAngle.GetTextureNames(var s: TDXStringList);
begin
  if Info.TextureName <> '' then
    if s.IndexOf(Info.TextureName) = -1 then
      s.Add(Info.TextureName);
end;

function TD3DQuadrAngle.IsIdentical(D3DSurface: TObject): boolean;
var
  inf: TD3DQuadrangleInfo;
begin
  Result := False;
  if not Inherited IsIdentical(D3DSurface) then
    Exit;
  if (D3DSurface is TD3DQuadrAngle) then
  begin
    (D3DSurface as TD3DQuadrAngle).GetInfo(@inf);
    Result := (
      (inf.x1 = Info.x1) and
      (inf.x2 = Info.x2) and
      (inf.x3 = Info.x3) and
      (inf.x4 = Info.x4) and
      (inf.y1 = Info.y1) and
      (inf.y2 = Info.y2) and
      (inf.y3 = Info.y3) and
      (inf.y4 = Info.y4) and
      (inf.z1 = Info.z1) and
      (inf.z2 = Info.z2) and
      (inf.z3 = Info.z3) and
      (inf.z4 = Info.z4) and
      (inf.u = Info.u) and
      (inf.v = Info.v) and
      (inf.du = Info.du) and
      (inf.dv = Info.dv) and
      (inf.ddu = Info.ddu) and
      (inf.ddv = Info.ddv) and
      (inf.C1 = Info.C1) and
      (inf.C2 = Info.C2) and
      (inf.C3 = Info.C3) and
      (inf.C4 = Info.C4) and
      (inf.Flags = info.Flags) and
      (inf.zOrder = Info.zOrder) and
      (inf.TextureName = Info.TextureName));
  end;
end;

function TD3DQuadrAngle.GetTypeID: byte;
begin
  Result := ID3D_Quadrangle;
end;

function TD3DQuadrAngle.GetKeyID: integer;
begin
  Result := Info.Key;
end;

procedure TD3DQuadrAngle.SaveToStream(s: TStream);
begin
  Inherited SaveToStream(s);
  with Info do
  begin
    s.Write(Key,SizeOf(Key));
    s.Write(x1, SizeOf(x1));
    s.Write(y1, SizeOf(y1));
    s.Write(z1, SizeOf(z1));
    s.Write(x2, SizeOf(x2));
    s.Write(y2, SizeOf(y2));
    s.Write(z2, SizeOf(z2));
    s.Write(x3, SizeOf(x3));
    s.Write(y3, SizeOf(y3));
    s.Write(z3, SizeOf(z3));
    s.Write(x4, SizeOf(x4));
    s.Write(y4, SizeOf(y4));
    s.Write(z4, SizeOf(z4));
    s.Write(zOrder, SizeOf(zOrder));
    s.Write(flags, SizeOf(flags));
    s.Write(u, SizeOf(u));
    s.Write(v, SizeOf(v));
    s.Write(du, SizeOf(du));
    s.Write(dv, SizeOf(dv));
    s.Write(ddu, SizeOf(ddu));
    s.Write(ddv, SizeOf(ddv));
    s.Write(C1, SizeOf(C1));
    s.Write(C2, SizeOf(C2));
    s.Write(C3, SizeOf(C3));
    s.Write(C4, SizeOf(C4));
    s.Write(Transparent, SizeOf(Transparent));
  end;
end;

{$IFNDEF NO_OLDSTREAMINGRUTINES}
procedure TD3DQuadrAngle.OldLoadFromStream(s: TStream; version: integer);
begin
  with Info do
  begin
    s.Read(Key,SizeOf(Key));
    s.Read(x1, SizeOf(x1));
    s.Read(y1, SizeOf(y1));
    s.Read(z1, SizeOf(z1));
    s.Read(x2, SizeOf(x2));
    s.Read(y2, SizeOf(y2));
    s.Read(z2, SizeOf(z2));
    s.Read(x3, SizeOf(x3));
    s.Read(y3, SizeOf(y3));
    s.Read(z3, SizeOf(z3));
    s.Read(x4, SizeOf(x4));
    s.Read(y4, SizeOf(y4));
    s.Read(z4, SizeOf(z4));
    s.Read(zOrder, SizeOf(zOrder));
    s.Read(flags, SizeOf(flags));
    s.Read(u, SizeOf(u));
    s.Read(v, SizeOf(v));
    if version >= FILEVERSION_100 then
    begin
      s.Read(du, SizeOf(du));
      s.Read(dv, SizeOf(dv));
    end
    else
    begin
      du := 0.0;
      dv := 0.0;
    end;
    if version >= FILEVERSION_118 then
    begin
      s.Read(ddu, SizeOf(ddu));
      s.Read(ddv, SizeOf(ddv));
    end
    else
    begin
      ddu := 0.0;
      ddv := 0.0;
    end;

    s.Read(C1, SizeOf(C1));
    s.Read(C2, SizeOf(C2));
    s.Read(C3, SizeOf(C3));
    s.Read(C4, SizeOf(C4));
    if version >= FILEVERSION_100 then
      s.Read(Transparent, SizeOf(Transparent))
    else
      Transparent := False;
    MakeTheVertexes;
  end;
end;
{$ENDIF}

procedure TD3DQuadrAngle.LoadFromStream(s: TStream; version: integer);
begin
  Inherited LoadFromStream(s, version);
{$IFNDEF NO_OLDSTREAMINGRUTINES}
  if version < FILEVERSION_118 then
    OldLoadFromStream(s, version)
  else {$ENDIF} with Info do
  begin
    s.Read(Key, SizeOf(Key));
    s.Read(x1, SizeOf(x1));
    s.Read(y1, SizeOf(y1));
    s.Read(z1, SizeOf(z1));
    s.Read(x2, SizeOf(x2));
    s.Read(y2, SizeOf(y2));
    s.Read(z2, SizeOf(z2));
    s.Read(x3, SizeOf(x3));
    s.Read(y3, SizeOf(y3));
    s.Read(z3, SizeOf(z3));
    s.Read(x4, SizeOf(x4));
    s.Read(y4, SizeOf(y4));
    s.Read(z4, SizeOf(z4));
    s.Read(zOrder, SizeOf(zOrder));
    s.Read(flags, SizeOf(flags));
    s.Read(u, SizeOf(u));
    s.Read(v, SizeOf(v));
    s.Read(du, SizeOf(du));
    s.Read(dv, SizeOf(dv));
    s.Read(ddu, SizeOf(ddu));
    s.Read(ddv, SizeOf(ddv));
    s.Read(C1, SizeOf(C1));
    s.Read(C2, SizeOf(C2));
    s.Read(C3, SizeOf(C3));
    s.Read(C4, SizeOf(C4));
    s.Read(Transparent, SizeOf(Transparent));
    MakeTheVertexes;
  end;
end;

function TD3DQuadrAngle.CalcDistance(const Position: TD3DVector): TD3DValue; register;
var
  XX, YY, ZZ: TD3DValue;
begin
  if Info.zOrder > 50000 then // ֿץסבםע, פבגםי, נפשלב
    Distance := Info.zOrder
  else
  begin
{    Result := VectorMagnitude(MakeD3DVector(
      (Info.x1 + Info.x2 + Info.x3 + Info.x4)/4 - Position.X,
      (Info.y1 + Info.y2 + Info.y3 + Info.y4)/4 - Position.Y,
      (Info.z1 + Info.z2 + Info.z3 + Info.z4)/4 - Position.Z));}
//    Result := Min(Min(Min(Min(Min(Min(
//    Distance := Max(Max(Max(Max(Max(Max(Max(
    XX := Position.X;
    YY := Position.Y;
    ZZ := Position.Z;
    Distance := Min(Min(Min(Min(Min(Min(Min(
      VectorMagnitude(
        MakeD3DVector(Info.x1 - XX, Info.y1 - YY, Info.z1 - ZZ)),
      VectorMagnitude(
        MakeD3DVector(Info.x2 - XX, Info.y2 - YY, Info.z2 - ZZ))),
      VectorMagnitude(
        MakeD3DVector(Info.x3 - XX, Info.y3 - YY, Info.z3 - ZZ))),
      VectorMagnitude(
        MakeD3DVector(Info.x4 - XX, Info.y4 - YY, Info.z4 - ZZ))),
      VectorMagnitude(
        MakeD3DVector((Info.x1 + Info.x2)/2 - XX,
                      (Info.y1 + Info.y2)/2 - YY,
                      (Info.z1 + Info.z2)/2 - ZZ))),
      VectorMagnitude(
        MakeD3DVector((Info.x2 + Info.x3)/2 - XX,
                      (Info.y2 + Info.y3)/2 - YY,
                      (Info.z2 + Info.z3)/2 - ZZ))),
      VectorMagnitude(
        MakeD3DVector((Info.x3 + Info.x4)/2 - XX,
                      (Info.y3 + Info.y4)/2 - YY,
                      (Info.z3 + Info.z4)/2 - ZZ))),
      VectorMagnitude(
        MakeD3DVector((Info.x4 + Info.x1)/2 - XX,
                      (Info.y4 + Info.y1)/2 - YY,
                      (Info.z4 + Info.z1)/2 - ZZ)));
  end;
  Result := Distance;
end;

function TD3DQuadrAngle.TextureName: string;
begin
  Result := Info.TextureName
end;

function TD3DQuadrAngle.CurTextureName: string;
begin
  Result := textureName;
end;

function TD3DQuadrAngle.CurTextureIndex: integer;
begin
  Result := 0;
end;

procedure TD3DQuadrAngle.GetInfo(p: Pointer);
begin
  PD3DQuadrangleInfo(p)^ := Info;
end;

function TD3DQuadrAngle.GetLocatePosition(aDistance: TD3DValue): TD3DVector;
begin
  with Info do
    Result := MakeD3DVector(
      (x1 + x2 + x3 + x4) / 4,
      (y1 + y2 + y3 + y4) / 4,
      (z1 + z2 + z3 + z4) / 4 - aDistance);
end;

procedure TD3DQuadrAngle.ApplyLight(l: TD3DSceneLight);
begin
  if l.IsAppliable(GetLocatePosition(0.0)) then
  begin
    l.ApplyToVertex(Vertexes[0], Info.C1);
    l.ApplyToVertex(Vertexes[1], Info.C2);
    l.ApplyToVertex(Vertexes[2], Info.C3);
    l.ApplyToVertex(Vertexes[3], Info.C4);
  end;
end;

// ֱסיטלע Vertexes פןץ בםפיךוילםןץ
function TD3DQuadrAngle.GetNumVertexes: integer;
begin
  Result := 4;
end;

// ֱסיטלע װסיד‏םשם פןץ בםפיךוילםןץ
function TD3DQuadrAngle.GetNumTriangles: integer;
begin
  Result := 2;
end;

{$IFNDEF NO_D3DACTORS}
constructor TD3DActor.Create(aScene: TD3DScene; aTextures: TDirect3DTextures2; const aInfo: TD3DActorInfo);
begin
  TheVertexes := nil;
  CalcedStatus := nil;
  Info := aInfo;
  fLastFrameIndexFloat := Info.AnimStart;
  fLastFrameFromOtherAnimation := False;
  if Info.MinFramesPerSec = 0 then
    Info.MinFramesPerSec := 1;
  AppliedInfo := Info;
  fScene := aScene;
  fLastUpdateTime := 0.0;
  fNeedsUpdate := True;

  if fScene <> nil then
  begin
    fModel := fScene.AddModelToCollection(Info.PathToModel);
    fNumVertexes := fModel.AllocFrameVertexes(AppliedInfo.AnimStart, TheVertexes);
    fStartTime := fScene.Time;
  end
  else
  begin
    fNumVertexes := 0;

    fStartTime := 0.0;

    fModel := nil;
  end;

  Textures := aTextures;
  Inherited Create(fScene.DXDraw, aTextures[0, 0]);
end;

constructor TD3DActor.CreateFromStream(s: TStream; aScene: TD3DScene; aTextures: TDirect3DTextures2; version: integer);
begin
  LoadFromStream(s, version);
  Create(aScene, aTextures, Info);
end;

function TD3DActor.SwitchToAnimation(animID: integer): boolean;
var newAnimStart, newAnimEnd: integer;
begin
  if (animID < fModel.frameNames.Count) and (animID >= 0) then
  begin
    newAnimStart := fModel.StartFrame(animID);
    newAnimEnd := fModel.EndFrame(animID);
    if (AppliedInfo.AnimStart = newAnimStart) and
       (AppliedInfo.AnimEnd = newAnimEnd) then
    begin
      Result := False;
      Exit; // Nothing to do!
    end;

    if AppliedInfo.AnimEnd > AppliedInfo.AnimStart then
      AppliedInfo.AnimSpeed :=
        (newAnimEnd - newAnimStart + 1) /
        (AppliedInfo.AnimEnd - AppliedInfo.AnimStart + 1) *
        AppliedInfo.AnimSpeed
    else
      AppliedInfo.AnimSpeed :=
        (newAnimEnd - newAnimStart) *
        AppliedInfo.AnimSpeed;

    AppliedInfo.AnimStart := newAnimStart;
    AppliedInfo.AnimEnd := newAnimEnd;
    fStartTime := fTime;
//    fStartTime := fScene.Time + fTime;
    fNeedsUpdate := True;
    fLastFrameFromOtherAnimation := True;
    Result := True;
  end
  else
    Result := False;
end;

function TD3DActor.SwitchToAnimation(animName: string): boolean;
var
  i: integer;
  s: TDXStringList;
  sTmp: string;
  newAnimStart, newAnimEnd: integer;
begin
  animName := UpperCase(animName);
  for i := 0 to fModel.frameNames.Count - 1 do
    if UpperCase(fModel.frameNames.Strings[i]) = animName then
    begin
      Result := SwitchToAnimation(i);
      Exit;
    end;
// ִום הטחךו animation name, בככ parsing string:
// animStart=a, animEnd=b
  s := TDXStringList.Create;
  try
    sTmp := '';
    for i := 1 to Length(animName) do
    begin
      if animName[i] = ',' then
        sTmp := sTmp + NL
      else if animName[i] <> ' ' then
        sTmp := sTmp + animName[i];
    end;

    s.Text := sTmp;
    newAnimStart := StrToIntDef(s.Values['ANIMSTART'], AppliedInfo.AnimStart);
    newAnimEnd := StrToIntDef(s.Values['ANIMEND'], AppliedInfo.AnimEnd);

    if (AppliedInfo.AnimStart = newAnimStart) and
       (AppliedInfo.AnimEnd = newAnimEnd) then
      Result := False

    else
    begin

      if AppliedInfo.AnimEnd > AppliedInfo.AnimStart then
        AppliedInfo.AnimSpeed :=
          (newAnimEnd - newAnimStart + 1) /
          (AppliedInfo.AnimEnd - AppliedInfo.AnimStart + 1) *
          AppliedInfo.AnimSpeed
      else
        AppliedInfo.AnimSpeed :=
          (newAnimEnd - newAnimStart) *
          AppliedInfo.AnimSpeed;

      AppliedInfo.AnimStart := newAnimStart;
      AppliedInfo.AnimEnd := newAnimEnd;
      fStartTime := fTime;
//      fStartTime := fScene.Time + fTime;
      fNeedsUpdate := True;
      fLastFrameFromOtherAnimation := True;
      Result := True;
    end;

  finally
    s.Free;
  end;

end;

function TD3DActor.CurrentAnimationDuration: double;
begin
  Result := AppliedInfo.AnimSpeed;
end;

procedure TD3DActor.InitParams;
var
  aC: TD3DColor;
  i: integer;
  col: TColor;
  canv: TCanvas;
  pV: PD3DLVertex;
begin
  with Info do
  begin
    if C <> $FFFFFF then
    begin
      aC := CA_MAKE(C, 0);
      pV := @TheVertexes[0];

      for i := 0 to fNumVertexes - 1 do
      begin
        pV.color := aC;
        inc(pV);
      end;
    end;
    if Texture[0] = nil then
    begin
      Graphic.Bitmap.Width := 2;
      Graphic.Bitmap.Height := 2;
      Graphic.Bitmap.PixelFormat := pf24bit;
      col := C;
      canv := Graphic.Bitmap.Canvas;
      canv.Pixels[0, 0] := col;
      canv.Pixels[1, 0] := col;
      canv.Pixels[0, 1] := col;
      canv.Pixels[1, 1] := col;
      Texture[0] := TDirect3DTexture2.Create(DXDraw, Graphic, False);
    end
    else
    begin
      Graphic.Bitmap.Width := 0;
      Graphic.Bitmap.Height := 0;
    end;
  end
end;

procedure TD3DActor.DoCalcDistance;
begin
  if fScene <> nil then
    CalcDistance(VectorSub(fScene.Position, fScene.GetParentPositionVector));
end;

procedure TD3DActor.ApplyInfoToVertexes;
var
  i: integer;
  mat, mat2: TD3DMatrix;
  vx, vy, vz: TD3DValue;
  pV: PD3DLVertex;
begin
  with AppliedInfo do
  begin

    GetRotationMatrix(mat, dx, dy, dz);
    if Scale <= 0 then
      Scale := 1.0;
    if Scale <> 1.0 then
    begin
      GetScaleMatrix(mat2, Scale, Scale, Scale);
      MulMatrix(mat, mat2, mat);
    end;

    pV := @TheVertexes[0];
    for i := 0 to fNumVertexes - 1 do
    begin
      vx := pV.x;
      vy := pV.y;
      vz := pV.z;
      D3D_VectorMatrixMultiply_Only_For_Sphere( // Optimized Matrix Multiply function
        pV.x, pV.y, pV.z,
        vx, vy, vz, mat);
      pV.x := pV.x + x;
      pV.y := pV.y + y;
      pV.z := pV.z + z;
      inc(pV);
    end;
    DoCalcDistance;
    fNeedsUpdate := False;
  end;
end;

destructor TD3DActor.Destroy;
begin
  ReAllocMem(TheVertexes, 0);
  Inherited Destroy;
end;

procedure TD3DActor.Draw;
var
  CurIndex: integer;
  fIdx: TD3DValue;
  tmp_end, tmp_start: word;
  ClearLastFrameFromOtherAnimationFlag: boolean;
  dev: IDirect3DDevice7;

  function NeedsUpdate: boolean;
  var fps: TD3DValue;
  begin
    if fNeedsUpdate then
    begin
      Result := True;
      Exit;
    end;
    if Distance > AppliedInfo.UpdateDistance then
    begin
      Result := False;
      Exit;
    end;
    if AppliedInfo.AnimStart = AppliedInfo.AnimEnd then
    begin
      Result := (fLastUpdateTime < g_EPSILON) and (not fLastFrameFromOtherAnimation);
      Exit;
    end;
    if (abs(fTime - fLastUpdateTime) < g_EPSILON) or (AppliedInfo.AnimSpeed = 0.0) then
    begin
      Result := False;
      Exit;
    end;

    fps := 1 / (fTime - fLastUpdateTime);
    if AppliedInfo.UseInterpolation then
      Result := fps < Max(AppliedInfo.MinFramesPerSec, abs(AppliedInfo.AnimStart - AppliedInfo.AnimEnd + 1) / AppliedInfo.AnimSpeed)
    else
      Result := fps < abs(AppliedInfo.AnimStart - AppliedInfo.AnimEnd + 1) / AppliedInfo.AnimSpeed
  end;

begin
  dev := DXDraw.D3DDevice7;
  fDidDraw := False;

  fIdx := CurFrameIndexFloat;
  if Assigned(OnEveryFrame) then
    OnEveryFrame(FloatToStr(fIdx));

  if trunc(fIdx) <> trunc(fLastFrameIndexFloat) then
    if Assigned(OnNewFrame) then
      OnNewFrame(IntToStr(trunc(fIdx)));

  if Distance > AppliedInfo.HideDistance then
  begin
    DoCalcDistance;
    Exit;
  end;
  if Distance > AppliedInfo.UpdateDistance then
    DoCalcDistance;

  if fLastFrameFromOtherAnimation then
    ClearLastFrameFromOtherAnimationFlag := True
  else
  begin
    ClearLastFrameFromOtherAnimationFlag := False;
    if (fLastFrameIndexFloat > CurFrameIndex) then
    begin
      tmp_end := AppliedInfo.AnimEnd;
      tmp_start := AppliedInfo.AnimStart;
      if Assigned(OnEndAnimation) then
        OnEndAnimation;
      fLastFrameFromOtherAnimation := (tmp_end <> AppliedInfo.AnimEnd) or
                                      (tmp_start <> AppliedInfo.AnimStart);
    end;
  end;

  if NeedsUpdate then
  begin
    if AppliedInfo.UseInterpolation then
    begin
      if fLastFrameFromOtherAnimation and (AppliedInfo.AnimEnd <> AppliedInfo.AnimStart) then
        fNumVertexes := fModel.GetFrameVertexesOnlyXYZ(fIdx,
          fLastFrameIndexFloat, TheVertexes)
      else if AppliedInfo.AnimEnd = AppliedInfo.AnimStart then
        fNumVertexes := fModel.GetFrameVertexesOnlyXYZ(AppliedInfo.AnimStart, TheVertexes)
      else
        fNumVertexes := fModel.GetFrameVertexesOnlyXYZ(fIdx, TheVertexes,
          AppliedInfo.AnimStart, AppliedInfo.AnimEnd, 1 / (1 + AppliedInfo.MinFramesPerSec));
    end
    else
      fNumVertexes := fModel.GetFrameVertexesOnlyXYZ(trunc(fIdx), TheVertexes);
    ApplyInfoToVertexes;
    fLastUpdateTime := fTime;
  end
  else
    fIdx := fLastFrameIndexFloat;

  dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(D3DCULL_NONE));
  if (Graphic.Bitmap.Width = 0) then
    with info do
    begin
      CurIndex := CurTextureIndex;
      // ױנסקוי לףךב, פחם קסחףילןנןין‎לו.
      // ¼פבם הום ץנסקוי לףךב ףפן Textures[CurIndex, 1] ץנסקוי ן הוךפחע
      // פןץ Textures[CurIndex, 0] (ךןפב ::AddTexturesToCollection)
      if Textures[CurIndex, 1] <> Textures[CurIndex, 0] then
      begin
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
        // ׃קוהיזןץלו פחם לףךב...
        dev.SetTexture( 0, Textures[CurTextureIndex, 1].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLELIST, D3DDXFVF_VERTEX, TheVertexes[0], fNumVertexes, 0);
        // ...ךבי נופלו בנ נםש פחם ויךםב
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVDESTCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetTexture( 0, Textures[CurTextureIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLELIST, D3DDXFVF_VERTEX, TheVertexes[0], fNumVertexes, 0);
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
      end
      else // ִום ץנסקוי לףךב
      begin
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
        dev.SetTexture(0, Textures[CurIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLELIST, D3DDXFVF_VERTEX, TheVertexes[0], fNumVertexes, 0);
      end;
    end
  else with Info do
  begin
    dev.SetTexture(0, Texture[0].Surface.IDDSurface7);
    dev.DrawPrimitive(D3DPT_TRIANGLELIST, D3DDXFVF_VERTEX, TheVertexes[0], fNumVertexes, 0);
  end;

  if ClearLastFrameFromOtherAnimationFlag then
    fLastFrameFromOtherAnimation := False;

  fLastFrameIndexFloat := fIdx;
  fDidDraw := True;
end;

procedure TD3DActor.Scale(factor: TD3DValue);
begin
  if factor <= 0 then
    factor := 1.0;
  if (factor <> 1.0) then
  begin
    AppliedInfo.Scale := factor;
    fNeedsRadiusAndCenterRecalc := True;
    fNeedsUpdate := True;
  end;
end;

procedure TD3DActor.SetPosition(vM: TD3DVector);
begin
  if (AppliedInfo.x <> vM.x) or
     (AppliedInfo.y <> vM.y) or
     (AppliedInfo.z <> vM.z) then
  begin
    with AppliedInfo do
    begin
      x := vM.X;
      y := vM.Y;
      z := vM.Z;
    end;
    fNeedsRadiusAndCenterRecalc := True;
    fNeedsUpdate := True;
  end;
end;

procedure TD3DActor.SetRotation(vM: TD3DVector);
begin
  if (AppliedInfo.x <> vM.x) or
     (AppliedInfo.y <> vM.y) or
     (AppliedInfo.z <> vM.z) then
  begin
    with AppliedInfo do
    begin
      dx := GetNormalizeAngle(vM.X);
      dy := GetNormalizeAngle(vM.Y);
      dz := GetNormalizeAngle(vM.Z);
    end;
    fNeedsRadiusAndCenterRecalc := True;
    fNeedsUpdate := True;
  end;
end;

procedure TD3DActor.Move(vM: TD3DVector);
begin
  if not VectorEquel(vM, NULLVECTOR) then
  begin
    with AppliedInfo do
    begin
      x := x + vM.X;
      y := y + vM.Y;
      z := z + vM.Z;
    end;
    fNeedsRadiusAndCenterRecalc := True;
    fNeedsUpdate := True;
  end;
end;

procedure TD3DActor.ApplyLight(l: TD3DSceneLight);
var i: integer;
    C: TColor;
begin
  if l.IsAppliable(GetLocatePosition(0.0)) then
  begin
    C := AppliedInfo.C;
    for i := 0 to fNumVertexes - 1 do
      l.ApplyToVertex(TheVertexes[i], C)
  end;
end;

function TD3DActor.GetNumVertexes: integer;
begin
  Result := fNumVertexes;
end;

function TD3DActor.GetNumTriangles: integer;
begin
  Result := fNumVertexes div 3;
end;

procedure TD3DActor.Rotate(vM: TD3DVector);
begin
  if not VectorEquel(vM, NULLVECTOR) then
  begin
    with AppliedInfo do
    begin
      dx := GetNormalizeAngle(dx + vM.X);
      dy := GetNormalizeAngle(dy + vM.Y);
      dz := GetNormalizeAngle(dz + vM.Z);
    end;
    fNeedsRadiusAndCenterRecalc := True;
    fNeedsUpdate := True;
  end;
end;

procedure TD3DActor.fCalcCenterAndRadius;
begin
  if AppliedInfo.Scale > 0.0 then
    fCenter := VectorAdd(
      MakeD3DVector(AppliedInfo.x, AppliedInfo.y, AppliedInfo.z),
        VectorMulS(fModel.Center, AppliedInfo.Scale))
  else
    fCenter :=
      MakeD3DVector(AppliedInfo.x, AppliedInfo.y, AppliedInfo.z);
  if (fNumVertexes > 0) and (fModel <> nil) then
    fRadius := fModel.Radius * AppliedInfo.Scale
  else
    fRadius := 0.0;
end;

{$IFDEF DESIGNER}
function TD3DActor.CanSaveVertexes: boolean;
begin
  Result := True;
end;
{$ENDIF}

{$IFDEF DESIGNER}
procedure TD3DActor.SaveVertexes(fName: string);
var f: TFileStream;
    cc: TD3DCull;
    pp: TD3DPrimitiveType;
begin
  f := TFileStream.Create(fName, fmCreate or fmShareDenyWrite);
  try
    cc := D3DCULL_NONE;
    pp := D3DPT_TRIANGLELIST;
    f.Write(cc, SizeOf(cc));
    f.Write(pp, SizeOf(pp));
    f.Write(TheVertexes^, fNumVertexes * SizeOf(TD3DLVertex));
  finally
    f.Free;
  end;
end;
{$ENDIF}

{$IFDEF DESIGNER}
function TD3DActor.RTL_CanBeRuntime: boolean;
begin
  Result := False
end;
{$ENDIF}

{$IFDEF DESIGNER}
procedure TD3DActor.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull);
begin
  DeclareSession := '';
  InitSession := '';
  DrawSession := '';
  DoneSession := '';
end;
{$ENDIF}

procedure TD3DActor.GetTextureNames(var s: TDXStringList);
var
  i: integer;
begin
  for i := 0 to Info.NumTextures - 1 do
  begin
    if Info.TextureNames[i, 0] <> '' then
      if s.IndexOf(Info.TextureNames[i, 0]) = -1 then
         s.Add(Info.TextureNames[i, 0]);
    if Info.TextureNames[i, 1] <> '' then
      if s.IndexOf(Info.TextureNames[i, 1]) = -1 then
         s.Add(Info.TextureNames[i, 1]);
  end;
end;

function TD3DActor.IsIdentical(D3DSurface: TObject): boolean;
var
  inf: TD3DActorInfo;
begin
  Result := False;
  if not Inherited IsIdentical(D3DSurface) then
    Exit;
  if D3DSurface is TD3DActor then
  begin
    (D3DSurface as TD3DActor).GetInfo(@inf);
    Result :=
      (Info.key = inf.Key) and
      (Info.C = inf.C) and
      (Info.NumTextures = inf.NumTextures) and
      (Info.zOrder = inf.zOrder) and
      (Info.Interval = inf.Interval) and
      (Info.x = inf.x) and
      (Info.y = inf.y) and
      (Info.z = inf.z) and
      (Info.dx = inf.dx) and
      (Info.dy = inf.dy) and
      (Info.dz = inf.dz) and
      (Info.Scale = inf.Scale) and
      (Info.AnimStart = inf.AnimStart) and
      (Info.AnimEnd = inf.AnimEnd) and
      (Info.AnimSpeed = inf.AnimSpeed) and
      (Info.UseInterpolation = inf.UseInterpolation) and
      (Info.MinFramesPerSec = inf.MinFramesPerSec) and
      (Info.HideDistance = inf.HideDistance) and
      (Info.UpdateDistance = inf.UpdateDistance) and
      (Info.PathToModel = inf.PathToModel) and
      TextureNamesEqual(inf.TextureNames, Info.TextureNames, Info.NumTextures);
   end;
end;

function TD3DActor.GetTypeID: byte;
begin
  Result := ID3D_Actor;
end;

function TD3DActor.GetKeyID: integer;
begin
  Result := Info.Key;
end;

procedure TD3DActor.SaveToStream(s: TStream);
var
  i: integer;
  len: word;
begin
  Inherited SaveToStream(s);
  with Info do
  begin
    s.Write(key, SizeOf(key));
    s.Write(zOrder, SizeOf(zOrder));
    s.Write(Interval, SizeOf(Interval));
    s.Write(x, SizeOf(x));
    s.Write(y, SizeOf(y));
    s.Write(z, SizeOf(z));
    s.Write(dx, SizeOf(dx));
    s.Write(dy, SizeOf(dy));
    s.Write(dz, SizeOf(dz));
    s.Write(C, SizeOf(C));
    s.Write(Scale, SizeOf(Scale));
    s.Write(AnimStart, SizeOf(AnimStart));
    s.Write(AnimEnd, SizeOf(AnimEnd));
    s.Write(AnimSpeed, SizeOf(AnimSpeed));
    s.Write(UseInterpolation, SizeOf(UseInterpolation));
    s.Write(MinFramesPerSec, SizeOf(MinFramesPerSec));
    s.Write(HideDistance, SizeOf(HideDistance));
    s.Write(UpdateDistance, SizeOf(UpdateDistance));
    s.Write(NumTextures, SizeOf(NumTextures));

    len := Length(PathToModel);
    s.Write(len, SizeOf(len));
    for i := 1 to len do
      s.Write(PathToModel[i], SizeOf(PathToModel[i]));
  end;
end;

procedure TD3DActor.LoadFromStream(s: TStream; version: integer);
var
  i: integer;
  len: word;
begin
  Inherited LoadFromStream(s, version);
  with Info do
  begin
    s.Read(key, SizeOf(key));
    s.Read(zOrder, SizeOf(zOrder));
    s.Read(Interval, SizeOf(Interval));
    s.Read(x, SizeOf(x));
    s.Read(y, SizeOf(y));
    s.Read(z, SizeOf(z));
    s.Read(dx, SizeOf(dx));
    s.Read(dy, SizeOf(dy));
    s.Read(dz, SizeOf(dz));
    s.Read(C, SizeOf(C));
    s.Read(Scale, SizeOf(Scale));
    s.Read(AnimStart, SizeOf(AnimStart));
    s.Read(AnimEnd, SizeOf(AnimEnd));
    s.Read(AnimSpeed, SizeOf(AnimSpeed));
    s.Read(UseInterpolation, SizeOf(UseInterpolation));
    s.Read(MinFramesPerSec, SizeOf(MinFramesPerSec));
    s.Read(HideDistance, SizeOf(HideDistance));
    s.Read(UpdateDistance, SizeOf(UpdateDistance));
    s.Read(NumTextures, SizeOf(NumTextures));
    s.Read(len, SizeOf(len));
    SetLength(PathToModel, len);
    for i := 1 to len do
      s.Read(PathToModel[i], SizeOf(PathToModel[i]));
  end;
end;

function TD3DActor.CurTextureName: string;
begin
  Result := Info.TextureNames[CurTextureIndex, 0];
end;

function TD3DActor.CurFrameIndexFloat: TD3DValue;
begin
  if AppliedInfo.AnimSpeed <= 0 then
  begin
    Result := AppliedInfo.AnimStart;
    Exit;
  end;
  if AppliedInfo.AnimStart = AppliedInfo.AnimEnd then
  begin
    Result := AppliedInfo.AnimStart;
    Exit;
  end;

  Result := AppliedInfo.AnimStart +
    (trunc(1024 * (fTime - fStartTime{ + fScene.StartTime})) mod trunc(1024 * AppliedInfo.AnimSpeed)) / 1024 / AppliedInfo.AnimSpeed *
      (abs(AppliedInfo.AnimStart - AppliedInfo.AnimEnd) + 1);
end;

function TD3DActor.CurFrameIndex: word;
begin
  if AppliedInfo.AnimSpeed <= 0 then
  begin
    Result := 0;
    Exit;
  end;
  if AppliedInfo.AnimStart = AppliedInfo.AnimEnd then
  begin
    Result := 0;
    Exit;
  end;
  Result := AppliedInfo.AnimStart + trunc(
    (fTime - fStartTime{ + fScene.StartTime}) *
      (abs(AppliedInfo.AnimStart - AppliedInfo.AnimEnd) + 1) / AppliedInfo.AnimSpeed)
  mod
    (abs(AppliedInfo.AnimStart - AppliedInfo.AnimEnd) + 1);
end;

function TD3DActor.CurTextureIndex: integer;
begin
  if (AppliedInfo.Interval = 0) or (AppliedInfo.NumTextures = 0) then
    Result := 0
  else
    Result := trunc(fTime * AppliedInfo.NumTextures / AppliedInfo.Interval) mod AppliedInfo.NumTextures;
end;

function TD3DActor.CalcDistance(const Position: TD3DVector): TD3DValue; register;
begin
  if AppliedInfo.zOrder > 50000 then // ֿץסבםע, פבגםי, נפשלב
    Distance := AppliedInfo.zOrder
  else
    Distance :=
      VectorMagnitude(
        VectorSub(
          MakeD3DVector(AppliedInfo.x, AppliedInfo.y, AppliedInfo.z), Position));
  Result := Distance;
end;

function TD3DActor.TextureName: string;
begin
  Result := Info.PathToModel;
end;

procedure TD3DActor.GetInfo(p: Pointer);
begin
  PD3DActorInfo(p)^ := Info;
end;

function TD3DActor.GetLocatePosition(aDistance: TD3DValue): TD3DVector;
begin
  with info do
    Result := MakeD3DVector(x, y, z - aDistance);
end;

{$ENDIF}

{$IFNDEF NO_D3DPLUGINS}

// *** TD3DPlugIn ***
constructor TD3DPlugIn.Create(aScene: TD3DScene; aTexture: TDirect3DTexture2; aInfo: TD3DPlugInInfo);
{$IFNDEF DESIGNER}
var prefix: string;
{$ENDIF}
begin
  fScene := aScene;
  Info := aInfo;
  if FileExists(aScene.GetExistedFileName(Info.DLL)) then
    DLL_Instance := LoadLibrary(PChar(aScene.GetExistedFileName(Info.DLL)))
  else
    DLL_Instance := 0;
  if DLL_Instance > 0 then
  begin
    DPlugIn_Initialize := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_Initialize));
    DPlugIn_ReInitialize := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_ReInitialize));
    DPlugIn_Finalize := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_Finalize));
    DPlugIn_Draw := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_Draw));
    DPlugIn_BeforeDraw := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_BeforeDraw));
    DPlugIn_AfterDraw := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_AfterDraw));
    DPlugIn_Move := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_Move));
    DPlugIn_Rotate := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_Rotate));
    DPlugIn_ApplyLight := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_ApplyLight));
    DPlugIn_GetFriendlyName := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_GetFriendlyName));
    DPlugIn_AcceptPosition := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_AcceptPosition));
    DPlugIn_AcceptRotation := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_AcceptRotation));
    DPlugIn_NotifyPosition := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_NotifyPosition));
    DPlugIn_NotifyRotation := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_NotifyRotation));
    DPlugIn_RequestResTexture := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_RequestResTexture));
    DPlugIn_AcceptTexture := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_AcceptTexture));
    DPlugIn_TransparentTexture := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_TransparentTexture));
    DPlugIn_GetVertex := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_GetVertex));
    DPlugIn_SetVertex := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_SetVertex));
    DPlugIn_GetNumVertexes := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_GetNumVertexes));
    DPlugIn_GetNumTriangles := GetProcAddress(DLL_Instance, PChar(rsDPlugIn_GetNumTriangles));
  end
{$IFNDEF DESIGNER}
  else
// ֱם ולבףפו ףו Viewer הםןץלו לב הו‎פוסח וץךביסב, רקםןץלו דיב וםףשלבפשלםוע
// ףפן וךפוכףילן ףץםבספףויע.
  begin
    prefix := ExtractFileNameOnly(Info.DLL) + '_';
    DLL_Instance := HInstance;
    DPlugIn_Initialize := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_Initialize));
    DPlugIn_ReInitialize := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_ReInitialize));
    DPlugIn_Finalize := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_Finalize));
    DPlugIn_Draw := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_Draw));
    DPlugIn_BeforeDraw := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_BeforeDraw));
    DPlugIn_AfterDraw := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_AfterDraw));
    DPlugIn_Move := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_Move));
    DPlugIn_Rotate := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_Rotate));
    DPlugIn_ApplyLight := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_ApplyLight));
    DPlugIn_GetFriendlyName := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_GetFriendlyName));
    DPlugIn_AcceptPosition := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_AcceptPosition));
    DPlugIn_AcceptRotation := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_AcceptRotation));
    DPlugIn_NotifyPosition := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_NotifyPosition));
    DPlugIn_NotifyRotation := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_NotifyRotation));
    DPlugIn_RequestResTexture := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_RequestResTexture));
    DPlugIn_AcceptTexture := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_AcceptTexture));
    DPlugIn_TransparentTexture := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_TransparentTexture));
    DPlugIn_GetVertex := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_GetVertex));
    DPlugIn_SetVertex := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_SetVertex));
    DPlugIn_GetNumVertexes := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_GetNumVertexes));
    DPlugIn_GetNumTriangles := GetProcAddress(DLL_Instance, PChar(prefix + rsDPlugIn_GetNumTriangles));
  end;
{$ELSE}
  else
    SetInvalid;
{$ENDIF}
  Inherited Create(fScene.DXDraw, aTexture);
end;

procedure TD3DPlugIn.SetInvalid;
begin
  DPlugIn_Initialize := nil;
  DPlugIn_ReInitialize := nil;
  DPlugIn_Finalize := nil;
  DPlugIn_Draw := nil;
  DPlugIn_BeforeDraw := nil;
  DPlugIn_AfterDraw := nil;
  DPlugIn_Move := nil;
  DPlugIn_Rotate := nil;
  DPlugIn_ApplyLight := nil;
  DPlugIn_GetFriendlyName := nil;
  DPlugIn_AcceptPosition := nil;
  DPlugIn_AcceptRotation := nil;
  DPlugIn_NotifyPosition := nil;
  DPlugIn_NotifyRotation := nil;
  DPlugIn_RequestResTexture := nil;
  DPlugIn_AcceptTexture := nil;
  DPlugIn_TransparentTexture := nil;
  DPlugIn_GetVertex := nil;
  DPlugIn_SetVertex := nil;
  DPlugIn_GetNumVertexes := nil;
  DPlugIn_GetNumTriangles := nil;
end;

procedure TD3DPlugIn.LoadLibTextures;
var
  s: string;
  txtr: TDirect3DTexture2;
  i: integer;
  canv: TCanvas;
begin
  if Assigned(DPlugIn_RequestResTexture) and Assigned(DPlugIn_AcceptTexture) then
  begin
    i := 0;
    repeat
      inc(i);
      SetLength(s, $FFFF);
      SetLength(s, DPlugIn_RequestResTexture(ID, @s[1]));
      if Length(s) > 0 then
      begin
      // ֱם פן texture וםבי nil, פפו פן טפןץלו
      // שע פן נס‏פן texture נןץ ךםוי request פן PlugIn
        if Texture[0] = nil then
        begin
          Texture[0] := fScene.CacheDLLTexture(Info.DLL, s);
          if Texture[0] <> nil then
            DPlugIn_AcceptTexture(ID, @s[1], Texture[0].Surface.IDDSurface7);
        end
        else
        begin
          txtr := fScene.CacheDLLTexture(Info.DLL, s);
          if txtr <> nil then
            DPlugIn_AcceptTexture(ID, @s[1], txtr.Surface.IDDSurface7);
        end;
      end;
    until (Length(s) = 0) or (i = MAXTEXTURES);
  end;
  if Texture[0] = nil then
  begin
    Graphic.Bitmap.Width := 2;
    Graphic.Bitmap.Height := 2;
    Graphic.Bitmap.PixelFormat := pf24bit;
    canv := Graphic.Bitmap.Canvas;
    canv.Pixels[0, 0] := clWhite;
    canv.Pixels[1, 0] := clWhite;
    canv.Pixels[0, 1] := clWhite;
    canv.Pixels[1, 1] := clWhite;
    Texture[0] := TDirect3DTexture2.Create(DXDraw, Graphic, False);
  end
end;

constructor TD3DPlugIn.CreateFromStream(s: TStream; aScene: TD3DScene; aTexture: TDirect3DTexture2; version: integer);
begin
  LoadFromStream(s, version);
  Create(aScene, aTexture, Info);
end;

destructor TD3DPlugIn.Destroy;
begin
  try
    if Assigned(DPlugIn_Finalize) then
      DPlugIn_Finalize(ID);
    SetInvalid;
  finally
    if DLL_Instance <> HInstance then
      FreeLibrary(DLL_Instance);
  end;
  Inherited;
end;

procedure TD3DPlugIn.fCalcCenterAndRadius;
begin
  fCenter := MakeD3DVector(Info.x, Info.y, Info.z);
  fRadius := 0.0;
end;

procedure TD3DPlugIn.InitParams;
begin
  v := MakeD3DLVERTEX(
        MakeD3DVector(Info.x, Info.y, Info.z),
          CA_MAKE(clWhite, 0), 0,
            0.0, 0.0);
  if Assigned(DPlugIn_Initialize) then
  begin
    ID := DPlugIn_Initialize(PChar(Info.Params));
    if ID = 0 then
      SetInvalid
    else
    begin
      if Assigned(DPlugIn_Rotate) then
        DPlugIn_Rotate(ID, Info.dx, Info.dy, Info.dz);
      if Assigned(DPlugIn_Move) then
        DPlugIn_Move(ID, Info.x, Info.y, Info.z);
      if Assigned(DPlugIn_TransparentTexture) then
        fTransparent := DPlugIn_TransparentTexture(ID)
      else
        fTransparent := False;
      LoadLibTextures;
      if Texture[0] <> nil then
      begin
        Texture[0].Transparent := fTransparent;
        if fTransparent then
          Texture[0].TransparentColor := RGB(0, 0, 0);
      end;
      NotifyRotation(fScene.Rotation);
      NotifyPosition(fScene.Position);
    end;
  end
  else
    ID := 0;
end;

procedure TD3DPlugIn.BeforeDraw;
begin
  if Assigned(DPlugIn_BeforeDraw) then
    DPlugIn_BeforeDraw(ID, DXDraw.D3DDevice7);
end;

procedure TD3DPlugIn.Draw;
begin
  if Assigned(DPlugIn_Draw) then
  begin
    if (Texture[0] <> nil) then
      DXDraw.D3DDevice7.SetTexture(0, Texture[0].Surface.IDDSurface7);
    DPlugIn_Draw(ID, DXDraw.D3DDevice7);
  end;
end;

function TD3DPlugIn.ReInitialize: boolean;
begin
  Result := False;
  if Assigned(DPlugIn_ReInitialize) then
  begin
    DPlugIn_ReInitialize(ID);
    if ID = 0 then
      SetInvalid
    else
    begin
      if Assigned(DPlugIn_Rotate) then
        DPlugIn_Rotate(ID, Info.dx, Info.dy, Info.dz);
      if Assigned(DPlugIn_Move) then
        DPlugIn_Move(ID, Info.x, Info.y, Info.z);
      if Assigned(DPlugIn_TransparentTexture) then
        fTransparent := DPlugIn_TransparentTexture(ID)
      else
        fTransparent := False;
      LoadLibTextures;
      if Texture[0] <> nil then
      begin
        Texture[0].Transparent := fTransparent;
        if fTransparent then
          Texture[0].TransparentColor := RGB(0, 0, 0);
      end;
      NotifyRotation(fScene.Rotation);
      NotifyPosition(fScene.Position);
      Result := True
    end
  end;
end;

procedure TD3DPlugIn.AfterDraw;
begin
  if Assigned(DPlugIn_AfterDraw) then
    DPlugIn_AfterDraw(ID, DXDraw.D3DDevice7);
end;

procedure TD3DPlugIn.Move(vM: TD3DVector);
begin
  with Info do
  begin
    x := x + vM.X;
    y := y + vM.Y;
    z := z + vM.Z;
  end;
  v := MakeD3DLVERTEX(
        MakeD3DVector(Info.x, Info.y, Info.z),
          CA_MAKE(clWhite, 0), 0,
            0.0, 0.0);
  if Assigned(DPlugIn_Move) then
    DPlugIn_Move(ID, vM.x, vM.y, vM.z);
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DPlugIn.Rotate(vM: TD3DVector);
begin
  with Info do
  begin
    dx := GetNormalizeAngle(dx + vM.X);
    dy := GetNormalizeAngle(dy + vM.Y);
    dz := GetNormalizeAngle(dz + vM.Z);
  end;
  if Assigned(DPlugIn_Rotate) then
    DPlugIn_Rotate(ID, vM.x, vM.y, vM.z);
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DPlugIn.GetTextureNames(var s: TDXStringList);
begin
  if Info.TextureName <> '' then
    if s.IndexOf(Info.TextureName) = - 1 then
      s.Add(Info.TextureName);
end;

function TD3DPlugIn.IsIdentical(D3DSurface: TObject): boolean;
var inf: TD3DPlugInInfo;
begin
  Result := False;
  if not Inherited IsIdentical(D3DSurface) then
    Exit;
  if D3DSurface is TD3DPlugIn then
  begin
    (D3DSurface as TD3DPlugIn).GetInfo(@inf);
    Result :=
      (inf.key = Info.Key) and
      (inf.x = Info.x) and
      (inf.y = Info.y) and
      (inf.z = Info.z) and
      (inf.dx = Info.dx) and
      (inf.dy = Info.dy) and
      (inf.dz = Info.dz) and
      (inf.DLL = Info.DLL) and
      (inf.TextureName = Info.TextureName) and
      (inf.Params = Info.Params) and
      (inf.zOrder = Info.zOrder);
  end;
end;

function TD3DPlugIn.GetTypeID: byte;
begin
  Result := ID3D_PlugIn;
end;

function TD3DPlugIn.GetKeyID: integer;
begin
  Result := Info.key;
end;

procedure TD3DPlugIn.SaveToStream(s: TStream);
var i: integer;
    len: SmallInt;
begin
  Inherited SaveToStream(s);
  with Info do
  begin
    s.Write(Key,SizeOf(Key));
    s.Write(x, SizeOf(x));
    s.Write(y, SizeOf(y));
    s.Write(z, SizeOf(z));
    s.Write(dx, SizeOf(dx));
    s.Write(dy, SizeOf(dy));
    s.Write(dz, SizeOf(dz));
    len := Length(DLL);
    s.Write(len, SizeOf(len));
    for i := 1 to len do s.Write(DLL[i], 1);
    len := Length(Params);
    s.Write(len, SizeOf(len));
    for i := 1 to len do s.Write(Params[i], 1);
    s.Write(zOrder, SizeOf(zOrder));
  end;
end;

procedure TD3DPlugIn.LoadFromStream(s: TStream; version: integer);
var
  i: integer;
  len: SmallInt;
  c: char;
begin
  Inherited LoadFromStream(s, version);
  with Info do
  begin
    s.Read(Key,SizeOf(Key));
    s.Read(x, SizeOf(x));
    s.Read(y, SizeOf(y));
    s.Read(z, SizeOf(z));
    s.Read(dx, SizeOf(dx));
    s.Read(dy, SizeOf(dy));
    s.Read(dz, SizeOf(dz));
    DLL := '';
    s.Read(len, SizeOf(len));
    for i := 1 to len do
    begin
      s.Read(c, 1);
      DLL := DLL + c;
    end;
    Params := '';
    s.Read(len, SizeOf(len));
    for i := 1 to len do
    begin
      s.Read(c, 1);
      Params := Params + c;
    end;
    s.Read(zOrder, SizeOf(zOrder));
  end;
end;

function TD3DPlugIn.CalcDistance(const Position: TD3DVector): TD3DValue; register;
begin
  if Info.zOrder > 50000 then // ֿץסבםע, פבגםי, נפשלב
    Distance := Info.zOrder
  else
    Distance := VectorMagnitude(MakeD3DVector(
      Info.x - Position.X,
      Info.y - Position.Y,
      Info.z - Position.Z));
  Result := Distance;
end;

function TD3DPlugIn.TextureName: string;
begin
  if Assigned(DPlugIn_GetFriendlyName) then
  begin
    SetLength(Result, $FFFF);
    SetLength(Result, DPlugIn_GetFriendlyName(@Result[1]));
  end
  else
    Result := Info.TextureName;
end;

procedure TD3DPlugIn.GetInfo(p: Pointer);
begin
  PD3DPlugInInfo(p)^ := Info;
end;

function TD3DPlugIn.GetLocatePosition(aDistance: TD3DValue): TD3DVector;
begin
  with info do
    Result := MakeD3DVector(x, y, z - aDistance);
end;

procedure TD3DPlugIn.AcceptPosition(var pos: TD3DVector);
begin
  if Assigned(DPlugIn_AcceptPosition) then
    DPlugIn_AcceptPosition(id, pos.x, pos.y, pos.z);
end;

procedure TD3DPlugIn.AcceptRotation(var rot: TD3DVector);
begin
  if Assigned(DPlugIn_AcceptRotation) then
    DPlugIn_AcceptRotation(id, rot.x, rot.y, rot.z);
end;

procedure TD3DPlugIn.NotifyPosition(pos: TD3DVector);
begin
  if Assigned(DPlugIn_NotifyPosition) then
    DPlugIn_NotifyPosition(id, pos.x, pos.y, pos.z);
end;

procedure TD3DPlugIn.NotifyRotation(rot: TD3DVector);
begin
  if Assigned(DPlugIn_NotifyRotation) then
    DPlugIn_NotifyRotation(id, rot.x, rot.y, rot.z);
end;

procedure TD3DPlugIn.ApplyLight(l: TD3DSceneLight);
var
  v1: TD3DLVertex;
  i: integer;
begin
  if Assigned(DPlugIn_GetVertex) and Assigned(DPlugIn_SetVertex) then
  begin
    i := 0;
    while DPlugIn_GetVertex(id, i, v1.x, v1.y, v1.z, v1.color, v1.specular) do
    begin
      l.ApplyToVertex(v1, v1.Color);
      DPlugIn_SetVertex(id, i, v1.x, v1.y, v1.z, v1.color, v1.specular);
      inc(i);
    end;
  end
  else if Assigned(DPlugIn_ApplyLight) then
  begin
    l.ApplyToVertex(v, clWhite);
    DPlugIn_ApplyLight(id, v.Color, v.Specular);
  end;
end;

{$IFDEF DESIGNER}
function TD3DPlugIn.CanSaveVertexes: boolean;
begin
  Result := False;
end;

procedure TD3DPlugIn.SaveVertexes(fName: string);
var
  f: TFileStream;
  cc: TD3DCull;
  pp: TD3DPrimitiveType;
begin
  f := TFileStream.Create(fName, fmCreate or fmShareDenyWrite);
  try
    cc := D3DCULL_INVALID_0;
    pp := D3DPT_INVALID_0;
    f.Write(cc, SizeOf(cc));
    f.Write(pp, SizeOf(pp));
  finally
    f.Free;
  end;
end;

function TD3DPlugIn.RTL_CanBeRuntime: boolean;
begin
  Result := False;
end;

procedure TD3DPlugIn.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull);
begin
  DeclareSession := '';
  InitSession := '';
  DrawSession := '';
  DoneSession := '';
end;
{$ENDIF}

// ֱסיטלע Vertexes פןץ בםפיךוילםןץ
function TD3DPlugIn.GetNumVertexes: integer;
begin
  if Assigned(DPlugIn_GetNumVertexes) then
    Result := DPlugIn_GetNumVertexes(id)
  else
    Result := 0;
end;

// ֱסיטלע װסיד‏םשם פןץ בםפיךוילםןץ
function TD3DPlugIn.GetNumTriangles: integer;
begin
  if Assigned(DPlugIn_GetNumTriangles) then
    Result := DPlugIn_GetNumTriangles(id)
  else
    Result := 0;
end;
{$ENDIF}

// *** TD3DPolygon *** //
constructor TD3DPolygon.Create(aDXDraw: TDXDraw; aTextures: TDirect3DTextures2;
  const aInfo: TD3DPolygonInfo);
// ׳סחףילןנןין‎לו פן 'const' ףפחם נבסלופסן aInfo: TD3DPolygonInfo דיבפ הוףלוץוי נןכ‎ לםלח
// ףפןגבע. ּו פן const הום הוףלו‎וי לםלח ףפןגבע
begin
  fMaxPolygonVertexes := MAXVERTEXES;
  fTessalationRoll := 0;
  fRealArraySize := 0;
  Info2.Vertexes := nil;
  TheVertexes := nil;
  LoadedRunTime := False;
  fNumVertexes := 0;
  InfoToInfo2(aInfo);
  CreateVertexes;
  Textures := aTextures;
  Inherited Create(aDXDraw, aTextures[0, 0]);
end;

constructor TD3DPolygon.Create(aDXDraw: TDXDraw; const aVertexes: PD3DLVertexArray;
  const aNumVertexes: integer; const prtype: TD3DPrimitiveType;
  const aTexture: TDirect3DTexture2; const aTextureName: string);
var
  i: integer;
begin
  fMaxPolygonVertexes := MAXVERTEXES;
  fTessalationRoll := 0;
  fRealArraySize := 0;
  FillChar(Info2, SizeOf(Info2), Chr(0));
  Info2.Key := GenGlobalID;
  Info2.C := $FFFFFF;
  Info2.NumTextures := 1;
  Info2.NumVertexes := aNumVertexes;
  Info2.Interval := 0;
  Info2.PrimitiveType := prtype;
  Info2.Transparency := 0;
  Info2.Cull := D3DCULL_NONE;
  SizeNumVertexes(aNumVertexes);
  for i := 0 to aNumVertexes - 1 do
  begin
    Info2.Vertexes[i] := PD3DVector(@aVertexes[i])^;//MakeD3DVector(aVertexes[i]);
    TheVertexes[i] := aVertexes[i];
  end;
  Info2.TextureNames[0, 0] := aTextureName;
  LoadedRunTime := True;
  FillChar(Textures, SizeOf(Textures), Chr(0));
  Textures[0, 0] := aTexture;
  Inherited Create(aDXDraw, aTexture);
end;

constructor TD3DPolygon.CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; version: integer);
begin
  fNumVertexes := 0;
  LoadFromStream(s, version);
  Textures := aTextures;
  Inherited Create(aDXDraw, aTextures[0, 0]);
end;

destructor TD3DPolygon.Destroy;
begin
  SizeNumVertexes(0);
  Inherited;
end;

function TD3DPolygon.DefaultRTLQuery: boolean;
begin
  if LoadedRunTime then
    Result := True
  else
    Result := Inherited DefaultRTLQuery;
end;

procedure TD3DPolygon.InfoToInfo2(const inf: TD3DPolygonInfo);
var i: integer;
begin
  info2.key := inf.key;
  info2.C := inf.C;
  info2.u := inf.u;
  info2.v := inf.v;
  info2.du := inf.du;
  info2.dv := inf.dv;
  info2.UseFlatUV := inf.UseFlatUV;
  info2.NumVertexes := inf.NumVertexes;
  info2.NumTextures := inf.NumTextures;
  info2.zOrder := inf.zOrder;
  info2.Interval := inf.Interval;
  info2.PrimitiveType := inf.PrimitiveType;
  info2.Transparency := inf.Transparency;
  info2.Cull := inf.Cull;
  info2.TextureNames := inf.TextureNames;
  SizeNumVertexes(inf.NumVertexes);
  for i := 0 to inf.NumVertexes - 1 do
    info2.Vertexes[i] := inf.Vertexes[i];
end;

procedure TD3DPolygon.Info2ToInfo(var inf: TD3DPolygonInfo);
var
  i: integer;
begin
  inf.key := info2.key;
  inf.C := info2.C;
  inf.u := info2.u;
  inf.v := info2.v;
  inf.du := info2.du;
  inf.dv := info2.dv;
  inf.UseFlatUV := info2.UseFlatUV;
  inf.NumVertexes := info2.NumVertexes;
  inf.NumTextures := info2.NumTextures;
  inf.zOrder := info2.zOrder;
  inf.Interval := info2.Interval;
  inf.PrimitiveType := info2.PrimitiveType;
  inf.Transparency := info2.Transparency;
  inf.Cull := info2.Cull;
  inf.TextureNames := info2.TextureNames;
  for i := 0 to info2.NumVertexes - 1 do
    inf.Vertexes[i] := PD3DVector(@TheVertexes[i])^;// MakeD3DVector(TheVertexes[i]);
end;

procedure TD3DPolygon.Roll;
// Rolls one position the polygon....
var
  vec: TD3DVector;
  vert: TD3DLVertex;
  i: integer;
begin
  vec := Info2.Vertexes[0];
  vert := TheVertexes[0];
  for i := 1 to Info2.NumVertexes - 1 do
  begin
    Info2.Vertexes[i - 1] := Info2.Vertexes[i];
    TheVertexes[i - 1] := TheVertexes[i];
  end;
  Info2.Vertexes[Info2.NumVertexes - 1] := vec;
  TheVertexes[Info2.NumVertexes - 1] := vert;
end;

function TD3DPolygon.Tessalate: boolean;
var
  i, j, k: integer;
  tr: TD3DFloatTriangle;
  poly: TD3DPolygon;
  inf: PD3DPolygonInfo;
begin
  if fTessalationRoll > Info2.NumVertexes then
  begin
    Result := False;
    Exit;
  end;

  if Info2.PrimitiveType <> D3DPT_TRIANGLEFAN then
  begin
    Result := False;
    Exit;
  end;

  if Info2.NumVertexes = 3 then
  begin
    Info2.PrimitiveType := D3DPT_TRIANGLELIST;
    Result := False;
    Exit;
  end;

  poly := nil;

  tr[0] := Info2.Vertexes[0];
  for i := 1 to Info2.NumVertexes - 2 do
  begin
    tr[1] := Info2.Vertexes[i];
    tr[2] := Info2.Vertexes[i + 1];
{    angle2 := GetAngle(
                MakeFloatPoint(tr[1]),
                MakeFloatPoint(tr[0]),
                MakeFloatPoint(tr[2]));
    if angle2 * angle1 < 0 then
    begin
      inc(fTessalationRoll);
      Roll;
      Result := tessalate;
      Exit;
    end;
    angle1 := angle2;}

    for j := i + 2 to Info2.NumVertexes - 2 do
//      if F_PtInTriangle(tr, Info2.Vertexes[j]) then
      if IsFloatPointInAngle(
                MakeFloatPoint(Info2.Vertexes[j]),
                MakeFloatPoint(tr[1]),
                MakeFloatPoint(tr[0]),
                MakeFloatPoint(tr[2])) then
      begin
        if i = 1 then
        begin
          inc(fTessalationRoll);
          Roll;
          Result := tessalate;
          Exit;
        end;

        new(inf);
        try
          Info2ToInfo(inf^);
          poly := TD3DPolyGon.Create(DXDraw, Textures, inf^);
          poly.MaxPolygonVertexes := fMaxPolygonVertexes;
        finally
          dispose(inf);
        end;
        poly.RunTimeOnly := True;
        for k := i + 1 to Info2.NumVertexes - 1 do
        begin
          poly.Info2.Vertexes[k - i - 1] := Info2.Vertexes[k];
          poly.TheVertexes[k - i - 1] := TheVertexes[k];
        end;
        poly.Info2.Vertexes[Info2.NumVertexes - i - 1] := Info2.Vertexes[0];
        poly.TheVertexes[Info2.NumVertexes - i - 1] := TheVertexes[0];
        poly.SizeNumVertexes(Info2.NumVertexes - i - 1);
        SizeNumVertexes(i);
        poly.Tessalate;
        break;
      end;
    if poly <> nil then
      break;
  end;

  if poly <> nil then
  begin
    MergeWithPolygon(poly);
    Result := True;
  end
  else
    Result := False;
end;

procedure TD3DPolygon.ReduceMemory;
begin
  fRealArraySize := fNumVertexes;
  ReAllocMem(Info2.Vertexes, SizeOf(TD3DVector) * fRealArraySize);
  ReAllocMem(TheVertexes, SizeOf(TD3DLVertex) * fRealArraySize);
end;

procedure TD3DPolygon.SizeNumVertexes(const NewSize: integer);
var
  tmp: integer;
begin
  if fNumVertexes <> NewSize then
  begin
    fNumVertexes := NewSize;
    Info2.NumVertexes := NewSize;
    if fNumVertexes = 0 then
    begin
      fRealArraySize := 0;
      ReAllocMem(Info2.Vertexes, 0);
      ReAllocMem(TheVertexes, 0);
    end
    else
    begin
      tmp := (fNumVertexes div POLYGON_ALLOCATION_FACTOR + 1) * POLYGON_ALLOCATION_FACTOR;
      if tmp <> fRealArraySize then
      begin
        fRealArraySize := tmp;
        ReAllocMem(Info2.Vertexes, SizeOf(TD3DVector) * fRealArraySize);
        ReAllocMem(TheVertexes, SizeOf(TD3DLVertex) * fRealArraySize);
      end;
    end;
  end;
{  begin
    if fNumVertexes <> 0 then
    begin
      FreeMem(Info2.Vertexes, SizeOf(TD3DVector) * fNumVertexes);
      FreeMem(TheVertexes, SizeOf(TD3DLVertex) * fNumVertexes);
    end;
    fNumVertexes := NewSize;
    if NewSize <> 0 then
    begin
      GetMem(Info2.Vertexes, SizeOf(TD3DVector) * fNumVertexes);
      GetMem(TheVertexes, SizeOf(TD3DLVertex) * fNumVertexes);
    end;
  end;}
end;

procedure TD3DPolygon.GetSplitData(var A: PD3DPolygonInfoArray; var Count: integer);
var
  i: integer;
begin
  for i := Low(A^) to High(A^) do FillChar(A[i], SizeOf(A[i]), Chr(0));
  with Info2 do
  begin
    if PrimitiveType = D3DPT_TRIANGLESTRIP then
    begin
      for i := 0 to NumVertexes - 3 do System.new(A[i]);
      for i := 1 to NumVertexes - 2 do
      begin
        Info2ToInfo(A[i - 1]^);
        FillChar(A[i - 1].Vertexes, SizeOf(A[i - 1].Vertexes), Chr(0));
        A[i - 1].Vertexes[1] := Vertexes[i]; //MakeD3DVECTOR(Vertexes[i].x,  Vertexes[i].y,  Vertexes[i].z);
        if Odd(i) then
        begin
          A[i - 1].Vertexes[0] := Vertexes[i - 1]; //MakeD3DVECTOR(Vertexes[i - 1].x,  Vertexes[i - 1].y,  Vertexes[i - 1].z);
          A[i - 1].Vertexes[2] := Vertexes[i + 1]; // MakeD3DVECTOR(Vertexes[i + 1].x,  Vertexes[i + 1].y,  Vertexes[i + 1].z);
        end
        else
        begin
          A[i - 1].Vertexes[0] := Vertexes[i + 1]; // MakeD3DVECTOR(Vertexes[i + 1].x,  Vertexes[i + 1].y,  Vertexes[i + 1].z);
          A[i - 1].Vertexes[2] := Vertexes[i - 1]; // MakeD3DVECTOR(Vertexes[i - 1].x,  Vertexes[i - 1].y,  Vertexes[i - 1].z);
          if not Info2.UseFlatUV then
          begin
            A[i - 1].u := - u;
            A[i - 1].v := - v;
          end;
        end;
        A[i - 1].NumVertexes := 3;
        A[i - 1].PrimitiveType := D3DPT_TRIANGLESTRIP;
      end;
      Count := NumVertexes - 2;
    end
    else if PrimitiveType = D3DPT_TRIANGLELIST then
    begin
      for i := 0 to NumVertexes div 3 - 1 do System.new(A[i]);
      for i := 0 to (NumVertexes div 3 - 1) do
      begin
        Info2ToInfo(A[i]^);
        FillChar(A[i].Vertexes, SizeOf(A[i].Vertexes), Chr(0));
        A[i].Vertexes[0] := Vertexes[3 * i]; // MakeD3DVECTOR(Vertexes[3 * i].x,  Vertexes[3 * i].y,  Vertexes[3 * i].z);
        A[i].Vertexes[1] := Vertexes[3 * i + 1]; // MakeD3DVECTOR(Vertexes[3 * i + 1].x,  Vertexes[3 * i + 1].y,  Vertexes[3 * i + 1].z);
        A[i].Vertexes[2] := Vertexes[3 * i + 2]; // MakeD3DVECTOR(Vertexes[3 * i + 2].x,  Vertexes[3 * i + 2].y,  Vertexes[3 * i + 2].z);
        A[i].NumVertexes := 3;
        A[i].PrimitiveType := D3DPT_TRIANGLELIST;
      end;
      Count := NumVertexes div 3;
    end
    else if PrimitiveType = D3DPT_TRIANGLEFAN then
    begin
      for i := 0 to NumVertexes - 3 do System.new(A[i]);
      for i := 1 to NumVertexes - 2 do
      begin
        Info2ToInfo(A[i - 1]^);
        FillChar(A[i - 1].Vertexes, SizeOf(A[i - 1].Vertexes), Chr(0));
        A[i - 1].Vertexes[0] := Vertexes[0]; // MakeD3DVECTOR(Vertexes[0].x,  Vertexes[0].y,  Vertexes[0].z);
        A[i - 1].Vertexes[1] := Vertexes[i]; //MakeD3DVECTOR(Vertexes[i].x,  Vertexes[i].y,  Vertexes[i].z);
        A[i - 1].Vertexes[2] := Vertexes[i + 1]; // MakeD3DVECTOR(Vertexes[i + 1].x,  Vertexes[i + 1].y,  Vertexes[i + 1].z);
        A[i - 1].NumVertexes := 3;
        A[i - 1].PrimitiveType := D3DPT_TRIANGLESTRIP;
      end;
      Count := NumVertexes - 2;
    end;
  end;
end;

procedure TD3DPolygon.CreateVertexes(KeepUV: boolean = False);
var
  uA, vA: TD3DValue;
  i: integer;
  aC: TD3DColor;
  oldV: PD3DLVertexArray;
  pvect: PD3DVector;
  pver, poldver: PD3DLVertex;
begin
  if RunTimeOnly then
  begin
    GetMem(oldV, Info2.NumVertexes * SizeOf(TD3DLVertex));
    poldver := @oldV[0];
    pver := @TheVertexes[0];
    for i := 0 to Info2.NumVertexes - 1 do
    begin
      poldver.color := pver.color;
      poldver.specular := pver.specular;
      poldver.tu := pver.tu;
      poldver.tv := pver.tv;
      inc(poldver);
      inc(pver);
    end;
  end
  else
    oldV := nil;

  with Info2 do
  begin
    aC := CA_MAKE(C, 0);
    if UseFlatUV then
    begin
      if KeepUV then
      begin
        pvect := @Vertexes[0];
        pver := @TheVertexes[0];
        for i := 0 to NumVertexes - 1 do
        begin
          pver^ := MakeD3DLVERTEX(
            pvect.x,  pvect.y,  pvect.z,
              aC, 0,
                pver.tu, pver.tv);
          inc(pvect);
          inc(pver);
        end;
      end
      else
      begin
        pvect := @Vertexes[0];
        pver := @TheVertexes[0];
        for i := 0 to NumVertexes - 1 do
        begin
          pver^ := MakeD3DLVERTEX(
            pvect.x,  pvect.y,  pvect.z,
              aC, 0,
                u * pvect.x + du, v * pvect.z + dv);
          inc(pvect);
          inc(pver);
        end;
      end;
    end
    else
    begin
      pvect := @Vertexes[0];
      pver := @TheVertexes[0];
      if PrimitiveType = D3DPT_TRIANGLESTRIP then
        for i := 0 to NumVertexes - 1 do
        begin
          case i mod 4 of
            0: begin uA := 0.0; vA := 0.0; end;
            1: begin uA := 1.0; vA := 0.0; end;
            2: begin uA := 0.0; vA := 1.0; end;
          else
            begin uA := 1.0; vA := 1.0; end;
          end;
          if KeepUV then
            pver^ := MakeD3DLVERTEX(
              pvect.x,  pvect.y,  pvect.z,
                aC, 0,
                  pver.tu, pver.tv)
          else
            pver^ := MakeD3DLVERTEX(
              pvect.x,  pvect.y,  pvect.z,
                aC, 0,
                  u*uA + du, v*vA + dv);
          inc(pvect);
          inc(pver);
        end
      else if PrimitiveType = D3DPT_TRIANGLELIST then
        for i := 0 to NumVertexes - 1 do
        begin
          case i mod 3 of
            0: begin uA := 0.0; vA := 0.0; end;
            1: begin uA := 1.0; vA := 0.0; end;
          else
            begin uA := 0.0; vA := 1.0; end;
          end;
          if KeepUV then
            pver^ := MakeD3DLVERTEX(
              pvect.x,  pvect.y,  pvect.z,
                aC, 0,
                  pver.tu, pver.tv)
          else
            pver^ := MakeD3DLVERTEX(
              pvect.x,  pvect.y,  pvect.z,
                aC, 0,
                  u*uA + du, v*vA + dv);
          inc(pvect);
          inc(pver);
        end
      else if PrimitiveType = D3DPT_TRIANGLEFAN then
        for i := 0 to NumVertexes - 1 do
        begin
          if i = 0 then
            begin uA := 0.0; vA := 0.0; end
          else if i mod 4 = 1 then
            begin uA := 1.0; vA := 0.0; end
          else if i mod 4 = 2 then
            begin uA := 1.0; vA := 1.0; end
          else if i mod 4 = 3 then
            begin uA := 0.0; vA := 1.0; end
          else
            begin uA := 1.0; vA := 1.0; end;
          if KeepUV then
            pver^ := MakeD3DLVERTEX(
              pvect.x,  pvect.y,  pvect.z,
                aC, 0,
                  pver.tu, pver.tv)
          else
            pver^ := MakeD3DLVERTEX(
              pvect.x,  pvect.y,  pvect.z,
                aC, 0,
                  u*uA + du, v*vA + dv);
          inc(pvect);
          inc(pver);
        end;
    end;
  end;

  if RunTimeOnly and (oldV <> nil) then
  begin
    poldver := @oldV[0];
    pver := @TheVertexes[0];
    for i := 0 to Info2.NumVertexes - 1 do
    begin
      pver.color := poldver.color;
      pver.specular := poldver.specular;
      pver.tu := poldver.tu;
      pver.tv := poldver.tv;
      inc(poldver);
      inc(pver);
    end;
    FreeMem(oldV, Info2.NumVertexes * SizeOf(TD3DLVertex));
  end;
end;

procedure TD3DPolygon.fCalcCenterAndRadius;
begin
  CalcCenterAndRadius(TheVertexes, fNumVertexes, fRadius, fCenter);
end;

function TD3DPolygon.BoundingCube: TBoundingCube;
begin
  if fNeedsRadiusAndCenterRecalc then
    fBoundingCube := CalcBoundingCube(TheVertexes, Info2.NumVertexes);

  Result := fBoundingCube
end;

procedure TD3DPolygon.InitParams;
var
  col: TColor;
  canv: TCanvas;
begin
  with Info2 do
  begin
    if Texture[0] = nil then
    begin
      Graphic.Bitmap.Width := 2;
      Graphic.Bitmap.Height := 2;
      Graphic.Bitmap.PixelFormat := pf24bit;
      col := C;
      canv := Graphic.Bitmap.Canvas;
      canv.Pixels[0, 0] := col;
      canv.Pixels[1, 0] := col;
      canv.Pixels[0, 1] := col;
      canv.Pixels[1, 1] := col;
      Texture[0] := TDirect3DTexture2.Create(DXDraw, Graphic, False);
    end
    else
    begin
      Graphic.Bitmap.Width := 0;
      Graphic.Bitmap.Height := 0;
    end;
    if not (PrimitiveType in [D3DPT_TRIANGLELIST, D3DPT_TRIANGLESTRIP, D3DPT_TRIANGLEFAN]) then
      PrimitiveType := D3DPT_TRIANGLESTRIP;
  end
end;

{$IFDEF DESIGNER}
function TD3DPolygon.CanSaveVertexes: boolean;
begin
  Result := True;
end;

procedure TD3DPolygon.SaveVertexes(fName: string);
var
  f: TFileStream;
begin
  f := TFileStream.Create(fName, fmCreate or fmShareDenyWrite);
  try
    f.Write(Info2.Cull, SizeOf(Info2.Cull));
    f.Write(Info2.PrimitiveType, SizeOf(Info2.PrimitiveType));
    f.Write(TheVertexes^, Info2.NumVertexes * SizeOf(TD3DLVertex));
  finally
    f.Free;
  end;
end;

function TD3DPolygon.RTL_CanBeRuntime: boolean;
begin
  Result := (Info2.NumTextures in [0..1]) and
            (Info2.Transparency = MAXTRANSPARENCYREPLICATION) and
            (Graphic.Bitmap.Width = 0) and
            (Textures[0, 1] = Textures[0, 0]);
end;

procedure TD3DPolygon.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull);
begin
  DeclareSession := '';
  InitSession := '';
  DrawSession := '';
  DoneSession := '';
  RTL_GetRunTimeCodeTemplate(
    DeclareSession, InitSession, DrawSession, DoneSession,
    doTexture, curCull,
    'POLYGON_',           // GlobalName
    TheVertexes,          // Vertexes Array Pointer
    Info2.NumVertexes,    // Number of Vertexes
    Info2.Cull,           // CULL
    Info2.PrimitiveType,  // Primitive Type
    0,
    0,
    tLights);
end;
{$ENDIF}

procedure TD3DPolygon.Draw;
var
  i, CurIndex: integer;
  dev: IDirect3DDevice7;
begin
  if Info2.NumVertexes < 2 then
    Exit;

  CurIndex := CurTextureIndex;

  dev := DXDraw.D3DDevice7;
  dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(Info2.Cull));
  if fSafeMode and (Info2.PrimitiveType = D3DPT_TRIANGLELIST) then
  begin
    Textures[CurIndex, 0].Surface.TransparentColor := 0;
    dev.SetTexture( 0, Textures[CurIndex, 0].Surface.IDDSurface7);
    i := 0;
    while i < Info2.NumVertexes do
    begin
      dev.DrawPrimitive(D3DPT_TRIANGLELIST, D3DDXFVF_VERTEX, TheVertexes[i], 3, 0);
      inc(i, 3);
    end;
  end
  else if (Info2.Transparency <> 0) and (Graphic.Bitmap.Width = 0) then with info2 do
  begin
    if Transparency < MAXTRANSPARENCYREPLICATION then
    begin
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
      dev.SetTexture( 0, Textures[CurIndex, 0].Surface.IDDSurface7);
      dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
      dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
    // ֲכיק, לנןסו םב קסויבףפו םב ךבכףןץלו פחם DrawPrimitive נןככע צןסע
    // בככ נסםןץלו םב חליהיבצבםע Texture.
      for i := 1 to Transparency do
        dev.DrawPrimitive(PrimitiveType, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
    end
    else
    begin
    // ױנסקוי לףךב, פחם קסחףילןנןין‎לו.
    // ¼פבם הום ץנסקוי לףךב ףפן Textures[CurIndex, 1] ץנסקוי ן הוךפחע
    // פןץ Textures[CurIndex, 0] (ךןפב ::AddTexturesToCollection
      if Textures[CurIndex, 1] <> Textures[CurIndex, 0] then
      begin
{*******************************************************************************
//        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_TEXTUREMAPBLEND, ord(D3DTBLEND_MODULATE));

        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_SRCCOLOR));
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        // ׃קוהיזןץלו פחם לףךב...
        DXDraw.D3DDevice7.SetTexture( 0, Textures[CurTextureIndex, 0].Surface.IDDSurface7);
        DXDraw.D3DDevice7.DrawPrimitive(PrimitiveType, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
        // ...ךבי פחם נופלו בנ נםש פחם ויךםב

//        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_TEXTUREMAPBLEND, ord(D3DTBLEND_COPY));

        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_ZERO));
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
        DXDraw.D3DDevice7.SetTexture( 0, Textures[CurTextureIndex, 1].Surface.IDDSurface7);
        DXDraw.D3DDevice7.DrawPrimitive(PrimitiveType, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
{*******************************************************************************}

{*******************************************************************************
new - needs to be rendered after background
//        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_TEXTUREMAPBLEND, ord(D3DTBLEND_MODULATE));

        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_ZERO));
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
        // ׃קוהיזןץלו פחם לףךב...
        DXDraw.D3DDevice7.SetTexture( 0, Textures[CurTextureIndex, 1].Surface.IDDSurface7);
        DXDraw.D3DDevice7.DrawPrimitive(PrimitiveType, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
        // ...ךבי פחם נופלו בנ נםש פחם ויךםב

//        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_TEXTUREMAPBLEND, ord(D3DTBLEND_COPY));

        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_ONE));
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        DXDraw.D3DDevice7.SetTexture( 0, Textures[CurTextureIndex, 0].Surface.IDDSurface7);
        DXDraw.D3DDevice7.DrawPrimitive(PrimitiveType, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
*******************************************************************************}
{ *******************************************************************************
old}
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
        // ׃קוהיזןץלו פחם לףךב...
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
        dev.SetTexture( 0, Textures[CurIndex, 1].Surface.IDDSurface7);
        dev.DrawPrimitive(PrimitiveType, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
        // ...ךבי פחם נופלו בנ נםש פחם ויךםב

        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVDESTCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetTexture( 0, Textures[CurIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(PrimitiveType, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
{********************************************************************************* }
      end
      else // ִום ץנסקוי לףךב
      begin
{   // The following gives a very good transparent effect!
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_SRCBLEND, ord(D3DBLEND_SRCCOLOR));
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_DESTBLEND, ord(D3DBLEND_ONE));
}
      // Disable D3DRENDERSTATE_ALPHABLENDENABLE before setting transparent color
      // ************
      // ֳיב םב יףק‎וי ףו 8bpp ויךםוע, נסנוי ח נבכפב פןץע םב קוי פב קס‏לבפב פשם Windows!! (?)
      // ************
        Textures[CurIndex, 0].Surface.TransparentColor := 0;
        dev.SetTexture(0, Textures[CurIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(PrimitiveType, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);

{
        DXDraw.D3DDevice7.DrawPrimitive(PrimitiveType, D3DFVF_VERTEX,

D3DFVF_XYZ or D3DFVF_RESERVED1 or D3DFVF_DIFFUSE or
                            D3DFVF_SPECULAR or D3DFVF_TEX2,

                            TheVertexes[0], NumVertexes, 0);
}

      end;
    end;
    dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
  end
  else with Info2 do
  begin
    dev.SetTexture( 0, Textures[CurIndex, 0].Surface.IDDSurface7);
    dev.DrawPrimitive(PrimitiveType, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
  end;
end;

procedure TD3DPolygon.Move(vM: TD3DVector);
var
  i: integer;
  pV: PD3DVector;
begin
  with Info2 do
  begin
    pV := @Vertexes[0];
    for i := 0 to NumVertexes - 1 do
    begin
      pV.x := pV.x + vM.x;
      pV.y := pV.y + vM.y;
      pV.z := pV.z + vM.z;
      inc(pV);
    end;
  end;
  CreateVertexes(True);
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DPolygon.Rotate(vM: TD3DVector);
var
  mat: TD3DMatrix;
  v1, v2: TD3DVector;
  i: integer;
  pV: PD3DVector;
begin
  GetRotationMatrix(mat, vM.x, vM.y, vM.z);
  with Info2 do
  begin
    pV := @Vertexes[0];
    for i := 0 to NumVertexes - 1 do
    begin
      v1 := pV^; //MakeD3DVector(Vertexes[i].x, Vertexes[i].y, Vertexes[i].z);
      D3DMath_VectorMatrixMultiply(v2, v1, mat);
      pV^ := v2;
      inc(pV);
    end;
  end;
  CreateVertexes(True);
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DPolygon.GetTextureNames(var s: TDXStringList);
var
  i: integer;
begin
  for i := 0 to Info2.NumTextures - 1 do
  begin
    if Info2.TextureNames[i, 0] <> '' then
      if s.IndexOf(Info2.TextureNames[i, 0]) = -1 then
         s.Add(Info2.TextureNames[i, 0]);
    if Info2.TextureNames[i, 1] <> '' then
      if s.IndexOf(Info2.TextureNames[i, 1]) = -1 then
         s.Add(Info2.TextureNames[i, 1]);
  end;
end;

//׀סןףןק, הום הןץכו‎וי דיב runtime polygons,
//נסנוי םב בםפידסצןםפבי ךבי פב TheVertexes ךבי םב לחם ךבכויפבי ח CreateVertexes
function TD3DPolygon.ConvertToTriangleList: boolean;
var
  VV: PD3DVectorArray;
  i, num, numnew: integer;
  pV, pVV, pVV0: PD3DVector;

  function _NumTriangles: integer;
  begin
    case Info2.PrimitiveType of
      D3DPT_TRIANGLELIST: Result := Info2.NumVertexes div 3;
      D3DPT_TRIANGLESTRIP,
      D3DPT_TRIANGLEFAN: Result := Max(Info2.NumVertexes - 2, 0);
    else
      Result := 0;
    end;
  end;

begin
  if Info2.PrimitiveType = D3DPT_TRIANGLELIST then
  begin
    Result := True;
    Exit;
  end;

// Always allow some space...
  if _NumTriangles > (fMaxPolygonVertexes - 3) div 3 then
  begin
    Result := False;
    Exit;
  end;

  VV := nil;
  case Info2.PrimitiveType of
    D3DPT_TRIANGLEFAN:
      if Info2.NumVertexes > 2 then
      begin
        num := Info2.NumVertexes;
        ReAllocMem(VV, num * SizeOf(TD3DVector));
        pV := @Info2.Vertexes[0];
        pVV := @VV[0];
        for i := 0 to num - 1 do
        begin
          pVV^ := pV^;
          inc(pV);
          inc(pVV);
//          VV[i] := Info2.Vertexes[i];
        end;
        numnew := _NumTriangles * 3;
        SizeNumVertexes(numnew);
        Info2.NumVertexes := numnew;
        pV := @Info2.Vertexes[0];
        pVV0 := @VV[0];
        pVV := @VV[1];
        for i := 1 to num - 2 do
        begin
          pV^ := pVV0^;
          inc(pV);
          pV^ := pVV^;
          inc(pV);
          inc(pVV);
          pV^ := pVV^;
          inc(pV);
        end;
        ReAllocMem(VV, 0);
        Info2.PrimitiveType := D3DPT_TRIANGLELIST;
        CreateVertexes;
        Result := True;
      end
      else
        Result := Info2.NumVertexes = 0;
    D3DPT_TRIANGLESTRIP:
      if Info2.NumVertexes > 2 then
      begin
        num := Info2.NumVertexes;
        ReAllocMem(VV, num * SizeOf(TD3DVector));
        pV := @Info2.Vertexes[0];
        pVV := @VV[0];
        for i := 0 to num - 1 do
        begin
          pVV^ := pV^;
          inc(pV);
          inc(pVV);
//          VV[i] := Info2.Vertexes[i];
        end;
        numnew := 3 * (num - 2);
        SizeNumVertexes(numnew);
        Info2.NumVertexes := numnew;
        pV := @Info2.Vertexes[0];
        for i := 0 to num - 3 do
          if odd(i) then
          begin
            pV^ := VV[i];
            inc(pV);
            pV^ := VV[i + 2];
            inc(pV);
            pV^ := VV[i + 1];
            inc(pV);
          end
          else
          begin
            pV^ := VV[i];
            inc(pV);
            pV^ := VV[i + 1];
            inc(pV);
            pV^ := VV[i + 2];
            inc(pV);
          end;
        ReAllocMem(VV, 0);
        Info2.PrimitiveType := D3DPT_TRIANGLELIST;
        CreateVertexes;
        Result := True;
      end
      else
        Result := Info2.NumVertexes = 0;
  else
    Result := False;
  end;
end;

function TD3DPolygon.CanMergeWithPolygon(p: TD3DPolygon): boolean;
var
  i: integer;
begin
  Result :=
    ((Info2.C = p.Info2.C) or RunTimeOnly) and
    ((Info2.u = p.Info2.u) or RunTimeOnly) and
    ((Info2.v = p.Info2.v) or RunTimeOnly) and
    ((Info2.du = p.Info2.du) or RunTimeOnly) and
    ((Info2.dv = p.Info2.dv) or RunTimeOnly) and
    (Info2.UseFlatUV or RunTimeOnly) and  // ׀סנוי םב קסחףילןנןין‎ם ךבי פב ה‎ן נןכ‎דשםב וננוהח ונבםבכחנפיךפחפב
    (p.Info2.UseFlatUV or RunTimeOnly) and
//    (Info2.NumVertexes = inf.NumVertexes) and
    (Info2.NumVertexes + p.Info2.NumVertexes < fMaxPolygonVertexes - 3) and
    (Info2.NumTextures = p.Info2.NumTextures) and
    ((Info2.zOrder = p.Info2.zOrder) or RunTimeOnly) and
    ((Info2.Interval = p.Info2.Interval) or (Info2.NumTextures < 2)) and
    (Info2.Transparency = p.Info2.Transparency) and
    (Info2.Cull = p.Info2.Cull);
  if Result then
    for i := 0 to Info2.NumTextures - 1 do
    begin
      Result := Result and
        (UpperCase(Info2.TextureNames[i, 0]) = UpperCase(p.Info2.TextureNames[i, 0])) and
        (UpperCase(Info2.TextureNames[i, 1]) = UpperCase(p.Info2.TextureNames[i, 1]));
      if not Result then
        Exit;
    end;
end;

function TD3DPolygon.CanMergeWith(SurfaceType: byte; pInfo: Pointer): boolean;
{ ׃ץדק‏םוץףח נןכץד‏םשם. ׀סנוי ךבי פב ה‎ן םב וםבי D3DPT_TRIANGLELIST ךבי םב
  קןץם נבסלןין Info. }
var
  i: integer;
  cl: TD3DCull;
begin
  Result := False;

  if (flags and flag_GoingToDelete) <> 0 then
    Exit;
  if (flags and flag_NonAcceptMerge) <> 0 then
    Exit;

  if SurfaceType = ID3D_Polygon then
  begin
    Result :=
      ((Info2.C = PD3DPolygonInfo(pInfo).C) or RunTimeOnly) and
      ((Info2.u = PD3DPolygonInfo(pInfo).u) or RunTimeOnly) and
      ((Info2.v = PD3DPolygonInfo(pInfo).v) or RunTimeOnly) and
      ((Info2.du = PD3DPolygonInfo(pInfo).du) or RunTimeOnly) and
      ((Info2.dv = PD3DPolygonInfo(pInfo).dv) or RunTimeOnly) and
      (Info2.UseFlatUV or RunTimeOnly) and  // ׀סנוי םב קסחףילןנןין‎ם ךבי פב ה‎ן נןכ‎דשםב וננוהח ונבםבכחנפיךפחפב
      (PD3DPolygonInfo(pInfo).UseFlatUV or RunTimeOnly) and
//    (Info2.NumVertexes = inf.NumVertexes) and
      (Info2.NumVertexes + PD3DPolygonInfo(pInfo).NumVertexes < fMaxPolygonVertexes - 3) and
      (Info2.NumTextures = PD3DPolygonInfo(pInfo).NumTextures) and
      ((Info2.zOrder = PD3DPolygonInfo(pInfo).zOrder) or RunTimeOnly) and
      ((Info2.Interval = PD3DPolygonInfo(pInfo).Interval) or (Info2.NumTextures < 2)) and
      (Info2.Transparency = PD3DPolygonInfo(pInfo).Transparency) and
      (Info2.Cull = PD3DPolygonInfo(pInfo).Cull);
    if Result then
      for i := 0 to Info2.NumTextures - 1 do
      begin
        Result := Result and
          (UpperCase(Info2.TextureNames[i, 0]) = UpperCase(PD3DPolygonInfo(pInfo).TextureNames[i, 0])) and
          (UpperCase(Info2.TextureNames[i, 1]) = UpperCase(PD3DPolygonInfo(pInfo).TextureNames[i, 1]));
        if not Result then
          Exit;
      end;
  end
{$IFNDEF NO_D3DTRIANGLES}
  else if SurfaceType = ID3D_Triangle then
  begin
    if (PD3DTriangleInfo(pInfo).flags and flg_DoubleSided) <> 0 then
      cl := D3DCULL_NONE
    else if (PD3DTriangleInfo(pInfo).flags and flg_CullCW) <> 0 then
      cl := D3DCULL_CW
    else
      cl := D3DCULL_CCW;
    Result :=
      (UpperCase(PD3DTriangleInfo(pInfo).TextureName) = UpperCase(Info2.TextureNames[0, 0])) and
      (Info2.NumTextures < 2) and
      (Info2.NumVertexes < fMaxPolygonVertexes - 6) and
      (Info2.Cull = cl);
    if not RunTimeOnly then
      Result :=
        Result and
        (PD3DTriangleInfo(pInfo).C = Info2.C) and
        (PD3DTriangleInfo(pInfo).u = Info2.u) and
        (PD3DTriangleInfo(pInfo).v = Info2.v) and
        (PD3DTriangleInfo(pInfo).du = Info2.du) and
        (PD3DTriangleInfo(pInfo).dv = Info2.dv);
  end
{$ENDIF}
  else if SurfaceType = ID3D_GenericTriangle then
  begin
    Result :=
      RunTimeOnly and
      (UpperCase(PD3DGenericTriangleInfo(pInfo).TextureName) = UpperCase(Info2.TextureNames[0, 0])) and
      (Info2.NumVertexes < fMaxPolygonVertexes - 6);
  end
  else if SurfaceType = ID3D_GenericQuadrangle then
  begin
    Result :=
      RunTimeOnly and
      (UpperCase(PD3DGenericQuadrangleInfo(pInfo).TextureName) = UpperCase(Info2.TextureNames[0, 0])) and
      (Info2.NumVertexes < fMaxPolygonVertexes - 9);
  end
  else if SurfaceType = ID3D_Quadrangle then
  begin
    if (PD3DQuadrangleInfo(pInfo).flags and flg_DoubleSided) <> 0 then
      cl := D3DCULL_NONE
    else if (PD3DQuadrangleInfo(pInfo).flags and flg_CullCW) <> 0 then
      cl := D3DCULL_CW
    else
      cl := D3DCULL_CCW;
    Result := (PD3DQuadrangleInfo(pInfo).ddu = 0.0) and (PD3DQuadrangleInfo(pInfo).ddv = 0.0) and
      (UpperCase(PD3DQuadrangleInfo(pInfo).TextureName) = UpperCase(Info2.TextureNames[0, 0])) and
      (Info2.NumTextures < 2) and
      (Info2.NumVertexes < fMaxPolygonVertexes - 9) and
      (Info2.Cull = cl);
    if not RunTimeOnly then
      Result :=
        Result and
        (PD3DQuadrangleInfo(pInfo).C1 = Info2.C) and
        (PD3DQuadrangleInfo(pInfo).C1 = PD3DQuadrangleInfo(pInfo).C2) and
        (PD3DQuadrangleInfo(pInfo).C1 = PD3DQuadrangleInfo(pInfo).C3) and
        (PD3DQuadrangleInfo(pInfo).C1 = PD3DQuadrangleInfo(pInfo).C4) and
        (PD3DQuadrangleInfo(pInfo).u = Info2.u) and
        (PD3DQuadrangleInfo(pInfo).v = Info2.v) and
        (PD3DQuadrangleInfo(pInfo).du = Info2.du) and
        (PD3DQuadrangleInfo(pInfo).dv = Info2.dv);
  end;
end;

function TD3DPolygon.MergeWith(SurfaceType: byte; pInfo: Pointer): boolean;
begin
  if SurfaceType = ID3D_Polygon then
    Result := MergeWithPolygon(PD3DPolygonInfo(pInfo)^)
{$IFNDEF NO_D3DTRIANGLES}
  else if SurfaceType = ID3D_Triangle then
    Result := MergeWithTriangle(PD3DTriangleInfo(pInfo)^)
{$ENDIF}
  else if SurfaceType = ID3D_Quadrangle then
    Result := MergeWithQuadrangle(PD3DQuadrangleInfo(pInfo)^)
  else if SurfaceType = ID3D_GenericTriangle then
    Result := MergeWithGenericTriangle(PD3DGenericTriangleInfo(pInfo)^)
  else if SurfaceType = ID3D_GenericQuadrangle then
    Result := MergeWithGenericQuadrangle(PD3DGenericQuadrangleInfo(pInfo)^)
  else
    Result := False;
end;

function TD3DPolygon.MergeWithGenericTriangle(const inf: TD3DGenericTriangleInfo): boolean;
var
  foldNumVertexes: integer;
  pv: PD3DLVertex;
  pvect: PD3DVector;
  pver: PD3DLVertex;
begin
// H ףץדק‏םוץףח בנביפו פן נןכ‎דשםן םב וםבי TriangleList
  Result := ConvertToTriangleList;
  if not Result then
    Exit;

  Result := (Info2.NumVertexes < fMaxPolygonVertexes - 6);
  if Result then
  begin
    foldNumVertexes := fNumVertexes;
    SizeNumVertexes(fNumVertexes + 3);

{    Info2.Vertexes[foldNumVertexes] := MakeD3DVector(inf.Vertexes[0]);
    Info2.Vertexes[foldNumVertexes + 1] := MakeD3DVector(inf.Vertexes[1]);
    Info2.Vertexes[foldNumVertexes + 2] := MakeD3DVector(inf.Vertexes[2]);

    TheVertexes[foldNumVertexes] := inf.Vertexes[0];
    TheVertexes[foldNumVertexes + 1] := inf.Vertexes[1];
    TheVertexes[foldNumVertexes + 2] := inf.Vertexes[2];}

    pv := @inf.Vertexes[0];
    pvect := @Info2.Vertexes[foldNumVertexes];
    pvect^ := PD3DVector(pV)^; //MakeD3DVector(pv^); // MakeD3DVector(pv.x, pv.y, pv.z);
    pver := @TheVertexes[foldNumVertexes];
    pver^ := pv^;

    inc(pv);
    inc(pvect);
    pvect^ := PD3DVector(pV)^; //MakeD3DVector(pv^); // MakeD3DVector(pv.x, pv.y, pv.z);
    inc(pver);
    pver^ := pv^;

    inc(pv);
    inc(pvect);
    pvect^ := PD3DVector(pV)^; //MakeD3DVector(pv^); // MakeD3DVector(pv.x, pv.y, pv.z);
    inc(pver);
    pver^ := pv^;

    fNeedsRadiusAndCenterRecalc := True;
  end;
end;


function TD3DPolygon.MergeWithGenericQuadrangle(const inf: TD3DGenericQuadrangleInfo): boolean;
var
  foldNumVertexes: integer;
  pv: PD3DLVertex;
  pvect: PD3DVector;
  pver: PD3DLVertex;
begin
// H ףץדק‏םוץףח בנביפו פן נןכ‎דשםן םב וםבי TriangleList
  Result := ConvertToTriangleList;
  if not Result then
    Exit;

  Result := (Info2.NumVertexes < fMaxPolygonVertexes - 9);
  if Result then
  begin
    foldNumVertexes := fNumVertexes;
    SizeNumVertexes(fNumVertexes + 6);

    pv := @inf.Vertexes[0];
    pvect := @Info2.Vertexes[foldNumVertexes];
    pvect^ := MakeD3DVector(pv^); // MakeD3DVector(pv.x, pv.y, pv.z);
    pver := @TheVertexes[foldNumVertexes];
    pver^ := pv^;

    inc(pv);
    inc(pvect);
    pvect^ := PD3DVector(pV)^; //MakeD3DVector(pv^); // MakeD3DVector(pv.x, pv.y, pv.z);
    inc(pver);
    pver^ := pv^;

    inc(pv);
    inc(pvect);
    pvect^ := PD3DVector(pV)^; //MakeD3DVector(pv^); // MakeD3DVector(pv.x, pv.y, pv.z);
    inc(pver);
    pver^ := pv^;

    inc(pvect);
    pvect^ := Info2.Vertexes[foldNumVertexes + 1];
    inc(pver);
    pver^ := inf.Vertexes[1];

    inc(pv);
    inc(pvect);
    pvect^ := PD3DVector(pV)^; //MakeD3DVector(pv^); // MakeD3DVector(pv.x, pv.y, pv.z);
    inc(pver);
    pver^ := pv^;

    inc(pvect);
    pvect^ := Info2.Vertexes[foldNumVertexes + 2];
    inc(pver);
    pver^ := inf.Vertexes[2];

    fNeedsRadiusAndCenterRecalc := True;
  end;
end;

{
function TD3DPolygon.MergeWithGenericQuadrangle(const inf: TD3DGenericQuadrangleInfo): boolean;
var foldNumVertexes: integer;
begin
// H s?????e?s? apa?te? t? p??????? ?a e??a? TriangleList
  Result := ConvertToTriangleList;
  if not Result then Exit;

  Result := (Info2.NumVertexes < MAXVERTEXES - 100);
  if Result then
  begin
    foldNumVertexes := fNumVertexes;
    SizeNumVertexes(fNumVertexes + 6);

    Info2.Vertexes[foldNumVertexes] := MakeD3DVector(
                                        inf.Vertexes[0].x,
                                        inf.Vertexes[0].y,
                                        inf.Vertexes[0].z);
    TheVertexes[foldNumVertexes] := inf.Vertexes[0];

    Info2.Vertexes[foldNumVertexes + 1] := MakeD3DVector(
                                            inf.Vertexes[1].x,
                                            inf.Vertexes[1].y,
                                            inf.Vertexes[1].z);
    TheVertexes[foldNumVertexes + 1] := inf.Vertexes[1];

    Info2.Vertexes[foldNumVertexes + 2] := MakeD3DVector(
                                            inf.Vertexes[2].x,
                                            inf.Vertexes[2].y,
                                            inf.Vertexes[2].z);
    TheVertexes[foldNumVertexes + 2] := inf.Vertexes[2];

    Info2.Vertexes[foldNumVertexes + 3] := Info2.Vertexes[foldNumVertexes + 1];
    TheVertexes[foldNumVertexes + 3] := inf.Vertexes[1];

    Info2.Vertexes[foldNumVertexes + 4] := MakeD3DVector(
                                            inf.Vertexes[3].x,
                                            inf.Vertexes[3].y,
                                            inf.Vertexes[3].z);
    TheVertexes[foldNumVertexes + 4] := inf.Vertexes[3];

    Info2.Vertexes[foldNumVertexes + 5] := Info2.Vertexes[foldNumVertexes + 2];
    TheVertexes[foldNumVertexes + 5] := inf.Vertexes[2];

  end;
end;
}

function TD3DPolygon.MergeWithPolygon(const inf: TD3DPolygonInfo): boolean;
var
  p: TD3DPolygon;
//  i: integer;
  oldVertexCount: integer;
// װן נןכ‎דשםן ףץדקשםו‎ופבי לו פן נןכ‎דשםן לו יהיפחפוע inf
begin
// ֱם ח ךכףח פחע CanMergeWith() לו נבסלופסן info וניףפסצוי False, פפו הום וםבי
// הץםבפ ח בםךפחףח כחע פחע נכחסןצןסבע, לםן דיב runtime operations
// H ףץדק‏םוץףח בנביפו פן נןכ‎דשםן םב וםבי TriangleList
  Result := ConvertToTriangleList;
  if not Result then
    Exit;

  p := TD3DPolygon.Create(DXDraw, Textures, inf);
  try
    Result := p.ConvertToTriangleList;
    if Result then
    begin
      // ַ ףץדק‏םוץףח בנביפו נןכ‎דשםן לו בסיטל Vertexes < MAXVERTEXES,
      // היבצןסופיך ח DrawPrimitive בנןפץדקםוי
      // ֱככבד 20/10/05: fMaxPolygonVertexes - 3
      Result := Info2.NumVertexes + inf.NumVertexes < fMaxPolygonVertexes - 3;
      if Result then
      begin
        oldVertexCount := fNumVertexes;
        SizeNumVertexes(fNumVertexes + p.fNumVertexes);

        System.Move(p.Info2.Vertexes[0], Info2.Vertexes[oldVertexCount], p.fNumVertexes * SizeOf(TD3DVector));
        System.Move(p.TheVertexes[0], TheVertexes[oldVertexCount], p.fNumVertexes * SizeOf(TD3DLVertex));
{      for i := 0 to p.fNumVertexes - 1 do
      begin
        Info2.Vertexes[oldVertexCount + i] := p.Info2.Vertexes[i];
        TheVertexes[oldVertexCount + i] := p.TheVertexes[i];
      end;}

        fNeedsRadiusAndCenterRecalc := True;
      end;

    end;
  finally
    p.Free;
  end;
end;

function TD3DPolygon.MergeWithPolygon(const poly: TD3DPolygon): boolean;
var
  oldVertexCount: integer;
begin
  if not RunTimeOnly then
  begin
    Result := False;
    Exit;
  end;

  Result := (Info2.NumVertexes + poly.Info2.NumVertexes < fMaxPolygonVertexes - 3) and
            (Info2.NumTextures = poly.Info2.NumTextures) and
            ((Info2.Interval = poly.Info2.Interval) or (Info2.NumTextures < 2)) and
            (Info2.Transparency = poly.Info2.Transparency) and
            (Info2.Cull = poly.Info2.Cull);

  if not Result then
    Exit;

  Result := ConvertToTriangleList;
  if not Result then
    Exit;

  Result := poly.ConvertToTriangleList;

  if Result then
  begin
    // ַ ףץדק‏םוץףח בנביפו נןכ‎דשםן לו בסיטל Vertexes < MAXVERTEXES,
    // היבצןסופיך ח DrawPrimitive בנןפץדקםוי
    // ֱככבד 20/10/05: fMaxPolygonVertexes - 3
    Result := Info2.NumVertexes + poly.info2.NumVertexes < fMaxPolygonVertexes - 3;
    if Result then
    begin
      oldVertexCount := fNumVertexes;
      SizeNumVertexes(fNumVertexes + poly.fNumVertexes);

      System.Move(poly.Info2.Vertexes[0], Info2.Vertexes[oldVertexCount], poly.fNumVertexes * SizeOf(TD3DVector));
      System.Move(poly.TheVertexes[0], TheVertexes[oldVertexCount], poly.fNumVertexes * SizeOf(TD3DLVertex));

      fNeedsRadiusAndCenterRecalc := True;
    end;
  end;
end;

{$IFNDEF NO_D3DTRIANGLES}
function TD3DPolygon.MergeWithTriangle(const inf: TD3DTriangleInfo): boolean;
var
  p: TD3DSTriangle;
// װן נןכ‎דשםן ףץדקשםו‎ופבי לו פן פסדשםן לו יהיפחפוע inf
begin
// ֱם ח ךכףח פחע CanMergeWith() לו נבסלופסן info וניףפסצוי False, פפו הום וםבי
// הץםבפ ח בםךפחףח כחע פחע נכחסןצןסבע, לםן דיב runtime operations
// H ףץדק‏םוץףח בנביפו פן נןכ‎דשםן םב וםבי TriangleList
  Result := ConvertToTriangleList;
  if not Result then
    Exit;

  p := TD3DSTriangle.Create(DXDraw, Textures[0, 0], inf);
  try
    Result := (Info2.NumVertexes < fMaxPolygonVertexes - 6);
    if Result then
    begin
      SizeNumVertexes(fNumVertexes + 3);

      Info2.Vertexes[fNumVertexes - 3] := MakeD3DVector(p.Info.x1, p.Info.y1, p.Info.z1);
      TheVertexes[fNumVertexes - 3] := p.Vertexes[0];

      Info2.Vertexes[fNumVertexes - 2] := MakeD3DVector(p.Info.x2, p.Info.y2, p.Info.z2);
      TheVertexes[fNumVertexes - 2] := p.Vertexes[1];

      Info2.Vertexes[fNumVertexes - 1] := MakeD3DVector(p.Info.x3, p.Info.y3, p.Info.z3);
      TheVertexes[fNumVertexes - 1] := p.Vertexes[2];

      fNeedsRadiusAndCenterRecalc := True;

{      ReAllocMem(Info2.Vertexes, SizeOf(TD3DVector) * (fNumVertexes + 3));
      ReAllocMem(TheVertexes, SizeOf(TD3DLVertex) * (fNumVertexes + 3));

      Info2.Vertexes[fNumVertexes] := MakeD3DVector(p.Info.x1, p.Info.y1, p.Info.z1);
      TheVertexes[fNumVertexes] := p.Vertexes[0];

      Info2.Vertexes[fNumVertexes + 1] := MakeD3DVector(p.Info.x2, p.Info.y2, p.Info.z2);
      TheVertexes[fNumVertexes + 1] := p.Vertexes[1];

      Info2.Vertexes[fNumVertexes + 2] := MakeD3DVector(p.Info.x3, p.Info.y3, p.Info.z3);
      TheVertexes[fNumVertexes + 2] := p.Vertexes[2];

      inc(fNumVertexes, 3);
      Info2.NumVertexes := fNumVertexes;}
    end;
  finally
    p.Free;
  end;
end;
{$ENDIF}

function TD3DPolygon.MergeWithQuadrangle(const inf: TD3DQuadrangleInfo): boolean;
var
  p: TD3DQuadrangle;
  i: integer;
// װן נןכ‎דשםן ףץדקשםו‎ופבי לו פן פופסדשםן לו יהיפחפוע inf
begin
// ֱם ח ךכףח פחע CanMergeWith() לו נבסלופסן info וניףפסצוי False, פפו הום וםבי
// הץםבפ ח בםךפחףח כחע פחע נכחסןצןסבע, לםן דיב runtime operations
// H ףץדק‏םוץףח בנביפו פן נןכ‎דשםן םב וםבי TriangleList
  Result := ConvertToTriangleList;
  if not Result then
    Exit;

  p := TD3DQuadrangle.Create(DXDraw, Textures[0, 0], inf);
  try
    Result := (Info2.NumVertexes < fMaxPolygonVertexes - 9);
    if Result then
    begin
      i := fNumVertexes;
      SizeNumVertexes(fNumVertexes + 6);

      // The first 3 vectors/vertexes are in order,
      // we use System.Move for fast copy
      System.Move(p.Info.x1, Info2.Vertexes[i], 3 * SizeOf(TD3DVector));
      System.Move(p.Vertexes[0], TheVertexes[i], 3 * SizeOf(TD3DLVertex));

//      Info2.Vertexes[fNumVertexes - 6] := MakeD3DVector(p.Info.x1, p.Info.y1, p.Info.z1);
//      TheVertexes[fNumVertexes - 6] := p.Vertexes[0];

//      Info2.Vertexes[fNumVertexes - 5] := MakeD3DVector(p.Info.x2, p.Info.y2, p.Info.z2);
//      TheVertexes[fNumVertexes - 5] := p.Vertexes[1];

//      Info2.Vertexes[fNumVertexes - 4] := MakeD3DVector(p.Info.x3, p.Info.y3, p.Info.z3);
//      TheVertexes[fNumVertexes - 4] := p.Vertexes[2];

      inc(i, 3);
      Info2.Vertexes[i] := Info2.Vertexes[fNumVertexes - 5];
      TheVertexes[i] := p.Vertexes[1];

      inc(i);
      Info2.Vertexes[i] := MakeD3DVector(p.Info.x4, p.Info.y4, p.Info.z4);
      TheVertexes[i] := p.Vertexes[3];

      inc(i);
      Info2.Vertexes[i] := Info2.Vertexes[fNumVertexes - 4];
      TheVertexes[i] := p.Vertexes[2];

      fNeedsRadiusAndCenterRecalc := True;

{      ReAllocMem(Info2.Vertexes, SizeOf(TD3DVector) * (fNumVertexes + 6));
      ReAllocMem(TheVertexes, SizeOf(TD3DLVertex) * (fNumVertexes + 6));

      Info2.Vertexes[fNumVertexes] := MakeD3DVector(p.Info.x1, p.Info.y1, p.Info.z1);
      TheVertexes[fNumVertexes] := p.Vertexes[0];

      Info2.Vertexes[fNumVertexes + 1] := MakeD3DVector(p.Info.x2, p.Info.y2, p.Info.z2);
      TheVertexes[fNumVertexes + 1] := p.Vertexes[1];

      Info2.Vertexes[fNumVertexes + 2] := MakeD3DVector(p.Info.x3, p.Info.y3, p.Info.z3);
      TheVertexes[fNumVertexes + 2] := p.Vertexes[2];

      Info2.Vertexes[fNumVertexes + 3] := Info2.Vertexes[fNumVertexes + 1];
      TheVertexes[fNumVertexes + 3] := p.Vertexes[1];

      Info2.Vertexes[fNumVertexes + 4] := MakeD3DVector(p.Info.x4, p.Info.y4, p.Info.z4);
      TheVertexes[fNumVertexes + 4] := p.Vertexes[3];

      Info2.Vertexes[fNumVertexes + 5] := Info2.Vertexes[fNumVertexes + 2];
      TheVertexes[fNumVertexes + 5] := p.Vertexes[2];

      inc(fNumVertexes, 6);
      Info2.NumVertexes := fNumVertexes;}
    end;
  finally
    p.Free;
  end;
end;

function TD3DPolygon.IsIdentical(D3DSurface: TObject): boolean;
var
  inf: TD3DPolygonInfo;
  i: integer;
begin
  Result := False;
  if not Inherited IsIdentical(D3DSurface) then
    Exit;
  if D3DSurface is TD3DPolygon then
  begin
    (D3DSurface as TD3DPolygon).GetInfo(@inf);
    Result :=
      (Info2.key = inf.Key) and
      (Info2.C = inf.C) and
      (Info2.u = inf.u) and
      (Info2.v = inf.v) and
      (Info2.du = inf.du) and
      (Info2.dv = inf.dv) and
      (Info2.UseFlatUV = inf.UseFlatUV) and
      (Info2.NumVertexes = inf.NumVertexes) and
      (Info2.NumTextures = inf.NumTextures) and
      (Info2.zOrder = inf.zOrder) and
      (Info2.Interval = inf.Interval) and
      (Info2.PrimitiveType = inf.PrimitiveType) and
      (Info2.Transparency = inf.Transparency) and
      (Info2.Cull = inf.Cull) and
      TextureNamesEqual(inf.TextureNames, Info2.TextureNames, Info2.NumTextures);
    if Result then
    begin
      for i := 0 to Info2.NumVertexes - 1 do
      begin
        Result := VectorEquel(Info2.Vertexes[i], inf.Vertexes[i]);
        if not Result then
          break;
      end;
    end;
  end;
end;

function TD3DPolygon.GetTypeID: byte;
begin
  Result := ID3D_Polygon;
end;

function TD3DPolygon.GetKeyID: integer;
begin
  Result := Info2.Key;
end;

{$IFNDEF NO_DXMESHES}
procedure TD3DPolygon.AdjustMeshData;
begin
  Inherited AdjustMeshData;
  fMesh.Cull := @Info2.Cull;
  fMesh.PrimitiveType := @Info2.PrimitiveType;
  fMesh.NumVertexes := @fNumVertexes;
  fMesh.Vertexes := @TheVertexes;
end;
{$ENDIF}

procedure TD3DPolygon.SaveToStream(s: TStream);
var
  i: integer;
begin
  Inherited SaveToStream(s);
  with Info2 do
  begin
    s.Write(RunTimeOnly, SizeOf(RunTimeOnly));
    s.Write(key, SizeOf(key));
    s.Write(C, SizeOf(C));
    s.Write(u, SizeOf(u));
    s.Write(v, SizeOf(v));
    s.Write(du, SizeOf(du));
    s.Write(dv, SizeOf(dv));
    s.Write(UseFlatUV, SizeOf(UseFlatUV));
    s.Write(zOrder, SizeOf(zOrder));
    s.Write(NumVertexes, SizeOf(NumVertexes));
    s.Write(NumTextures, SizeOf(NumTextures));
    s.Write(Interval, SizeOf(Interval));
    s.Write(PrimitiveType, SizeOf(PrimitiveType));
    s.Write(Transparency, SizeOf(Transparency));
    s.Write(Cull, SizeOf(Cull));
    if RunTimeOnly then
      for i := 0 to NumVertexes - 1 do
        s.Write(TheVertexes[i], SizeOf(TheVertexes[i]))
    else
      for i := 0 to NumVertexes - 1 do
        s.Write(Vertexes[i], SizeOf(Vertexes[i]));
  end;
end;

{$IFNDEF NO_OLDSTREAMINGRUTINES}
procedure TD3DPolygon.OldLoadFromStream(s: TStream; version: integer);
var
  i: integer;
  si: ShortInt;
  intd: double;
begin
  with Info2 do
  begin
    s.Read(key, SizeOf(key));
    s.Read(C, SizeOf(C));
    s.Read(u, SizeOf(u));
    s.Read(v, SizeOf(v));
    if version >= FILEVERSION_100 then
    begin
      s.Read(du, SizeOf(du));
      s.Read(dv, SizeOf(dv));
      s.Read(UseFlatUV, SizeOf(UseFlatUV));
    end
    else
    begin
      du := 0.0;
      dv := 0.0;
      UseFlatUV := False;
    end;
    s.Read(zOrder, SizeOf(zOrder));
    if version >= FILEVERSION_100 then
    begin
      s.Read(NumVertexes, SizeOf(NumVertexes));
      s.Read(NumTextures, SizeOf(NumTextures));
    end
    else
    begin
      s.Read(si, SizeOf(si));
      NumVertexes := si;
      s.Read(si, SizeOf(si));
      NumTextures := si;
    end;
    if version >= FILEVERSION_100 then
      s.Read(Interval, SizeOf(Interval))
    else
    begin
      s.Read(intd, SizeOf(intd));
      Interval := intd;
    end;
    s.Read(PrimitiveType, SizeOf(PrimitiveType));
    s.Read(Transparency, SizeOf(Transparency));
    s.Read(Cull, SizeOf(Cull));
    SizeNumVertexes(Info2.NumVertexes);
    for i := 0 to NumVertexes - 1 do
      s.Read(Vertexes[i], SizeOf(Vertexes[i]));
    CreateVertexes;
  end;
end;
{$ENDIF}

procedure TD3DPolygon.LoadFromStream(s: TStream; version: integer);
var
  i: integer;
begin
  Inherited LoadFromStream(s, version);
{$IFNDEF NO_OLDSTREAMINGRUTINES}
  if version < FILEVERSION_107 then
    OldLoadFromStream(s, version)
  else {$ENDIF} with Info2 do
  begin
    if version >= FILEVERSION_108 then
      s.Read(RunTimeOnly, SizeOf(RunTimeOnly));
    LoadedRunTime := RunTimeOnly;
    s.Read(key, SizeOf(key));
    s.Read(C, SizeOf(C));
    s.Read(u, SizeOf(u));
    s.Read(v, SizeOf(v));
    s.Read(du, SizeOf(du));
    s.Read(dv, SizeOf(dv));
    s.Read(UseFlatUV, SizeOf(UseFlatUV));
    s.Read(zOrder, SizeOf(zOrder));
    s.Read(NumVertexes, SizeOf(NumVertexes));
    s.Read(NumTextures, SizeOf(NumTextures));
    s.Read(Interval, SizeOf(Interval));
    s.Read(PrimitiveType, SizeOf(PrimitiveType));
    s.Read(Transparency, SizeOf(Transparency));
    s.Read(Cull, SizeOf(Cull));
    SizeNumVertexes(Info2.NumVertexes);
    if RunTimeOnly then
    begin
      for i := 0 to NumVertexes - 1 do
      begin
        s.Read(TheVertexes[i], SizeOf(TheVertexes[i]));
        Vertexes[i].x := TheVertexes[i].x;
        Vertexes[i].y := TheVertexes[i].y;
        Vertexes[i].z := TheVertexes[i].z;
      end
    end
    else
    begin
      for i := 0 to NumVertexes - 1 do
        s.Read(Vertexes[i], SizeOf(Vertexes[i]));
      CreateVertexes;
    end;
  end;
end;

function TD3DPolygon.CurTextureName: string;
begin
  Result := Info2.TextureNames[CurTextureIndex, 0];
end;

function TD3DPolygon.CurTextureIndex: integer;
begin
  if (Info2.Interval = 0) or (Info2.NumTextures = 0) then
    Result := 0
  else
    Result := trunc(fTime * Info2.NumTextures / Info2.Interval) mod Info2.NumTextures;
end;

function TD3DPolygon.CalcDistance(const Position: TD3DVector): TD3DValue; register;
var
  nv: integer;
begin
  nv := Info2.NumVertexes;
  if Info2.zOrder > 50000 then // ֿץסבםע, פבגםי, נפשלב
    Distance := Info2.zOrder
  else if nv = 0 then
    Distance := 0
  else
  begin
    case Info2.PrimitiveType of
      D3DPT_TRIANGLELIST,
      D3DPT_TRIANGLESTRIP:
        begin
          Distance := VectorMagnitude(
              MakeD3DVector(
               (Info2.Vertexes[0].x +
                Info2.Vertexes[nv div 2].x +
                Info2.Vertexes[nv - 1].x)/3 - Position.x,
               (Info2.Vertexes[0].y +
                Info2.Vertexes[nv div 2].y +
                Info2.Vertexes[nv - 1].y)/3 - Position.y,
               (Info2.Vertexes[0].z +
                Info2.Vertexes[nv div 2].z +
                Info2.Vertexes[nv - 1].z)/3 - Position.z));
        end;
      D3DPT_TRIANGLEFAN:
        Distance := VectorMagnitude(VectorSub(Info2.Vertexes[0], Position));
    else
      Distance := 0;
    end
  end;
  Result := Distance;
end;

function TD3DPolygon.TextureName: string;
begin
  Result := Info2.TextureNames[0, 0];
end;

procedure TD3DPolygon.GetInfo(p: Pointer);
begin
  Info2ToInfo(PD3DPolygonInfo(p)^);
end;

function TD3DPolygon.GetLocatePosition(aDistance: TD3DValue): TD3DVector;
begin
  if Info2.NumVertexes > 0 then
    with Info2.Vertexes[0] do
      Result := MakeD3DVector(x, y, z - aDistance)
  else
    Result := NULLVECTOR;
end;

procedure TD3DPolygon.ApplyLight(l: TD3DSceneLight);
var
  i: integer;
  C: TColor;
begin
  if RunTimeOnly then
  begin
    if l.IsAppliable(GetLocatePosition(0.0)) then
      for i := 0 to Info2.NumVertexes - 1 do
        l.ApplyToVertex(TheVertexes[i], TheVertexes[i].color shr 8)
  end
  else
  begin
    if l.IsAppliable(GetLocatePosition(0.0)) then
    begin
      C := Info2.C;
      for i := 0 to Info2.NumVertexes - 1 do
        l.ApplyToVertex(TheVertexes[i], C);
    end;
  end;
end;

// ֱסיטלע Vertexes פןץ בםפיךוילםןץ
function TD3DPolygon.GetNumVertexes: integer;
begin
  if (Info2.Transparency < MAXTRANSPARENCYREPLICATION) and (Info2.Transparency > 0) then
    Result := Info2.NumVertexes * Info2.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := Info2.NumVertexes * 2
  else
    Result := Info2.NumVertexes;
end;

// ֱסיטלע װסיד‏םשם פןץ בםפיךוילםןץ
function TD3DPolygon.GetNumTriangles: integer;
begin
  case Info2.PrimitiveType of
    D3DPT_TRIANGLELIST: Result := Info2.NumVertexes div 3;
    D3DPT_TRIANGLESTRIP,
    D3DPT_TRIANGLEFAN: Result := Max(Info2.NumVertexes - 2, 0);
  else
    begin
      Result := 0;
      Exit;
    end;
  end;
  if (Info2.Transparency > 0) and (Info2.Transparency < MAXTRANSPARENCYREPLICATION) then
    Result := Result * Info2.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := Result * 2
end;

{$IFNDEF NO_D3DPROCEDURALOBJECTS}
// *** TD3DProceduralObject *** //
constructor TD3DProceduralObject.Create(aScene: TD3DScene; aTextures: TDirect3DTextures2; const aInfo: TD3DProceduralObjectInfo);
// ׳סחףילןנןין‎לו פן 'const' ףפחם נבסלופסן aInfo: TD3DProceduralObjectInfo דיבפ הוףלוץוי נןכ‎ לםלח
// ףפןגבע. ּו פן const הום הוףלו‎וי לםלח ףפןגבע
// 16/10/2005 - בכ, נפו סקיםב םב פן דסצש בץפ ן נסדסבללב ךבי בףקןכן‎לןץםב לו ףקכיב ףב פן נבסבנםש???
begin
  if Info.ModuleName <> '' then
    fProc := GetProcAddress(HInstance, PChar(Info.ModuleName))
  else
    fProc := nil;
  fScene := aScene;
  Info := aInfo;
  fNumVertexes := 0;
  fNumSpherePoints := 0;
  flatUVParam := '׳ֶ';
  SpherePointsComplexity := 15;
  StartVertexIndex;
  StartSpherePointIndex;
  Textures := aTextures;
  Inherited Create(fScene.DXDraw, aTextures[0, 0]);
end;

constructor TD3DProceduralObject.CreateFromStream(s: TStream; aScene: TD3DScene; aTextures: TDirect3DTextures2; version: integer);
begin
  fProc := nil;
  fScene := aScene;
  fNumVertexes := 0;
  fNumSpherePoints := 0;
  flatUVParam := '׳ֶ';
  SpherePointsComplexity := 15;
  StartVertexIndex;
  StartSpherePointIndex;
  LoadFromStream(s, version);
  Textures := aTextures;
  Inherited Create(fScene.DXDraw, aTextures[0, 0]);
end;

procedure TD3DProceduralObject.StartVertexIndex(index: integer = 0);
begin
  VertexIndex := index;
end;

procedure TD3DProceduralObject.StopVertexIndex;
begin
  VertexIndex := 0;
end;

procedure TD3DProceduralObject.StartSpherePointIndex(index: integer = 0);
begin
  SpherePointIndex := index;
end;

procedure TD3DProceduralObject.ScaleX(fx: TD3DValue);
var
  i: integer;
begin
  if fx <> 1 then
  begin
    if Info.x = 0 then
      for i := 0 to fNumVertexes - 1 do
        TheVertexes[i].x := TheVertexes[i].x * fx
    else
      for i := 0 to fNumVertexes - 1 do
        TheVertexes[i].x := (TheVertexes[i].x - Info.x) * fx + Info.x;
  end;
end;

procedure TD3DProceduralObject.ScaleY(fy: TD3DValue);
var
  i: integer;
begin
  if fy <> 1 then
  begin
    if Info.y = 0 then
      for i := 0 to fNumVertexes - 1 do
        TheVertexes[i].y := TheVertexes[i].y * fy
    else
      for i := 0 to fNumVertexes - 1 do
        TheVertexes[i].y := (TheVertexes[i].y - Info.y) * fy + Info.y;
  end;
end;

procedure TD3DProceduralObject.ScaleZ(fz: TD3DValue);
var
  i: integer;
begin
  if fz <> 1 then
  begin
    if Info.z = 0 then
      for i := 0 to fNumVertexes - 1 do
        TheVertexes[i].z := TheVertexes[i].z * fz
    else
      for i := 0 to fNumVertexes - 1 do
        TheVertexes[i].z := (TheVertexes[i].z - Info.z) * fz + Info.z;
  end;
end;

procedure TD3DProceduralObject.Scale(fV: TD3DVector);
begin
  Scale(fV.x, fV.y, fv.z);
end;

procedure TD3DProceduralObject.Scale(fx, fy, fz: TD3DValue);
begin
  ScaleX(fx);
  ScaleY(fy);
  ScaleZ(fz);
end;

procedure TD3DProceduralObject.StopSpherePointIndex;
var
  i, ring, seg: integer;
  fDeltaSegAngle: double;
  ss, sc,
  r0, r1,
  x0, x1,
  y0, y1,
  z0, z1: extended;
  NumRings, NumSegments: integer;
  u, v: double;
begin
  SpherePointIndex := 0;
  if fNumSpherePoints < 2 then
    Exit;

  NumRings := fNumSpherePoints - 1;

  if 2 * NumRings * (SpherePointsComplexity + 1) > $FFFA then
    SpherePointsComplexity := trunc($FFFA / 2 / NumRings) - 1;

  NumSegments := SpherePointsComplexity;

  Info.PrimitiveType := D3DPT_TRIANGLESTRIP;

  u := 0.0;
  for i := 0 to NumRings do
    if abs(SpherePoints[i].x) > u then
      u := abs(SpherePoints[i].x);

  if u > 0 then
    u := 1 / u / 2;
  v := u;

  SizeNumVertexes(2 * NumRings * (NumSegments + 1));

  fDeltaSegAngle  := g_2_PI / NumSegments;

  i := 0;

  for ring := 0 to NumRings - 1 do
  begin
    y0 := SpherePoints[ring].y;
    y1 := SpherePoints[ring + 1].y;
    r0 := SpherePoints[ring].x;
    r1 := SpherePoints[ring + 1].x;

// Generate the group of segments for the current ring
    for seg := 0 to NumSegments do
    begin
      SinCos(seg * fDeltaSegAngle, ss, sc);
      x0 := r0 * ss;
      z0 := r0 * sc;
      x1 := r1 * ss;
      z1 := r1 * sc;
{      x0 := r0 * test1[seg * 2];
      z0 := r0 * test1[(seg * 2 + 1) mod 40];
      x1 := r1 * test1[seg * 2];
      z1 := r1 * test1[(seg * 2 + 1) mod 40];}

      TheVertexes[i] := MakeD3DLVERTEX(
        x0 , y0, z0,
          $FFFFFF, 0,
            x0 * u + 0.5, z0 * v + 0.5);
      inc(i);

      TheVertexes[i] := MakeD3DLVERTEX(
        x1, y1, z1,
          $FFFFFF, 0,
            x1 * u + 0.5, z1 * v + 0.5);
      inc(i);
    end;
  end;
  flatUVParam := UpperCase(flatUVParam);
  if (pos('X', flatUVParam) = 2) then
    for i := 0 to fNumVertexes - 1 do
      TheVertexes[i].tv := TheVertexes[i].x * v + 0.5;
  if (pos('Y', flatUVParam) = 1) then
    for i := 0 to fNumVertexes - 1 do
      TheVertexes[i].tu := TheVertexes[i].y * u + 0.5;
  if (pos('Y', flatUVParam) = 2) then
    for i := 0 to fNumVertexes - 1 do
      TheVertexes[i].tv := TheVertexes[i].y * v + 0.5;
  if (pos('Z', flatUVParam) = 1) then
    for i := 0 to fNumVertexes - 1 do
      TheVertexes[i].tu := TheVertexes[i].z * u + 0.5;
end;

procedure TD3DProceduralObject.AddVertex(v: TD3DLVertex);
begin
  if VertexIndex < fNumVertexes then
  begin
    TheVertexes[VertexIndex] := v;
    inc(VertexIndex);
  end;
end;

destructor TD3DProceduralObject.Destroy;
begin
  SizeNumVertexes(0);
  SizeNumSpherePoints(0);
  Inherited;
end;

function TD3DProceduralObject.DefaultRTLQuery: boolean;
begin
  Result := Inherited DefaultRTLQuery;
end;

procedure TD3DProceduralObject.AddSpherePoint(v: T2DVector);
begin
  if SpherePointIndex < fNumSpherePoints then
  begin
    SpherePoints[SpherePointIndex] := v;
    inc(SpherePointIndex);
  end;
end;

procedure TD3DProceduralObject.SizeNumSpherePoints(NewSize: integer);
begin
  if fNumSpherePoints <> NewSize then
  begin
    if fNumSpherePoints <> 0 then
      FreeMem(SpherePoints, SizeOf(T2DVector) * fNumSpherePoints);
    fNumSpherePoints := NewSize;
    if NewSize <> 0 then
      GetMem(SpherePoints, SizeOf(T2DVector) * fNumSpherePoints);
  end;
end;

procedure TD3DProceduralObject.SizeNumVertexes(const NewSize: integer);
begin
  if fNumVertexes <> NewSize then
  begin
    if fNumVertexes <> 0 then
      FreeMem(TheVertexes, SizeOf(TD3DLVertex) * fNumVertexes);
    fNumVertexes := NewSize;
    if NewSize <> 0 then
      GetMem(TheVertexes, SizeOf(TD3DLVertex) * fNumVertexes);
  end;
end;

procedure TD3DProceduralObject.Execute;
begin
  if Assigned(fScene) then
  begin
    fScene.CurrentProceduralObject := self;
    if Assigned(fProc) then
      fProc
{$IFNDEF NO_SCRIPTS}
    else
      fScene.RunProcedure(Info.ModuleName, True){$ENDIF};
    fScene.CurrentProceduralObject := nil;
    Rotate(Info.dx, Info.dy, Info.dz);
    Move(Info.x, Info.y, Info.z);
  end;
end;

procedure TD3DProceduralObject.fCalcCenterAndRadius;
begin
  CalcCenterAndRadius(TheVertexes, fNumVertexes, fRadius, fCenter);
end;

procedure TD3DProceduralObject.InitParams;
var
  canv: TCanvas;
begin
  with Info do
  begin
    if Texture[0] = nil then
    begin
      Graphic.Bitmap.Width := 2;
      Graphic.Bitmap.Height := 2;
      Graphic.Bitmap.PixelFormat := pf24bit;
      canv := Graphic.Bitmap.Canvas;
      canv.Pixels[0, 0] := clWhite;
      canv.Pixels[1, 0] := clWhite;
      canv.Pixels[0, 1] := clWhite;
      canv.Pixels[1, 1] := clWhite;
      Texture[0] := TDirect3DTexture2.Create(DXDraw, Graphic, False);
    end
    else
    begin
      Graphic.Bitmap.Width := 0;
      Graphic.Bitmap.Height := 0;
    end;
    if not (PrimitiveType in [D3DPT_TRIANGLELIST, D3DPT_TRIANGLESTRIP, D3DPT_TRIANGLEFAN]) then
      PrimitiveType := D3DPT_TRIANGLESTRIP;
  end
end;

{$IFDEF DESIGNER}
function TD3DProceduralObject.CanSaveVertexes: boolean;
begin
  Result := True;
end;

procedure TD3DProceduralObject.SaveVertexes(fName: string);
var
  f: TFileStream;
begin
  f := TFileStream.Create(fName, fmCreate or fmShareDenyWrite);
  try
    f.Write(Info.Cull, SizeOf(Info.Cull));
    f.Write(Info.PrimitiveType, SizeOf(Info.PrimitiveType));
    f.Write(TheVertexes^, fNumVertexes * SizeOf(TD3DLVertex));
  finally
    f.Free;
  end;
end;

function TD3DProceduralObject.RTL_CanBeRuntime: boolean;
begin
  Result := False;
end;

procedure TD3DProceduralObject.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull);
begin
  DeclareSession := '';
  InitSession := '';
  DrawSession := '';
  DoneSession := '';
end;
{$ENDIF}

procedure TD3DProceduralObject.Draw;
var
  i, CurIndex: integer;
  dev: IDirect3DDevice7;
begin
  dev := DXDraw.D3DDevice7;
  dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(Info.Cull));
  if (Info.Transparency <> 0) and (Graphic.Bitmap.Width = 0) then with info do
  begin
    CurIndex := CurTextureIndex;
    if Transparency < MAXTRANSPARENCYREPLICATION then
    begin
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
      dev.SetTexture( 0, Textures[CurTextureIndex, 0].Surface.IDDSurface7);
      dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
      dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
    // ֲכיק, לנןסו םב קסויבףפו םב ךבכףןץלו פחם DrawPrimitive נןככע צןסע
    // בככ נסםןץלו םב חליהיבצבםע Texture.
      for i := 1 to Transparency do
        dev.DrawPrimitive(PrimitiveType, D3DDXFVF_VERTEX, TheVertexes[0], fNumVertexes, 0);
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
    end
    else
    begin
    // ױנסקוי לףךב, פחם קסחףילןנןין‎לו.
    // ¼פבם הום ץנסקוי לףךב ףפן Textures[CurIndex, 1] ץנסקוי ן הוךפחע
    // פןץ Textures[CurIndex, 0] (ךןפב ::AddTexturesToCollection
      if Textures[CurIndex, 1] <> Textures[CurIndex, 0] then
      begin
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
        // ׃קוהיזןץלו פחם לףךב...
        dev.SetTexture( 0, Textures[CurTextureIndex, 1].Surface.IDDSurface7);
        dev.DrawPrimitive(PrimitiveType, D3DDXFVF_VERTEX, TheVertexes[0], fNumVertexes, 0);
        // ...ךבי פחם נופלו בנ נםש פחם ויךםב
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVDESTCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetTexture( 0, Textures[CurTextureIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(PrimitiveType, D3DDXFVF_VERTEX, TheVertexes[0], fNumVertexes, 0);
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
      end
      else // ִום ץנסקוי לףךב
      begin
{   // The following gives a very good transparent effect!
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_SRCBLEND, ord(D3DBLEND_SRCCOLOR));
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_DESTBLEND, ord(D3DBLEND_ONE));
}
      // Disable D3DRENDERSTATE_ALPHABLENDENABLE before setting transparent color
      // ************
      // ֳיב םב יףק‎וי ףו 8bpp ויךםוע, נסנוי ח נבכפב פןץע םב קוי פב קס‏לבפב פשם Windows!! (?)
      // ************
        Textures[CurIndex, 0].Surface.TransparentColor := 0;
        dev.SetTexture(0, Textures[CurIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(PrimitiveType, D3DDXFVF_VERTEX, TheVertexes[0], fNumVertexes, 0);

      end;
    end;
    dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
  end
  else with Info do
  begin
    dev.SetTexture( 0, Texture[0].Surface.IDDSurface7);
    dev.DrawPrimitive(PrimitiveType, D3DDXFVF_VERTEX, TheVertexes[0], fNumVertexes, 0);
  end;
end;

procedure TD3DProceduralObject.Move(vM: TD3DVector);
var
  i: integer;
begin
  with Info do
  begin
    for i := 0 to fNumVertexes - 1 do
    begin
      TheVertexes[i].x := TheVertexes[i].x + vM.x;
      TheVertexes[i].y := TheVertexes[i].y + vM.y;
      TheVertexes[i].z := TheVertexes[i].z + vM.z;
    end;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DProceduralObject.MoveX(fx: TD3DValue);
var i: integer;
begin
  if fx <> 0 then
    with Info do
      for i := 0 to fNumVertexes - 1 do
        TheVertexes[i].x := TheVertexes[i].x + fx;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DProceduralObject.MoveY(fy: TD3DValue);
var i: integer;
begin
  if fy <> 0 then
   with Info do
     for i := 0 to fNumVertexes - 1 do
       TheVertexes[i].y := TheVertexes[i].y + fy;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DProceduralObject.MoveZ(fz: TD3DValue);
var
  i: integer;
begin
  if fz <> 0 then
    with Info do
      for i := 0 to fNumVertexes - 1 do
        TheVertexes[i].z := TheVertexes[i].z + fz;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DProceduralObject.RotateX(dx: TD3DValue);
var
  mat: TD3DMatrix;
  v1, v2: TD3DVector;
  i: integer;
begin
  D3DUtil_SetRotateXMatrix(mat, dx);
  with Info do
  begin
    for i := 0 to fNumVertexes - 1 do
    begin
      v1 := PD3DVector(@TheVertexes[i])^; //MakeD3DVector(TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z);
      D3DMath_VectorMatrixMultiply(v2, v1, mat);
      TheVertexes[i].x := v2.x;
      TheVertexes[i].y := v2.y;
      TheVertexes[i].z := v2.z;
    end;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DProceduralObject.RotateY(dy: TD3DValue);
var
  mat: TD3DMatrix;
  v1, v2: TD3DVector;
  i: integer;
begin
  D3DUtil_SetRotateYMatrix(mat, dy);
  with Info do
  begin
    for i := 0 to fNumVertexes - 1 do
    begin
      v1 := PD3DVector(@TheVertexes[i])^; // MakeD3DVector(TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z);
      D3DMath_VectorMatrixMultiply(v2, v1, mat);
      TheVertexes[i].x := v2.x;
      TheVertexes[i].y := v2.y;
      TheVertexes[i].z := v2.z;
    end;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DProceduralObject.RotateZ(dz: TD3DValue);
var
  mat: TD3DMatrix;
  v1, v2: TD3DVector;
  i: integer;
begin
  D3DUtil_SetRotateZMatrix(mat, dz);
  with Info do
  begin
    for i := 0 to fNumVertexes - 1 do
    begin
      v1 := PD3DVector(@TheVertexes[i])^; // MakeD3DVector(TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z);
      D3DMath_VectorMatrixMultiply(v2, v1, mat);
      TheVertexes[i].x := v2.x;
      TheVertexes[i].y := v2.y;
      TheVertexes[i].z := v2.z;
    end;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DProceduralObject.Rotate(vM: TD3DVector);
var
  mat: TD3DMatrix;
  v1, v2: TD3DVector;
  i: integer;
begin
  GetRotationMatrix(mat, vM.x, vM.y, vM.z);
  with Info do
  begin
    for i := 0 to fNumVertexes - 1 do
    begin
      v1 := PD3DVector(@TheVertexes[i])^; // MakeD3DVector(TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z);
      D3DMath_VectorMatrixMultiply(v2, v1, mat);
      TheVertexes[i].x := v2.x;
      TheVertexes[i].y := v2.y;
      TheVertexes[i].z := v2.z;
    end;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DProceduralObject.GetTextureNames(var s: TDXStringList);
var
  i: integer;
begin
  for i := 0 to Info.NumTextures - 1 do
  begin
    if Info.TextureNames[i, 0] <> '' then
      if s.IndexOf(Info.TextureNames[i, 0]) = -1 then
         s.Add(Info.TextureNames[i, 0]);
    if Info.TextureNames[i, 1] <> '' then
      if s.IndexOf(Info.TextureNames[i, 1]) = -1 then
         s.Add(Info.TextureNames[i, 1]);
  end;
end;

function TD3DProceduralObject.IsIdentical(D3DSurface: TObject): boolean;
var
  inf: TD3DProceduralObjectInfo;
begin
  Result := False;
  if not Inherited IsIdentical(D3DSurface) then
    Exit;
  if D3DSurface is TD3DProceduralObject then
  begin
    (D3DSurface as TD3DProceduralObject).GetInfo(@inf);
    Result :=
      (Info.key = inf.Key) and
      (Info.zOrder = inf.zOrder) and
      (Info.Interval = inf.Interval) and
      (Info.PrimitiveType = inf.PrimitiveType) and
      (Info.Transparency = inf.Transparency) and
      (Info.Cull = inf.Cull) and
      (Info.x = inf.x) and
      (Info.y = inf.y) and
      (Info.z = inf.z) and
      (Info.dx = inf.dx) and
      (Info.dy = inf.dy) and
      (Info.dz = inf.dz) and
      (Info.ModuleName = inf.ModuleName) and
      (Info.NumTextures = inf.NumTextures) and
      TextureNamesEqual(inf.TextureNames, Info.TextureNames, Info.NumTextures);
  end;
end;

function TD3DProceduralObject.GetTypeID: byte;
begin
  Result := ID3D_ProceduralObject;
end;

function TD3DProceduralObject.GetKeyID: integer;
begin
  Result := Info.Key;
end;

procedure TD3DProceduralObject.SaveToStream(s: TStream);
var
  i: integer;
  l: smallint;
begin
  Inherited SaveToStream(s);
  with Info do
  begin
    s.Write(key, SizeOf(key));
    s.Write(zOrder, SizeOf(zOrder));
    s.Write(Interval, SizeOf(Interval));
    s.Write(PrimitiveType, SizeOf(PrimitiveType));
    s.Write(Transparency, SizeOf(Transparency));
    s.Write(Cull, SizeOf(Cull));
    s.Write(x, SizeOf(x));
    s.Write(y, SizeOf(y));
    s.Write(z, SizeOf(z));
    s.Write(dx, SizeOf(dx));
    s.Write(dy, SizeOf(dy));
    s.Write(dz, SizeOf(dz));
    s.Write(NumTextures, SizeOf(NumTextures));
    l := Length(moduleName);
    s.Write(l, SizeOf(l));
    for i := 1 to l do
      s.Write(ModuleName[i], SizeOf(ModuleName[i]));
  end;
end;

procedure TD3DProceduralObject.LoadFromStream(s: TStream; version: integer);
var
  i: integer;
  l: smallint;
  c: char;
begin
  Inherited LoadFromStream(s, version);
  with Info do
  begin
    s.Read(key, SizeOf(key));
    s.Read(zOrder, SizeOf(zOrder));
    s.Read(Interval, SizeOf(Interval));
    s.Read(PrimitiveType, SizeOf(PrimitiveType));
    s.Read(Transparency, SizeOf(Transparency));
    s.Read(Cull, SizeOf(Cull));
    s.Read(x, SizeOf(x));
    s.Read(y, SizeOf(y));
    s.Read(z, SizeOf(z));
    s.Read(dx, SizeOf(dx));
    s.Read(dy, SizeOf(dy));
    s.Read(dz, SizeOf(dz));
    s.Read(NumTextures, SizeOf(NumTextures));
    s.Read(l, SizeOf(l));
    ModuleName := '';
    for i := 1 to l do
    begin
      s.Read(c, SizeOf(c));
      ModuleName := ModuleName + c;
    end;
    if l > 0 then
      fProc := GetProcAddress(HInstance, PChar(ModuleName))
    else
      fProc := nil;
//    CreateVertexes;
  end;
end;

function TD3DProceduralObject.CurTextureName: string;
begin
  Result := Info.TextureNames[CurTextureIndex, 0];
end;

function TD3DProceduralObject.CurTextureIndex: integer;
begin
  if (Info.Interval = 0) or (Info.NumTextures = 0) then
    Result := 0
  else
    Result := trunc(fTime * Info.NumTextures / Info.Interval) mod Info.NumTextures;
end;

function TD3DProceduralObject.CalcDistance(const Position: TD3DVector): TD3DValue; register;
begin
  if Info.zOrder > 50000 then // ֿץסבםע, פבגםי, נפשלב
    Distance := Info.zOrder
  else
    Distance := VectorMagnitude(
            MakeD3DVector(
              Info.x - Position.x,
              Info.y - Position.y,
              Info.z - Position.z));
  Result := Distance;
end;

function TD3DProceduralObject.TextureName: string;
begin
  Result := Info.TextureNames[0, 0];
end;

procedure TD3DProceduralObject.GetInfo(p: Pointer);
begin
  PD3DProceduralObjectInfo(p)^ := Info;
end;

function TD3DProceduralObject.GetLocatePosition(aDistance: TD3DValue): TD3DVector;
begin
  with Info do
    Result := MakeD3DVector(x, y, z - aDistance)
end;

procedure TD3DProceduralObject.LoadVertexes(fName: string);
var
  s: TStream;
begin
  s := fScene.AddStreamToCollection(fName);
  if s <> nil then
  begin
    s.Seek(0, soFromBeginning);
    s.Read(Info.Cull, SizeOf(Info.Cull));
    s.Read(Info.PrimitiveType, SizeOf(Info.PrimitiveType));
    SizeNumVertexes((s.Size - SizeOf(Info.Cull) - SizeOf(Info.PrimitiveType)) div SizeOf(TD3DLVertex));
    s.Read(TheVertexes^, fNumVertexes * SizeOf(TD3DLVertex));
  end;
end;

procedure TD3DProceduralObject.ApplyLight(l: TD3DSceneLight);
var
  i: integer;
begin
  if l.IsAppliable(GetLocatePosition(0.0)) then
    for i := 0 to fNumVertexes - 1 do
      l.ApplyToVertex(TheVertexes[i], clWhite)
end;

// ֱסיטלע Vertexes פןץ בםפיךוילםןץ
function TD3DProceduralObject.GetNumVertexes: integer;
begin
  if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    Result := fNumVertexes * Info.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := fNumVertexes * 2
  else
    Result := fNumVertexes;
end;

// ֱסיטלע װסיד‏םשם פןץ בםפיךוילםןץ
function TD3DProceduralObject.GetNumTriangles: integer;
begin
  case Info.PrimitiveType of
    D3DPT_TRIANGLELIST: Result := fNumVertexes div 3;
    D3DPT_TRIANGLESTRIP,
    D3DPT_TRIANGLEFAN: Result := Max(fNumVertexes - 2, 0);
  else
    Result := 0;
  end;
  if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    Result := Result * Info.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := Result * 2
end;
{$ENDIF}

{$IFNDEF NO_D3DCUBES}
{ *** TD3DCube *** }
constructor TD3DCube.Create(aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; aInfo: TD3DCubeInfo);
begin
  Info := aInfo;
  Textures := aTextures;
  Inherited Create(aDXDraw, aTextures[0, 0]);
end;

constructor TD3DCube.CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; version: integer);
begin
  LoadFromStream(s, version);
  Create(aDXDraw, aTextures, Info);
end;

procedure TD3DCube.CreateVertexes;
var mat: TD3DMatrix;
    v1, v2: TD3DVector;
    i: integer;
    aC: TD3DColor;
begin
  with Info do
  begin
    GetRotationMatrix(mat, dx, dy, dz);
    aC := CA_MAKE(C, 0);

    if VisibleSides[0] then
    begin
      // Front Face
      TheVertexes[0] :=
        MakeD3DLVERTEX(
          -Width/2, Height/2, -Depth/2,
            aC, 0, 0.0 + du, dv);
      TheVertexes[1] :=
        MakeD3DLVERTEX(
          Width/2, Height/2,-Depth/2,
            aC, 0, u + du, dv);
      TheVertexes[2] :=
        MakeD3DLVERTEX(
          -Width/2,-Height/2,-Depth/2,
            aC, 0, du, v + dv);
      TheVertexes[3] :=
        MakeD3DLVERTEX(
          Width/2,-Height/2,-Depth/2,
            aC, 0, u + du, v + dv);

      for i := 0 to 3 do
      begin
        v1 := PD3DVector(@TheVertexes[i])^; // MakeD3DVector(TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z);
        D3DMath_VectorMatrixMultiply(v2, v1, mat);
        TheVertexes[i].x := v2.x + x;
        TheVertexes[i].y := v2.y + y;
        TheVertexes[i].z := v2.z + z;
      end;

    end;

    if VisibleSides[1] then
    begin
      // Back face
      TheVertexes[4] :=
        MakeD3DLVERTEX(
          -Width/2, Height/2, Depth/2,
            aC, 0, u + du, dv);
      TheVertexes[5] :=
        MakeD3DLVERTEX(
          -Width/2,-Height/2, Depth/2,
            aC, 0, u + du, v + dv);
      TheVertexes[6] :=
        MakeD3DLVERTEX(
          Width/2, Height/2, Depth/2,
            aC, 0, du, dv);
      TheVertexes[7] :=
        MakeD3DLVERTEX(
          Width/2,-Height/2, Depth/2,
            aC, 0, du, v + dv);

      for i := 4 to 7 do
      begin
        v1 := PD3DVector(@TheVertexes[i])^; // MakeD3DVector(TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z);
        D3DMath_VectorMatrixMultiply(v2, v1, mat);
        TheVertexes[i].x := v2.x + x;
        TheVertexes[i].y := v2.y + y;
        TheVertexes[i].z := v2.z + z;
      end;

    end;

    if VisibleSides[2] then
    begin
      // Top face
      TheVertexes[8] :=
        MakeD3DLVERTEX(
          -Width/2, Height/2, Depth/2,
            aC, 0, du, dv);
      TheVertexes[9] :=
        MakeD3DLVERTEX(
          Width/2, Height/2, Depth/2,
            aC, 0, u + du, dv);
      TheVertexes[10] :=
        MakeD3DLVERTEX(
          -Width/2, Height/2,-Depth/2,
            aC, 0, du, v + dv);
      TheVertexes[11] :=
        MakeD3DLVERTEX(
          Width/2, Height/2,-Depth/2,
            aC, 0, u + du, v + dv);

      for i := 8 to 11 do
      begin
        v1 := PD3DVector(@TheVertexes[i])^; // MakeD3DVector(TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z);
        D3DMath_VectorMatrixMultiply(v2, v1, mat);
        TheVertexes[i].x := v2.x + x;
        TheVertexes[i].y := v2.y + y;
        TheVertexes[i].z := v2.z + z;
      end;

    end;

    if VisibleSides[3] then
    begin
      // Bottom face
      TheVertexes[12] :=
        MakeD3DLVERTEX(
          -Width/2,-Height/2, Depth/2,
            aC, 0, du, dv);
      TheVertexes[13] :=
        MakeD3DLVERTEX(
          -Width/2,-Height/2,-Depth/2,
            aC, 0, du, v + dv);
      TheVertexes[14] :=
        MakeD3DLVERTEX(
          Width/2,-Height/2, Depth/2,
            aC, 0, u + du, dv);
      TheVertexes[15] :=
        MakeD3DLVERTEX(
          Width/2,-Height/2,-Depth/2,
            aC, 0, u + du, v + dv);

      for i := 12 to 15 do
      begin
        v1 := PD3DVector(@TheVertexes[i])^; // MakeD3DVector(TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z);
        D3DMath_VectorMatrixMultiply(v2, v1, mat);
        TheVertexes[i].x := v2.x + x;
        TheVertexes[i].y := v2.y + y;
        TheVertexes[i].z := v2.z + z;
      end;

    end;

    if VisibleSides[4] then
    begin
      // Right face
      TheVertexes[16] :=
        MakeD3DLVERTEX(
          Width/2, Height/2,-Depth/2,
            aC, 0, du, dv);
      TheVertexes[17] :=
        MakeD3DLVERTEX(
          Width/2, Height/2, Depth/2,
            aC, 0, u + du, dv);
      TheVertexes[18] :=
        MakeD3DLVERTEX(
          Width/2,-Height/2,-Depth/2,
            aC, 0, du, v + dv);
      TheVertexes[19] :=
        MakeD3DLVERTEX(
          Width/2,-Height/2, Depth/2,
            aC, 0, u + du, v + dv);

      for i := 16 to 19 do
      begin
        v1 := PD3DVector(@TheVertexes[i])^; // MakeD3DVector(TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z);
        D3DMath_VectorMatrixMultiply(v2, v1, mat);
        TheVertexes[i].x := v2.x + x;
        TheVertexes[i].y := v2.y + y;
        TheVertexes[i].z := v2.z + z;
      end;

    end;

    if VisibleSides[5] then
    begin
      // Left face
      TheVertexes[20] :=
        MakeD3DLVERTEX(
          -Width/2, Height/2,-Depth/2,
            aC, 0, u + du, dv);
      TheVertexes[21] :=
        MakeD3DLVERTEX(
          -Width/2,-Height/2,-Depth/2,
            aC, 0, u + du, v + dv);
      TheVertexes[22] :=
        MakeD3DLVERTEX(
          -Width/2, Height/2, Depth/2,
            aC, 0, du, dv);
      TheVertexes[23] :=
        MakeD3DLVERTEX(
          -Width/2,-Height/2, Depth/2,
            aC, 0, du, v + dv);

      for i := 20 to 23 do
      begin
        v1 := PD3DVector(@TheVertexes[i])^; // MakeD3DVector(TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z);
        D3DMath_VectorMatrixMultiply(v2, v1, mat);
        TheVertexes[i].x := v2.x + x;
        TheVertexes[i].y := v2.y + y;
        TheVertexes[i].z := v2.z + z;
      end;

    end;
  end;
end;

procedure TD3DCube.fCalcCenterAndRadius;
begin
  if Info.VisibleSides[0] then
    CalcCenterAndRadius(PD3DLVertexArray(@TheVertexes[0]), 1, fRadius, fCenter)
  else if Info.VisibleSides[1] then
    CalcCenterAndRadius(PD3DLVertexArray(@TheVertexes[4]), 1, fRadius, fCenter)
  else if Info.VisibleSides[2] then
    CalcCenterAndRadius(PD3DLVertexArray(@TheVertexes[8]), 1, fRadius, fCenter)
  else if Info.VisibleSides[3] then
    CalcCenterAndRadius(PD3DLVertexArray(@TheVertexes[12]), 1, fRadius, fCenter)
  else if Info.VisibleSides[4] then
    CalcCenterAndRadius(PD3DLVertexArray(@TheVertexes[16]), 1, fRadius, fCenter)
  else if Info.VisibleSides[5] then
    CalcCenterAndRadius(PD3DLVertexArray(@TheVertexes[20]), 1, fRadius, fCenter)
  else
  begin
    fRadius := 0;
    fCenter := NULLVECTOR;
  end;
end;

procedure TD3DCube.InitParams;
var col: TColor;
    canv: TCanvas;
begin
  CreateVertexes;
  with Info do
  begin
    if Texture[0] = nil then
    begin
      Graphic.Bitmap.Width := 2;
      Graphic.Bitmap.Height := 2;
      Graphic.Bitmap.PixelFormat := pf24bit;
      col := C;
      canv := Graphic.Bitmap.Canvas;
      canv.Pixels[0, 0] := col;
      canv.Pixels[1, 0] := col;
      canv.Pixels[0, 1] := col;
      canv.Pixels[1, 1] := col;
      Texture[0] := TDirect3DTexture2.Create(DXDraw, Graphic, False);
    end
    else
    begin
      Graphic.Bitmap.Width := 0;
      Graphic.Bitmap.Height := 0;
    end;
  end
end;

{$IFDEF DESIGNER}
function TD3DCube.CanSaveVertexes: boolean;
begin
  Result := True;
end;

procedure TD3DCube.SaveVertexes(fName: string);
var
  f: TFileStream;
  pp: TD3DPrimitiveType;
  i: integer;
begin
  f := TFileStream.Create(fName, fmCreate or fmShareDenyWrite);
  try
    f.Write(Info.Cull, SizeOf(Info.Cull));
    pp := D3DPT_TRIANGLELIST;
    f.Write(pp, SizeOf(pp));
    for i := 0 to 5 do
      if Info.VisibleSides[i] then
      begin
        f.Write(TheVertexes[i * 4 + 0], SizeOf(TD3DLVertex));
        f.Write(TheVertexes[i * 4 + 1], SizeOf(TD3DLVertex));
        f.Write(TheVertexes[i * 4 + 2], SizeOf(TD3DLVertex));
        f.Write(TheVertexes[i * 4 + 1], SizeOf(TD3DLVertex));
        f.Write(TheVertexes[i * 4 + 2], SizeOf(TD3DLVertex));
        f.Write(TheVertexes[i * 4 + 3], SizeOf(TD3DLVertex));
      end;
  finally
    f.Free;
  end;
end;

function TD3DCube.RTL_CanBeRuntime: boolean;
begin
  Result := (Info.NumTextures in [0..1]) and
            (Info.Transparency = MAXTRANSPARENCYREPLICATION) and
            (Graphic.Bitmap.Width = 0) and
            (Textures[0, 1] = Textures[0, 0]);
end;

procedure TD3DCube.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull);
var
  GlobalName: string;
begin
  DeclareSession := '';
  InitSession := '';
  DrawSession := '';
  DoneSession := '';
  RTL_GetRunTimeCodeTemplate(
    DeclareSession, InitSession, DrawSession, DoneSession,
    doTexture, curCull,
    'CUBE_',              // GlobalName
    @TheVertexes,         // Vertexes Array
    24,                   // Number of Vertexes
    Info.Cull,            // CULL
    D3DPT_TRIANGLESTRIP,  // Primitive Type
    0,
    0,
    tLights,
    @GlobalName);

  if curCull <> Info.Cull then
  begin
    DrawSession :=
 '    Scene.DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_CULLMODE, ' + IntToStr(Ord(Info.Cull)) + ');' + NL;
    curCull := Info.Cull;
  end
  else
    DrawSession := '';
  if doTexture then
    DrawSession := DrawSession +
 '    Scene.DXDraw.D3DDevice7.SetTexture(0, Texture_' + RTLGetExistedResourceEntry(TextureName) + '.Surface.IDDSurface7);' + NL;
  if Info.VisibleSides[0] then
    DrawSession := DrawSession +
 '    Scene.DXDraw.D3DDevice7.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, ' + GlobalName + '_Vertexes[0], 4, 0);' + NL;
  if Info.VisibleSides[1] then
    DrawSession := DrawSession +
 '    Scene.DXDraw.D3DDevice7.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, ' + GlobalName + '_Vertexes[4], 4, 0);' + NL;
  if Info.VisibleSides[2] then
    DrawSession := DrawSession +
 '    Scene.DXDraw.D3DDevice7.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, ' + GlobalName + '_Vertexes[8], 4, 0);' + NL;
  if Info.VisibleSides[3] then
    DrawSession := DrawSession +
 '    Scene.DXDraw.D3DDevice7.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, ' + GlobalName + '_Vertexes[12], 4, 0);' + NL;
  if Info.VisibleSides[4] then
    DrawSession := DrawSession +
 '    Scene.DXDraw.D3DDevice7.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, ' + GlobalName + '_Vertexes[16], 4, 0);' + NL;
  if Info.VisibleSides[5] then
    DrawSession := DrawSession +
 '    Scene.DXDraw.D3DDevice7.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, ' + GlobalName + '_Vertexes[20], 4, 0);' + NL;

end;
{$ENDIF}

procedure TD3DCube.Draw;
var
  i, CurIndex: integer;
  dev: IDirect3DDevice7;
begin
  dev := DXDraw.D3DDevice7;
  dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(Info.Cull));
  if (Info.Transparency <> 0) and (Graphic.Bitmap.Width = 0) then with info do
  begin
    CurIndex := CurTextureIndex;
    if Transparency < MAXTRANSPARENCYREPLICATION then
    begin
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
      dev.SetTexture( 0, Textures[CurTextureIndex, 0].Surface.IDDSurface7);
      dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
      dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
    // ֲכיק, לנןסו םב קסויבףפו םב ךבכףןץלו פחם DrawPrimitive נןככע צןסע
    // בככ נסםןץלו םב חליהיבצבםע Texture.
      for i := 1 to Info.Transparency do
      begin
        if VisibleSides[0] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], 4, 0);
        if VisibleSides[1] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[4], 4, 0);
        if VisibleSides[2] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[8], 4, 0);
        if VisibleSides[3] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[12], 4, 0);
        if VisibleSides[4] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[16], 4, 0);
        if VisibleSides[5] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[20], 4, 0);
      end;
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
    end
    else
    begin
    // ױנסקוי לףךב, פחם קסחףילןנןין‎לו.
    // ¼פבם הום ץנסקוי לףךב ףפן Textures[CurIndex, 1] ץנסקוי ן הוךפחע
    // פןץ Textures[CurIndex, 0] (ךןפב ::AddTexturesToCollection
      if Textures[CurIndex, 1] <> Textures[CurIndex, 0] then
      begin
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
        // ׃קוהיזןץלו פחם לףךב...
        dev.SetTexture( 0, Textures[CurTextureIndex, 1].Surface.IDDSurface7);
        if VisibleSides[0] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], 4, 0);
        if VisibleSides[1] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[4], 4, 0);
        if VisibleSides[2] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[8], 4, 0);
        if VisibleSides[3] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[12], 4, 0);
        if VisibleSides[4] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[16], 4, 0);
        if VisibleSides[5] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[20], 4, 0);
        // ...ךבי פחם נופלו בנ נםש פחם ויךםב
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVDESTCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetTexture( 0, Textures[CurTextureIndex, 0].Surface.IDDSurface7);
        if VisibleSides[0] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], 4, 0);
        if VisibleSides[1] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[4], 4, 0);
        if VisibleSides[2] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[8], 4, 0);
        if VisibleSides[3] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[12], 4, 0);
        if VisibleSides[4] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[16], 4, 0);
        if VisibleSides[5] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[20], 4, 0);
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
      end
      else // ִום ץנסקוי לףךב
      begin
{   // The following gives a very good transparent effect!
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_SRCBLEND, ord(D3DBLEND_SRCCOLOR));
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_DESTBLEND, ord(D3DBLEND_ONE));
}
      // Disable D3DRENDERSTATE_ALPHABLENDENABLE before setting transparent color
      // ************
      // ֳיב םב יףק‎וי ףו 8bpp ויךםוע, נסנוי ח נבכפב פןץע םב קוי פב קס‏לבפב פשם Windows!! (?)
      // ************
        Textures[CurIndex, 0].Surface.TransparentColor := 0;
        dev.SetTexture(0, Textures[CurIndex, 0].Surface.IDDSurface7);
        if VisibleSides[0] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], 4, 0);
        if VisibleSides[1] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[4], 4, 0);
        if VisibleSides[2] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[8], 4, 0);
        if VisibleSides[3] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[12], 4, 0);
        if VisibleSides[4] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[16], 4, 0);
        if VisibleSides[5] then
          dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[20], 4, 0);
      end;
    end;
    dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
  end
  else with Info do
  begin
    dev.SetTexture( 0, Texture[0].Surface.IDDSurface7);
    if VisibleSides[0] then
      dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], 4, 0);
    if VisibleSides[1] then
      dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[4], 4, 0);
    if VisibleSides[2] then
      dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[8], 4, 0);
    if VisibleSides[3] then
      dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[12], 4, 0);
    if VisibleSides[4] then
      dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[16], 4, 0);
    if VisibleSides[5] then
      dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[20], 4, 0);
  end;
end;

procedure TD3DCube.Move(vM: TD3DVector);
begin
  with Info do
  begin
    x := x + vM.X;
    y := y + vM.Y;
    z := z + vM.Z;
  end;
  CreateVertexes;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DCube.Rotate(vM: TD3DVector);
begin
  with Info do
  begin
    dx := dx + vM.X;
    dy := dy + vM.Y;
    dz := dz + vM.Z;
  end;
  CreateVertexes;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DCube.GetTextureNames(var s: TDXStringList);
var
  i: integer;
begin
  for i := 0 to Info.NumTextures - 1 do
  begin
    if Info.TextureNames[i, 0] <> '' then
      if s.IndexOf(Info.TextureNames[i, 0]) = -1 then
         s.Add(Info.TextureNames[i, 0]);
    if Info.TextureNames[i, 1] <> '' then
      if s.IndexOf(Info.TextureNames[i, 1]) = -1 then
         s.Add(Info.TextureNames[i, 1]);
  end;
end;

function TD3DCube.IsIdentical(D3DSurface: TObject): boolean;
var
  inf: TD3DCubeInfo;
begin
  Result := False;
  if not Inherited IsIdentical(D3DSurface) then
    Exit;
  if D3DSurface is TD3DCube then
  begin
    (D3DSurface as TD3DCube).GetInfo(@inf);
    Result :=
      (Info.key = inf.Key) and
      (Info.C = inf.C) and
      (Info.u = inf.u) and
      (Info.v = inf.v) and
      (Info.du = inf.du) and
      (Info.dv = inf.dv) and
      (Info.NumTextures = inf.NumTextures) and
      (Info.zOrder = inf.zOrder) and
      (Info.Interval = inf.Interval) and
      (Info.x = inf.x) and
      (Info.y = inf.y) and
      (Info.z = inf.z) and
      (Info.dx = inf.dx) and
      (Info.dy = inf.dy) and
      (Info.dz = inf.dz) and
      (Info.Width = inf.Width) and
      (Info.Height = inf.Height) and
      (Info.Depth = inf.Depth) and
      (Info.Transparency = inf.Transparency) and
      (Info.Cull = inf.Cull) and
      (Info.VisibleSides[0] = inf.VisibleSides[0]) and
      (Info.VisibleSides[1] = inf.VisibleSides[1]) and
      (Info.VisibleSides[2] = inf.VisibleSides[2]) and
      (Info.VisibleSides[3] = inf.VisibleSides[3]) and
      (Info.VisibleSides[4] = inf.VisibleSides[4]) and
      (Info.VisibleSides[5] = inf.VisibleSides[5]) and
      TextureNamesEqual(inf.TextureNames, Info.TextureNames, Info.NumTextures);
   end;
end;

function TD3DCube.GetTypeID: byte;
begin
  Result := ID3D_Cube;
end;

function TD3DCube.GetKeyID: integer;
begin
  Result := Info.Key;
end;

procedure TD3DCube.SaveToStream(s: TStream);
var
  i: integer;
begin
  Inherited SaveToStream(s);
  with Info do
  begin
    s.Write(key, SizeOf(key));
    s.Write(C, SizeOf(C));
    s.Write(u, SizeOf(u));
    s.Write(v, SizeOf(v));
    s.Write(du, SizeOf(du));
    s.Write(dv, SizeOf(dv));
    s.Write(NumTextures, SizeOf(NumTextures));
    s.Write(zOrder, SizeOf(zOrder));
    s.Write(Interval, SizeOf(Interval));

    s.Write(x, SizeOf(x));
    s.Write(y, SizeOf(y));
    s.Write(z, SizeOf(z));
    s.Write(dx, SizeOf(dx));
    s.Write(dy, SizeOf(dy));
    s.Write(dz, SizeOf(dz));
    s.Write(Width, SizeOf(Width));
    s.Write(Height, SizeOf(Height));
    s.Write(Depth, SizeOf(Depth));
    s.Write(Transparency, SizeOf(Transparency));
    s.Write(Cull, SizeOf(Cull));
    for i := 0 to 5 do s.Write(VisibleSides[i], SizeOf(VisibleSides[i]));
  end;
end;

{$IFNDEF NO_OLDSTREAMINGRUTINES}
procedure TD3DCube.OldLoadFromStream(s: TStream; version: integer);
var
  i: integer;
  si: ShortInt;
  intd: double;
begin
  with Info do
  begin
    s.Read(key, SizeOf(key));
    s.Read(C, SizeOf(C));
    s.Read(u, SizeOf(u));
    s.Read(v, SizeOf(v));
    if version >= FILEVERSION_101 then
    begin
      s.Read(du, SizeOf(du));
      s.Read(dv, SizeOf(dv));
    end
    else
    begin
      du := 0.0;
      dv := 0.0;
    end;
    if version >= FILEVERSION_100 then
      s.Read(NumTextures, SizeOf(NumTextures))
    else
    begin
      s.Read(si, SizeOf(si));
      NumTextures := si;
    end;

    s.Read(zOrder, SizeOf(zOrder));

    if version >= FILEVERSION_100 then
      s.Read(Interval, SizeOf(Interval))
    else
    begin
      s.Read(Intd, SizeOf(Intd));
      Interval := Intd;
    end;

    s.Read(x, SizeOf(x));
    s.Read(y, SizeOf(y));
    s.Read(z, SizeOf(z));
    s.Read(dx, SizeOf(dx));
    s.Read(dy, SizeOf(dy));
    s.Read(dz, SizeOf(dz));
    s.Read(Width, SizeOf(Width));
    s.Read(Height, SizeOf(Height));
    s.Read(Depth, SizeOf(Depth));
    s.Read(Transparency, SizeOf(Transparency));
    s.Read(Cull, SizeOf(Cull));
    for i := 0 to 5 do s.Read(VisibleSides[i], SizeOf(VisibleSides[i]));
  end;
  CreateVertexes;
end;
{$ENDIF}

procedure TD3DCube.LoadFromStream(s: TStream; version: integer);
var
  i: integer;
begin
  Inherited LoadFromStream(s, version);
{$IFNDEF NO_OLDSTREAMINGRUTINES}
  if version < FILEVERSION_107 then
    OldLoadFromStream(s, version)
  else {$ENDIF} with Info do
  begin
    s.Read(key, SizeOf(key));
    s.Read(C, SizeOf(C));
    s.Read(u, SizeOf(u));
    s.Read(v, SizeOf(v));
    s.Read(du, SizeOf(du));
    s.Read(dv, SizeOf(dv));
    s.Read(NumTextures, SizeOf(NumTextures));
    s.Read(zOrder, SizeOf(zOrder));
    s.Read(Interval, SizeOf(Interval));
    s.Read(x, SizeOf(x));
    s.Read(y, SizeOf(y));
    s.Read(z, SizeOf(z));
    s.Read(dx, SizeOf(dx));
    s.Read(dy, SizeOf(dy));
    s.Read(dz, SizeOf(dz));
    s.Read(Width, SizeOf(Width));
    s.Read(Height, SizeOf(Height));
    s.Read(Depth, SizeOf(Depth));
    s.Read(Transparency, SizeOf(Transparency));
    s.Read(Cull, SizeOf(Cull));
    for i := 0 to 5 do s.Read(VisibleSides[i], SizeOf(VisibleSides[i]));
    CreateVertexes;
  end;
end;

function TD3DCube.CurTextureName: string;
begin
  Result := Info.TextureNames[CurTextureIndex, 0];
end;

function TD3DCube.CurTextureIndex: integer;
begin
  if (Info.Interval = 0) or (Info.NumTextures = 0) then
    Result := 0
  else
    Result := trunc(fTime * Info.NumTextures / Info.Interval) mod Info.NumTextures;
end;

function TD3DCube.CalcDistance(const Position: TD3DVector): TD3DValue; register;
begin
  if Info.zOrder > 50000 then // ֿץסבםע, פבגםי, נפשלב
    Distance := Info.zOrder
  else
    Distance :=
      VectorMagnitude(
        VectorSub(
          MakeD3DVector(Info.x, Info.y, Info.z), Position));
  Result := Distance;
end;

function TD3DCube.TextureName: string;
begin
  Result := Info.TextureNames[0, 0];
end;

procedure TD3DCube.GetInfo(p: Pointer);
begin
  PD3DCubeInfo(p)^ := Info;
end;

function TD3DCube.GetLocatePosition(aDistance: TD3DValue): TD3DVector;
begin
  with info do
    Result := MakeD3DVector(x, y, z - aDistance);
end;

procedure TD3DCube.ApplyLight(l: TD3DSceneLight);
var i: integer;
    C: TColor;
begin
  if l.IsAppliable(GetLocatePosition(0.0)) then
  begin
    C := Info.C;
    for i := 0 to 23 do
      l.ApplyToVertex(TheVertexes[i], C)
  end;
end;

// ֱסיטלע Vertexes פןץ בםפיךוילםןץ
function TD3DCube.GetNumVertexes: integer;
var
  i: integer;
begin
  Result := 0;
  for i := 0 to 5 do
    if Info.VisibleSides[i] then
      inc(Result, 4);
  if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    Result := Result * Info.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := Result * 2
end;

// ֱסיטלע װסיד‏םשם פןץ בםפיךוילםןץ
function TD3DCube.GetNumTriangles: integer;
var i: integer;
begin
  Result := 0;
  for i := 0 to 5 do
    if Info.VisibleSides[i] then
      inc(Result, 2);
  if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    Result := Result * Info.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := Result * 2
end;
{$ENDIF}

{ *** TD3DVariableComplexityTimingObject *** }

{$IFNDEF NO_DXMESHES}
procedure TD3DVariableComplexityTimingObject.AdjustMeshData;
begin
  Inherited AdjustMeshData;
  fMesh.VertexTypeDesc := @D3DDXFVF_VERTEX;
  fMesh.Cull := @CULL_NONE;
  fMesh.PrimitiveType := @PT_TRIANGLESTRIP;
  fMesh.NumVertexes := @NumVertexes;
  fMesh.Vertexes := @TheVertexes;
end;
{$ENDIF}

procedure TD3DVariableComplexityTimingObject.SizeNumVertexes(const NewSize: integer); // ִוףלו‎וי לםלח ףפןץע נםבךוע לו פב װD3DLVertex
begin
  if NumVertexes <> NewSize then
  begin
    if NumVertexes <> 0 then
    begin
      FreeMem(TheInitialVertexes, SizeOf(TD3DLVertex) * NumVertexes);
      FreeMem(TheVertexes, SizeOf(TD3DLVertex) * NumVertexes);
    end;
    NumVertexes := NewSize;
    GetMem(TheInitialVertexes, SizeOf(TD3DLVertex) * NumVertexes);
    GetMem(TheVertexes, SizeOf(TD3DLVertex) * NumVertexes);
  end;
end;

procedure TD3DVariableComplexityTimingObject.SaveComplexityLevel;
begin
  SetComplexityLevel(-1, 1);
end;

procedure TD3DVariableComplexityTimingObject.RestoreComplexityLevel;
begin
  SetComplexityLevel(0, 1);
end;

{$IFDEF DESIGNER}
procedure TD3DVariableComplexityTimingObject.RTL_GetRunTimeCodeTemplate(
      out DeclareSession, InitSession, DrawSession, DoneSession: string;
      doTexture: boolean; var curCull: TD3DCull;
      tGlobalName: string;
      tVX: PD3DLVertexArray;
      tNumVertexes: integer;
      tCull: TD3DCULL;
      tPrimitive: TD3DPrimitiveType;
      ComplexityLevel: integer;
      ComplexityDistance: TD3DValue;
      Lights: TDXStringList;
      pVertexName: PString = nil;
      pTextureName: PString = nil);

const
  rsIF = 'if';
  rsELSE = 'else';

  function ELIF(id: integer): string;
  begin
    if id = 0 then
      Result := rsIF
    else if id = ComplexityLevel - 1 then
      Result := rsELSE
    else
      Result := rsELSE + ' ' + rsIF;
  end;

var
  GlobalName, prim_str, str_tmp, str2_j: string;
  i, j: integer;
  pos: TD3DVector;
begin
  if (ComplexityLevel * ComplexityDistance) = 0 then
  begin
    Inherited;
    Exit;
  end;
  GlobalName := tGlobalName + IntToStr4(GetKeyID) + '_ID_' + IntToStr4(GenGlobalID);
  if pVertexName <> nil then
    pVertexName^ := GlobalName;

  DeclareSession := '';
  if doTexture then
    DeclareSession := DeclareSession +
 '    Texture_' + RTLGetExistedResourceEntry(TextureName) + ': TDirect3DTexture2;' + NL;
  if pTextureName <> nil then
    pTextureName^ := 'Texture_' + RTLGetExistedResourceEntry(TextureName);

  for j := 0 to ComplexityLevel - 1 do
    DeclareSession := DeclareSession +
 '    ' + GlobalName + '_Vertexes_' + IntToStr2(j) + ': PD3DLVertexArray;' + NL;

  InitSession := '';

  if doTexture then
    InitSession := InitSession +
 '    Texture_' + RTLGetExistedResourceEntry(TextureName) +
   ' := Scene.AddTextureToCollectionConst(''' +
          RTLGetExistedResourceEntry(TextureName) +
          ExtractFileExt(TextureName) + ''');' + NL +
 '    Texture_' + RTLGetExistedResourceEntry(TextureName) + '.Surface.TransparentColor := 0;' + NL;

  SaveComplexityLevel; // Kםןץלו בנןטךוץףח פשם הוהןלםשם
  for j := 0 to ComplexityLevel - 1 do
  begin
    SetComplexityLevel(j, ComplexityLevel);
    ApplyLights(Lights);
    str2_j := IntToStr2(j);
    InitSession := InitSession +
 '    GetMem(' + GlobalName + '_Vertexes_' + str2_j + ', ' + IntToStr(NumVertexes) + ' * SizeOf(TD3DLVertex));' + NL;
    for i := 0 to NumVertexes - 1 do
    begin
      str_tmp := '    ' + GlobalName + '_Vertexes_' + str2_j + '[' + IntToStr(i) + '] := MakeD3DLVERTEX(';
      InitSession := InitSession +
        str_tmp + FloatToStr(TheVertexes[i].x) + ', ' +
                  FloatToStr(TheVertexes[i].y) + ', ' +
                  FloatToStr(TheVertexes[i].z) + ', ' +
                  'D3DCOLOR(' + IntToStr(TheVertexes[i].color) + '), ' +
                  'D3DCOLOR(' + IntToStr(TheVertexes[i].specular) + '), ' +
                  FloatToStr(TheVertexes[i].tu) + ', ' +
                  FloatToStr(TheVertexes[i].tv) + ');' + NL;
    end;
  end;
  RestoreComplexityLevel; // Kםןץלו restore

  pos := GetLocatePosition(0.0);
  DrawSession :=
 '    tmpDistanceFrom := Scene.DistanceFrom(' +
      FloatToStr(pos.X) + ', ' +
      FloatToStr(pos.Y) + ', ' +
      FloatToStr(pos.Z) + ');' + NL;

  if (curCull <> tCull) and (tCull in [D3DCULL_NONE, D3DCULL_CW, D3DCULL_CCW]) then
  begin
    case tCull of
      D3DCULL_NONE:
        DrawSession := DrawSession +
 '    Scene.DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(D3DCULL_NONE));' + NL;
      D3DCULL_CCW:
        DrawSession := DrawSession +
 '    Scene.DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(D3DCULL_CCW));' + NL;
      D3DCULL_CW:
        DrawSession := DrawSession +
 '    Scene.DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(D3DCULL_CW));' + NL;
    else
    end;
    curCull := tCull;
  end;

  if tPrimitive = D3DPT_TRIANGLELIST then
    prim_str := 'D3DPT_TRIANGLELIST'
  else if tPrimitive = D3DPT_TRIANGLESTRIP then
    prim_str := 'D3DPT_TRIANGLESTRIP'
  else
    prim_str := 'D3DPT_TRIANGLEFAN';

  if doTexture then
    DrawSession := DrawSession +
 '    Scene.DXDraw.D3DDevice7.SetTexture(0, Texture_' + RTLGetExistedResourceEntry(TextureName) + '.Surface.IDDSurface7);' + NL;

  for j := 0 to ComplexityLevel - 1 do
  begin
    SetComplexityLevel(j, ComplexityLevel);
    if j <> ComplexityLevel - 1 then
      DrawSession := DrawSession +
 '    ' + ELIF(j) + ' tmpDistanceFrom < ' + FloatToStr((j + 1) * GetBoundFactor * ComplexityDistance) + ' then' + NL
    else
      DrawSession := DrawSession +
 '    ' + ELIF(j) + NL;
  DrawSession := DrawSession +
 '        Scene.DXDraw.D3DDevice7.DrawPrimitive(' + prim_str + ', D3DDXFVF_VERTEX, ' + GlobalName + '_Vertexes_' + IntToStr2(j) + '[0], ' + IntToStr(NumVertexes) + ', 0)';
    if j <> ComplexityLevel - 1 then
      DrawSession := DrawSession + NL
    else
      DrawSession := DrawSession + ';' + NL;
  end;
  RestoreComplexityLevel;

  DoneSession := '';
  for j := 0 to ComplexityLevel - 1 do
  begin
    SetComplexityLevel(j, ComplexityLevel);
    DoneSession := DoneSession +
 '    FreeMem(' + GlobalName + '_Vertexes_' + IntToStr2(j) + ', ' + IntToStr(NumVertexes) + ' * SizeOf(TD3DLVertex));' + NL;
  end;
  RestoreComplexityLevel;
end;
{$ENDIF}

// ֱסיטלע Vertexes פןץ בםפיךוילםןץ
function TD3DVariableComplexityTimingObject.GetNumVertexes: integer;
begin
  Result := NumVertexes;
end;

{$IFNDEF NO_D3DSPHERES}

{ *** TD3DSphere *** }
constructor TD3DSphere.Create(aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; aInfo: TD3DSphereInfo);
begin
  NumVertexes := 0;
  Info := aInfo;
  Textures := aTextures;
  Inherited Create(aDXDraw, aTextures[0, 0]);
end;

constructor TD3DSphere.CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; version: integer);
begin
  LoadFromStream(s, version);
  Create(aDXDraw, aTextures, Info);
end;

destructor TD3DSphere.Destroy;
begin
  Inherited;
  SizeNumVertexes(0);
end;

function TD3DSphere.GetBoundFactor: TD3DValue;
// Mדוטןע דיב bounded rectangle
begin
  Result := MaxValue([Info.Width, Info.Height, Info.Depth]);
end;

procedure TD3DSphere.SetComplexityLevel(Curlevel, ComplexityLevel: integer);
begin
  if CurLevel = -1 then
    GetQuality(OriginalRings, OriginalSegs)
  else if CurLevel = 0 then
    SetQuality(OriginalRings, OriginalSegs)
  else
    SetQuality(
      Min(OriginalRings, Max(3, trunc(OriginalRings * (ComplexityLevel - CurLevel) / ComplexityLevel))),
      Min(OriginalSegs, Max(3, trunc(OriginalSegs * (ComplexityLevel - CurLevel) / ComplexityLevel))));
end;

// ִחליןץסדו פןם נםבךב TheInitialVertexes.
// ֿ נםבךבע TheVertexes טב החליןץסדחטו לו פחם ApplyInfoToVertexes
// ¸פףי ףפיע נוסיףפסןצע ךבי ףפיע לופבךיםףויע, הום טב מבםבדםופבי ן
// נבסבךפש (קסןםןגסןע) ץנןכןדיףלע
// ֱנביפופבי גגביב םב קןץלו ה‎ן נםבךוע בנ Vertexes -> נוסיףףפוסח לםלח
// בככ פי םב ךםןץלו? ִום לנןסן‎לו םב פב קןץלו כב.
procedure TD3DSphere.CreateInitialVertexes;
var
  i, ring, seg: integer;
  aC: TD3DColor;
  fDeltaRingAngle,
  fDeltaSegAngle: TD3DValue;
  ss, sc,
  r0, r1,
  x0, x1,
  y0, y1,
  z0, z1: TD3DValue;
  segNumSegmentsU: TD3DValue;
  ringNv: TD3DValue;      // for optimization;
  vNumRings: TD3DValue;   // for optimization;
begin
  with Info do
  begin
    SizeNumVertexes(2 * NumRings * (NumSegments + 1));

    // Establish constants used in sphere generation
    fDeltaRingAngle := g_PI / NumRings;
    fDeltaSegAngle  := g_2_PI / NumSegments;

    aC := CA_MAKE(C, 0);

    i := 0;

    vNumRings := v / NumRings;

    // Generate the group of rings for the sphere
    for ring := 0 to NumRings - 1 do
    begin
      SinCosS(ring * fDeltaRingAngle, r0, y0);
      SinCosS((ring + 1) * fDeltaRingAngle, r1, y1);

      ringNv := ring/NumRings * v + dv;
      // Generate the group of segments for the current ring
      for seg := 0 to NumSegments do
      begin
        SinCosS(seg * fDeltaSegAngle, ss, sc);
        x0 := r0 * ss;
        z0 := r0 * sc;
        x1 := r1 * ss;
        z1 := r1 * sc;

        segNumSegmentsU :=  -seg/NumSegments * u + du;

        TheInitialVertexes[i] :=
          MakeD3DLVERTEX(
            x0 , y0, z0,
              aC, 0, segNumSegmentsU, ringNv); //ring/NumRings * v);
        TheVertexes[i] := TheInitialVertexes[i]; // ֱסקיך נכחסןצןסב ףפןם נםבךב TheVertexes
        inc(i);

        TheInitialVertexes[i] :=
          MakeD3DLVERTEX(
            x1, y1, z1,
              aC, 0, segNumSegmentsU, ringNv + vNumRings);//(ring + 1)/NumRings * v);
        TheVertexes[i] := TheInitialVertexes[i]; // ֱסקיך נכחסןצןסב ףפןם נםבךב TheVertexes
        inc(i);
      end;
    end;
  end;
end;

procedure TD3DSphere.ApplyInfoToVertexes;
var
  mat, mat2: TD3DMatrix;
  i: integer;
  pV, pVi: PD3DLVertex;
begin
  with Info do
  begin
    GetScaleMatrix(mat2, width, height, depth);
    GetRotationMatrix(mat, dx, dy, dz);
    MulMatrix(mat, mat2, mat);

    pV := @TheVertexes[0];
    pVi := @TheInitialVertexes[0];
    for i := 0 to NumVertexes - 1 do
    begin
      D3D_VectorMatrixMultiply_Only_For_Sphere( // Optimized Matrix Multiply function
        pV.x, pV.y, pV.z,
        pVi.x, pVi.y, pVi.z, mat);
      pV.x := pV.x + x;
      pV.y := pV.y + y;
      pV.z := pV.z + z;
      inc(pV);
      inc(pVi);
    end;
  end;
end;

procedure TD3DSphere.fCalcCenterAndRadius;
begin
  fCenter := MakeD3DVector(Info.x, Info.y, Info.z);
  fRadius := Max(Info.Width, Max(Info.Height, Info.Depth));
end;

procedure TD3DSphere.InitParams;
var
  col: TColor;
  canv: TCanvas;
begin
  CreateInitialVertexes;
  ApplyInfoToVertexes;
  with Info do
  begin
    if Texture[0] = nil then
    begin
      Graphic.Bitmap.Width := 2;
      Graphic.Bitmap.Height := 2;
      Graphic.Bitmap.PixelFormat := pf24bit;
      col := C;
      canv := Graphic.Bitmap.Canvas;
      canv.Pixels[0, 0] := col;
      canv.Pixels[1, 0] := col;
      canv.Pixels[0, 1] := col;
      canv.Pixels[1, 1] := col;
      Texture[0] := TDirect3DTexture2.Create(DXDraw, Graphic, False);
    end
    else
    begin
      Graphic.Bitmap.Width := 0;
      Graphic.Bitmap.Height := 0;
    end;
  end
end;

procedure TD3DSphere.SetQuality(nRings, nSegments: byte);
begin
  if (Info.NumRings <> nRings) or (Info.NumSegments <> nSegments) then
  begin
    Info.NumRings := nRings;
    Info.NumSegments := nSegments;
    CreateInitialVertexes;
    ApplyInfoToVertexes;
  end;
end;

procedure TD3DSphere.GetQuality(var nRings, nSegments: byte);
begin
  nRings := Info.NumRings;
  nSegments := Info.NumSegments;
end;

{$IFDEF DESIGNER}
function TD3DSphere.CanSaveVertexes: boolean;
begin
  Result := True;
end;

procedure TD3DSphere.SaveVertexes(fName: string);
var
  f: TFileStream;
  dd: TD3DPrimitiveType;
begin
  f := TFileStream.Create(fName, fmCreate or fmShareDenyWrite);
  try
    f.Write(Info.Cull, SizeOf(Info.Cull));
    dd := D3DPT_TRIANGLESTRIP;
    f.Write(dd, SizeOf(dd));
    f.Write(TheVertexes^, NumVertexes * SizeOf(TD3DLVertex));
  finally
    f.Free;
  end;
end;

function TD3DSphere.RTL_CanBeRuntime: boolean;
begin
  Result := (Info.NumTextures in [0..1]) and
            (Info.Transparency = MAXTRANSPARENCYREPLICATION) and
            (Graphic.Bitmap.Width = 0) and
            (Textures[0, 1] = Textures[0, 0]);
end;

procedure TD3DSphere.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull);
begin
  DeclareSession := '';
  InitSession := '';
  DrawSession := '';
  DoneSession := '';
  RTL_GetRunTimeCodeTemplate(
    DeclareSession, InitSession, DrawSession, DoneSession,
    doTexture, curCull,
    'SPHERE_',            // GlobalName
    TheVertexes,          // Vertexes Array
    NumVertexes,          // Number of Vertexes
    Info.Cull,            // CULL
    D3DPT_TRIANGLESTRIP,  // Primitive Type
    ComplexityLevel,
    ComplexityDistance,
    tLights);
end;
{$ENDIF}

procedure TD3DSphere.Draw;
var
  i, CurIndex: integer;
  dev: IDirect3DDevice7;
begin
  dev := DXDraw.D3DDevice7;
  dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(Info.Cull));
  if (Info.Transparency <> 0) and (Graphic.Bitmap.Width = 0) then with info do
  begin
    CurIndex := CurTextureIndex;
    if Transparency < MAXTRANSPARENCYREPLICATION then
    begin
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
      dev.SetTexture( 0, Textures[CurTextureIndex, 0].Surface.IDDSurface7);
      dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
      dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
    // ֲכיק, לנןסו םב קסויבףפו םב ךבכףןץלו פחם DrawPrimitive נןככע צןסע
    // בככ נסםןץלו םב חליהיבצבםע Texture.
      for i := 1 to Info.Transparency do
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
    end
    else
    begin
    // ױנסקוי לףךב, פחם קסחףילןנןין‎לו.
    // ¼פבם הום ץנסקוי לףךב ףפן Textures[CurIndex, 1] ץנסקוי ן הוךפחע
    // פןץ Textures[CurIndex, 0] (ךןפב ::AddTexturesToCollection
      if Textures[CurIndex, 1] <> Textures[CurIndex, 0] then
      begin
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
        // ׃קוהיזןץלו פחם לףךב...
        dev.SetTexture( 0, Textures[CurTextureIndex, 1].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
        // ...ךבי פחם נופלו בנ נםש פחם ויךםב
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVDESTCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetTexture( 0, Textures[CurTextureIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
      end
      else // ִום ץנסקוי לףךב
      begin
{   // The following gives a very good transparent effect!
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_SRCBLEND, ord(D3DBLEND_SRCCOLOR));
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_DESTBLEND, ord(D3DBLEND_ONE));
}
      // Disable D3DRENDERSTATE_ALPHABLENDENABLE before setting transparent color
      // ************
      // ֳיב םב יףק‎וי ףו 8bpp ויךםוע, נסנוי ח נבכפב פןץע םב קוי פב קס‏לבפב פשם Windows!! (?)
      // ************
        Textures[CurIndex, 0].Surface.TransparentColor := 0;
        dev.SetTexture(0, Textures[CurIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
//        DXDraw.D3DDevice7.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
      end;
    end;
    dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
  end
  else with Info do
  begin
    dev.SetTexture( 0, Texture[0].Surface.IDDSurface7);
    dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
  end;
end;

procedure TD3DSphere.Move(vM: TD3DVector);
var
  i: integer;
begin
  if not VectorEquel(vM, NULLVECTOR) then
  begin
    with Info do
    begin
      x := x + vM.X;
      y := y + vM.Y;
      z := z + vM.Z;
    end;
    for i := 0 to NumVertexes - 1 do
    begin
      TheVertexes[i].x := TheVertexes[i].x + vM.x;
      TheVertexes[i].y := TheVertexes[i].y + vM.y;
      TheVertexes[i].z := TheVertexes[i].z + vM.z;
    end;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DSphere.Rotate(vM: TD3DVector);
var mat: TD3DMatrix;
    i: integer;
begin
  if not VectorEquel(vM, NULLVECTOR) then
  begin
    with Info do
    begin
      dx := GetNormalizeAngle(dx + vM.X);
      dy := GetNormalizeAngle(dy + vM.Y);
      dz := GetNormalizeAngle(dz + vM.Z);
    end;

    GetRotationMatrix(mat, vM.x, vM.y, vM.z);
    for i := 0 to NumVertexes - 1 do
    begin
      D3D_VectorMatrixMultiply_Only_For_SphereRotation(
        TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z,
        TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z, mat);
    end;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DSphere.GetTextureNames(var s: TDXStringList);
var i: integer;
begin
  for i := 0 to Info.NumTextures - 1 do
  begin
    if Info.TextureNames[i, 0] <> '' then
      if s.IndexOf(Info.TextureNames[i, 0]) = -1 then
         s.Add(Info.TextureNames[i, 0]);
    if Info.TextureNames[i, 1] <> '' then
      if s.IndexOf(Info.TextureNames[i, 1]) = -1 then
         s.Add(Info.TextureNames[i, 1]);
  end;
end;

function TD3DSphere.IsIdentical(D3DSurface: TObject): boolean;
var inf: TD3DSphereInfo;
begin
  Result := False;
  if not Inherited IsIdentical(D3DSurface) then
    Exit;
  if D3DSurface is TD3DSphere then
  begin
    (D3DSurface as TD3DSphere).GetInfo(@inf);
    Result :=
      (Info.key = inf.Key) and
      (Info.C = inf.C) and
      (Info.u = inf.u) and
      (Info.v = inf.v) and
      (Info.NumTextures = inf.NumTextures) and
      (Info.zOrder = inf.zOrder) and
      (Info.Interval = inf.Interval) and
      (Info.x = inf.x) and
      (Info.y = inf.y) and
      (Info.z = inf.z) and
      (Info.dx = inf.dx) and
      (Info.dy = inf.dy) and
      (Info.dz = inf.dz) and
      (Info.Width = inf.Width) and
      (Info.Height = inf.Height) and
      (Info.Depth = inf.Depth) and
      (Info.Transparency = inf.Transparency) and
      (Info.Cull = inf.Cull) and
      (Info.NumRings = inf.NumRings) and
      (Info.NumSegments = inf.NumSegments) and
      TextureNamesEqual(inf.TextureNames, Info.TextureNames, Info.NumTextures);
   end;
end;

function TD3DSphere.GetTypeID: byte;
begin
  Result := ID3D_Sphere;
end;

function TD3DSphere.GetKeyID: integer;
begin
  Result := Info.Key;
end;

procedure TD3DSphere.SaveToStream(s: TStream);
begin
  Inherited SaveToStream(s);
  with Info do
  begin
    s.Write(key, SizeOf(key));
    s.Write(C, SizeOf(C));
    s.Write(u, SizeOf(u));
    s.Write(v, SizeOf(v));
    s.Write(du, SizeOf(du));
    s.Write(dv, SizeOf(dv));
    s.Write(NumTextures, SizeOf(NumTextures));
    s.Write(zOrder, SizeOf(zOrder));
    s.Write(Interval, SizeOf(Interval));

    s.Write(x, SizeOf(x));
    s.Write(y, SizeOf(y));
    s.Write(z, SizeOf(z));
    s.Write(dx, SizeOf(dx));
    s.Write(dy, SizeOf(dy));
    s.Write(dz, SizeOf(dz));
    s.Write(Width, SizeOf(Width));
    s.Write(Height, SizeOf(Height));
    s.Write(Depth, SizeOf(Depth));
    s.Write(Transparency, SizeOf(Transparency));
    s.Write(Cull, SizeOf(Cull));
    s.Write(NumRings, SizeOf(NumRings));
    s.Write(NumSegments, SizeOf(NumSegments));
  end;
end;

{$IFNDEF NO_OLDSTREAMINGRUTINES}
procedure TD3DSphere.OldLoadFromStream(s: TStream; version: integer);
var
  si: ShortInt;
  intd: double;
begin
  with Info do
  begin
    s.Read(key, SizeOf(key));
    s.Read(C, SizeOf(C));
    s.Read(u, SizeOf(u));
    s.Read(v, SizeOf(v));
    if version >= FILEVERSION_101 then
    begin
      s.Read(du, SizeOf(du));
      s.Read(dv, SizeOf(dv));
    end
    else
    begin
      du := 0.0;
      dv := 0.0;
    end;

    if version >= FILEVERSION_100 then
      s.Read(NumTextures, SizeOf(NumTextures))
    else
    begin
      s.Read(si, SizeOf(si));
      NumTextures := si;
    end;

    s.Read(zOrder, SizeOf(zOrder));

    if version >= FILEVERSION_100 then
      s.Read(Interval, SizeOf(Interval))
    else
    begin
      s.Read(intd, SizeOf(intd));
      Interval := intd;
    end;

    s.Read(x, SizeOf(x));
    s.Read(y, SizeOf(y));
    s.Read(z, SizeOf(z));
    s.Read(dx, SizeOf(dx));
    s.Read(dy, SizeOf(dy));
    s.Read(dz, SizeOf(dz));
    s.Read(Width, SizeOf(Width));
    s.Read(Height, SizeOf(Height));
    s.Read(Depth, SizeOf(Depth));
    s.Read(Transparency, SizeOf(Transparency));
    s.Read(Cull, SizeOf(Cull));
    s.Read(NumRings, SizeOf(NumRings));
    s.Read(NumSegments, SizeOf(NumSegments));
  end;
  CreateInitialVertexes;
  ApplyInfoToVertexes;
end;
{$ENDIF}

procedure TD3DSphere.LoadFromStream(s: TStream; version: integer);
begin
  Inherited LoadFromStream(s, version);
{$IFNDEF NO_OLDSTREAMINGRUTINES}
  if version < FILEVERSION then
    OldLoadFromStream(s, version)
  else {$ENDIF}
  begin
    with Info do
    begin
      s.Read(key, SizeOf(key));
      s.Read(C, SizeOf(C));
      s.Read(u, SizeOf(u));
      s.Read(v, SizeOf(v));
      s.Read(du, SizeOf(du));
      s.Read(dv, SizeOf(dv));
      s.Read(NumTextures, SizeOf(NumTextures));
      s.Read(zOrder, SizeOf(zOrder));
      s.Read(Interval, SizeOf(Interval));
      s.Read(x, SizeOf(x));
      s.Read(y, SizeOf(y));
      s.Read(z, SizeOf(z));
      s.Read(dx, SizeOf(dx));
      s.Read(dy, SizeOf(dy));
      s.Read(dz, SizeOf(dz));
      s.Read(Width, SizeOf(Width));
      s.Read(Height, SizeOf(Height));
      s.Read(Depth, SizeOf(Depth));
      s.Read(Transparency, SizeOf(Transparency));
      s.Read(Cull, SizeOf(Cull));
      s.Read(NumRings, SizeOf(NumRings));
      s.Read(NumSegments, SizeOf(NumSegments));
    end;
    CreateInitialVertexes;
    ApplyInfoToVertexes;
  end;
end;

function TD3DSphere.CurTextureName: string;
begin
  Result := Info.TextureNames[CurTextureIndex, 0];
end;

function TD3DSphere.CurTextureIndex: integer;
begin
  if (Info.Interval = 0) or (Info.NumTextures = 0) then
    Result := 0
  else
    Result := trunc(fTime * Info.NumTextures / Info.Interval) mod Info.NumTextures;
end;

function TD3DSphere.CalcDistance(const Position: TD3DVector): TD3DValue; register;
begin
  if Info.zOrder > 50000 then // ֿץסבםע, פבגםי, נפשלב
    Distance := Info.zOrder
  else
    Distance :=
      VectorMagnitude(
        VectorSub(
          MakeD3DVector(Info.x, Info.y, Info.z), Position));
  Result := Distance;
end;

function TD3DSphere.TextureName: string;
begin
  Result := Info.TextureNames[0, 0];
end;

procedure TD3DSphere.GetInfo(p: Pointer);
begin
  PD3DSphereInfo(p)^ := Info;
end;

function TD3DSphere.GetLocatePosition(aDistance: TD3DValue): TD3DVector;
begin
  with info do
    Result := MakeD3DVector(x, y, z - aDistance);
end;

procedure TD3DSphere.ApplyLight(l: TD3DSceneLight);
var
  i: integer;
  C: TColor;
begin
  if l.IsAppliable(GetLocatePosition(0.0)) then
  begin
    C := Info.C;
    for i := 0 to NumVertexes - 1 do
      l.ApplyToVertex(TheVertexes[i], C)
  end;
end;

// ֱסיטלע Vertexes פןץ בםפיךוילםןץ
function TD3DSphere.GetNumVertexes: integer;
begin
  if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    Result := Inherited GetNumVertexes * Info.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := Inherited GetNumVertexes * 2
  else
    Result := Inherited GetNumVertexes;
end;

// ֱסיטלע װסיד‏םשם פןץ בםפיךוילםןץ
function TD3DSphere.GetNumTriangles: integer;
begin
  Result := NumVertexes - 2;
  if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    Result := Result * Info.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := Result * 2
end;
{$ENDIF}

{$IFNDEF NO_D3DRINGS}

{ *** TD3DRing *** }
constructor TD3DRing.Create(aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; aInfo: TD3DRingInfo);
begin
  NumVertexes := 0;
  Info := aInfo;
  Textures := aTextures;
  Inherited Create(aDXDraw, aTextures[0, 0]);
end;

constructor TD3DRing.CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; version: integer);
begin
  LoadFromStream(s, version);
  Create(aDXDraw, aTextures, Info);
end;

destructor TD3DRing.Destroy;
begin
  Inherited;
  SizeNumVertexes(0);
end;

function TD3DRing.GetBoundFactor: TD3DValue;
// Mדוטןע דיב bounded rectangle
begin
  Result := MaxValue([Info.Width, Info.Height, Info.Depth]);
end;

procedure TD3DRing.SetComplexityLevel(Curlevel, ComplexityLevel: integer);
begin
  if CurLevel = -1 then
    GetQuality(OriginalRings, OriginalSegs)
  else if CurLevel = 0 then
    SetQuality(OriginalRings, OriginalSegs)
  else
    SetQuality(
      Min(OriginalRings, Max(3, trunc(OriginalRings * (ComplexityLevel - CurLevel) / ComplexityLevel))),
      Min(OriginalSegs, Max(3, trunc(OriginalSegs * (ComplexityLevel - CurLevel) / ComplexityLevel))));
end;

// ִחליןץסדו פןם נםבךב TheInitialVertexes.
// ֿ נםבךבע TheVertexes טב החליןץסדחטו לו פחם ApplyInfoToVertexes
// ¸פףי ףפיע נוסיףפסןצע ךבי ףפיע לופבךיםףויע, הום טב מבםבדםופבי ן
// נבסבךפש (קסןםןגסןע) ץנןכןדיףלע
// ֱנביפופבי גגביב םב קןץלו ה‎ן נםבךוע בנ Vertexes -> נוסיףףפוסח לםלח
// בככ פי םב ךםןץלו? ִום לנןסן‎לו םב פב קןץלו כב.
procedure TD3DRing.CreateInitialVertexes;
var
  i, j: integer;
  theta, phi, theta1, phi1: TD3DValue;
  aC: TD3DColor;
  NumRings_gpi2, NumSegments_gpi2: TD3DValue;
  cosTheta, sinTheta,
  cosTheta1, sinTheta1,
  cosPhi, sinPhi,
  cosPhi1, sinPhi1: TD3DValue;
  pV, pVi: PD3DLVertex;
begin
  with info do
  begin
    SizeNumVertexes(4 * NumRings * NumSegments);
    aC := CA_MAKE(C, 0);
    pVi := @TheInitialVertexes[0];
    NumRings_gpi2 := g_2_PI/NumRings;
    NumSegments_gpi2 := g_2_PI/NumSegments;
    theta1 := 0.0;
    for i := 1 to NumRings do
    begin
      theta := theta1;  //i * g_2_PI/NumRings;
      theta1 := i * NumRings_gpi2;
      SinCosS(theta, sinTheta, cosTheta);
      sinTheta := - sinTheta;
      SinCosS(theta1, sinTheta1, cosTheta1);
      sinTheta1 := - sinTheta1;
      phi1 := 0.0;
      for j := 1 to NumSegments do
      begin
        phi := phi1;    //j*2.0*PI/NumSegments;
        phi1 := j * NumSegments_gpi2;

        SinCosS(phi, sinPhi, cosPhi);
        sinPhi := InnerOuterFactor * sinPhi;
        cosPhi := 1.0 + InnerOuterFactor * cosPhi;

        SinCosS(phi1, sinPhi1, cosPhi1);
        sinPhi1 := InnerOuterFactor * sinPhi1;
        cosPhi1 := 1.0 + InnerOuterFactor * cosPhi1;

        pVi.x := cosTheta*cosPhi;
        pVi.y := sinTheta*cosPhi;
        pVi.z := sinPhi;
        pVi.color := aC;
        pVi.specular := 0;
        inc(pVi);

        pVi.x := cosTheta1*cosPhi;
        pVi.y := sinTheta1*cosPhi;
        pVi.z := sinPhi;
        pVi.color := aC;
        pVi.specular := 0;
        inc(pVi);

        pVi.x := cosTheta*cosPhi1;
        pVi.y := sinTheta*cosPhi1;
        pVi.z := sinPhi1;
        pVi.color := aC;
        pVi.specular := 0;
        inc(pVi);

        pVi.x := cosTheta1*cosPhi1;
        pVi.y := sinTheta1*cosPhi1;
        pVi.z := sinPhi1;
        pVi.color := aC;
        pVi.specular := 0;
        inc(pVi);

      end;
    end;
    pVi := @TheInitialVertexes[0];
    pV := @TheVertexes[0];
    case UVType of
      cuv_XY: for i := 0 to NumVertexes - 1 do
              begin
                pVi.tu := pVi.x * u + du;
                pVi.tv := pVi.y * v + dv;
                pV^ := pVi^;
                inc(pV);
                inc(pVi);
              end;
      cuv_XZ: for i := 0 to NumVertexes - 1 do
              begin
                pVi.tu := pVi.x * u + du;
                pVi.tv := pVi.z * v + dv;
                pV^ := pVi^;
                inc(pV);
                inc(pVi);
              end;
      cuv_YZ: for i := 0 to NumVertexes - 1 do
              begin
                pVi.tu := pVi.y * u + du;
                pVi.tv := pVi.z * v + dv;
                pV^ := pVi^;
                inc(pV);
                inc(pVi);
              end;
    else
      raise Exception.Create(rsInvalidUVType);
    end;
  end;
end;

procedure TD3DRing.ApplyInfoToVertexes;
var
  mat, mat2: TD3DMatrix;
  i: integer;
  pV, pVi: PD3DLVertex;
begin
  with Info do
  begin
    GetScaleMatrix(mat2, width, height, depth);
    GetRotationMatrix(mat, dx, dy, dz);
    MulMatrix(mat, mat2, mat);

    pV := @TheVertexes[0];
    pVi := @TheInitialVertexes[0];
    for i := 0 to NumVertexes - 1 do
    begin
      D3D_VectorMatrixMultiply_Only_For_Sphere( // Optimized Matrix Multiply function
        pV.x, pV.y, pV.z,
        pVi.x, pVi.y, pVi.z, mat);
      pV.x := pV.x + x;
      pV.y := pV.y + y;
      pV.z := pV.z + z;
      inc(pV);
      inc(pVi);
    end;
  end;
end;

procedure TD3DRing.fCalcCenterAndRadius;
begin
  CalcCenterAndRadius(TheVertexes, NumVertexes, fRadius, fCenter);
end;

procedure TD3DRing.InitParams;
var
  col: TColor;
  canv: TCanvas;
begin
  CreateInitialVertexes;
  ApplyInfoToVertexes;
  with Info do
  begin
    if Texture[0] = nil then
    begin
      Graphic.Bitmap.Width := 2;
      Graphic.Bitmap.Height := 2;
      Graphic.Bitmap.PixelFormat := pf24bit;
      col := C;
      canv := Graphic.Bitmap.Canvas;
      canv.Pixels[0, 0] := col;
      canv.Pixels[1, 0] := col;
      canv.Pixels[0, 1] := col;
      canv.Pixels[1, 1] := col;
      Texture[0] := TDirect3DTexture2.Create(DXDraw, Graphic, False);
    end
    else
    begin
      Graphic.Bitmap.Width := 0;
      Graphic.Bitmap.Height := 0;
    end;
  end
end;

procedure TD3DRing.SetQuality(nRings, nSegments: byte);
begin
  if (Info.NumRings <> nRings) or (Info.NumSegments <> nSegments) then
  begin
    Info.NumRings := nRings;
    Info.NumSegments := nSegments;
    CreateInitialVertexes;
    ApplyInfoToVertexes;
  end;
end;

procedure TD3DRing.GetQuality(var nRings, nSegments: byte);
begin
  nRings := Info.NumRings;
  nSegments := Info.NumSegments;
end;

{$IFDEF DESIGNER}
function TD3DRing.CanSaveVertexes: boolean;
begin
  Result := True;
end;

procedure TD3DRing.SaveVertexes(fName: string);
var f: TFileStream;
    dd: TD3DPrimitiveType;
begin
  f := TFileStream.Create(fName, fmCreate or fmShareDenyWrite);
  try
    f.Write(Info.Cull, SizeOf(Info.Cull));
    dd := D3DPT_TRIANGLESTRIP;
    f.Write(dd, SizeOf(dd));
    f.Write(TheVertexes^, NumVertexes * SizeOf(TD3DLVertex));
  finally
    f.Free;
  end;
end;

function TD3DRing.RTL_CanBeRuntime: boolean;
begin
  Result := (Info.NumTextures in [0..1]) and
            (Info.Transparency = MAXTRANSPARENCYREPLICATION) and
            (Graphic.Bitmap.Width = 0) and
            (Textures[0, 1] = Textures[0, 0]);
end;

procedure TD3DRing.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull);
begin
  DeclareSession := '';
  InitSession := '';
  DrawSession := '';
  DoneSession := '';
  RTL_GetRunTimeCodeTemplate(
    DeclareSession, InitSession, DrawSession, DoneSession,
    doTexture, curCull,
    'Ring_',            // GlobalName
    TheVertexes,          // Vertexes Array
    NumVertexes,          // Number of Vertexes
    Info.Cull,            // CULL
    D3DPT_TRIANGLESTRIP,  // Primitive Type
    ComplexityLevel,
    ComplexityDistance,
    tLights);
end;
{$ENDIF}

procedure TD3DRing.Draw;
var i, CurIndex: integer;
    dev: IDirect3DDevice7;
begin
  dev := DXDraw.D3DDevice7;
  dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(Info.Cull));
  if (Info.Transparency <> 0) and (Graphic.Bitmap.Width = 0) then with info do
  begin
    CurIndex := CurTextureIndex;
    if Transparency < MAXTRANSPARENCYREPLICATION then
    begin
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
      dev.SetTexture( 0, Textures[CurTextureIndex, 0].Surface.IDDSurface7);
      dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
      dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
    // ֲכיק, לנןסו םב קסויבףפו םב ךבכףןץלו פחם DrawPrimitive נןככע צןסע
    // בככ נסםןץלו םב חליהיבצבםע Texture.
      for i := 1 to Info.Transparency do
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
    end
    else
    begin
    // ױנסקוי לףךב, פחם קסחףילןנןין‎לו.
    // ¼פבם הום ץנסקוי לףךב ףפן Textures[CurIndex, 1] ץנסקוי ן הוךפחע
    // פןץ Textures[CurIndex, 0] (ךןפב ::AddTexturesToCollection
      if Textures[CurIndex, 1] <> Textures[CurIndex, 0] then
      begin
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
        // ׃קוהיזןץלו פחם לףךב...
        dev.SetTexture( 0, Textures[CurTextureIndex, 1].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
        // ...ךבי פחם נופלו בנ נםש פחם ויךםב
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVDESTCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetTexture( 0, Textures[CurTextureIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
      end
      else // ִום ץנסקוי לףךב
      begin
        Textures[CurIndex, 0].Surface.TransparentColor := 0;
        dev.SetTexture(0, Textures[CurIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
      end;
    end;
    dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
  end
  else with Info do
  begin
    dev.SetTexture( 0, Texture[0].Surface.IDDSurface7);
    dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
  end;
end;

procedure TD3DRing.Move(vM: TD3DVector);
var i: integer;
begin
  if not VectorEquel(vM, NULLVECTOR) then
  begin
    with Info do
    begin
      x := x + vM.X;
      y := y + vM.Y;
      z := z + vM.Z;
    end;
    for i := 0 to NumVertexes - 1 do
    begin
      TheVertexes[i].x := TheVertexes[i].x + vM.x;
      TheVertexes[i].y := TheVertexes[i].y + vM.y;
      TheVertexes[i].z := TheVertexes[i].z + vM.z;
    end;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DRing.Rotate(vM: TD3DVector);
var
  mat: TD3DMatrix;
  i: integer;
begin
  if not VectorEquel(vM, NULLVECTOR) then
  begin
    with Info do
    begin
      dx := GetNormalizeAngle(dx + vM.X);
      dy := GetNormalizeAngle(dy + vM.Y);
      dz := GetNormalizeAngle(dz + vM.Z);
    end;

    GetRotationMatrix(mat, vM.x, vM.y, vM.z);
    for i := 0 to NumVertexes - 1 do
    begin
      D3D_VectorMatrixMultiply_Only_For_SphereRotation(
        TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z,
        TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z, mat);
    end;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DRing.GetTextureNames(var s: TDXStringList);
var
  i: integer;
begin
  for i := 0 to Info.NumTextures - 1 do
  begin
    if Info.TextureNames[i, 0] <> '' then
      if s.IndexOf(Info.TextureNames[i, 0]) = -1 then
         s.Add(Info.TextureNames[i, 0]);
    if Info.TextureNames[i, 1] <> '' then
      if s.IndexOf(Info.TextureNames[i, 1]) = -1 then
         s.Add(Info.TextureNames[i, 1]);
  end;
end;

function TD3DRing.IsIdentical(D3DSurface: TObject): boolean;
var inf: TD3DRingInfo;
begin
  Result := False;
  if not Inherited IsIdentical(D3DSurface) then
    Exit;
  if D3DSurface is TD3DRing then
  begin
    (D3DSurface as TD3DRing).GetInfo(@inf);
    Result :=
      (Info.key = inf.Key) and
      (Info.C = inf.C) and
      (Info.u = inf.u) and
      (Info.v = inf.v) and
      (Info.NumTextures = inf.NumTextures) and
      (Info.zOrder = inf.zOrder) and
      (Info.Interval = inf.Interval) and
      (Info.x = inf.x) and
      (Info.y = inf.y) and
      (Info.z = inf.z) and
      (Info.dx = inf.dx) and
      (Info.dy = inf.dy) and
      (Info.dz = inf.dz) and
      (Info.Width = inf.Width) and
      (Info.Height = inf.Height) and
      (Info.Depth = inf.Depth) and
      (Info.Transparency = inf.Transparency) and
      (Info.Cull = inf.Cull) and
      (Info.UVType = inf.UVType) and
      (Info.InnerOuterFactor = inf.InnerOuterFactor) and
      (Info.NumRings = inf.NumRings) and
      (Info.NumSegments = inf.NumSegments) and
      TextureNamesEqual(inf.TextureNames, Info.TextureNames, Info.NumTextures);
   end;
end;

function TD3DRing.GetTypeID: byte;
begin
  Result := ID3D_Ring;
end;

function TD3DRing.GetKeyID: integer;
begin
  Result := Info.Key;
end;

procedure TD3DRing.SaveToStream(s: TStream);
begin
  Inherited SaveToStream(s);
  with Info do
  begin
    s.Write(key, SizeOf(key));
    s.Write(C, SizeOf(C));
    s.Write(u, SizeOf(u));
    s.Write(v, SizeOf(v));
    s.Write(du, SizeOf(du));
    s.Write(dv, SizeOf(dv));
    s.Write(NumTextures, SizeOf(NumTextures));
    s.Write(zOrder, SizeOf(zOrder));
    s.Write(Interval, SizeOf(Interval));
    s.Write(x, SizeOf(x));
    s.Write(y, SizeOf(y));
    s.Write(z, SizeOf(z));
    s.Write(dx, SizeOf(dx));
    s.Write(dy, SizeOf(dy));
    s.Write(dz, SizeOf(dz));
    s.Write(Width, SizeOf(Width));
    s.Write(Height, SizeOf(Height));
    s.Write(Depth, SizeOf(Depth));
    s.Write(Transparency, SizeOf(Transparency));
    s.Write(Cull, SizeOf(Cull));
    s.Write(UVType, SizeOf(UVType));
    s.Write(InnerOuterFactor, SizeOf(InnerOuterFactor));
    s.Write(NumRings, SizeOf(NumRings));
    s.Write(NumSegments, SizeOf(NumSegments));
  end;
end;

procedure TD3DRing.LoadFromStream(s: TStream; version: integer);
begin
  Inherited LoadFromStream(s, version);
  with Info do
  begin
    s.Read(key, SizeOf(key));
    s.Read(C, SizeOf(C));
    s.Read(u, SizeOf(u));
    s.Read(v, SizeOf(v));
    s.Read(du, SizeOf(du));
    s.Read(dv, SizeOf(dv));
    s.Read(NumTextures, SizeOf(NumTextures));
    s.Read(zOrder, SizeOf(zOrder));
    s.Read(Interval, SizeOf(Interval));
    s.Read(x, SizeOf(x));
    s.Read(y, SizeOf(y));
    s.Read(z, SizeOf(z));
    s.Read(dx, SizeOf(dx));
    s.Read(dy, SizeOf(dy));
    s.Read(dz, SizeOf(dz));
    s.Read(Width, SizeOf(Width));
    s.Read(Height, SizeOf(Height));
    s.Read(Depth, SizeOf(Depth));
    s.Read(Transparency, SizeOf(Transparency));
    s.Read(Cull, SizeOf(Cull));
    s.Read(UVType, SizeOf(UVType));
    s.Read(InnerOuterFactor, SizeOf(InnerOuterFactor));
    s.Read(NumRings, SizeOf(NumRings));
    s.Read(NumSegments, SizeOf(NumSegments));
  end;
  CreateInitialVertexes;
  ApplyInfoToVertexes;
end;

function TD3DRing.CurTextureName: string;
begin
  Result := Info.TextureNames[CurTextureIndex, 0];
end;

function TD3DRing.CurTextureIndex: integer;
begin
  if (Info.Interval = 0) or (Info.NumTextures = 0) then
    Result := 0
  else
    Result := trunc(fTime * Info.NumTextures / Info.Interval) mod Info.NumTextures;
end;

function TD3DRing.CalcDistance(const Position: TD3DVector): TD3DValue; register;
begin
  if Info.zOrder > 50000 then // ֿץסבםע, פבגםי, נפשלב
    Distance := Info.zOrder
  else
    Distance :=
      VectorMagnitude(
        VectorSub(
          MakeD3DVector(Info.x, Info.y, Info.z), Position));
  Result := Distance;
end;

function TD3DRing.TextureName: string;
begin
  Result := Info.TextureNames[0, 0];
end;

procedure TD3DRing.GetInfo(p: Pointer);
begin
  PD3DRingInfo(p)^ := Info;
end;

function TD3DRing.GetLocatePosition(aDistance: TD3DValue): TD3DVector;
begin
  with info do
    Result := MakeD3DVector(x, y, z - aDistance);
end;

procedure TD3DRing.ApplyLight(l: TD3DSceneLight);
var i: integer;
    C: TColor;
begin
  if l.IsAppliable(GetLocatePosition(0.0)) then
  begin
    C := Info.C;
    for i := 0 to NumVertexes - 1 do
      l.ApplyToVertex(TheVertexes[i], C)
  end;
end;

// ֱסיטלע Vertexes פןץ בםפיךוילםןץ
function TD3DRing.GetNumVertexes: integer;
begin
  if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    Result := Inherited GetNumVertexes * Info.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := Inherited GetNumVertexes * 2
  else
    Result := Inherited GetNumVertexes;
end;

// ֱסיטלע װסיד‏םשם פןץ בםפיךוילםןץ
function TD3DRing.GetNumTriangles: integer;
begin
  Result := NumVertexes - 2;
  if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    Result := Result * Info.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := Result * 2
end;
{$ENDIF}

{$IFNDEF NO_D3DCONES}

{ *** TD3DCone *** }
constructor TD3DCone.Create(aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; aInfo: TD3DConeInfo);
begin
  NumVertexes := 0;
  Info := aInfo;
  Textures := aTextures;
  Inherited Create(aDXDraw, aTextures[0, 0]);
end;

constructor TD3DCone.CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; version: integer);
begin
  LoadFromStream(s, version);
  Create(aDXDraw, aTextures, Info);
end;

destructor TD3DCone.Destroy;
begin
  Inherited;
  SizeNumVertexes(0); // ֱנוכוץטסשףח לםלחע
end;

function TD3DCone.GetBoundFactor: TD3DValue;
// Mדוטןע דיב bounded rectangle
begin
  Result := MaxValue([Info.Width, Info.Height, Info.Depth]);
end;

procedure TD3DCone.SetComplexityLevel(Curlevel, ComplexityLevel: integer);
begin
  if CurLevel = -1 then
    GetQuality(OriginalSegs)
  else if CurLevel = 0 then
    SetQuality(OriginalSegs)
  else
    SetQuality(
      Min(OriginalSegs, Max(3, trunc(OriginalSegs * (ComplexityLevel - CurLevel) / ComplexityLevel))));
end;

// ִחליןץסדו פןם נםבךב TheInitialVertexes.
// ֿ נםבךבע TheVertexes טב החליןץסדחטו לו פחם ApplyInfoToVertexes
// ¸פףי ףפיע נוסיףפסןצע ךבי ףפיע לופבךיםףויע, הום טב מבםבדםופבי ן
// נבסבךפש (קסןםןגסןע) ץנןכןדיףלע
// ֱנביפופבי גגביב םב קןץלו ה‎ן נםבךוע בנ Vertexes -> נוסיףףפוסח לםלח
// בככ פי םב ךםןץלו? ִום לנןסן‎לו םב פב קןץלו כב.
procedure TD3DCone.CreateInitialVertexes;
var i, seg: integer;
    aC: TD3DColor;
    fDeltaRingAngle,
    fDeltaSegAngle: TD3DValue;
    ss, sc,
    r0, r1,
    x0, x1,
    y0, y1,
    z0, z1: TD3DValue;
    segNumSegmentsU: TD3DValue;
    ringNv: TD3DValue;      // for optimization;
    vNumRings: TD3DValue;   // for optimization;
begin
  with Info do
  begin
    if Style = csFull then
      SizeNumVertexes(4 * (NumSegments + 1))
    else
      SizeNumVertexes(2 * (NumSegments + 1));

    // Establish constants used in cone generation
    fDeltaRingAngle := g_PI_DIV_2;
    fDeltaSegAngle  := g_2_PI / NumSegments;

    aC := CA_MAKE(C, 0);

    i := 0;

    vNumRings := v / 2;

    // Generate the group of rings for the top cone
    if Style in [csFull, csTop] then
    begin

      SinCosS(fDeltaRingAngle, r0, y0);
      SinCosS(2 * fDeltaRingAngle, r1, y1);

      // Generate the group of segments for the top
      ringNv := v / 2;
      for seg := 0 to NumSegments do
      begin
        SinCosS(seg * fDeltaSegAngle, ss, sc);
        x0 := r0 * ss;
        z0 := r0 * sc;
        x1 := r1 * ss;
        z1 := r1 * sc;

        segNumSegmentsU :=  -seg/NumSegments * u;

        TheInitialVertexes[i] :=
          MakeD3DLVERTEX(
            x0 , y0, z0,
              aC, 0, segNumSegmentsU, ringNv); //ring/NumRings * v);
        TheVertexes[i] := TheInitialVertexes[i]; // ֱסקיך נכחסןצןסב ףפןם נםבךב TheVertexes
        inc(i);

        TheInitialVertexes[i] :=
          MakeD3DLVERTEX(
            x1, y1, z1,
              aC, 0,  segNumSegmentsU, ringNv + vNumRings);//(ring + 1)/NumRings * v);
        TheVertexes[i] := TheInitialVertexes[i]; // ֱסקיך נכחסןצןסב ףפןם נםבךב TheVertexes
        inc(i);
      end;
    end;

    // Generate the group of rings for the cone
    if Style in [csFull, csBottom] then
    begin

      r0 := 0;
      y0 := 0;
      SinCosS(fDeltaRingAngle, r1, y1);

      // Generate the group of segments for the bottom
      for seg := 0 to NumSegments do
      begin
        SinCosS(seg * fDeltaSegAngle, ss, sc);
        x0 := r0 * ss;
        z0 := r0 * sc;
        x1 := r1 * ss;
        z1 := r1 * sc;

        segNumSegmentsU :=  -seg/NumSegments * u;

        TheInitialVertexes[i] :=
          MakeD3DLVERTEX(
            x0 , y0, z0,
              aC, 0, segNumSegmentsU, 0.0 );
        TheVertexes[i] := TheInitialVertexes[i]; // ֱסקיך נכחסןצןסב ףפןם נםבךב TheVertexes
        inc(i);

        TheInitialVertexes[i] :=
          MakeD3DLVERTEX(
            x1, y1, z1,
              aC, 0,  segNumSegmentsU, vNumRings);
        TheVertexes[i] := TheInitialVertexes[i]; // ֱסקיך נכחסןצןסב ףפןם נםבךב TheVertexes
        inc(i);
      end;
    end;

    if (du <> 0.0) or (dv <> 0.0) then
        for i := 0 to NumVertexes - 1 do
        begin
          TheVertexes[i].tu := TheVertexes[i].tu + du;
          TheVertexes[i].tv := TheVertexes[i].tv + dv;
          TheInitialVertexes[i].tu := TheVertexes[i].tu;
          TheInitialVertexes[i].tv := TheVertexes[i].tv;
        end;

  end;
end;

procedure TD3DCone.ApplyInfoToVertexes;
var mat, mat2: TD3DMatrix;
    i: integer;
    height2, dz2, y2: TD3DValue; // Values for patch the CreateInitialVertexes code (witch is taken from sphere)
    pV, pVi: PD3DLVertex;
begin
  with Info do
  begin
    height2 := height * 2;
    dz2 := dz + g_PI;
    y2 := y - height;
    GetScaleMatrix(mat2, width, height2, depth);
    GetRotationMatrix(mat, dx, dy, dz2);
    MulMatrix(mat, mat2, mat);

    pV := @TheVertexes[0];
    pVi := @TheInitialVertexes[0];
    for i := 0 to NumVertexes - 1 do
    begin
      D3D_VectorMatrixMultiply_Only_For_Sphere(
        pV.x, pV.y, pV.z,
        pVi.x, pVi.y, pVi.z, mat);
      pV.x := pV.x + x;
      pV.y := pV.y + y2;
      pV.z := pV.z + z;
      inc(pV);
      inc(pVi);
    end;
  end;
end;

procedure TD3DCone.SetQuality(nSegments: byte);
begin
  if Info.NumSegments <> nSegments then
  begin
    Info.NumSegments := nSegments;
    CreateInitialVertexes;
    ApplyInfoToVertexes;
  end;
end;

procedure TD3DCone.GetQuality(var nSegments: byte);
begin
  nSegments := Info.NumSegments;
end;

procedure TD3DCone.fCalcCenterAndRadius;
begin
  CalcCenterAndRadius(TheVertexes, NumVertexes, fRadius, fCenter);
end;

procedure TD3DCone.InitParams;
var col: TColor;
    canv: TCanvas;
begin
  CreateInitialVertexes;
  ApplyInfoToVertexes;
  with Info do
  begin
    if Texture[0] = nil then
    begin
      Graphic.Bitmap.Width := 2;
      Graphic.Bitmap.Height := 2;
      Graphic.Bitmap.PixelFormat := pf24bit;
      col := C;
      canv := Graphic.Bitmap.Canvas;
      canv.Pixels[0, 0] := col;
      canv.Pixels[1, 0] := col;
      canv.Pixels[0, 1] := col;
      canv.Pixels[1, 1] := col;
      Texture[0] := TDirect3DTexture2.Create(DXDraw, Graphic, False);
    end
    else
    begin
      Graphic.Bitmap.Width := 0;
      Graphic.Bitmap.Height := 0;
    end;
  end
end;

{$IFDEF DESIGNER}
function TD3DCone.CanSaveVertexes: boolean;
begin
  Result := True;
end;

procedure TD3DCone.SaveVertexes(fName: string);
var f: TFileStream;
    dd: TD3DPrimitiveType;
begin
  f := TFileStream.Create(fName, fmCreate or fmShareDenyWrite);
  try
    f.Write(Info.Cull, SizeOf(Info.Cull));
    dd := D3DPT_TRIANGLESTRIP;
    f.Write(dd, SizeOf(dd));
    f.Write(TheVertexes^, NumVertexes * SizeOf(TD3DLVertex));
  finally
    f.Free;
  end;
end;

function TD3DCone.RTL_CanBeRuntime: boolean;
begin
  Result := (Info.NumTextures in [0..1]) and
            (Info.Transparency = MAXTRANSPARENCYREPLICATION) and
            (Graphic.Bitmap.Width = 0) and
            (Textures[0, 1] = Textures[0, 0]);
end;

procedure TD3DCone.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull);
begin
  DeclareSession := '';
  InitSession := '';
  DrawSession := '';
  DoneSession := '';
  RTL_GetRunTimeCodeTemplate(
    DeclareSession, InitSession, DrawSession, DoneSession,
    doTexture, curCull,
    'CONE_',              // GlobalName
    TheVertexes,          // Vertexes Array
    NumVertexes,          // Number of Vertexes
    Info.Cull,            // CULL
    D3DPT_TRIANGLESTRIP,  // Primitive Type
    ComplexityLevel,
    ComplexityDistance,
    tLights);
end;
{$ENDIF}

procedure TD3DCone.Draw;
var i, CurIndex: integer;
    dev: IDirect3DDevice7;
begin
  dev := DXDraw.D3DDevice7;
  dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(Info.Cull));
  if (Info.Transparency <> 0) and (Graphic.Bitmap.Width = 0) then with info do
  begin
    CurIndex := CurTextureIndex;
    if Transparency < MAXTRANSPARENCYREPLICATION then
    begin
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
      dev.SetTexture( 0, Textures[CurTextureIndex, 0].Surface.IDDSurface7);
      dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
      dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
    // ֲכיק, לנןסו םב קסויבףפו םב ךבכףןץלו פחם DrawPrimitive נןככע צןסע
    // בככ נסםןץלו םב חליהיבצבםע Texture.
      for i := 1 to Info.Transparency do
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
    end
    else
    begin
    // ױנסקוי לףךב, פחם קסחףילןנןין‎לו.
    // ¼פבם הום ץנסקוי לףךב ףפן Textures[CurIndex, 1] ץנסקוי ן הוךפחע
    // פןץ Textures[CurIndex, 0] (ךןפב ::AddTexturesToCollection
      if Textures[CurIndex, 1] <> Textures[CurIndex, 0] then
      begin
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
        // ׃קוהיזןץלו פחם לףךב...
        dev.SetTexture( 0, Textures[CurTextureIndex, 1].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
        // ...ךבי פחם נופלו בנ נםש פחם ויךםב
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVDESTCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetTexture( 0, Textures[CurTextureIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
      end
      else // ִום ץנסקוי לףךב
      begin
{   // The following gives a very good transparent effect!
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_SRCBLEND, ord(D3DBLEND_SRCCOLOR));
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_DESTBLEND, ord(D3DBLEND_ONE));
}
      // Disable D3DRENDERSTATE_ALPHABLENDENABLE before setting transparent color
      // ************
      // ֳיב םב יףק‎וי ףו 8bpp ויךםוע, נסנוי ח נבכפב פןץע םב קוי פב קס‏לבפב פשם Windows!! (?)
      // ************
        Textures[CurIndex, 0].Surface.TransparentColor := 0;
        dev.SetTexture(0, Textures[CurIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
      end;
    end;
    dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
  end
  else with Info do
  begin
    dev.SetTexture( 0, Texture[0].Surface.IDDSurface7);
    dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
  end;
end;

procedure TD3DCone.Move(vM: TD3DVector);
var i: integer;
begin
  if not VectorEquel(vM, NULLVECTOR) then
  begin
    with Info do
    begin
      x := x + vM.X;
      y := y + vM.Y;
      z := z + vM.Z;
    end;
    for i := 0 to NumVertexes - 1 do
    begin
      TheVertexes[i].x := TheVertexes[i].x + vM.x;
      TheVertexes[i].y := TheVertexes[i].y + vM.y;
      TheVertexes[i].z := TheVertexes[i].z + vM.z;
    end;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DCone.Rotate(vM: TD3DVector);
var mat: TD3DMatrix;
    i: integer;
begin
  if not VectorEquel(vM, NULLVECTOR) then
  begin
    with Info do
    begin
      dx := GetNormalizeAngle(dx + vM.X);
      dy := GetNormalizeAngle(dy + vM.Y);
      dz := GetNormalizeAngle(dz + vM.Z);
    end;

    GetRotationMatrix(mat, vM.x, vM.y, vM.z);
    for i := 0 to NumVertexes - 1 do
    begin
      D3D_VectorMatrixMultiply_Only_For_SphereRotation( // Oplimized Matrix Multiply only for rotation
        TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z,
        TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z, mat);
    end;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DCone.GetTextureNames(var s: TDXStringList);
var i: integer;
begin
  for i := 0 to Info.NumTextures - 1 do
  begin
    if Info.TextureNames[i, 0] <> '' then
      if s.IndexOf(Info.TextureNames[i, 0]) = -1 then
         s.Add(Info.TextureNames[i, 0]);
    if Info.TextureNames[i, 1] <> '' then
      if s.IndexOf(Info.TextureNames[i, 1]) = -1 then
         s.Add(Info.TextureNames[i, 1]);
  end;
end;

function TD3DCone.IsIdentical(D3DSurface: TObject): boolean;
var inf: TD3DConeInfo;
begin
  Result := False;
  if not Inherited IsIdentical(D3DSurface) then
    Exit;
  if D3DSurface is TD3DCone then
  begin
    (D3DSurface as TD3DCone).GetInfo(@inf);
    Result :=
      (Info.key = inf.Key) and
      (Info.C = inf.C) and
      (Info.u = inf.u) and
      (Info.v = inf.v) and
      (Info.du = inf.du) and
      (Info.dv = inf.dv) and
      (Info.NumTextures = inf.NumTextures) and
      (Info.zOrder = inf.zOrder) and
      (Info.Interval = inf.Interval) and
      (Info.x = inf.x) and
      (Info.y = inf.y) and
      (Info.z = inf.z) and
      (Info.dx = inf.dx) and
      (Info.dy = inf.dy) and
      (Info.dz = inf.dz) and
      (Info.Width = inf.Width) and
      (Info.Height = inf.Height) and
      (Info.Depth = inf.Depth) and
      (Info.Transparency = inf.Transparency) and
      (Info.Cull = inf.Cull) and
      (Info.Style = inf.Style) and
      (Info.NumSegments = inf.NumSegments) and
      TextureNamesEqual(inf.TextureNames, Info.TextureNames, Info.NumTextures);
   end;
end;

function TD3DCone.GetTypeID: byte;
begin
  Result := ID3D_Cone;
end;

function TD3DCone.GetKeyID: integer;
begin
  Result := Info.Key;
end;

procedure TD3DCone.SaveToStream(s: TStream);
begin
  Inherited SaveToStream(s);
  with Info do
  begin
    s.Write(key, SizeOf(key));
    s.Write(C, SizeOf(C));
    s.Write(u, SizeOf(u));
    s.Write(v, SizeOf(v));
    s.Write(du, SizeOf(du));
    s.Write(dv, SizeOf(dv));

    s.Write(NumTextures, SizeOf(NumTextures));
    s.Write(zOrder, SizeOf(zOrder));
    s.Write(Interval, SizeOf(Interval));

    s.Write(x, SizeOf(x));
    s.Write(y, SizeOf(y));
    s.Write(z, SizeOf(z));
    s.Write(dx, SizeOf(dx));
    s.Write(dy, SizeOf(dy));
    s.Write(dz, SizeOf(dz));
    s.Write(Width, SizeOf(Width));
    s.Write(Height, SizeOf(Height));
    s.Write(Depth, SizeOf(Depth));
    s.Write(Transparency, SizeOf(Transparency));
    s.Write(Cull, SizeOf(Cull));
    s.Write(NumSegments, SizeOf(NumSegments));
    s.Write(Style, SizeOf(Style));
  end;
end;

{$IFNDEF NO_OLDSTREAMINGRUTINES}
procedure TD3DCone.OldLoadFromStream(s: TStream; version: integer);
var si: ShortInt;
    intd: double;
begin
  with Info do
  begin
    s.Read(key, SizeOf(key));
    s.Read(C, SizeOf(C));
    s.Read(u, SizeOf(u));
    s.Read(v, SizeOf(v));
    if version >= FILEVERSION_116 then
    begin
      s.Read(du, SizeOf(du));
      s.Read(dv, SizeOf(dv));
    end
    else
    begin
      du := 0.0;
      dv := 0.0;
    end;

    if version >= FILEVERSION_100 then
      s.Read(NumTextures, SizeOf(NumTextures))
    else
    begin
      s.Read(si, SizeOf(si));
      NumTextures := si;
    end;

    s.Read(zOrder, SizeOf(zOrder));

    if version >= FILEVERSION_100 then
      s.Read(Interval, SizeOf(Interval))
    else
    begin
      s.Read(intd, SizeOf(intd));
      Interval := intd;
    end;

    s.Read(x, SizeOf(x));
    s.Read(y, SizeOf(y));
    s.Read(z, SizeOf(z));
    s.Read(dx, SizeOf(dx));
    s.Read(dy, SizeOf(dy));
    s.Read(dz, SizeOf(dz));
    s.Read(Width, SizeOf(Width));
    s.Read(Height, SizeOf(Height));
    s.Read(Depth, SizeOf(Depth));
    s.Read(Transparency, SizeOf(Transparency));
    s.Read(Cull, SizeOf(Cull));
    s.Read(NumSegments, SizeOf(NumSegments));
    s.Read(Style, SizeOf(Style));
  end;
  CreateInitialVertexes;
  ApplyInfoToVertexes;
end;
{$ENDIF}

procedure TD3DCone.LoadFromStream(s: TStream; version: integer);
begin
  Inherited LoadFromStream(s, version);
{$IFNDEF NO_OLDSTREAMINGRUTINES}
  if version < FILEVERSION then
    OldLoadFromStream(s, version)
  else {$ENDIF}
  begin
    with Info do
    begin
      s.Read(key, SizeOf(key));
      s.Read(C, SizeOf(C));
      s.Read(u, SizeOf(u));
      s.Read(v, SizeOf(v));
      s.Read(du, SizeOf(du));
      s.Read(dv, SizeOf(dv));
      du := 0.0;
      dv := 0.0;
      s.Read(NumTextures, SizeOf(NumTextures));
      s.Read(zOrder, SizeOf(zOrder));
      s.Read(Interval, SizeOf(Interval));
      s.Read(x, SizeOf(x));
      s.Read(y, SizeOf(y));
      s.Read(z, SizeOf(z));
      s.Read(dx, SizeOf(dx));
      s.Read(dy, SizeOf(dy));
      s.Read(dz, SizeOf(dz));
      s.Read(Width, SizeOf(Width));
      s.Read(Height, SizeOf(Height));
      s.Read(Depth, SizeOf(Depth));
      s.Read(Transparency, SizeOf(Transparency));
      s.Read(Cull, SizeOf(Cull));
      s.Read(NumSegments, SizeOf(NumSegments));
      s.Read(Style, SizeOf(Style));
    end;
    CreateInitialVertexes;
    ApplyInfoToVertexes;
  end;
end;

function TD3DCone.CurTextureName: string;
begin
  Result := Info.TextureNames[CurTextureIndex, 0];
end;

function TD3DCone.CurTextureIndex: integer;
begin
  if (Info.Interval = 0) or (Info.NumTextures = 0) then
    Result := 0
  else
    Result := trunc(fTime * Info.NumTextures / Info.Interval) mod Info.NumTextures;
end;

function TD3DCone.CalcDistance(const Position: TD3DVector): TD3DValue; register;
begin
  if Info.zOrder > 50000 then // ֿץסבםע, פבגםי, נפשלב
    Distance := Info.zOrder
  else
    Distance :=
      VectorMagnitude(
        VectorSub(
          MakeD3DVector(Info.x, Info.y, Info.z), Position));
  Result := Distance;
end;

function TD3DCone.TextureName: string;
begin
  Result := Info.TextureNames[0, 0];
end;

procedure TD3DCone.GetInfo(p: Pointer);
begin
  PD3DConeInfo(p)^ := Info;
end;

function TD3DCone.GetLocatePosition(aDistance: TD3DValue): TD3DVector;
begin
  with info do
    Result := MakeD3DVector(x, y, z - aDistance);
end;

procedure TD3DCone.ApplyLight(l: TD3DSceneLight);
var i: integer;
    C: TColor;
begin
  if l.IsAppliable(GetLocatePosition(0.0)) then
  begin
    C := Info.C;
    for i := 0 to NumVertexes - 1 do
      l.ApplyToVertex(TheVertexes[i], C)
  end;
end;

// ֱסיטלע Vertexes פןץ בםפיךוילםןץ
function TD3DCone.GetNumVertexes: integer;
begin
  if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    Result := Inherited GetNumVertexes * Info.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := Inherited GetNumVertexes * 2
  else
    Result := Inherited GetNumVertexes;
end;

// ֱסיטלע װסיד‏םשם פןץ בםפיךוילםןץ
function TD3DCone.GetNumTriangles: integer;
begin
  Result := NumVertexes - 2;
  if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    Result := Result * Info.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := Result * 2
end;
{$ENDIF}

{$IFNDEF NO_D3DCYLINDERS}

{ *** TD3DCylinder *** }
constructor TD3DCylinder.Create(aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; aInfo: TD3DCylinderInfo);
begin
  NumVertexes := 0;
  Info := aInfo;
  Textures := aTextures;
  Inherited Create(aDXDraw, aTextures[0, 0]);
end;

constructor TD3DCylinder.CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; version: integer);
begin
  LoadFromStream(s, version);
  Create(aDXDraw, aTextures, Info);
end;

destructor TD3DCylinder.Destroy;
begin
  Inherited;
  SizeNumVertexes(0); // ֱנוכוץטסשףח לםלחע
end;

function TD3DCylinder.GetBoundFactor: TD3DValue;
// Mדוטןע דיב bounded rectangle
begin
  Result := MaxValue([Info.Width, Info.Height, Info.Depth]);
end;

procedure TD3DCylinder.SetComplexityLevel(Curlevel, ComplexityLevel: integer);
begin
  if CurLevel = -1 then
    GetQuality(OriginalRings)
  else if CurLevel = 0 then
    SetQuality(OriginalRings)
  else
    SetQuality(
      Min(OriginalRings, Max(3, trunc(OriginalRings * (ComplexityLevel - CurLevel) / ComplexityLevel))));
end;

// ִחליןץסדו פןם נםבךב TheInitialVertexes.
// ֿ נםבךבע TheVertexes טב החליןץסדחטו לו פחם ApplyInfoToVertexes
// ¸פףי ףפיע נוסיףפסןצע ךבי ףפיע לופבךיםףויע, הום טב מבםבדםופבי ן
// נבסבךפש (קסןםןגסןע) ץנןכןדיףלע
// ֱנביפופבי גגביב םב קןץלו ה‎ן נםבךוע בנ Vertexes -> נוסיףףפוסח לםלח
// בככ פי םב ךםןץלו? ִום לנןסן‎לו םב פב קןץלו כב.
procedure TD3DCylinder.CreateInitialVertexes;
var i, seg: integer;
    aC: TD3DColor;
    fDeltaSegAngle: TD3DValue;
    ss, sc,
    x0, x1,
    z0, z1: TD3DValue;
    segNumSegmentsU: TD3DValue;
    ringNv: TD3DValue;      // for optimization;
    vNumRings: TD3DValue;   // for optimization;
begin
  with Info do
  begin
    SizeNumVertexes((ord(DrawTop) * 2 + ord(DrawBottom) * 2 + ord(DrawCylinder) * 2)  * (NumSegments + 1) + ord(DrawCylinder));

    if NumVertexes = 0 then
      Exit;

    // Establish constants used in cylinder generation
    fDeltaSegAngle  := g_2_PI / NumSegments;

    aC := CA_MAKE(C, 0);

    i := 0;

    vNumRings := v / 3;

    if DrawBottom then
    begin

      // Generate the group of segments for the bottom
      for seg := 0 to NumSegments do
      begin
        SinCosS(seg * fDeltaSegAngle, ss, sc);
        x1 := ss/2;
        z1 := sc/2;

        segNumSegmentsU :=  -seg/NumSegments * u;

        TheInitialVertexes[i] :=
          MakeD3DLVERTEX(
            0.0, 0.5, 0.0,
              aC, 0, segNumSegmentsU, 0.0 );
        TheVertexes[i] := TheInitialVertexes[i]; // ֱסקיך נכחסןצןסב ףפןם נםבךב TheVertexes
        inc(i);

        TheInitialVertexes[i] :=
          MakeD3DLVERTEX(
            x1, 0.5, z1,
              aC, 0,  segNumSegmentsU, vNumRings);
        TheVertexes[i] := TheInitialVertexes[i]; // ֱסקיך נכחסןצןסב ףפןם נםבךב TheVertexes
        inc(i);
      end;
    end;

    if DrawCylinder then
    begin

      ringNv := v / 2;
      for seg := 0 to NumSegments do
      begin
        SinCosS(seg * fDeltaSegAngle, ss, sc);
        x0 := ss/2;
        z0 := sc/2;

        segNumSegmentsU :=  -seg/NumSegments * u;

        TheInitialVertexes[i] :=
          MakeD3DLVERTEX(
            x0 , 0.5, z0,
              aC, 0, segNumSegmentsU, ringNv); //ring/NumRings * v);
        TheVertexes[i] := TheInitialVertexes[i]; // ֱסקיך נכחסןצןסב ףפןם נםבךב TheVertexes
        inc(i);

        TheInitialVertexes[i] :=
          MakeD3DLVERTEX(
            x0, -0.5, z0,
              aC, 0,  segNumSegmentsU, ringNv + vNumRings);//(ring + 1)/NumRings * v);
        TheVertexes[i] := TheInitialVertexes[i]; // ֱסקיך נכחסןצןסב ףפןם נםבךב TheVertexes
        inc(i);
      end;

      TheInitialVertexes[i] := TheInitialVertexes[i - 3];
      TheVertexes[i] := TheInitialVertexes[i];
      inc(i);

    end;

    if DrawTop then
    begin

      // Generate the group of segments for the top
      for seg := NumSegments downto 0 do
      begin
        SinCosS(seg * fDeltaSegAngle, ss, sc);
        x1 := ss/2;
        z1 := sc/2;

        segNumSegmentsU :=  -seg/NumSegments * u;

        TheInitialVertexes[i] :=
          MakeD3DLVERTEX(
            0.0, -0.5, 0.0,
              aC, 0, segNumSegmentsU, 0.0 );
        TheVertexes[i] := TheInitialVertexes[i]; // ֱסקיך נכחסןצןסב ףפןם נםבךב TheVertexes
        inc(i);

        TheInitialVertexes[i] :=
          MakeD3DLVERTEX(
            x1, -0.5, z1,
              aC, 0,  segNumSegmentsU, vNumRings);
        TheVertexes[i] := TheInitialVertexes[i]; // ֱסקיך נכחסןצןסב ףפןם נםבךב TheVertexes
        inc(i);
      end;
    end;

    if (du <> 0.0) or (dv <> 0.0) then
      for i := 0 to NumVertexes - 1 do
      begin
        TheVertexes[i].tu := TheVertexes[i].tu + du;
        TheVertexes[i].tv := TheVertexes[i].tv + dv;
        TheInitialVertexes[i].tu := TheVertexes[i].tu;
        TheInitialVertexes[i].tv := TheVertexes[i].tv;
      end;
  end;
end;

procedure TD3DCylinder.ApplyInfoToVertexes;
var mat, mat2: TD3DMatrix;
    i: integer;
    pV, pVi: PD3DLVertex;
begin
  with Info do
  begin
    GetScaleMatrix(mat2, width, height, depth);
    GetRotationMatrix(mat, dx, dy, dz + g_PI);
    MulMatrix(mat, mat2, mat);

    pV := @TheVertexes[0];
    pVi := @TheInitialVertexes[0];
    for i := 0 to NumVertexes - 1 do
    begin
      D3D_VectorMatrixMultiply_Only_For_Sphere(
        pV.x, pV.y, pV.z,
        pVi.x, pVi.y, pVi.z, mat);
      pV.x := pV.x + x;
      pV.y := pV.y + y;
      pV.z := pV.z + z;
      inc(pV);
      inc(pVi);
    end;
  end;
end;

procedure TD3DCylinder.SetQuality(nSegments: byte);
begin
  if Info.NumSegments <> nSegments then
  begin
    Info.NumSegments := nSegments;
    CreateInitialVertexes;
    ApplyInfoToVertexes;
  end;
end;

procedure TD3DCylinder.GetQuality(var nSegments: byte);
begin
  nSegments := Info.NumSegments;
end;

procedure TD3DCylinder.fCalcCenterAndRadius;
begin
// ּנשע  CalcCenterAndRadius(TheVertexes, 2, fRadius, fCenter); וםבי בסךופ ?
  CalcCenterAndRadius(TheVertexes, NumVertexes, fRadius, fCenter);
end;

procedure TD3DCylinder.InitParams;
var col: TColor;
    canv: TCanvas;
begin
  CreateInitialVertexes;
  ApplyInfoToVertexes;
  with Info do
  begin
    if Texture[0] = nil then
    begin
      Graphic.Bitmap.Width := 2;
      Graphic.Bitmap.Height := 2;
      Graphic.Bitmap.PixelFormat := pf24bit;
      col := C;
      canv := Graphic.Bitmap.Canvas;
      canv.Pixels[0, 0] := col;
      canv.Pixels[1, 0] := col;
      canv.Pixels[0, 1] := col;
      canv.Pixels[1, 1] := col;
      Texture[0] := TDirect3DTexture2.Create(DXDraw, Graphic, False);
    end
    else
    begin
      Graphic.Bitmap.Width := 0;
      Graphic.Bitmap.Height := 0;
    end;
  end
end;

{$IFDEF DESIGNER}
function TD3DCylinder.CanSaveVertexes: boolean;
begin
  Result := True;
end;

procedure TD3DCylinder.SaveVertexes(fName: string);
var f: TFileStream;
    dd: TD3DPrimitiveType;
begin
  f := TFileStream.Create(fName, fmCreate or fmShareDenyWrite);
  try
    f.Write(Info.Cull, SizeOf(Info.Cull));
    dd := D3DPT_TRIANGLESTRIP;
    f.Write(dd, SizeOf(dd));
    f.Write(TheVertexes^, NumVertexes * SizeOf(TD3DLVertex));
  finally
    f.Free;
  end;
end;

function TD3DCylinder.RTL_CanBeRuntime: boolean;
begin
  Result := (Info.NumTextures in [0..1]) and
            (Info.Transparency = MAXTRANSPARENCYREPLICATION) and
            (Graphic.Bitmap.Width = 0) and
            (Textures[0, 1] = Textures[0, 0]);
end;

procedure TD3DCylinder.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull);
begin
  DeclareSession := '';
  InitSession := '';
  DrawSession := '';
  DoneSession := '';
  RTL_GetRunTimeCodeTemplate(
    DeclareSession, InitSession, DrawSession, DoneSession,
    doTexture, curCull,
    'CYLINDER_',          // GlobalName
    TheVertexes,          // Vertexes Array
    NumVertexes,          // Number of Vertexes
    Info.Cull,            // CULL
    D3DPT_TRIANGLESTRIP,  // Primitive Type
    ComplexityLevel,
    ComplexityDistance,
    tLights);
end;
{$ENDIF}

procedure TD3DCylinder.Draw;
var i, CurIndex: integer;
    dev: IDirect3DDevice7;
begin
  dev := DXDraw.D3DDevice7;
  dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(Info.Cull));
  if (Info.Transparency <> 0) and (Graphic.Bitmap.Width = 0) then with info do
  begin
    CurIndex := CurTextureIndex;
    if Transparency < MAXTRANSPARENCYREPLICATION then
    begin
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
      dev.SetTexture( 0, Textures[CurTextureIndex, 0].Surface.IDDSurface7);
      dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
      dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
    // ֲכיק, לנןסו םב קסויבףפו םב ךבכףןץלו פחם DrawPrimitive נןככע צןסע
    // בככ נסםןץלו םב חליהיבצבםע Texture.
      for i := 1 to Info.Transparency do
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
    end
    else
    begin
    // ױנסקוי לףךב, פחם קסחףילןנןין‎לו.
    // ¼פבם הום ץנסקוי לףךב ףפן Textures[CurIndex, 1] ץנסקוי ן הוךפחע
    // פןץ Textures[CurIndex, 0] (ךןפב ::AddTexturesToCollection
      if Textures[CurIndex, 1] <> Textures[CurIndex, 0] then
      begin
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
        // ׃קוהיזןץלו פחם לףךב...
        dev.SetTexture( 0, Textures[CurTextureIndex, 1].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
        // ...ךבי פחם נופלו בנ נםש פחם ויךםב
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVDESTCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetTexture( 0, Textures[CurTextureIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
      end
      else // ִום ץנסקוי לףךב
      begin
{   // The following gives a very good transparent effect!
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_SRCBLEND, ord(D3DBLEND_SRCCOLOR));
        DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_DESTBLEND, ord(D3DBLEND_ONE));
}
      // Disable D3DRENDERSTATE_ALPHABLENDENABLE before setting transparent color
      // ************
      // ֳיב םב יףק‎וי ףו 8bpp ויךםוע, נסנוי ח נבכפב פןץע םב קוי פב קס‏לבפב פשם Windows!! (?)
      // ************
        Textures[CurIndex, 0].Surface.TransparentColor := 0;
        dev.SetTexture(0, Textures[CurIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
      end;
    end;
    dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
  end
  else with Info do
  begin
    dev.SetTexture( 0, Texture[0].Surface.IDDSurface7);
    dev.DrawPrimitive(D3DPT_TRIANGLESTRIP, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
  end;
end;

procedure TD3DCylinder.Move(vM: TD3DVector);
var i: integer;
begin
  if not VectorEquel(vM, NULLVECTOR) then
  begin
    with Info do
    begin
      x := x + vM.X;
      y := y + vM.Y;
      z := z + vM.Z;
    end;
    for i := 0 to NumVertexes - 1 do
    begin
      TheVertexes[i].x := TheVertexes[i].x + vM.x;
      TheVertexes[i].y := TheVertexes[i].y + vM.y;
      TheVertexes[i].z := TheVertexes[i].z + vM.z;
    end;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DCylinder.Rotate(vM: TD3DVector);
var mat: TD3DMatrix;
    i: integer;
begin
  if not VectorEquel(vM, NULLVECTOR) then
  begin
    with Info do
    begin
      dx := GetNormalizeAngle(dx + vM.X);
      dy := GetNormalizeAngle(dy + vM.Y);
      dz := GetNormalizeAngle(dz + vM.Z);
    end;

    GetRotationMatrix(mat, vM.x, vM.y, vM.z);
    for i := 0 to NumVertexes - 1 do
    begin
      D3D_VectorMatrixMultiply_Only_For_SphereRotation( // Oplimized Matrix Multiply only for rotation
        TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z,
        TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z, mat);
    end;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DCylinder.GetTextureNames(var s: TDXStringList);
var i: integer;
begin
  for i := 0 to Info.NumTextures - 1 do
  begin
    if Info.TextureNames[i, 0] <> '' then
      if s.IndexOf(Info.TextureNames[i, 0]) = -1 then
         s.Add(Info.TextureNames[i, 0]);
    if Info.TextureNames[i, 1] <> '' then
      if s.IndexOf(Info.TextureNames[i, 1]) = -1 then
         s.Add(Info.TextureNames[i, 1]);
  end;
end;

function TD3DCylinder.IsIdentical(D3DSurface: TObject): boolean;
var inf: TD3DCylinderInfo;
begin
  Result := False;
  if not Inherited IsIdentical(D3DSurface) then
    Exit;
  if D3DSurface is TD3DCylinder then
  begin
    (D3DSurface as TD3DCylinder).GetInfo(@inf);
    Result :=
      (Info.key = inf.Key) and
      (Info.C = inf.C) and
      (Info.u = inf.u) and
      (Info.v = inf.v) and
      (Info.du = inf.du) and
      (Info.dv = inf.dv) and
      (Info.NumTextures = inf.NumTextures) and
      (Info.zOrder = inf.zOrder) and
      (Info.Interval = inf.Interval) and
      (Info.x = inf.x) and
      (Info.y = inf.y) and
      (Info.z = inf.z) and
      (Info.dx = inf.dx) and
      (Info.dy = inf.dy) and
      (Info.dz = inf.dz) and
      (Info.Width = inf.Width) and
      (Info.Height = inf.Height) and
      (Info.Depth = inf.Depth) and
      (Info.Transparency = inf.Transparency) and
      (Info.Cull = inf.Cull) and
      (Info.DrawTop = inf.DrawTop) and
      (Info.DrawBottom = inf.DrawBottom) and
      (Info.DrawCylinder = inf.DrawCylinder) and
      (Info.NumSegments = inf.NumSegments) and
      TextureNamesEqual(inf.TextureNames, Info.TextureNames, Info.NumTextures);
   end;
end;

function TD3DCylinder.GetTypeID: byte;
begin
  Result := ID3D_Cylinder;
end;

function TD3DCylinder.GetKeyID: integer;
begin
  Result := Info.Key;
end;

procedure TD3DCylinder.SaveToStream(s: TStream);
begin
  Inherited SaveToStream(s);
  with Info do
  begin
    s.Write(key, SizeOf(key));
    s.Write(C, SizeOf(C));
    s.Write(u, SizeOf(u));
    s.Write(v, SizeOf(v));
    s.Write(du, SizeOf(du));
    s.Write(dv, SizeOf(dv));
    s.Write(NumTextures, SizeOf(NumTextures));
    s.Write(zOrder, SizeOf(zOrder));
    s.Write(Interval, SizeOf(Interval));

    s.Write(x, SizeOf(x));
    s.Write(y, SizeOf(y));
    s.Write(z, SizeOf(z));
    s.Write(dx, SizeOf(dx));
    s.Write(dy, SizeOf(dy));
    s.Write(dz, SizeOf(dz));
    s.Write(Width, SizeOf(Width));
    s.Write(Height, SizeOf(Height));
    s.Write(Depth, SizeOf(Depth));
    s.Write(Transparency, SizeOf(Transparency));
    s.Write(Cull, SizeOf(Cull));
    s.Write(NumSegments, SizeOf(NumSegments));
    s.Write(DrawBottom, SizeOf(DrawBottom));
    s.Write(DrawTop, SizeOf(DrawTop));
    s.Write(DrawCylinder, SizeOf(DrawCylinder));
  end;
end;

{$IFNDEF NO_OLDSTREAMINGRUTINES}
procedure TD3DCylinder.OldLoadFromStream(s: TStream; version: integer);
var si: ShortInt;
    intd: double;
begin
  with Info do
  begin
    s.Read(key, SizeOf(key));
    s.Read(C, SizeOf(C));
    s.Read(u, SizeOf(u));
    s.Read(v, SizeOf(v));

    if version >= FILEVERSION_116 then
    begin
      s.Read(du, SizeOf(du));
      s.Read(dv, SizeOf(dv));
    end
    else
    begin
      du := 0.0;
      dv := 0.0;
    end;

    if version >= FILEVERSION_100 then
      s.Read(NumTextures, SizeOf(NumTextures))
    else
    begin
      s.Read(si, SizeOf(si));
      NumTextures := si;
    end;
    s.Read(zOrder, SizeOf(zOrder));
    if version >= FILEVERSION_100 then
      s.Read(Interval, SizeOf(Interval))
    else
    begin
      s.Read(intd, SizeOf(intd));
      Interval := intd;
    end;

    s.Read(x, SizeOf(x));
    s.Read(y, SizeOf(y));
    s.Read(z, SizeOf(z));
    s.Read(dx, SizeOf(dx));
    s.Read(dy, SizeOf(dy));
    s.Read(dz, SizeOf(dz));
    s.Read(Width, SizeOf(Width));
    s.Read(Height, SizeOf(Height));
    s.Read(Depth, SizeOf(Depth));
    s.Read(Transparency, SizeOf(Transparency));
    s.Read(Cull, SizeOf(Cull));
    s.Read(NumSegments, SizeOf(NumSegments));
    s.Read(DrawBottom, SizeOf(DrawBottom));
    s.Read(DrawTop, SizeOf(DrawTop));
    s.Read(DrawCylinder, SizeOf(DrawCylinder));
  end;
  CreateInitialVertexes;
  ApplyInfoToVertexes;                       
end;
{$ENDIF}

procedure TD3DCylinder.LoadFromStream(s: TStream; version: integer);
begin
  Inherited LoadFromStream(s, version);
{$IFNDEF NO_OLDSTREAMINGRUTINES}
  if version < FILEVERSION then
    OldLoadFromStream(s, version)
  else {$ENDIF}
  begin
    with Info do
    begin
      s.Read(key, SizeOf(key));
      s.Read(C, SizeOf(C));
      s.Read(u, SizeOf(u));
      s.Read(v, SizeOf(v));
      s.Read(du, SizeOf(du));
      s.Read(dv, SizeOf(dv));
      s.Read(NumTextures, SizeOf(NumTextures));
      s.Read(zOrder, SizeOf(zOrder));
      s.Read(Interval, SizeOf(Interval));
      s.Read(x, SizeOf(x));
      s.Read(y, SizeOf(y));
      s.Read(z, SizeOf(z));
      s.Read(dx, SizeOf(dx));
      s.Read(dy, SizeOf(dy));
      s.Read(dz, SizeOf(dz));
      s.Read(Width, SizeOf(Width));
      s.Read(Height, SizeOf(Height));
      s.Read(Depth, SizeOf(Depth));
      s.Read(Transparency, SizeOf(Transparency));
      s.Read(Cull, SizeOf(Cull));
      s.Read(NumSegments, SizeOf(NumSegments));
      s.Read(DrawBottom, SizeOf(DrawBottom));
      s.Read(DrawTop, SizeOf(DrawTop));
      s.Read(DrawCylinder, SizeOf(DrawCylinder));
    end;
    CreateInitialVertexes;
    ApplyInfoToVertexes;
  end;
end;

function TD3DCylinder.CurTextureName: string;
begin
  Result := Info.TextureNames[CurTextureIndex, 0];
end;

function TD3DCylinder.CurTextureIndex: integer;
begin
  if (Info.Interval = 0) or (Info.NumTextures = 0) then
    Result := 0
  else
    Result := trunc(fTime * Info.NumTextures / Info.Interval) mod Info.NumTextures;
end;

function TD3DCylinder.CalcDistance(const Position: TD3DVector): TD3DValue; register;
begin
  if Info.zOrder > 50000 then // ֿץסבםע, פבגםי, נפשלב
    Distance := Info.zOrder
  else
    Distance :=
      VectorMagnitude(
        VectorSub(
          MakeD3DVector(Info.x, Info.y, Info.z), Position));
  Result := Distance;
end;

function TD3DCylinder.TextureName: string;
begin
  Result := Info.TextureNames[0, 0];
end;

procedure TD3DCylinder.GetInfo(p: Pointer);
begin
  PD3DCylinderInfo(p)^ := Info;
end;

function TD3DCylinder.GetLocatePosition(aDistance: TD3DValue): TD3DVector;
begin
  with info do
    Result := MakeD3DVector(x, y, z - aDistance);
end;

procedure TD3DCylinder.ApplyLight(l: TD3DSceneLight);
var i: integer;
    C: TColor;
begin
  if l.IsAppliable(GetLocatePosition(0.0)) then
  begin
    C := Info.C;
    for i := 0 to NumVertexes - 1 do
      l.ApplyToVertex(TheVertexes[i], C)
  end;
end;

// ֱסיטלע Vertexes פןץ בםפיךוילםןץ
function TD3DCylinder.GetNumVertexes: integer;
begin
  if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    Result := Inherited GetNumVertexes * Info.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := Inherited GetNumVertexes * 2
  else
    Result := Inherited GetNumVertexes;
end;

// ֱסיטלע װסיד‏םשם פןץ בםפיךוילםןץ
function TD3DCylinder.GetNumTriangles: integer;
begin
  Result := NumVertexes - 2;
  if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    Result := Result * Info.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := Result * 2
end;
{$ENDIF}

{$IFNDEF NO_D3DTEXTS}

{ *** TD3DText *** }
constructor TD3DText.Create(aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; aInfo: TD3DTextInfo);
begin
  NumVertexes := 0;
  Info := aInfo;
  Textures := aTextures;
  Inherited Create(aDXDraw, aTextures[0, 0]);
end;

constructor TD3DText.CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DTextures2; version: integer);
begin
  LoadFromStream(s, version);
  Create(aDXDraw, aTextures, Info);
end;

destructor TD3DText.Destroy;
begin
  Inherited;
  SizeNumVertexes(0);                       
end;

function TD3DText.GetText: string;
begin
  Result := Info.Text;
end;

procedure TD3DText.SetText(Value: string);
begin
  if Value <> Info.Text then
  begin
    Info.Text := Value;
    CreateInitialVertexes;
    ApplyInfoToVertexes;
  end;
end;

const
  rsFONTDATA = 'FONTDATA';
  rsFILLED = 'FILLED';
  rsOUTLINE = 'OUTLINE';

procedure TD3DText.CreateInitialVertexes;
const
  GL_FACTOR    = 15;
  FILLEDFONT_SCALE = 0.023 / GL_FACTOR;

var i, j, i3, advance, num: integer;
    advance2: TD3DValue;
    aC: TD3DColor;
    r: TResourceStream;
    m: TMemoryStream;
    b: TBinaryData;
    pVi, pVi2: PD3DLVertex;

    procedure MakeLetter(Offset, Size, adv: integer);
    var local_i: integer;
        x, y: smallInt;
    begin
      ReAllocMem(TheInitialVertexes, (numVertexes + Size) * SizeOf(TD3DLVertex));
      m.Seek(Offset, soFromBeginning);
      pVi := @TheInitialVertexes[numVertexes];
      for local_i := 0 to Size - 1 do
      begin
        m.Read(x, SizeOf(x));
        m.Read(y, SizeOf(y));
        pVi.x := x + y * (Info.ItalicLevelH - 0.5) + advance;
        pVi.y := x * (Info.ItalicLevelV - 0.5) + y;
        inc(pVi);
      end;
      inc(numVertexes, Size);
      inc(advance, adv);
    end;

begin                                               
  numVertexes := 0;
  ReAllocMem(TheInitialVertexes, 0);
  aC := CA_MAKE(Info.frontC, 0);
  advance := 0;
  if Info.filled then
  begin

    r := TResourceStream.Create(HInstance, rsFILLED, PChar(rsFONTDATA));
    b := TBinaryData.Create(nil);
    m := TMemoryStream.Create;
    try
      b.LoadFromStream(r, True);
      b.SaveToStream(m, False);
    finally
      b.Free;
      r.Free;
    end;

    for i := 1 to Length(Info.Text) do
    case ord(Info.Text[i]) of
      33: MakeLetter(0, 78, 333);
      34: MakeLetter(312, 66, 408);
      35: MakeLetter(576, 96, 500);
      36: MakeLetter(960, 210, 500);
      37: MakeLetter(1800, 285, 833);
      38: MakeLetter(2940, 297, 778);
      39: MakeLetter(4128, 63, 333);
      40: MakeLetter(4380, 84, 333);
      41: MakeLetter(4716, 84, 333);
      42: MakeLetter(5052, 234, 500);
      43: MakeLetter(5988, 30, 564);
      44: MakeLetter(6108, 63, 250);
      45: MakeLetter(6360, 6, 333);
      46: MakeLetter(6384, 36, 250);
      47: MakeLetter(6528, 6, 278);
      48: MakeLetter(6552, 162, 500);
      49: MakeLetter(7200, 60, 500);
      50: MakeLetter(7440, 111, 500);
      51: MakeLetter(7884, 183, 500);
      52: MakeLetter(8616, 45, 500);
      53: MakeLetter(8796, 132, 500);
      54: MakeLetter(9324, 186, 500);
      55: MakeLetter(10068, 33, 500);
      56: MakeLetter(10200, 213, 500);
      57: MakeLetter(11052, 189, 500);
      58: MakeLetter(11808, 72, 278);
      59: MakeLetter(12096, 102, 278);
      60: MakeLetter(12504, 15, 564);
      61: MakeLetter(12564, 12, 564);
      62: MakeLetter(12612, 15, 564);
      63: MakeLetter(12672, 156, 444);
      64: MakeLetter(13296, 339, 921);
      65: MakeLetter(14652, 96, 722);
      66: MakeLetter(15036, 222, 667);
      67: MakeLetter(15924, 171, 667);
      68: MakeLetter(16608, 162, 722);
      69: MakeLetter(17256, 144, 611);
      70: MakeLetter(17832, 123, 556);
      71: MakeLetter(18324, 198, 722);
      72: MakeLetter(19116, 150, 722);
      73: MakeLetter(19716, 66, 333);
      74: MakeLetter(19980, 102, 389);
      75: MakeLetter(20388, 183, 722);
      76: MakeLetter(21120, 87, 611);
      77: MakeLetter(21468, 132, 889);
      78: MakeLetter(21996, 111, 722);
      79: MakeLetter(22440, 192, 722);
      80: MakeLetter(23208, 153, 556);
      81: MakeLetter(23820, 222, 722);
      82: MakeLetter(24708, 165, 667);
      83: MakeLetter(25368, 186, 556);
      84: MakeLetter(26112, 78, 611);
      85: MakeLetter(26424, 156, 722);
      86: MakeLetter(27048, 90, 722);
      87: MakeLetter(27408, 150, 944);
      88: MakeLetter(28008, 189, 722);
      89: MakeLetter(28764, 126, 722);
      90: MakeLetter(29268, 63, 611);
      91: MakeLetter(29520, 36, 333);
      92: MakeLetter(29664, 6, 278);
      93: MakeLetter(29688, 36, 333);
      94: MakeLetter(29832, 15, 469);
      95: MakeLetter(29892, 6, 500);
      96: MakeLetter(29916, 63, 333);
      97: MakeLetter(30168, 204, 444);
      98: MakeLetter(30984, 156, 500);
      99: MakeLetter(31608, 126, 444);
     100: MakeLetter(32112, 171, 500);
     101: MakeLetter(32796, 138, 444);
     102: MakeLetter(33348, 108, 333);
     103: MakeLetter(33780, 285, 500);
     104: MakeLetter(34920, 150, 500);
     105: MakeLetter(35520, 87, 278);
     106: MakeLetter(35868, 105, 278);
     107: MakeLetter(36288, 156, 500);
     108: MakeLetter(36912, 57, 278);
     109: MakeLetter(37140, 222, 778);
     110: MakeLetter(38028, 138, 500);
     111: MakeLetter(38580, 153, 500);
     112: MakeLetter(39192, 186, 500);
     113: MakeLetter(39936, 168, 500);
     114: MakeLetter(40608, 111, 333);
     115: MakeLetter(41052, 150, 389);
     116: MakeLetter(41652, 78, 278);
     117: MakeLetter(41964, 117, 500);
     118: MakeLetter(42432, 99, 500);
     119: MakeLetter(42828, 159, 722);
     120: MakeLetter(43464, 144, 500);
     121: MakeLetter(44040, 132, 500);
     122: MakeLetter(44568, 57, 444);
     123: MakeLetter(44796, 123, 480);
     124: MakeLetter(45288, 6, 200);
     125: MakeLetter(45312, 123, 480);
     126: MakeLetter(45804, 60, 541);
    else
  { ֱם פן דסללב הום ץנןףפחסזופבי, פפו לופבךיםן‎לו פןם הסןלב ךבפ לב טףח,
    ףבם םב וקבלו ךום }
      inc(advance, 250);
    end;
    m.Free;
  end
  else
  begin

    r := TResourceStream.Create(HInstance, rsOUTLINE, PChar(rsFONTDATA));
    b := TBinaryData.Create(nil);
    m := TMemoryStream.Create;
    try
      b.LoadFromStream(r, True);
      b.SaveToStream(m, False);
    finally
      b.Free;
      r.Free;
    end;

    for i := 1 to Length(Info.Text) do
    case ord(Info.Text[i]) of
      33: MakeLetter(0, 78, 333);
      34: MakeLetter(312, 66, 408);
      35: MakeLetter(576, 84, 500);
      36: MakeLetter(912, 186, 500);
      37: MakeLetter(1656, 261, 833);
      38: MakeLetter(2700, 273, 778);
      39: MakeLetter(3792, 63, 333);
      40: MakeLetter(4044, 84, 333);
      41: MakeLetter(4380, 84, 333);
      42: MakeLetter(4716, 234, 500);
      43: MakeLetter(5652, 30, 564);
      44: MakeLetter(5772, 63, 250);
      45: MakeLetter(6024, 6, 333);
      46: MakeLetter(6048, 36, 250);
      47: MakeLetter(6192, 6, 278);
      48: MakeLetter(6216, 150, 500);
      49: MakeLetter(6816, 60, 500);
      50: MakeLetter(7056, 111, 500);
      51: MakeLetter(7500, 183, 500);
      52: MakeLetter(8232, 33, 500);
      53: MakeLetter(8364, 132, 500);
      54: MakeLetter(8892, 174, 500);
      55: MakeLetter(9588, 33, 500);
      56: MakeLetter(9720, 189, 500);
      57: MakeLetter(10476, 177, 500);
      58: MakeLetter(11184, 72, 278);
      59: MakeLetter(11472, 102, 278);
      60: MakeLetter(11880, 15, 564);
      61: MakeLetter(11940, 12, 564);
      62: MakeLetter(11988, 15, 564);
      63: MakeLetter(12048, 156, 444);
      64: MakeLetter(12672, 327, 921);
      65: MakeLetter(13980, 84, 722);
      66: MakeLetter(14316, 198, 667);
      67: MakeLetter(15108, 171, 667);
      68: MakeLetter(15792, 150, 722);
      69: MakeLetter(16392, 144, 611);
      70: MakeLetter(16968, 123, 556);
      71: MakeLetter(17460, 198, 722);
      72: MakeLetter(18252, 150, 722);
      73: MakeLetter(18852, 66, 333);
      74: MakeLetter(19116, 102, 389);
      75: MakeLetter(19524, 183, 722);
      76: MakeLetter(20256, 87, 611);
      77: MakeLetter(20604, 132, 889);
      78: MakeLetter(21132, 111, 722);
      79: MakeLetter(21576, 180, 722);
      80: MakeLetter(22296, 141, 556);
      81: MakeLetter(22860, 210, 722);
      82: MakeLetter(23700, 153, 667);
      83: MakeLetter(24312, 186, 556);
      84: MakeLetter(25056, 78, 611);
      85: MakeLetter(25368, 156, 722);
      86: MakeLetter(25992, 90, 722);
      87: MakeLetter(26352, 150, 944);
      88: MakeLetter(26952, 189, 722);
      89: MakeLetter(27708, 126, 722);
      90: MakeLetter(28212, 63, 611);
      91: MakeLetter(28464, 36, 333);
      92: MakeLetter(28608, 6, 278);
      93: MakeLetter(28632, 36, 333);
      94: MakeLetter(28776, 15, 469);
      95: MakeLetter(28836, 6, 500);
      96: MakeLetter(28860, 63, 333);
      97: MakeLetter(29112, 192, 444);
      98: MakeLetter(29880, 144, 500);
      99: MakeLetter(30456, 126, 444);
     100: MakeLetter(30960, 159, 500);
     101: MakeLetter(31596, 126, 444);
     102: MakeLetter(32100, 108, 333);
     103: MakeLetter(32532, 261, 500);
     104: MakeLetter(33576, 150, 500);
     105: MakeLetter(34176, 87, 278);
     106: MakeLetter(34524, 105, 278);
     107: MakeLetter(34944, 156, 500);
     108: MakeLetter(35568, 57, 278);
     109: MakeLetter(35796, 222, 778);
     110: MakeLetter(36684, 138, 500);
     111: MakeLetter(37236, 141, 500);
     112: MakeLetter(37800, 174, 500);
     113: MakeLetter(38496, 156, 500);
     114: MakeLetter(39120, 111, 333);
     115: MakeLetter(39564, 150, 389);
     116: MakeLetter(40164, 78, 278);
     117: MakeLetter(40476, 117, 500);
     118: MakeLetter(40944, 99, 500);
     119: MakeLetter(41340, 159, 722);
     120: MakeLetter(41976, 144, 500);
     121: MakeLetter(42552, 132, 500);
     122: MakeLetter(43080, 57, 444);
     123: MakeLetter(43308, 123, 480);
     124: MakeLetter(43800, 6, 200);
     125: MakeLetter(43824, 123, 480);
     126: MakeLetter(44316, 60, 541);
    else
  { ֱם פן דסללב הום ץנןףפחסזופבי, פפו לופבךיםן‎לו פןם הסןלב ךבפ לב טףח,
    ףבם םב וקבלו ךום }
      inc(advance, 250);
    end;
    m.Free;
  end;
  pVi := @TheInitialVertexes[0];
  advance2 := advance / 2;
  for i := 0 to numVertexes - 1 do
  begin
    pVi.x := (pVi.x - advance2) * FILLEDFONT_SCALE;
    pVi.y := pVi.y * FILLEDFONT_SCALE - 0.5;
    pVi.Color := aC;
    pVi.Specular := 0;
    pVi.tu := pVi.x * Info.u + Info.du;
    pVi.tv := pVi.y * Info.v + Info.dv;
    inc(pVi);
  end;
  if abs(Info.Depth) > g_EPSILON then
  begin
    aC := CA_MAKE(Info.backC, 0);
    num := numVertexes;
    numVertexes := 2 * numVertexes;
    ReAllocMem(TheInitialVertexes, numVertexes * SizeOf(TD3DLVertex));
    pVi := @TheInitialVertexes[0];
    pVi2 := @TheInitialVertexes[num];
    for i := 0 to num - 1 do
    begin
      pVi.z := -0.5;
      pVi2.x := pVi.x;
      pVi2.y := pVi.y;
      pVi2.z := 0.5;
      pVi2.Color := aC;
      pVi2.specular := 0;
      pVi2.tu := pVi.x * Info.u + Info.backU;
      pVi2.tv := pVi.y * Info.v + Info.backV;
      inc(pVi);
      inc(pVi2);
    end;
  { ֵם‏םןץלו פב ולנסע לו פב נףש פסדשםב לםן פבם Info.Depth > g_EPSILON &
    Info.ConnectBackWithFront = True }
    if Info.ConnectBackWithFront then
    begin
      j := numVertexes;
      ReAllocMem(TheInitialVertexes, (4 * numVertexes) * SizeOf(TD3DLVertex));
      pVi := @TheInitialVertexes[numVertexes];
      i3 := 0;
      for i := 0 to (num div 3) - 1 do
      begin
        pVi^ := TheInitialVertexes[(i3    ) mod num];
        inc(pVi);
        pVi^ := TheInitialVertexes[(i3    ) mod num + num];
        inc(pVi);
        pVi^ := TheInitialVertexes[(i3 + 1) mod num];
        inc(pVi);
        pVi^ := TheInitialVertexes[(i3 + 1) mod num + num];
        inc(pVi);
        pVi^ := TheInitialVertexes[(i3 + 1) mod num];
        inc(pVi);
        pVi^ := TheInitialVertexes[(i3    ) mod num + num];
        inc(pVi);

        pVi^ := TheInitialVertexes[(i3 + 3) mod num];
        inc(pVi);
        pVi^ := TheInitialVertexes[(i3 + 3) mod num + num];
        inc(pVi);
        pVi^ := TheInitialVertexes[(i3 + 4) mod num];
        inc(pVi);
        pVi^ := TheInitialVertexes[(i3 + 4) mod num + num];
        inc(pVi);
        pVi^ := TheInitialVertexes[(i3 + 4) mod num];
        inc(pVi);
        pVi^ := TheInitialVertexes[(i3 + 3) mod num + num];
        inc(pVi);

        pVi^ := TheInitialVertexes[(i3 + 6) mod num];
        inc(pVi);
        pVi^ := TheInitialVertexes[(i3 + 6) mod num + num];
        inc(pVi);
        pVi^ := TheInitialVertexes[(i3 + 7) mod num];
        inc(pVi);
        pVi^ := TheInitialVertexes[(i3 + 7) mod num + num];
        inc(pVi);
        pVi^ := TheInitialVertexes[(i3 + 7) mod num];
        inc(pVi);
        pVi^ := TheInitialVertexes[(i3 + 6) mod num + num];
        inc(pVi);

        inc(j, 18);

        inc(i3, 3);
      end;
      numVertexes := j;
    end;
  end
  else
    for i := 0 to numVertexes - 1 do
      TheInitialVertexes[i].z := 0.0;
end;

procedure TD3DText.ApplyInfoToVertexes;
var mat, mat2: TD3DMatrix;
    i: integer;
    pV, pVi: PD3DLVertex;
begin
  with Info do
  begin
    ReAllocMem(TheVertexes, numVertexes * SizeOf(TD3DLVertex));
    GetScaleMatrix(mat2, width, height, depth);
    GetRotationMatrix(mat, dx, dy, dz);
    MulMatrix(mat, mat2, mat);

    pV := @TheVertexes[0];
    pVi := @TheInitialVertexes[0];
    for i := 0 to NumVertexes - 1 do
    begin
      D3D_VectorMatrixMultiply_Only_For_Sphere( // Optimized Matrix Multiply function
        pV.x, pV.y, pV.z,
        pVi.x, pVi.y, pVi.z, mat);
      pV.x := pV.x + x;
      pV.y := pV.y + y;
      pV.z := pV.z + z;
      pV.color := pVi.color;
      pV.specular := pVi.specular;
      pV.tu := pVi.tu;
      pV.tv := pVi.tv;
      inc(pV);
      inc(pVi);
    end;
  end;
end;

procedure TD3DText.fCalcCenterAndRadius;
begin
  CalcCenterAndRadius(TheVertexes, NumVertexes, fRadius, fCenter);
end;

procedure TD3DText.InitParams;
var col: TColor;
    canv: TCanvas;
begin
  CreateInitialVertexes;
  ApplyInfoToVertexes;
  with Info do
  begin
    if Texture[0] = nil then
    begin
      Graphic.Bitmap.Width := 2;
      Graphic.Bitmap.Height := 2;
      Graphic.Bitmap.PixelFormat := pf24bit;
      col := frontC;
      canv := Graphic.Bitmap.Canvas;
      canv.Pixels[0, 0] := col;
      canv.Pixels[1, 0] := col;
      canv.Pixels[0, 1] := col;
      canv.Pixels[1, 1] := col;
      Texture[0] := TDirect3DTexture2.Create(DXDraw, Graphic, False);
    end
    else
    begin
      Graphic.Bitmap.Width := 0;
      Graphic.Bitmap.Height := 0;
    end;
  end
end;

{$IFDEF DESIGNER}
function TD3DText.CanSaveVertexes: boolean;
begin
  Result := True;
end;

procedure TD3DText.SaveVertexes(fName: string);
var f: TFileStream;
    cc: TD3DCull;
    dd: TD3DPrimitiveType;
begin
  f := TFileStream.Create(fName, fmCreate or fmShareDenyWrite);
  try
    cc := D3DCULL_NONE;
    dd := D3DPT_TRIANGLELIST;
    f.Write(cc, SizeOf(cc));
    f.Write(dd, SizeOf(dd));
    f.Write(TheVertexes^, NumVertexes * SizeOf(TD3DLVertex));
  finally
    f.Free;
  end;
end;

function TD3DText.RTL_CanBeRuntime: boolean;
begin
  Result := (Info.NumTextures in [0..1]) and
            (Info.Transparency = MAXTRANSPARENCYREPLICATION) and
            (Graphic.Bitmap.Width = 0) and
            (Textures[0, 1] = Textures[0, 0]);
end;

procedure TD3DText.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull);
begin
  DeclareSession := '';
  InitSession := '';
  DrawSession := '';
  DoneSession := '';
  RTL_GetRunTimeCodeTemplate(
    DeclareSession, InitSession, DrawSession, DoneSession,
    doTexture, curCull,
    'Text_',              // GlobalName
    TheVertexes,          // Vertexes Array
    NumVertexes,          // Number of Vertexes
    D3DCULL_NONE,         // CULL
    D3DPT_TRIANGLELIST,   // Primitive Type
    0,
    0,
    tLights);
end;
{$ENDIF}

procedure TD3DText.Draw;
var i, CurIndex: integer;
    dev: IDirect3DDevice7;
begin
  dev := DXDraw.D3DDevice7;
  dev.SetRenderState(D3DRENDERSTATE_CULLMODE, Ord(D3DCULL_NONE));
  if (Info.Transparency <> 0) and (Graphic.Bitmap.Width = 0) then with info do
  begin
    CurIndex := CurTextureIndex;
    if Transparency < MAXTRANSPARENCYREPLICATION then
    begin
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
      dev.SetTexture( 0, Textures[CurTextureIndex, 0].Surface.IDDSurface7);
      dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
      dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
    // ֲכיק, לנןסו םב קסויבףפו םב ךבכףןץלו פחם DrawPrimitive נןככע צןסע
    // בככ נסםןץלו םב חליהיבצבםע Texture.
      for i := 1 to Info.Transparency do
        dev.DrawPrimitive(D3DPT_TRIANGLELIST, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
      dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
    end
    else
    begin
    // ױנסקוי לףךב, פחם קסחףילןנןין‎לו.
    // ¼פבם הום ץנסקוי לףךב ףפן Textures[CurIndex, 1] ץנסקוי ן הוךפחע
    // פןץ Textures[CurIndex, 0] (ךןפב ::AddTexturesToCollection
      if Textures[CurIndex, 1] <> Textures[CurIndex, 0] then
      begin
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 1);
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_SRCCOLOR));
        // ׃קוהיזןץלו פחם לףךב...
        dev.SetTexture( 0, Textures[CurTextureIndex, 1].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLELIST, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
        // ...ךבי פחם נופלו בנ נםש פחם ויךםב
        dev.SetRenderState(D3DRENDERSTATE_SRCBLEND, Integer(D3DBLEND_INVDESTCOLOR));
        dev.SetRenderState(D3DRENDERSTATE_DESTBLEND, Integer(D3DBLEND_INVSRCCOLOR));
        dev.SetTexture( 0, Textures[CurTextureIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLELIST, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
        dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
      end
      else // ִום ץנסקוי לףךב
      begin
        Textures[CurIndex, 0].Surface.TransparentColor := 0;
        dev.SetTexture(0, Textures[CurIndex, 0].Surface.IDDSurface7);
        dev.DrawPrimitive(D3DPT_TRIANGLELIST, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
      end;
    end;
    dev.SetRenderState(D3DRENDERSTATE_ALPHABLENDENABLE, 0);
  end
  else with Info do
  begin
    dev.SetTexture( 0, Texture[0].Surface.IDDSurface7);
    dev.DrawPrimitive(D3DPT_TRIANGLELIST, D3DDXFVF_VERTEX, TheVertexes[0], NumVertexes, 0);
  end;
end;

procedure TD3DText.Move(vM: TD3DVector);
var i: integer;
begin
  if not VectorEquel(vM, NULLVECTOR) then
  begin
    with Info do
    begin
      x := x + vM.X;
      y := y + vM.Y;
      z := z + vM.Z;
    end;
    for i := 0 to NumVertexes - 1 do
    begin
      TheVertexes[i].x := TheVertexes[i].x + vM.x;
      TheVertexes[i].y := TheVertexes[i].y + vM.y;
      TheVertexes[i].z := TheVertexes[i].z + vM.z;
    end;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DText.Rotate(vM: TD3DVector);
var mat: TD3DMatrix;
    i: integer;
begin
  if not VectorEquel(vM, NULLVECTOR) then
  begin
    with Info do
    begin
      dx := GetNormalizeAngle(dx + vM.X);
      dy := GetNormalizeAngle(dy + vM.Y);
      dz := GetNormalizeAngle(dz + vM.Z);
    end;

    GetRotationMatrix(mat, vM.x, vM.y, vM.z);
    for i := 0 to NumVertexes - 1 do
    begin
      D3D_VectorMatrixMultiply_Only_For_SphereRotation(
        TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z,
        TheVertexes[i].x, TheVertexes[i].y, TheVertexes[i].z, mat);
    end;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DText.GetTextureNames(var s: TDXStringList);
var i: integer;
begin
  for i := 0 to Info.NumTextures - 1 do
  begin
    if Info.TextureNames[i, 0] <> '' then
      if s.IndexOf(Info.TextureNames[i, 0]) = -1 then
         s.Add(Info.TextureNames[i, 0]);
    if Info.TextureNames[i, 1] <> '' then
      if s.IndexOf(Info.TextureNames[i, 1]) = -1 then
         s.Add(Info.TextureNames[i, 1]);
  end;
end;

function TD3DText.IsIdentical(D3DSurface: TObject): boolean;
var inf: TD3DTextInfo;
begin
  Result := False;
  if not Inherited IsIdentical(D3DSurface) then
    Exit;
  if D3DSurface is TD3DText then
  begin
    (D3DSurface as TD3DText).GetInfo(@inf);
    Result :=
      (Info.key = inf.Key) and
      (Info.frontC = inf.frontC) and
      (Info.backC = inf.backC) and
      (Info.u = inf.u) and
      (Info.v = inf.v) and
      (Info.du = inf.du) and
      (Info.dv = inf.dv) and
      (Info.NumTextures = inf.NumTextures) and
      (Info.zOrder = inf.zOrder) and
      (Info.Interval = inf.Interval) and
      (Info.x = inf.x) and
      (Info.y = inf.y) and
      (Info.z = inf.z) and
      (Info.dx = inf.dx) and
      (Info.dy = inf.dy) and
      (Info.dz = inf.dz) and
      (Info.Width = inf.Width) and
      (Info.Height = inf.Height) and
      (Info.Depth = inf.Depth) and
      (Info.Transparency = inf.Transparency) and
      (Info.ConnectBackWithFront = inf.ConnectBackWithFront) and
      (Info.ItalicLevelH = inf.ItalicLevelH) and
      (Info.ItalicLevelV = inf.ItalicLevelV) and
      (Info.Filled = inf.Filled) and
      TextureNamesEqual(inf.TextureNames, Info.TextureNames, Info.NumTextures);
   end;
end;

function TD3DText.GetTypeID: byte;
begin
  Result := ID3D_Text;
end;

function TD3DText.GetKeyID: integer;
begin
  Result := Info.Key;
end;

procedure TD3DText.SaveToStream(s: TStream);
var i: integer;
    len: word;
begin
  Inherited SaveToStream(s);
  with Info do
  begin
    s.Write(key, SizeOf(key));
    s.Write(frontC, SizeOf(frontC));
    s.Write(backC, SizeOf(backC));
    s.Write(u, SizeOf(u));
    s.Write(v, SizeOf(v));
    s.Write(du, SizeOf(du));
    s.Write(dv, SizeOf(dv));
    s.Write(backU, SizeOf(backU));
    s.Write(backV, SizeOf(backV));
    s.Write(NumTextures, SizeOf(NumTextures));
    s.Write(zOrder, SizeOf(zOrder));
    s.Write(Interval, SizeOf(Interval));
    s.Write(x, SizeOf(x));
    s.Write(y, SizeOf(y));
    s.Write(z, SizeOf(z));
    s.Write(dx, SizeOf(dx));
    s.Write(dy, SizeOf(dy));
    s.Write(dz, SizeOf(dz));
    s.Write(Width, SizeOf(Width));
    s.Write(Height, SizeOf(Height));
    s.Write(Depth, SizeOf(Depth));
    s.Write(Transparency, SizeOf(Transparency));
    s.Write(ConnectBackWithFront, SizeOf(ConnectBackWithFront));
    s.Write(ItalicLevelH, SizeOf(ItalicLevelH));
    s.Write(ItalicLevelV, SizeOf(ItalicLevelV));
    s.Write(Filled, SizeOf(Filled));
    len := Length(Text);
    s.Write(len, SizeOf(len));
    for i := 1 to len do
      s.Write(Text[i], SizeOf(Text[i]));
  end;
end;

{$IFNDEF NO_OLDSTREAMINGRUTINES}
procedure TD3DText.OldLoadFromStream(s: TStream; version: integer);
var i: integer;
    len: word;
begin
  with Info do
  begin
    s.Read(key, SizeOf(key));
    s.Read(frontC, SizeOf(frontC));
    s.Read(backC, SizeOf(backC));
    s.Read(u, SizeOf(u));
    s.Read(v, SizeOf(v));
    s.Read(du, SizeOf(du));
    s.Read(dv, SizeOf(dv));
    s.Read(backU, SizeOf(backU));
    s.Read(backV, SizeOf(backV));
    s.Read(NumTextures, SizeOf(NumTextures));
    s.Read(zOrder, SizeOf(zOrder));
    s.Read(Interval, SizeOf(Interval));
    s.Read(x, SizeOf(x));
    s.Read(y, SizeOf(y));
    s.Read(z, SizeOf(z));
    s.Read(dx, SizeOf(dx));
    s.Read(dy, SizeOf(dy));
    s.Read(dz, SizeOf(dz));
    s.Read(Width, SizeOf(Width));
    s.Read(Height, SizeOf(Height));
    s.Read(Depth, SizeOf(Depth));
    s.Read(Transparency, SizeOf(Transparency));
    if version > FILEVERSION_104 then
      s.Read(ConnectBackWithFront, SizeOf(ConnectBackWithFront))
    else
      ConnectBackWithFront := True;
    if version > FILEVERSION_105 then
    begin
      s.Read(ItalicLevelH, SizeOf(ItalicLevelH));
      s.Read(ItalicLevelV, SizeOf(ItalicLevelV));
    end
    else
    begin
      ItalicLevelH := 0.5;
      ItalicLevelV := 0.5;
    end;
    if version > FILEVERSION_106 then
      s.Read(Filled, SizeOf(Filled))
    else
      Filled := True;

    s.Read(len, SizeOf(len));
    SetLength(Text, len);
    for i := 1 to len do
      s.Read(Text[i], SizeOf(Text[i]));
  end;
  CreateInitialVertexes;
  ApplyInfoToVertexes;
end;
{$ENDIF}

procedure TD3DText.LoadFromStream(s: TStream; version: integer);
var i: integer;
    len: word;
begin
  Inherited LoadFromStream(s, version);
{$IFNDEF NO_OLDSTREAMINGRUTINES}
  if version < FILEVERSION_107 then
    OldLoadFromStream(s, version)
  else {$ENDIF} with Info do
  begin
    s.Read(key, SizeOf(key));
    s.Read(frontC, SizeOf(frontC));
    s.Read(backC, SizeOf(backC));
    s.Read(u, SizeOf(u));
    s.Read(v, SizeOf(v));
    s.Read(du, SizeOf(du));
    s.Read(dv, SizeOf(dv));
    s.Read(backU, SizeOf(backU));
    s.Read(backV, SizeOf(backV));
    s.Read(NumTextures, SizeOf(NumTextures));
    s.Read(zOrder, SizeOf(zOrder));
    s.Read(Interval, SizeOf(Interval));
    s.Read(x, SizeOf(x));
    s.Read(y, SizeOf(y));
    s.Read(z, SizeOf(z));
    s.Read(dx, SizeOf(dx));
    s.Read(dy, SizeOf(dy));
    s.Read(dz, SizeOf(dz));
    s.Read(Width, SizeOf(Width));
    s.Read(Height, SizeOf(Height));
    s.Read(Depth, SizeOf(Depth));
    s.Read(Transparency, SizeOf(Transparency));
    s.Read(ConnectBackWithFront, SizeOf(ConnectBackWithFront));
    s.Read(ItalicLevelH, SizeOf(ItalicLevelH));
    s.Read(ItalicLevelV, SizeOf(ItalicLevelV));
    s.Read(Filled, SizeOf(Filled));
    s.Read(len, SizeOf(len));
    SetLength(Text, len);
    for i := 1 to len do
      s.Read(Text[i], SizeOf(Text[i]));
    CreateInitialVertexes;
    ApplyInfoToVertexes;
  end;
end;

function TD3DText.CurTextureName: string;
begin
  Result := Info.TextureNames[CurTextureIndex, 0];
end;

function TD3DText.CurTextureIndex: integer;
begin
  if (Info.Interval = 0) or (Info.NumTextures = 0) then
    Result := 0
  else
    Result := trunc(fTime * Info.NumTextures / Info.Interval) mod Info.NumTextures;
end;

function TD3DText.CalcDistance(const Position: TD3DVector): TD3DValue; register;
begin
  if Info.zOrder > 50000 then // ֿץסבםע, פבגםי, נפשלב
    Distance := Info.zOrder
  else
    Distance :=
      VectorMagnitude(
        VectorSub(
          MakeD3DVector(Info.x, Info.y, Info.z), Position));
  Result := Distance;
end;

function TD3DText.TextureName: string;
begin
  Result := Info.TextureNames[0, 0];
end;

procedure TD3DText.GetInfo(p: Pointer);
begin
  PD3DTextInfo(p)^ := Info;
end;

function TD3DText.GetLocatePosition(aDistance: TD3DValue): TD3DVector;
begin
  with info do
    Result := MakeD3DVector(x, y, z - aDistance);
end;

procedure TD3DText.ApplyLight(l: TD3DSceneLight);
var i: integer;
begin
  if l.IsAppliable(GetLocatePosition(0.0)) then
    for i := 0 to NumVertexes - 1 do
      l.ApplyToVertex(TheVertexes[i], TheInitialVertexes[i].color shr 8)
end;

// ֱסיטלע Vertexes פןץ בםפיךוילםןץ
function TD3DText.GetNumVertexes: integer;
begin
  if Info.Transparency < MAXTRANSPARENCYREPLICATION then
    Result := NumVertexes * Info.Transparency
  else if Textures[CurTextureIndex, 1] <> Textures[CurTextureIndex, 0] then
    Result := NumVertexes * 2
  else
    Result := NumVertexes;
end;

// ֱסיטלע װסיד‏םשם פןץ בםפיךוילםןץ
function TD3DText.GetNumTriangles: integer;
begin
  Result := GetNumVertexes div 3;
end;

procedure TD3DText.SizeNumVertexes(const NewSize: integer); // ִוףלו‎וי לםלח ףפןץע נםבךוע לו פב װD3DLVertex
begin
  if NumVertexes <> NewSize then
  begin
    if NumVertexes <> 0 then
    begin
      FreeMem(TheInitialVertexes, SizeOf(TD3DLVertex) * NumVertexes);
      FreeMem(TheVertexes, SizeOf(TD3DLVertex) * NumVertexes);
    end;
    NumVertexes := NewSize;
    GetMem(TheInitialVertexes, SizeOf(TD3DLVertex) * NumVertexes);
    GetMem(TheVertexes, SizeOf(TD3DLVertex) * NumVertexes);
  end;
end;
{$ENDIF}

{$IFNDEF NO_D3DBILLBOARDS}

{ *** TD3DBillBoard *** }
constructor TD3DBillBoard.Create(aDXDraw: TDXDraw; aTextures: TDirect3DPictures; aInfo: TD3DBillBoardInfo);
begin
  fTexture := TBitmap.Create;
  Info := aInfo;
  Textures := aTextures;
  Inherited Create(aDXDraw, nil);
end;

{$IFDEF DESIGNER}
function TD3DBillBoard.CanSaveVertexes: boolean;
begin
  Result := False;
end;

procedure TD3DBillBoard.SaveVertexes(fName: string);
var f: TFileStream;
    cc: TD3DCull;
    dd: TD3DPrimitiveType;
begin
  f := TFileStream.Create(fName, fmCreate or fmShareDenyWrite);
  try
    cc := D3DCULL_INVALID_0;
    dd := D3DPT_INVALID_0;
    f.Write(dd, SizeOf(dd));
    f.Write(cc, SizeOf(cc));
  finally
    f.Free;
  end;
end;

function TD3DBillBoard.RTL_CanBeRuntime: boolean;
begin
  Result := False;
end;

procedure TD3DBillBoard.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull);
begin
  DeclareSession := '';
  InitSession := '';
  DrawSession := '';
end;
{$ENDIF}

constructor TD3DBillBoard.CreateFromStream(s: TStream; aDXDraw: TDXDraw; aTextures: TDirect3DPictures; version: integer);
begin
  LoadFromStream(s, version);
  Create(aDXDraw, aTextures, Info);
end;

destructor TD3DBillBoard.Destroy;
begin
  fTexture.Width := 0;
  fTexture.Height := 0;
  fTexture.Free;
  Inherited Destroy;
end;

function TD3DBillBoard.IsIntersectWith(aObject: TD3DObject): boolean;
begin
  Result := aObject.InheritsFrom(TD3DBillBoard);
end;

function TD3DBillBoard.IsIntersectWith(aRadius: TD3DValue; aCenter: TD3DVector): boolean;
begin
  Result := aRadius >= MAX_SINGLE;
end;

procedure TD3DBillBoard.fCalcCenterAndRadius;
begin
  fCenter := NULLVECTOR;
  fRadius := MAXSINGLE;
end;

procedure TD3DBillBoard.InitParams;
var C: TColor;
    canv: TCanvas;
begin
{ ֱם פן נס‏פן texture וםבי nil פפו פן Info.C ךסבפוי פן קס‏לב פחע וניצםויבע
  היבצןסופיך ךסבפוי transparency information. }
  if Textures[0, 0] = nil then
  begin
    Graphic.Bitmap.Width := 2;
    Graphic.Bitmap.Height := 2;
    Graphic.Bitmap.PixelFormat := pf24bit;
    C := Info.C;
    canv := Graphic.Bitmap.Canvas;
    canv.Pixels[0, 0] := C;
    canv.Pixels[1, 0] := C;
    canv.Pixels[0, 1] := C;
    canv.Pixels[1, 1] := C;
    Textures[0, 0] := Graphic;
    Textures[0, 1] := Graphic;
    Info.NumTextures := 1; // ֱם פן נס‏פן Texture וםבי nil ץנןטפןץלו נשע הום קןץלו ככב Textures
  end
{ ִםןץלו לחהוםיךע פילע ףפיע היבףפףויע פןץ Graphic.Bitmap
  ָב פן קסחףילןנןיףןץלו דיב כודקן ךבפ פן Draw ‏ףפו םב וניכמןץלו:
    1. Transparent Draw פןץ Texture
    2. Non transparent Draw, בנכ‏ע לב וניצםויב לו קס‏לב Info.C }
  else
  begin
    Graphic.Bitmap.TransparentColor := Info.C;
    Graphic.Bitmap.Width := 0;
    Graphic.Bitmap.Height := 0;
  end;
// ִםןץלו ףפן fAngle היבצןסופיך פיל בנ בץפ פחע נבסבלפסןץ ףפחם נס‏פח ךכףח פחע
// SimpleRotate(), ח SimpleRotate() טב בםבכגוי םב טפוי פחם פיל ףפן fAngle & טב
// החליןץסדףוי פן fTexture;
  fAngle := 1.0;
  SimpleRotate(0.0);
end;

procedure TD3DBillBoard.Draw;
begin
  with DXDraw, Info do
  begin
    Surface.Canvas.StretchDraw(
      Rect(0, round(StartH*SurfaceHeight), SurfaceWidth, round(EndH*SurfaceHeight)),
      fTexture);
    Surface.Canvas.Release;
  end;
end;

procedure TD3DBillBoard.GetTextureNames(var s: TDXStringList);
var i: integer;
begin
  for i := 0 to Info.NumTextures - 1 do
  begin
    if Info.TextureNames[i, 0] <> '' then
      if s.IndexOf(Info.TextureNames[i, 0]) = -1 then
         s.Add(Info.TextureNames[i, 0]);
    if Info.TextureNames[i, 1] <> '' then
      if s.IndexOf(Info.TextureNames[i, 1]) = -1 then
         s.Add(Info.TextureNames[i, 1]);
  end;
end;

function TD3DBillBoard.IsIdentical(D3DSurface: TObject): boolean;
var inf: TD3DBillBoardInfo;
begin
  Result := False;
  if not Inherited IsIdentical(D3DSurface) then
    Exit;
  if D3DSurface is TD3DBillBoard then
  begin
    (D3DSurface as TD3DBillBoard).GetInfo(@inf);
    Result := (
      (inf.C = Info.C) and
      (inf.StartH = Info.StartH) and
      (inf.EndH = Info.EndH) and
      (inf.Interval = Info.Interval) and
      (inf.zOrder = Info.zOrder) and
      (inf.NumTextures = Info.NumTextures) and
      TextureNamesEqual(inf.TextureNames, Info.TextureNames, Info.NumTextures))
  end;
end;

function TD3DBillBoard.GetTypeID: byte;
begin
  Result := ID3D_Billboard;
end;

function TD3DBillBoard.GetKeyID: integer;
begin
  Result := Info.key;
end;

procedure TD3DBillBoard.SaveToStream(s: TStream);
begin
  Inherited SaveToStream(s);
  with Info do
  begin
    s.Write(key, SizeOf(key));
    s.Write(C, SizeOf(C));
    s.Write(StartH, SizeOf(StartH));
    s.Write(EndH, SizeOf(EndH));
    s.Write(Interval, SizeOf(Interval));
    s.Write(zOrder, SizeOf(zOrder));
    s.Write(NumTextures, SizeOf(NumTextures));
  end;
end;

{$IFNDEF NO_OLDSTREAMINGRUTINES}
procedure TD3DBillBoard.OldLoadFromStream(s: TStream; version: integer);
var si: ShortInt;
    intd: double;
begin
  with Info do
  begin
    s.Read(key, SizeOf(key));
    s.Read(C, SizeOf(C));
    s.Read(StartH, SizeOf(StartH));
    s.Read(EndH, SizeOf(EndH));
    if version >= FILEVERSION_100 then
      s.Read(Interval, SizeOf(Interval))
    else
    begin
      s.Read(Intd, SizeOf(Intd));
      Interval := intd;
    end;
    s.Read(zOrder, SizeOf(zOrder));
    if version >= FILEVERSION_100 then
      s.Read(NumTextures, SizeOf(NumTextures))
    else
    begin
      s.Read(si, SizeOf(si));
      NumTextures := si;
    end;
  end;
end;
{$ENDIF}

procedure TD3DBillBoard.LoadFromStream(s: TStream; version: integer);
begin
  Inherited LoadFromStream(s, version);
{$IFNDEF NO_OLDSTREAMINGRUTINES}
  if version < FILEVERSION then
    OldLoadFromStream(s, version)
  else {$ENDIF}
  begin
    with Info do
    begin
      s.Read(key, SizeOf(key));
      s.Read(C, SizeOf(C));
      s.Read(StartH, SizeOf(StartH));
      s.Read(EndH, SizeOf(EndH));
      s.Read(Interval, SizeOf(Interval));
      s.Read(zOrder, SizeOf(zOrder));
      s.Read(NumTextures, SizeOf(NumTextures));
    end;
  end;
end;

function TD3DBillBoard.CalcDistance(const Position: TD3DVector): TD3DValue; register;
begin
  Distance := Info.zOrder;
  Result := Distance;
end;

function TD3DBillBoard.TextureName: string;
begin
  Result := Info.TextureNames[0, 0];
end;

function TD3DBillBoard.CurTextureName: string;
begin
  Result := Info.TextureNames[CurTextureIndex, 0];
end;

function TD3DBillBoard.CurTextureIndex: integer;
begin
  if (Info.Interval = 0) or (Info.NumTextures = 0) then
    Result := 0
  else
    Result := trunc(fTime * Info.NumTextures / Info.Interval) mod Info.NumTextures;
end;

procedure TD3DBillBoard.GetInfo(p: Pointer);
begin
  PD3DBillboardInfo(p)^ := Info;
end;

procedure TD3DBillBoard.SimpleRotate(angle: single);
var l: integer;
    cur: SmallInt;
begin
  if abs(fAngle - angle) > 0.01 then // do not need to recalc for small changes
  begin
    fAngle := angle;
    cur := CurTextureIndex;
    if Textures[cur, 0].Width <> 0 then
    begin
      l := round((1 - (round(angle * g_RADTODEG) mod 90) /90) * Textures[cur, 0].Width) mod Textures[cur, 0].Width;
      fTexture.Width := Textures[cur, 0].Width;
      fTexture.Height := Textures[cur, 0].Height;
      fTexture.Canvas.CopyRect(Rect(0, 0, l, fTexture.Height),
                               Textures[cur, 0].Bitmap.Canvas,
                               Rect(fTexture.Width - l, 0, fTexture.Width, fTexture.Height));
      fTexture.Canvas.CopyRect(Rect(l, 0, fTexture.Width, fTexture.Height),
                               Textures[cur, 0].Bitmap.Canvas,
                               Rect(0, 0, fTexture.Width - l, fTexture.Height));
    end;
  end;
end;

function TD3DBillBoard.GetLocatePosition(aDistance: TD3DValue): TD3DVector;
begin
  Result := NULLVECTOR;
end;

procedure TD3DBillBoard.ApplyLight(l: TD3DSceneLight);
begin
end;

// ֱסיטלע Vertexes פןץ בםפיךוילםןץ
// ֿ ןסזןםפבע קסחףילןנןיו directdraw, קי Direct3D!
function TD3DBillBoard.GetNumVertexes: integer;
begin
  Result := 0;
end;

// ֱסיטלע װסיד‏םשם פןץ בםפיךוילםןץ
// ֿ ןסזןםפבע קסחףילןנןיו directdraw, קי Direct3D!
function TD3DBillBoard.GetNumTriangles: integer;
begin
  Result := 0;
end;
{$ENDIF}


{$IFNDEF NO_D3DSOUNDS}

// *** TD3DBaseAudio *** //

procedure TD3DBaseAudio.SetPosition(Value: TD3DVector);
begin
  if not VectorEquel(fPosition, Value) then
    fPosition := Value;
end;

procedure TD3DBaseAudio.SetRotation(Value: TD3DVector);
begin
  if not VectorEquel(fRotation, Value) then
    fRotation := Value;
end;

function TD3DBaseAudio.GetKeyID: integer;
begin
  Result := 0;
end;

function TD3DBaseAudio.GetTypeID: integer;
begin
  Result := ID3D_Abstract;
end;

procedure TD3DBaseAudio.Move(x, y, z: TD3DValue);
begin
  Move(MakeD3DVector(x, y, z));
end;

procedure TD3DBaseAudio.MoveTo(vM: TD3DVector);
begin
  Move(VectorSub(vM, fPosition));
end;

procedure TD3DBaseAudio.MoveTo(x, y, z: TD3DValue);
begin
  MoveTo(MakeD3DVector(x, y, z));
end;

procedure TD3DBaseAudio.Rotate(x, y, z: TD3DValue);
begin
  Rotate(MakeD3DVector(x, y, z));
end;

// *** TD3DSound ***

constructor TD3DSound.Create(aDXSound: TDXSound; aWave: TWaveStream; aInfo: TD3DSoundInfo; muted: boolean);
begin
  Inherited Create;
  inc(GlobalID);
  Info := aInfo;
  DXSound := aDXSound;
  Audio := TAudioStream.Create(DXSound.DSound);
  Audio.BufferLength := 1000;
  Audio.WaveStream := aWave;
  Audio.Looped := Info.Loop;
  fOriginalFrequence := Audio.Frequency;

  fOldDistance := GetDistance(MakeD3DVector(Info.x, Info.y, Info.z));
  fDistance := fOldDistance;

  fPosition := MakeD3DVector(Info.x, Info.y, Info.z);

  fStartTime := Time;
  fOldTime := 0.0;

  DoRecalc;
  if not muted then
    Play;
end;

constructor TD3DSound.CreateFromStream(s: TStream; aDXSound: TDXSound; aWave: TWaveStream; version: integer; muted: boolean = False);
begin
  LoadFromStream(s, version);
  Create(aDXSound, aWave, Info, muted);
end;

destructor TD3DSound.Destroy;
begin
  try
    pause;
    FreeAndNilSafe(Audio);
  finally
    Inherited;
  end;
end;

procedure TD3DSound.SaveToStream(s: TStream);
begin
  with Info do
  begin
    s.Write(Key, SizeOf(Key));
    s.Write(x, SizeOf(x));
    s.Write(y, SizeOf(y));
    s.Write(z, SizeOf(z));

    s.Write(DopplerEffectEnabled, SizeOf(DopplerEffectEnabled));
    if DopplerEffectEnabled then
      s.Write(SoundSpeed, SizeOf(SoundSpeed));

    s.Write(MaxHearAbility, SizeOf(MaxHearAbility));
    s.Write(Loop, SizeOf(Loop));
    s.Write(Enabled, SizeOf(Enabled));
  end;
end;

procedure TD3DSound.LoadFromStream(s: TStream; version: integer);
begin
  with Info do
  begin
    s.Read(Key, SizeOf(Key));
    s.Read(x, SizeOf(x));
    s.Read(y, SizeOf(y));
    s.Read(z, SizeOf(z));
    if version >= FILEVERSION_116 then
    begin
      s.Read(DopplerEffectEnabled, SizeOf(DopplerEffectEnabled));
      if DopplerEffectEnabled then
        s.Read(SoundSpeed, SizeOf(SoundSpeed))
      else
        SoundSpeed := 344.0 // װבק‎פחפב לופהןףחע קןץ ףפןם בסב ףפןץע 20 גבטלן‎ע וכףןץ (331,6 ףפןץע 0 גבטלן‎ע)
    end
    else
    begin
      DopplerEffectEnabled := False;
      SoundSpeed := 344.0 // װבק‎פחפב לופהןףחע קןץ ףפןם בסב ףפןץע 20 גבטלן‎ע וכףןץ
    end;

    s.Read(MaxHearAbility, SizeOf(MaxHearAbility));
    s.Read(Loop, SizeOf(Loop));
    s.Read(Enabled, SizeOf(Enabled));
  end;
end;

function TD3DSound.Time: Double;
var Freq, Time1: Int64;
begin
  if QueryPerformanceFrequency(Freq) then
    if Freq <> 0 then
      if QueryPerformanceCounter(Time1) then
      begin
        Result := Time1 / Freq - fStartTime;
        Exit;
      end;
  Result := (GetTickCount / 1000) - fStartTime;
end;

procedure TD3DSound.Play;
begin
  if Assigned(Audio) and (Info.Enabled) then
    Audio.Play;
end;

procedure TD3DSound.Pause;
begin
  if Assigned(Audio) then
    Audio.Stop;
end;

procedure TD3DSound.Move(vM: TD3DVector);
begin
  with Info do
  begin
    x := x + vM.x;
    y := y + vM.y;
    z := z + vM.z;
    DoRecalc;
  end;
end;

procedure TD3DSound.Rotate(vM: TD3DVector);
var mat: TD3DMatrix;
    v1,v2: TD3DVector;
begin
  GetRotationMatrix(mat, vM.x, vM.y, vM.z);
  with Info do
  begin
    v1 := MakeD3DVector(x, y, z);
    D3DMath_VectorMatrixMultiply(v2, v1, mat);
    x := v2.x;
    y := v2.y;
    z := v2.z;
  end;
end;

procedure TD3DSound.Stop;
begin
  Pause;
  Rewind;
end;

procedure TD3DSound.Rewind;
begin
  if Assigned(Audio) then
    Audio.Position := 0;
end;

function TD3DSound.GetDistance(aPosition: TD3DVector): TD3DValue;
begin
  Result := VectorMagnitude(MakeD3DVector(
    Info.x - aPosition.X,
    Info.y - aPosition.Y,
    Info.z - aPosition.Z));
end;

function TD3DSound.GetKeyID: integer;
begin
  Result := Info.Key;
end;

function TD3DSound.GetTypeID: integer;
begin
  Result := ID3D_Sound;
end;

procedure TD3DSound.DoRecalc;
// Value: ָףח בךסןבפ
var nowTime: double;
begin
  if Assigned(Audio) then
  begin
    fOldDistance := fDistance;
    fDistance := VectorMagnitude(VectorSub(fPosition, MakeD3DVector(Info.x, Info.y, Info.z)));

    if Info.DopplerEffectEnabled then
    begin
      nowTime := Time;

      if fDistance - fOldDistance = 0.0 then
        Audio.Frequency := fOriginalFrequence
      else if nowTime > fOldTime then
      begin
        Audio.Frequency := round(fOriginalFrequence * (
          (Info.SoundSpeed - (fDistance - fOldDistance) / (nowTime - fOldTime)) / Info.SoundSpeed));
      end;
      fOldTime := nowTime;
    end;

    if (fDistance < Info.MaxHearAbility) and (Info.MaxHearAbility > 0.0) then
    begin
      Audio.Volume := - round((fDistance/Info.MaxHearAbility)*5000); // 10000 -> factor דיב לושףח פןץ קןץ => -100dB
      Play;
    end
    else if Info.MaxHearAbility = 0.0 then
    begin
      Audio.Volume := 0;
      Play;
    end
    else
    begin
      Audio.Volume := -10000;
      Play;
    end;
  end;
end;

procedure TD3DSound.SetPosition(Value: TD3DVector);
begin
  if not VectorEquel(fPosition, Value) then
  begin
    fPosition := Value;
    DoRecalc;
  end
  else if Info.DopplerEffectEnabled then
  begin
    Audio.Frequency := fOriginalFrequence;
    fOldTime := Time;
    Play;
  end;
end;

procedure TD3DSound.SetRotation(Value: TD3DVector);
// Value: ֳשםב בךסןבפ
var diff: TD3DVector;
    a: single;
begin
  fRotation := Value;
  diff := VectorSub(fPosition, MakeD3DVector(Info.x, Info.y, Info.z));
  if (VectorMagnitude(diff) < Info.MaxHearAbility) and (Info.MaxHearAbility > 0) then
  begin
    if diff.z = 0 then
      a := -sin(fRotation.y) * cos(fRotation.z)
    else if diff.z < 0 then
      a := sin(ArcTan(diff.x/diff.z) - fRotation.y) * cos(fRotation.z)
    else
      a := sin(ArcTan(-(diff.x)/diff.z) + fRotation.y) * cos(fRotation.z);
    Audio.Pan := round(a * 2000);  // 10000 -> factor דיב לושףח פןץ קןץ => -100dB //DSBPAN_LEFT
  end;
end;

// *** TD3DTone *** //

constructor TD3DTone.Create(aInfo: TD3DToneInfo; muted: boolean=False);
begin
  Inherited Create;
  inc(GlobalID);
  Info := aInfo;
  ToneGenerator := TToneGen.Create(nil);
  ToneGenerator.Loop := Info.Loop;
  ToneGenerator.Async := True;
  ToneGenerator.Frequency := Info.Frequency;
  ToneGenerator.Duration := Info.Duration;
  ToneGenerator.Waveform := Info.Waveform;
  ToneGenerator.Attack := Info.Attack;
  ToneGenerator.Decay := Info.Decay;
  ToneGenerator.Sustain := Info.Sustain;
  ToneGenerator.Release := Info.Release;
  ToneGenerator.Resolution := Info.Resolution;
  ToneGenerator.Quality := Info.Quality;
  Prepare;
  if not muted then
    Play;
end;

constructor TD3DTone.CreateFromStream(s: TStream; version: integer; muted: boolean=False);
begin
  LoadFromStream(s, version);
  Create(Info, muted);
end;

destructor TD3DTone.Destroy;
begin
  Stop;
  ToneGenerator.Free;
  Inherited;
end;

procedure TD3DTone.SaveToStream(s: TStream);
begin
  s.Write(Info, SizeOf(Info));
end;

procedure TD3DTone.LoadFromStream(s: TStream; version: integer);
begin
  s.Read(Info, SizeOf(Info));
end;

procedure TD3DTone.SetPosition(Value: TD3DVector);
// Value: ָףח בךסןבפ
var dist: TD3DValue;
begin
  if not VectorEquel(fPosition, Value) then
  begin
    fPosition := Value;
    if Assigned(ToneGenerator) then
    begin
      dist := VectorMagnitude(VectorSub(fPosition, MakeD3DVector(Info.x, Info.y, Info.z)));
      if (dist < Info.MaxHearAbility) and (Info.MaxHearAbility > 0) then
      begin
        ToneGenerator.LeftVolume := round((1-dist/Info.MaxHearAbility)*100);
        ToneGenerator.RightVolume := round((1-dist/Info.MaxHearAbility)*100);
        Prepare;
        Play;
      end
      else
//        Pause;
    end;
  end;
end;

procedure TD3DTone.SetRotation(Value: TD3DVector);
begin
end;

procedure TD3DTone.Play;
begin
  if Assigned(ToneGenerator) then
    ToneGenerator.PlayADSR;
end;

procedure TD3DTone.Pause;
begin
  Stop;
end;

procedure TD3DTone.Stop;
begin
  if Assigned(ToneGenerator) then
    ToneGenerator.Stop;
end;

procedure TD3DTone.Rewind;
begin
  if Assigned(ToneGenerator) then
    ToneGenerator.Stop;
end;

procedure TD3DTone.Move(vM: TD3DVector);
begin
  with Info do
  begin
    x := x + vM.x;
    y := y + vM.y;
    z := z + vM.z;
  end;
end;

procedure TD3DTone.Rotate(vM: TD3DVector);
var mat: TD3DMatrix;
    v1,v2: TD3DVector;
begin
  GetRotationMatrix(mat, vM.x, vM.y, vM.z);
  with Info do
  begin
    v1 := MakeD3DVector(x, y, z);
    D3DMath_VectorMatrixMultiply(v2, v1, mat);
    x := v2.x;
    y := v2.y;
    z := v2.z;
  end;
end;

function TD3DTone.GetKeyID: integer;
begin
  Result := Info.Key;
end;

function TD3DTone.GetTypeID: integer;
begin
  Result := ID3D_Tone;
end;

function TD3DTone.GetDistance(aPosition: TD3DVector): TD3DValue;
begin
  Result := VectorMagnitude(MakeD3DVector(
    Info.x - aPosition.X,
    Info.y - aPosition.Y,
    Info.z - aPosition.Z));
end;

procedure TD3DTone.Prepare;
begin
  ToneGenerator.PrepareADSR;
end;
{$ENDIF}

// *** TCustomData ***
constructor TCustomData.Create(aInfo: TCustomDataInfo; aStream: TStream);
begin
  Inherited Create;
  fInfo := aInfo;
  fStream := aStream;
end;

constructor TCustomData.CreateFromStream(s: TStream; aStream: TStream; aPathToStream: string; version: integer);
begin
  LoadFromStream(s, version); // ִיבגזןץלו פן fInfo
  fInfo.PathToStream := aPathToStream;
  Create(fInfo, aStream);
end;

procedure TCustomData.SaveToStream(s: TStream);
begin
  s.Write(fInfo.Key, SizeOf(fInfo.Key));
end;

procedure TCustomData.LoadFromStream(s: TStream; version: integer);
begin
  s.Read(fInfo.Key, SizeOf(fInfo.Key));
end;

function TCustomData.GetTypeID: byte;
begin
  Result := ID3D_Custom
end;

function TCustomData.GetKeyID: integer;
begin
  Result := fInfo.key;
end;

{$IFNDEF NO_SCRIPTS}

// *** TScript ***
constructor TScript.Create(aInfo: TD3DScriptInfo; var aStream: TStream);
begin
  Inherited Create;
  fInfo := aInfo;
  aStream.Seek(0, soFromBeginning);
  SetLength(fText, aStream.Size);
  aStream.Read(fText[1], aStream.Size);
  FreeAndNilSafe(aStream);
end;

constructor TScript.CreateFromStream(s: TStream; aStream: TStream; version: integer);
begin
  LoadFromStream(s, version); // ִיבגזןץלו פן fInfo
  Create(fInfo, aStream);
end;

procedure TScript.SaveToStream(s: TStream);
begin
  s.Write(fInfo.Key, SizeOf(fInfo.Key));
  s.Write(fInfo.AttachedEvent, SizeOf(fInfo.AttachedEvent));
end;

procedure TScript.LoadFromStream(s: TStream; version: integer);
begin
  s.Read(fInfo.Key, SizeOf(fInfo.Key));
  s.Read(fInfo.AttachedEvent, SizeOf(fInfo.AttachedEvent));
end;

function TScript.GetTypeID: byte;
begin
  Result := ID3D_Script
end;

function TScript.GetKeyID: integer;
begin
  Result := fInfo.key;
end;
{$ENDIF}

{ *** TD3DAction *** }

constructor TD3DAction.Create(aInfo: TD3DActionInfo; aScene: TD3DScene);
begin
  fScene := aScene;
  fOldTime := fScene.Time;
  fHasExecute := False;
  fInfo := aInfo;
  Inherited Create;
end;

constructor TD3DAction.CreateFromStream(s: TStream; aScene: TD3DScene; version: integer);
begin
  LoadFromStream(s, version);
  Create(fInfo, aScene);
end;

function TD3DAction.GetRunTime: boolean;
begin
  Result := fInfo.RunTimeOnly
end;

procedure TD3DAction.LoadFromStream(s: TStream; version: integer);
begin
  s.Read(fInfo, SizeOf(fInfo) - SizeOf(fInfo.RunTimeOnly));
  fInfo.RunTimeOnly := False; // ֱנ פחם ףפידל נןץ היבגזופבי בנ Stream, הום פבם RunTime
end;

procedure TD3DAction.SaveToStream(s: TStream);
begin
  s.Write(fInfo, SizeOf(fInfo) - SizeOf(fInfo.RunTimeOnly));
end;

function TD3DAction.GetTypeID: integer;
begin
  Result := fInfo.ActionID;
end;

function TD3DAction.GetKeyID: integer;
begin
  Result := fInfo.ActionKey;
end;

procedure TD3DAction.Execute;
begin
  if ((fScene.Time - fOldTime) > fScene.UpdateTolerance) or not fHasExecute then // UpdateTolerance ךבס / sec דיב םב קןץלו ךבכ ךםחףח
  begin
    fHasExecute := True;
    with fInfo do
    begin
      factor := (fScene.Time - fOldTime) / Secs;
      case ActionID of
        ID3D_Rotator:
          begin
            fLastRotationVector :=
              MakeD3DVector(
                RotationVector.x * factor,
                RotationVector.y * factor,
                RotationVector.z * factor);
            fScene.RotateObjects(ID, key,
              fLastRotationVector.x, fLastRotationVector.y, fLastRotationVector.z);
          end;
        ID3D_Mover:
          begin
            fLastPositionVector :=
              MakeD3DVector(
                PositionVector.x * factor,
                PositionVector.y * factor,
                PositionVector.z * factor);
            fScene.MoveObjects(ID, key,
              fLastPositionVector.x, fLastPositionVector.y, fLastPositionVector.z);
          end;
        ID3D_RotatorAround:
          begin
            fLastRotationVector :=
              MakeD3DVector(
                RotationVector.x * factor,
                RotationVector.y * factor,
                RotationVector.z * factor);
            fScene.RotateObjectsAround(ID, key,
              PositionVector.x, PositionVector.y, PositionVector.z,
              fLastRotationVector.x, fLastRotationVector.y, fLastRotationVector.z);
          end;
      else
      end;
    end;
    fOldTime := fScene.Time;
  end;
end;

// **** TSceneFPSReporter
constructor TSceneFPSReporter.Create;
begin
  Inherited Create;
  fInitialized := False;
  icount := 0;
  fFPS:= 0.0;
end;

function TSceneFPSReporter.fCalcFPS(History: integer): TD3DValue;
var i: integer;
    sum: TD3DValue;
begin
  if (History > MAXFPSHISTORY) or (History < 0) then
    raise Exception.Create('TFPSReporter.fCalcFPS() -> Invalid Parameter');
  sum := 0.0;
  for i := 0 to History - 1 do
    sum := sum + fFPSArray[i];
  Result := sum / History;
end;

procedure TSceneFPSReporter.AddFPS(aFPS: TD3DValue);
begin
  if icount = MAXFPSHISTORY then
  begin
    icount := 0;
    fInitialized := True;
    fFPS := fCalcFPS(MAXFPSHISTORY);
  end;
  fFPSArray[icount] := aFPS;
  inc(icount);
end;

function TSceneFPSReporter.FPS: TD3DValue;
begin
  if fInitialized then
    Result := fFPS
  else if icount > 0 then
    Result := fCalcFPS(icount)
  else
    Result := 0.0;
end;

// *** TD3DScene ***
constructor TD3DScene.Create(aDXDraw: TDXDraw; {$IFNDEF NO_D3DSOUNDS}aDXSound: TDXSound; {$ENDIF}aAttached: boolean = False);
{$IFNDEF NO_SCRIPTS}
var i: integer;
begin
  Inherited Create(ADXDraw, nil);
  for i := 0 to AttachedEventsCount - 1 do FutureProcList[i] := nil;
{$ELSE}
begin
  Inherited Create(ADXDraw, nil);
{$ENDIF}
  fPauseDelta := 0.0;
  fPaused := False;
  fPausedStartTime := 0.0;
{$IFNDEF NO_AVI}
  if fAttached and (fParent <> nil) then
    AVIPlayer := fParent.AVIPlayer
  else
    AVIPlayer := nil;
{$ENDIF}
  fThreadLevel := 0;
  fSpeed := 0.0;
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
  _CurrentSectorIndex := -1;
  _NeedsPositionRecalcFromSectorCollection := True;
{$ENDIF}
{$IFDEF DESIGNER}
  UndoStack := TUndoStack.Create;
  RedoStack := TRedoStack.Create;
  CanSaveUndo := True;
{$ENDIF}
  fUpdateTolerance := 1/100; // 100 ךבס / sec
  fIsDrawing := False;
  fNeedsRecalc := 0;
{$IFNDEF NO_SCRIPTS}
  IsScriptStarting := False;
  IsScriptFinishing := False;
  iStatus := iStopped;
  ScriptEngine := TD3DSceneScriptEngine.Create(nil, self);
  CurrentScriptEngine := ScriptEngine;
{$ENDIF}
  fAttached := aAttached;
{$IFNDEF NO_D3DSOUNDS}
  fMute := False;
{$ENDIF}
  fPosition := NULLVECTOR;
  fRotation := NULLVECTOR;
  fOldPosition := NULLVECTOR;
  fOlderPosition := NULLVECTOR;
  fOldRotation := NULLVECTOR;
  fOldTime := -1 / 1000; // Avoid fOldTime = fTime
  fStartTime := GetTickCount / 1000;
  fLastTime := -2 * fUpdateTolerance; // ¿ףפו םב דםוי recalc ךבפ פחם נס‏פח צןס
  DXDraw := aDXDraw;
{$IFNDEF NO_D3DSOUNDS}
  DXSound := aDXSound;
{$ENDIF}
  Surfaces := TDXStringList.Create;
{$IFNDEF NO_D3DSOUNDS}
  Sounds := TDXStringList.Create;
{$ENDIF}
  CustomData := TDXStringList.Create;
  Actions := TDXStringList.Create;
{$IFNDEF NO_SCRIPTS}
  Scripts := TDXStringList.Create;
{$ENDIF}
  Lights := TDXStringList.Create;
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
  _CacheSectorCollections := TDXStringList.Create;
{$ENDIF}
{$IFNDEF NO_D3DBILLBOARDS}
  _CacheBillBoards := TDXStringList.Create;
{$ENDIF}
  _CacheNestedScenes := TDXStringList.Create;
{$IFNDEF NO_D3DPLUGINS}
  _CachePlugIns := TDXStringList.Create;
{$ENDIF}
  _CacheRotatingObjects := TDXStringList.Create;
  fImageLoader := TImage.Create(nil);
  if fAttached and (fParent <> nil) then
  begin
    FPSReporter := fParent.FPSReporter;
    fMaxPolygonVertexes := fparent.MaxPolygonVertexes;
    fNearClippingPlane := fParent.NearClippingPlane;
    fDoSquareBitmaps := fParent.DoSquareBitmaps;
{$IFNDEF NO_D3DSOUNDS}
    fForceWavesInMemory := fParent.ForceWavesInMemory;
{$ENDIF}
{$IFNDEF NO_SCRIPTS}
    fEventsEnabled := fParent.EventsEnabled;
{$ENDIF}
    fTextureQuality := fParent.TextureQuality;
    Textures := fParent.Textures;
{$IFNDEF NO_D3DSOUNDS}
    Waves := fParent.Waves;
{$ENDIF}
    Streams := fParent.Streams;
    SearchPaths := fParent.SearchPaths;
{$IFNDEF NO_D3DACTORS}
    Models := fParent.Models;
{$ENDIF}
  end
  else
  begin
    FPSReporter := TSceneFPSReporter.Create;
    fParent := nil;
    fMaxPolygonVertexes := MAXVERTEXES;
    fDoSquareBitmaps := True;
{$IFNDEF NO_D3DSOUNDS}
    fForceWavesInMemory := False;
{$ENDIF}
    fNearClippingPlane := 0.05; // Default Near Clipping Plane
{$IFNDEF NO_SCRIPTS}
    fEventsEnabled := True;
{$ENDIF}
    fTextureQuality := tq100;
    FillChar(Info, SizeOf(Info), Chr(0));
    Textures := TDXStringList.Create;
{$IFNDEF NO_D3DSOUNDS}
    Waves := TDXStringList.Create;
{$ENDIF}
    Streams := TDXStringList.Create;
    SearchPaths := TDXStringList.Create;
{$IFNDEF NO_D3DACTORS}
    Models := TDXStringList.Create;
{$ENDIF}
  end;
  New;
  InvokeWAD := False;
  InvokeResource := False;
end;

procedure TD3DScene.SetMaxPolygonVertexes(Value: integer);
var i: integer;
begin
  if Value <> fMaxPolygonVertexes then
  begin
    fMaxPolygonVertexes := Value;
    for i := 0 to _CacheNestedScenes.Count - 1 do
      (_CacheNestedScenes.Objects[i] as TD3DScene).MaxPolygonVertexes := Value;
    for i := 0 to Surfaces.Count - 1 do
      if (Surfaces.Objects[i] is TD3DPolygon) then
        (Surfaces.Objects[i] as TD3DPolygon).MaxPolygonVertexes := Value;
  end;
end;

function TD3DScene.GetThreadLevel: byte;
begin
  if fAttached and (fParent <> nil) then
    Result := fParent.GetThreadLevel
  else
    Result := fThreadLevel;
end;

procedure TD3DScene.StopFog;
var dev: IDirect3DDevice7;
begin

  if Assigned(DXDraw) then
  begin
    dev := DXDraw.D3DDevice7;
    if Assigned(dev) then
    begin
      dev.SetRenderState(D3DRENDERSTATE_FOGENABLE, 0);
      dev.SetRenderState(D3DRENDERSTATE_FOGVERTEXMODE, ord(D3DFOG_NONE));
      dev.SetRenderState(D3DRENDERSTATE_FOGTABLEMODE, ord(D3DFOG_NONE));
    end;
  end;
end;

function TD3DScene.StartFog(color: TColor; Alfa: byte;
      fStart, fEnd: TD3DValue; fDensity: TD3DValue): boolean; // ִןךילזוי TABLE_EXP, TABLE_LINEAR ךבי פכןע VERTEXFOG
begin
  Result := True;
  if not StartTableFog(color, alfa, fStart, fEnd, fDensity, D3DFOG_EXP) then
    if not StartTableFog(color, alfa, fStart, fEnd, fDensity, D3DFOG_LINEAR) then
      Result := StartVertexFog(color, alfa, fStart, fEnd);
end;

function TD3DScene.StartVertexFog(color: TColor; Alfa: byte; fStart, fEnd: TD3DValue): boolean;
var
  Desc: TD3DDeviceDesc7;
  m_bCanDoFogRange: boolean;
  s, e: DWORD;
  dev: IDirect3DDevice7;
begin
  if not Assigned(DXDraw) then
  begin
    Result := False;
    Exit;
  end;
  dev := DXDraw.D3DDevice7;
  if not Assigned(dev) then
  begin
    Result := False;
    Exit;
  end;

  dev.GetCaps(Desc);
  Result := bool(Desc.dpcTriCaps.dwRasterCaps and D3DPRASTERCAPS_FOGVERTEX);

  if not Result then
    Exit;

  // Enable fog blending.
  dev.SetRenderState(D3DRENDERSTATE_FOGENABLE, 1);

  // Set the fog color.
  dev.SetRenderState(D3DRENDERSTATE_FOGCOLOR, CA_MAKE(color, Alfa));

  m_bCanDoFogRange  := bool(Desc.dpcTriCaps.dwRasterCaps and D3DPRASTERCAPS_FOGRANGE);

  s := PDWORD(@fStart)^;
  e := PDWORD(@fEnd)^;

  dev.SetRenderState(D3DRENDERSTATE_FOGSTART, s);
  dev.SetRenderState(D3DRENDERSTATE_FOGEND, e);
  dev.SetRenderState(D3DRENDERSTATE_FOGTABLEMODE, ord(D3DFOG_NONE));
  //vertex fog use always LINEAR mode (D3DFOG_LINEAR)
  dev.SetRenderState(D3DRENDERSTATE_FOGVERTEXMODE, ord(D3DFOG_LINEAR));

  if m_bCanDoFogRange then
    dev.SetRenderState(D3DRENDERSTATE_RANGEFOGENABLE, 1);
end;

function TD3DScene.StartTableFog(color: TColor; Alfa: byte; fStart, fEnd: TD3DValue; fDensity: TD3DValue; mode: TD3DFogMode): boolean;
var
  Desc: TD3DDeviceDesc7;
  m_bCanDoFogRange: boolean;
  s, e: DWORD;
  ss, se: TD3DValue;
  dev: IDirect3DDevice7;
begin
  if not Assigned(DXDraw) then
  begin
    Result := False;
    Exit;
  end;
  dev := DXDraw.D3DDevice7;
  if not Assigned(dev) then
  begin
    Result := False;
    Exit;
  end;

  dev.GetCaps(Desc);
  Result := bool(Desc.dpcTriCaps.dwRasterCaps and D3DPRASTERCAPS_FOGTABLE) and (fEnd > 0);

  if not Result then
    Exit;

  // Enable fog blending.
  dev.SetRenderState(D3DRENDERSTATE_FOGENABLE, 1);

  // Set the fog color.
  dev.SetRenderState(D3DRENDERSTATE_FOGCOLOR, CA_MAKE(color, Alfa));

  ss := fStart;
  se := fEnd;

  if (se > 1.0) or (ss > 1.0) or (se > ss) then
  begin
    ss := Min(ss, se)/Max(ss, se);
    se := 1.0;
  end;
  s := PDWORD(@ss)^;
  e := PDWORD(@se)^;

  // Set fog parameters.
  dev.SetRenderState(D3DRENDERSTATE_FOGSTART, s);
  dev.SetRenderState(D3DRENDERSTATE_FOGEND, e);

  dev.SetRenderState(D3DRENDERSTATE_FOGDENSITY, PDWORD(@fDensity)^);
  dev.SetRenderState(D3DRENDERSTATE_FOGVERTEXMODE, ord(D3DFOG_NONE));
  //Setup table fog to use EXP mode (D3DFOG_EXP)
  dev.SetRenderState(D3DRENDERSTATE_FOGTABLEMODE, ord(mode));

  m_bCanDoFogRange  := bool(Desc.dpcTriCaps.dwRasterCaps and D3DPRASTERCAPS_FOGRANGE);

  if m_bCanDoFogRange then
    dev.SetRenderState(D3DRENDERSTATE_RANGEFOGENABLE, 1);

end;

{$IFNDEF NO_AVI}
function TD3DScene.PlayAVI(const FileName: string): boolean;
var
  r: TScreenRect;
begin
  if AVIPlayer = nil then
  begin
    AVIPlayer := TSilleXAVI.Create(nil);
////    AVIPlayer.MovieOptions := VideoOnly; /////////////////////////////////////
    AVIPlayer.OnVideoStop := OnFreeAVIPlayer;
    AVIPlayer.DXDraw := DXDraw;
{$IFNDEF NO_D3DSOUNDS}
    AVIPlayer.DXSound := DXSound;
{$ENDIF}
    AVIPlayer.FileName := GetExistedFileName(FileName);
    if FileExists(AVIPlayer.FileName) then
    begin
      r := TScreenRect.Create;
      try
        r.Left := 0;
        r.Top := 0;
        r.Right := DXDraw.SurfaceWidth;
        r.Bottom := DXDraw.SurfaceHeight;
        AVIPlayer.DestinationRectangle := r;
      finally
        r.Free;
      end;
    //  AVIPlayer.SetDisplay(FullScreen);
      Result := AVIPlayer.Play;
      if not Result then
      begin
        StopAVI;
        Draw;
      end;
    end
    else
      Result := False;
  end
  else
  begin
    StopAVI;
    Draw; // Force the FutureFunctionCall which free the avi to play
    Result := PlayAVI(FileName);
  end;
end;

procedure FreeAviPlayer; stdcall;
begin
  if ActiveScene <> nil then
  begin
    FreeAndNilSafe(ActiveScene.AVIPlayer);
    ActiveScene := nil;
  end;
end;

const
  rsFreeAviPlayer = 'FreeAviPlayer';

procedure TD3DScene.OnFreeAVIPlayer(sender: TObject);
var
  tmp: TD3DScene;
begin
  tmp := ActiveScene;
  ActiveScene := self;
  try
    AddFutureProc(rsFreeAviPlayer, ID3D_EVENTONBEFOREDRAW, 0.0);
  finally
    ActiveScene := tmp;
  end;
end;

procedure TD3DScene.StopAVI;
begin
  if AVIPlayer <> nil then
    AVIPlayer.Stop;
end;

function TD3DScene.IsPlayingAVI: boolean;
begin
  if AVIPlayer <> nil then
    Result := AVIPlayer.Playing
  else if fParent <> nil then
    Result := fParent.IsPlayingAVI
  else
    Result := False;
end;

{$ENDIF}

{$IFDEF DESIGNER}
procedure TD3DScene.ClearUndoRedo;
begin
  UndoStack.Clear;
  RedoStack.Clear;
end;

procedure TD3DScene.Undo;
var mRedo, mUndo: TMemoryStream;
    flag: boolean;
begin
  if CanUndo then
  begin
    flag := CanSaveUndo;
    CanSaveUndo := False;
    mUndo := TMemoryStream.Create;
    mRedo := TMemoryStream.Create;
    try
      SaveToStream(mRedo);
      RedoStack.Push(mRedo);
      UndoStack.Pop(mUndo);
      FastLoadFromStream(mUndo);
    finally
      ClearMemoryStream(mUndo);
      ClearMemoryStream(mRedo);
    end;
    CanSaveUndo := flag;
  end;
end;

procedure TD3DScene.Redo;
var
  mRedo, mUndo: TMemoryStream;
  flag: boolean;
begin
  if CanRedo then
  begin
    flag := CanSaveUndo;
    CanSaveUndo := False;
    mUndo := TMemoryStream.Create;
    mRedo := TMemoryStream.Create;
    try
      SaveToStream(mUndo);
      UndoStack.Push(mUndo);
      RedoStack.Pop(mRedo);
      FastLoadFromStream(mRedo);
    finally
      ClearMemoryStream(mUndo);
      ClearMemoryStream(mRedo);
    end;
    CanSaveUndo := flag;
  end;
end;            

function TD3DScene.CanUndo: boolean;
begin
  if Assigned(UndoStack) then
    Result := not UndoStack.Empty
  else
    Result := False;
end;

function TD3DScene.CanRedo: boolean;
begin
  if Assigned(RedoStack) then
    Result := not RedoStack.Empty
  else                          
    Result := False;
end;

procedure TD3DScene.SaveUndo;
var
  m: TMemoryStream;
begin
  if CanSaveUndo then
  begin
    m := TMemoryStream.Create;
    try
      SaveToStream(m);
      UndoStack.Push(m);
    finally
      ClearMemoryStream(m);
    end;
    RedoStack.Clear;
  end;
end;

function TD3DScene.CanSaveVertexes: boolean;
begin
  Result := False;
end;

procedure TD3DScene.SaveVertexes(fName: string);
var
  f: TFileStream;
  cc: TD3DCull;
  dd: TD3DPrimitiveType;
begin
  f := TFileStream.Create(fName, fmCreate or fmShareDenyWrite);
  try
    cc := D3DCULL_INVALID_0;
    dd := D3DPT_INVALID_0;
    f.Write(dd, SizeOf(dd));
    f.Write(cc, SizeOf(cc));
  finally
    f.Free;
  end;
end;

function TD3DScene.RTL_CanBeRuntime: boolean;
begin
  Result := False;
end;

procedure TD3DScene.RTL_GetRunTimeCode(out DeclareSession, InitSession, DrawSession, DoneSession: string;
      ComplexityLevel: integer; ComplexityDistance: TD3DValue; tLights: TDXStringList;
      doTexture: boolean; var curCull: TD3DCull);
var
  i: integer;
  Declare_Str, Init_Str, Draw_Str, Done_Str: string;
  lastTexture: string;
  obj: TObject;
begin
  DeclareSession := NL;
  InitSession := NL + '    Scene.InvokeResource := True;' + NL + NL;
  DrawSession := NL;
  DoneSession := NL;
  lastTexture := '';
  Surfaces.Sort;
  for i := 0 to Surfaces.Count - 1 do
  begin
    obj := Surfaces.Objects[i];
    if (obj as TD3DObject).RTL_CanBeRuntime then
    begin
      (obj as TD3DObject).
        RTL_GetRunTimeCode(Declare_Str, Init_Str, Draw_Str, Done_Str,
          ComplexityLevel, ComplexityDistance, tLights,
          (lastTexture <> (obj as TD3DObject).TextureName) and doTexture,
          curCull);
      lastTexture := (obj as TD3DObject).TextureName;
      DeclareSession := DeclareSession + Declare_Str;
      InitSession := InitSession + Init_Str + NL;
      DrawSession := DrawSession + Draw_Str + NL;
      DoneSession := DoneSession + Done_Str + NL;
{$IFNDEF NO_MESSAGESCAN}
      MessageScan;
{$ENDIF}
    end;
  end;
  DeclareSession := DeclareSession + NL;
  InitSession := InitSession + NL + '    Scene.InvokeResource := False;' + NL;
  DrawSession := DrawSession + NL;
  DoneSession := DoneSession + NL;
end;

procedure TD3DScene.RTL_GetRCEntries(Path, Prefix: string; ID: integer; var sl: TDXStringList);

  procedure DoAdd(entry: string);
  var uEntry: string;
  begin
    uEntry := UpperCase(entry);
    if sl.IndexOf(uEntry) = -1 then
      sl.Add(uEntry);
  end;

var
  i: integer;
begin
  for i := 0 to _CacheNestedScenes.Count - 1 do
  begin
    DoAdd(
      Format(rsFmtRC,
       [GetExistedResourceEntry(_CacheNestedScenes.Strings[i]),
        UpperCase(ExtractFileExtention(_CacheNestedScenes.Strings[i])),
        FixBackSlash(_CacheNestedScenes.Strings[i])]
      ));
    (_CacheNestedScenes.Objects[i] as TD3DScene).RTL_GetRCEntries(Path, Prefix, ID, sl);
  end;

  if Textures.Count > 0 then
  begin
    sl.Add('');
    for i := 0 to Textures.Count - 1 do
      DoAdd(
        Format(rsFmtRC,
         [GetExistedResourceEntry(Textures.Strings[i]),
          UpperCase(ExtractFileExtention(Textures.Strings[i])),
          FixBackSlash(Textures.Strings[i])]
        ));
  end;
  if Waves.Count > 0 then
  begin
    sl.Add('');
    for i := 0 to Waves.Count - 1 do
      DoAdd(
        Format(rsFmtRC,
         [GetExistedResourceEntry(Waves.Strings[i]),
          rsRESWave,
          FixBackSlash(Waves.Strings[i])]
        ));
  end;
  if Scripts.Count > 0 then
  begin
    sl.Add('');
    for i := 0 to Scripts.Count - 1 do
      DoAdd(
        Format(rsFmtRC,
         [GetExistedResourceEntry(Scripts.Strings[i]),
          rsRESData,
          FixBackSlash(Scripts.Strings[i])]
        ));
  end;
  if CustomData.Count > 0 then
  begin
    sl.Add('');
    for i := 0 to CustomData.Count - 1 do
      DoAdd(
        Format(rsFmtRC,
         [GetExistedResourceEntry(CustomData.Strings[i]),
          rsRESData,
          FixBackSlash(CustomData.Strings[i])]
        ));
  end;
end;

procedure TD3DScene.RTL_CreateViewer(Path, Prefix: string; ID: integer; doProgramSource: boolean;
  ComplexityLevel: integer; ComplexityDistance: TD3DValue);
var
  Decl_Str, Init_Str, Draw_Str, Done_Str: string;
  s_Tmp: TDXStringList;
  strm: TStream;
  scn: TD3DScene;
  i: integer;
  lastCull: TD3DCull;
  rtl_lib: TRTLLibrary;
begin
  ForceDirectories(Path + '\' + prefix);
  lastCull := D3DCULL_INVALID_0;
  RTL_GetRunTimeCode(
    Decl_Str, Init_Str, Draw_Str, Done_Str,
    ComplexityLevel, ComplexityDistance, Lights,
    True, lastCull);
  s_Tmp := TDXStringList.Create;
  try
    s_Tmp.Text := Decl_Str;
    s_Tmp.SaveToFile(Path + '\' + prefix + '\decl' + IntToStr4(ID) + '.inc');
    s_Tmp.Text := Init_Str;
    s_Tmp.SaveToFile(Path + '\' + prefix + '\init' + IntToStr4(ID) + '.inc');
    s_Tmp.Text := Draw_Str;
    s_Tmp.SaveToFile(Path + '\' + prefix + '\draw' + IntToStr4(ID) + '.inc');
    s_Tmp.Text := Done_Str;
    s_Tmp.SaveToFile(Path + '\' + prefix + '\done' + IntToStr4(ID) + '.inc');

    if doProgramSource then
    begin
      rtl_lib := TRTLLibrary.Create(nil);
      try
        s_Tmp.Text := rtl_lib.GetScriptText('RTLdpr');
        s_Tmp.Strings[0] := 'program ' + prefix + ';';
        s_Tmp.SaveToFile(Path + '\' + prefix + '\' + prefix + '.dpr');
        s_Tmp.Text := rtl_lib.GetScriptText('RTLpfas');
        s_Tmp.SaveToFile(Path + '\' + prefix + '\Unit1.pas');
        s_Tmp.Text := rtl_lib.GetScriptText('RTLdfm');
        s_Tmp.SaveToFile(Path + '\' + prefix + '\Unit1.dfm');
        rtl_lib.RTLres.SaveToFile(Path + '\' + prefix + '\' + prefix + '.res');
      finally
        rtl_lib.Free;
      end;
    end;

    // Now prepare the resource script for our executable
    s_Tmp.Clear;

    // First add the Scene
    s_Tmp.Add(
      Format(rsFmtRC,
       ['Scene' + IntToStr4(ID),
        'D3D ',
        FixBackSlash(Path + '\' + prefix + '\Scene' + IntToStr4(ID) + '.d3d')]
      ));

    RTL_GetRCEntries(Path, Prefix, ID, s_Tmp);

    s_Tmp.SaveToFile(Path + '\' + prefix + '\resource' + IntToStr4(ID) + '.rc');
  finally
    s_Tmp.Free;
  end;

  strm := TMemoryStream.Create;
  scn := TD3DScene.Create(DXDraw, DXSound);
  try
    SaveToStream(strm);
    strm.Seek(0, soFromBeginning);
    scn.LoadFromStream(strm, FILEVERSION);
    scn.CanSaveUndo := False;
    for i := scn.Surfaces.Count - 1 downto 0 do
      if (scn.Surfaces.Objects[i] as TD3DObject).RTL_CanBeRuntime then
        scn.DeleteSurface(i);
    scn.SaveToFile(Path + '\' + prefix + '\Scene' + IntToStr4(ID) + '.d3d');
  finally
    strm.Free;
    scn.Free;
  end;
end;

{$ENDIF}

{$IFDEF DESIGNER}
procedure TD3DScene.RTL_CreatePlugIn(Path, Prefix: string);
var
  s_Tmp: TDXStringList;
  rtl_lib: TRTLLibrary;
begin
  s_Tmp := TDXStringList.Create;
  try
    rtl_lib := TRTLLibrary.Create(nil);
    try
      ForceDirectories(Path + '\' + prefix);
      s_Tmp.Text := rtl_lib.GetScriptText('PLUGINdpr');
      s_Tmp.Strings[0] := 'library ' + prefix + ';';
      s_Tmp.SaveToFile(Path + '\' + prefix + '\' + prefix + '.dpr');
      rtl_lib.PLUGINres.SaveToFile(Path + '\' + prefix + '\' + prefix + '.res');
    finally
      rtl_lib.Free;
    end;
  finally
    s_Tmp.Free;
  end;
end;
{$ENDIF} // IFDEF DESIGNER

constructor TD3DScene.CreateAttached(aInfo: TD3DSceneInfo; aScene: TD3DScene);
begin
  fThreadLevel := 0;
  fParent := aScene;
  Create(fParent.DXDraw, {$IFNDEF NO_D3DSOUNDS}fParent.DXSound, {$ENDIF}True);
{$IFNDEF NO_SCRIPTS}
  fOnScriptMessage := fParent.fOnScriptMessage;
  fOnScriptWarning := fParent.fOnScriptWarning;
  fOnScriptError := fParent.fOnScriptError;
{$ENDIF}
  Info := aInfo;
// ֱם PathToScene = '' פפו הום צןספ‏םןץלו
  if aInfo.PathToScene <> '' then
  begin
    if fParent.InvokeWAD then
//      LoadFromWadFile(fParent.fFileName, aInfo.PathToScene)
      LoadFromWadStream(fParent.WAD.Stream, 0, fParent.WAD.Stream.Size, aInfo.PathToScene)
    else if fParent.InvokeResource then
      LoadFromResource(aInfo.PathToScene)
    else
      LoadFromFile(aInfo.PathToScene);
  end;
  InitialRotate(MakeD3DVector(aInfo.dx, aInfo.dy, aInfo.dz));
  InitialMove(MakeD3DVector(aInfo.x, aInfo.y, aInfo.z));
  ForceRecalc;
end;

function TD3DScene.BoundingCube: TBoundingCube;
var
  i: integer;
  bc: TBoundingCube;
begin
  if fNeedsRadiusAndCenterRecalc then
  begin
    MakeEmptyBoundingCube(fBoundingCube);
    MakeEmptyBoundingCube(bc);
    for i := 0 to Surfaces.Count - 1 do
    begin
      bc := CombineBoundingCubes(fBoundingCube, (Surfaces.Objects[i] as TD3DObject).BoundingCube);
      fBoundingCube := bc;
    end;
  end;
  Result := fBoundingCube;
end;

procedure TD3DScene.fCalcCenterAndRadius;
begin
  BoundingCube;
  fCenter := MakeD3DVector(
                (fBoundingCube.maxX + fBoundingCube.minX) / 2,
                (fBoundingCube.maxY + fBoundingCube.minY) / 2,
                (fBoundingCube.maxZ + fBoundingCube.minZ) / 2);
  fRadius := Max(Max(
                (fBoundingCube.maxX - fBoundingCube.minX),
                (fBoundingCube.maxY - fBoundingCube.minY)),
                (fBoundingCube.maxZ - fBoundingCube.minZ)) / 2;
{  fRadius := Max(Max(
                (fBoundingCube.maxX + fBoundingCube.minX),
                (fBoundingCube.maxY + fBoundingCube.minY)),
                (fBoundingCube.maxZ + fBoundingCube.minZ)) / 2;}
{
  if fAttached then
    fCenter := MakeD3DVector(Info.x, Info.y, Info.z)
  else
    fCenter := NULLVECTOR;
  // fRadius := ?
}
end;

procedure TD3DScene.SetSafeMode(Value: boolean);
var i: integer;
begin
  if Value <> fSafeMode then
  begin
    for i := 0 to Surfaces.Count - 1 do
      (Surfaces.Objects[i] as TD3DObject).SafeMode := Value;
    fSafeMode := Value;
  end;
end;

procedure TD3DScene.InitParams;
begin
end;

destructor TD3DScene.Destroy;
begin
{$IFDEF DESIGNER}
  CanSaveUndo := False;
{$ENDIF}
{$IFNDEF NO_AVI}
  if fParent = nil then
    if AVIPlayer <> nil then
    begin
      AVIPlayer.OnVideoStop := nil;
      AVIPlayer.Stop;
      FreeAndNilSafe(AVIPlayer);
    end;
{$ENDIF}
{$IFNDEF NO_SCRIPTS}
  ScriptStopRun;
  StopScriptEngine;
{$ENDIF}
  Clear;
  FreeAndNilSafe(Surfaces);
{$IFNDEF NO_D3DSOUNDS}
  FreeAndNilSafe(Sounds);
{$ENDIF}
  FreeAndNilSafe(CustomData);
{$IFNDEF NO_SCRIPTS}
  FreeAndNilSafe(Scripts);
{$ENDIF}
  FreeAndNilSafe(Actions);
  FreeAndNilSafe(Lights);
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
  FreeAndNilSafe(_CacheSectorCollections);
{$ENDIF}
{$IFNDEF NO_D3DBILLBOARDS}
  FreeAndNilSafe(_CacheBillBoards);
{$ENDIF}
  FreeAndNilSafe(_CacheNestedScenes);
{$IFNDEF NO_D3DPLUGINS}
  FreeAndNilSafe(_CachePlugIns);
{$ENDIF}
  FreeAndNilSafe(_CacheRotatingObjects);
  if fParent = nil then
  begin
    FreeAndNilSafe(FPSReporter);
{$IFNDEF NO_D3DACTORS}
    FreeAndNilSafe(Models);
{$ENDIF}
    SearchPaths.Clear;
    FreeAndNilSafe(SearchPaths);
    FreeAndNilSafe(Textures);
{$IFNDEF NO_D3DSOUNDS}
    FreeAndNilSafe(Waves);
{$ENDIF}
    FreeAndNilSafe(Streams);
    FreeAndNilSafe(WAD);
  end;
{$IFNDEF NO_SCRIPTS}
  try
    ScriptEngine.Free;
  except
    raise Exception.Create(rsErrScriptEngineFree);
  end;
{$ENDIF}
{$IFDEF DESIGNER}
  UndoStack.Free;
  RedoStack.Free;
{$ENDIF}
  fImageLoader.Free;
  Inherited Destroy;
end;

procedure TD3DScene.Pause;
var Freq, Time1: Int64;
    i: integer;
begin
  if not fPaused then
  begin
    fPaused := True;
    fPausedStartTime := (GetTickCount/1000);
    if QueryPerformanceFrequency(Freq) then
      if Freq <> 0 then
        if QueryPerformanceCounter(Time1) then
          fPausedStartTime := Time1/Freq;
    for i := 0 to _CacheNestedScenes.Count - 1 do
      (_CacheNestedScenes.Objects[i] as TD3DScene).Pause
  end;
end;

procedure TD3DScene.Resume;
var
  Freq, Time1: Int64;
  i: integer;
  fResumeTime: double;
begin
  if fPaused then
  begin
    fPaused := False;
    fResumeTime := (GetTickCount/1000);
    if QueryPerformanceFrequency(Freq) then
      if Freq <> 0 then
        if QueryPerformanceCounter(Time1) then
          fResumeTime := Time1/Freq;
    fPauseDelta := fPauseDelta - fPausedStartTime + fResumeTime;
    for i := 0 to _CacheNestedScenes.Count - 1 do
      (_CacheNestedScenes.Objects[i] as TD3DScene).Resume
  end;
end;

// ֵניףפסצוי פב הוץפוסכונפב נןץ קןץם נוסףוי בנ פחם החליןץסדב פחע ףךחםע
function TD3DScene.Time: Double;
var
  Freq, Time1: Int64;
begin
  if QueryPerformanceFrequency(Freq) then
    if Freq <> 0 then
      if QueryPerformanceCounter(Time1) then
      begin
        Result := Time1/Freq - fStartTime - fPauseDelta;
        Exit;
      end;
  Result := (GetTickCount/1000) - fStartTime - fPauseDelta;
end;

procedure TD3DScene.Locate(obj: TD3DObject; distance: TD3DValue);
begin
  SetPosition(obj.GetLocatePosition(distance));
end;

procedure TD3DScene.GetInfo(p: Pointer);
begin
  PD3DSceneInfo(p)^ := Info;
end;

function TD3DScene.GetLocatePosition(aDistance: TD3DValue): TD3DVector;
begin
  Result := VectorSub(
    MakeD3DVector(Info.x, Info.y, Info.z),
    MakeD3DVector(fPosition.x, fPosition.y, fPosition.z - aDistance));
end;

function TD3DScene.DistanceFrom(aPos: TD3DVector): TD3DValue;
begin
  Result := VectorMagnitude(
    VectorSub(
      VectorSub(
        fPosition,
//        MakeD3DVector(fPosition.x, fPosition.y, fPosition.z),
        MakeD3DVector(Info.x, Info.y, Info.z)),
    aPos));
end;

function TD3DScene.DistanceFrom(aPosX, aPosY, aPosZ: TD3DValue): TD3DValue;
begin
  Result := VectorMagnitude(
    VectorSub(
      VectorSub(
        fPosition,
//        MakeD3DVector(fPosition.x, fPosition.y, fPosition.z),
        MakeD3DVector(Info.x, Info.y, Info.z)),
    MakeD3DVector(aPosX, aPosY, aPosZ)));
end;

function TD3DScene.GetNewGraphicFromFileName(var NewGraphic: TGraphic; const fName: string): boolean;
begin
  Result := GetNewGraphicFromFile(NewGraphic, fName);
end;

function ClosestPowerOf2(const x: integer): integer;
begin
  if x <= 2 then
    Result := 2
  else if x <= 4 then
    Result := 4
  else if x <= 8 then
    Result :=  8
  else if x <= 16 then
    Result := 16
  else if x <= 32 then
    Result := 32
  else if x <= 64 then
    Result := 64
  else if x <= 128 then
    Result := 128
  else if x <= 256 then
    Result := 256
  else if x <= 512 then
    Result := 512
  else if x <= 1024 then
    Result := 1024
  else if x <= 2048 then
    Result := 2048
  else if x <= 4096 then
    Result := 4096
  else if x <= 8192 then
    Result := 8192
  else if x <= 16384 then
    Result := 16384
  else if x <= 32768 then
    Result := 32768
  else
    Result := x;
end;

function LowestPowerOf2(const x: integer): integer;
begin
  if x < 4 then
    Result := 2
  else if x < 8 then
    Result := 4
  else if x < 16 then
    Result :=  8
  else if x < 32 then
    Result := 16
  else if x < 64 then
    Result := 32
  else if x < 128 then
    Result := 64
  else if x < 256 then
    Result := 128
  else if x < 512 then
    Result := 256
  else if x < 1024 then
    Result := 512
  else if x < 2048 then
    Result := 1024
  else if x < 4096  then
    Result := 2048
  else if x < 8192 then
    Result := 4096
  else if x < 16384 then
    Result := 8192
  else if x < 32768 then
    Result := 16384
  else if x < 65536 then
    Result := 32768
  else
    Result := x;
end;

function TD3DScene.AdjustImageDimentions(var w, h: integer): boolean;
// Calculate image dimentions as power of 2.
// Rerurns True if made changes to w, h
// 2018: Added larger image dimentions.
begin
  if w <> h then
  begin
    Result := True;
    if w > h then
      h := w
    else
      w := h;
  end
  else
    Result := False;
  Result := Result or not
        ((w =   2) or (w =   4) or (w =   8) or (w =  16) or (w =   32) or
         (w =  64) or (w = 128) or (w = 256) or (w = 512) or (w = 1024) or
         // 2018
         (w = 2048) or (w = 4096) or (w = 8192) or (w = 16384));
  if Result then // Change size
  begin
    if w <= 2 then w := 2
    else if w <= 4 then w := 4
    else if w <= 8 then w := 8
    else if w <= 16 then w := 16
    else if w <= 32 then w := 32
    else if w <= 64 then w := 64
    else if w <= 128 then w := 128
    else if w <= 256 then w := 256
    else if w <= 512 then w := 512
    else if w <= 1024 then w := 1024
    else if w <= 2048 then w := 2048
    else if w <= 4096 then w := 4096
    else if w <= 8192 then w := 8192
    else w := 16384;
    h := w;
  end;
end;

procedure TD3DScene.MakeSquareBitmap(bmp: TBitmap; hasImage: boolean);
var
  oldw, oldh, neww, newh: integer;
  bmp2: TBitmap;
begin
  if not fDoSquareBitmaps then Exit;
  if bmp <> nil then
  begin
    oldw := bmp.Width;
    oldh := bmp.Height;
    neww := oldw;
    newh := oldh;
    if AdjustImageDimentions(neww, newh) then
    begin
      bmp.Width := neww;
      bmp.Height := newh;
      if hasImage then
      begin
        bmp2 := TBitmap.Create;
        try
          bmp2.Assign(bmp);
          bmp2.Width := oldw - 1;
          bmp2.Height := oldh - 1;
          bmp2.Canvas.Draw(0, 0, bmp);
          // CopyRect(Rect(0, 0, oldw, oldh), bmp.Canvas, Rect(0, 0, oldw, oldh));
          bmp.Canvas.StretchDraw(Rect(0, 0, neww, newh), bmp2);
        finally
          bmp2.Width := 0;
          bmp2.Height := 0;
          bmp2.Free;
        end;
      end;
    end;
  end;
end;

procedure TD3DScene.MakePowerOf2Bitmap(bmp: TBitmap);
var
  oldw, oldh, neww, newh: integer;
  bmp2: TBitmap;
begin
  oldw := bmp.Width;
  oldh := bmp.Height;
  neww := ClosestPowerOf2(oldw);
  newh := ClosestPowerOf2(oldh);

{  neww := LowestPowerOf2(oldw);
  newh := LowestPowerOf2(oldh);}

  if (neww <> oldw) or (newh <> oldh) then
  begin
    bmp.Width := neww;
    bmp.Height := newh;

    bmp2 := TBitmap.Create;
    try
      bmp2.Assign(bmp);
      bmp2.Width := oldw;// - 1;  VJ ??????
      bmp2.Height := oldh;// - 1;
      bmp2.Canvas.Draw(0, 0, bmp);
      bmp.Canvas.StretchDraw(Rect(0, 0, neww, newh), bmp2);
    finally
{      bmp2.Width := 0;
      bmp2.Height := 0;}
      bmp2.Free;
    end;
  end;
end;

procedure TD3DScene.MakePowerOf2BitmapFast(var bmp: TBitmap);
var oldw, oldh, neww, newh: integer;
    bmp2: TBitmap;
begin
  oldw := bmp.Width;
  oldh := bmp.Height;
  neww := ClosestPowerOf2(oldw);
  newh := ClosestPowerOf2(oldh);

{  neww := LowestPowerOf2(oldw);
  newh := LowestPowerOf2(oldh);}

//  neww := 32;       //////////////////////
//  newh := 32;       //////////////////////

  if (neww <> oldw) or (newh <> oldh) then
  begin
    bmp2 := TBitmap.Create;
    try
      bmp2.Assign(bmp);
      bmp2.Width := neww;
      bmp2.Height := newh;
      bmp2.Canvas.StretchDraw(Rect(0, 0, neww, newh), bmp);
    finally
      bmp.Free;
    end;
    bmp := bmp2;
  end;
end;

function TD3DScene.MakePowerOf2TGAToBitmap(var tga: TTGABitmap): TBitmap;
var
  oldw, oldh, neww, newh: integer;
begin
  oldw := tga.Width;
  oldh := tga.Height;
  neww := ClosestPowerOf2(oldw);
  newh := ClosestPowerOf2(oldh);

  Result := TBitmap.Create;
  Result.Width := neww;
  Result.Height := newh;
  if (neww <> oldw) or (newh <> oldh) then
    Result.Canvas.StretchDraw(Rect(0, 0, neww, newh), tga)
  else
    Result.Canvas.Draw(0, 0, tga)
end;

procedure TD3DScene.MakePowerOf2BitmapFast(var tga: TTGABitmap);
var
  oldw, oldh, neww, newh: integer;
  tga2: TTGABitmap;
begin
  oldw := tga.Width;
  oldh := tga.Height;
  neww := ClosestPowerOf2(oldw);
  newh := ClosestPowerOf2(oldh);

  if (neww <> oldw) or (newh <> oldh) then
  begin
    tga2 := TTGABitmap.Create;
    try
      tga2.Assign(tga);
      tga2.Width := neww;
      tga2.Height := newh;
      tga2.Canvas.StretchDraw(Rect(0, 0, neww, newh), tga);
    finally
      tga.Free;
    end;
    tga := tga2;
  end;
end;

function IsSpecialTextureName(const tex: string): boolean;
begin
  if Length(tex) > 0 then
    Result := tex[1] = '$'
  else
    Result := False;
end;

function GetLinkEntryName(const inf: string): string;
var
  fFileName: string;
  Entry: string;
begin
  if GetWadLinkInfo(inf, fFileName, Entry) then
    Result := Entry
  else
    Result := inf;
end;

function TD3DScene.LoadTexture(var TextureName: string): boolean;
var
  s: TStream;
  NewGraphic: TGraphic;
  Ext: string;
  tmp: TPicture;
  uTextureName: string;
  IBitmap: TBitmap;
  ICanvas: TCanvas;
begin
  IBitmap := fImageLoader.Picture.Bitmap;
  ICanvas := IBitmap.Canvas;
  if fTextureQuality in [tqWireframe, tqPoint] then
  begin
    IBitmap.Width := 2;
    IBitmap.Height := 2;
    ICanvas.Pixels[0, 0] := clWhite;
    ICanvas.Pixels[1, 0] := clWhite;
    ICanvas.Pixels[0, 1] := clWhite;
    ICanvas.Pixels[1, 1] := clWhite;
    Result := True;
    Exit;
  end;
  if TrimStr(TextureName) = EmptyStr then
  begin
    Result := False;
    Exit;
  end;
{$IFNDEF NO_IDSOFTGAMESSUPPORT}
  uTextureName := UpperCase(GetLinkEntryName(TextureName));
//  uTextureName := UpperCase(GetWadLinkEntryName(TextureName));
{$ELSE}
  uTextureName := UpperCase(TextureName);
{$ENDIF}
  if IsSpecialTextureName(uTextureName) then
  begin
    if uTextureName = UpperCase(rsBlack) then
    begin
      IBitmap.PixelFormat := pf8bit;
      IBitmap.Width := 2;
      IBitmap.Height := 2;
      ICanvas.Pixels[0, 0] := clBlack;
      ICanvas.Pixels[1, 0] := clBlack;
      ICanvas.Pixels[0, 1] := clBlack;
      ICanvas.Pixels[1, 1] := clBlack;
      Result := True;
      Exit;
    end;
    if uTextureName = UpperCase(rsWhite) then
    begin
      IBitmap.PixelFormat := pf8bit;
      IBitmap.Width := 2;
      IBitmap.Height := 2;
      ICanvas.Pixels[0, 0] := clWhite;
      ICanvas.Pixels[1, 0] := clWhite;
      ICanvas.Pixels[0, 1] := clWhite;
      ICanvas.Pixels[1, 1] := clWhite;
      Result := True;
      Exit;
    end;
    if (Length(uTextureName) > 2) and (uTextureName[2] = 'G') then
    begin
      if uTextureName = UpperCase(rsGray1) then
      begin
        IBitmap.PixelFormat := pf24bit;
        IBitmap.Width := 2;
        IBitmap.Height := 2;
        ICanvas.Pixels[0, 0] := RGB(16, 16, 16);
        ICanvas.Pixels[1, 0] := RGB(16, 16, 16);
        ICanvas.Pixels[0, 1] := RGB(16, 16, 16);
        ICanvas.Pixels[1, 1] := RGB(16, 16, 16);
        Result := True;
        Exit;
      end;
      if uTextureName = UpperCase(rsGray2) then
      begin
        IBitmap.PixelFormat := pf24bit;
        IBitmap.Width := 2;
        IBitmap.Height := 2;
        ICanvas.Pixels[0, 0] := RGB(32, 32, 32);
        ICanvas.Pixels[1, 0] := RGB(32, 32, 32);
        ICanvas.Pixels[0, 1] := RGB(32, 32, 32);
        ICanvas.Pixels[1, 1] := RGB(32, 32, 32);
        Result := True;
        Exit;
      end;
      if uTextureName = UpperCase(rsGray3) then
      begin
        IBitmap.PixelFormat := pf24bit;
        IBitmap.Width := 2;
        IBitmap.Height := 2;
        ICanvas.Pixels[0, 0] := RGB(48, 48, 48);
        ICanvas.Pixels[1, 0] := RGB(48, 48, 48);
        ICanvas.Pixels[0, 1] := RGB(48, 48, 48);
        ICanvas.Pixels[1, 1] := RGB(48, 48, 48);
        Result := True;
        Exit;
      end;
      if uTextureName = UpperCase(rsGray4) then
      begin
        IBitmap.PixelFormat := pf24bit;
        IBitmap.Width := 2;
        IBitmap.Height := 2;
        ICanvas.Pixels[0, 0] := RGB(64, 64, 64);
        ICanvas.Pixels[1, 0] := RGB(64, 64, 64);
        ICanvas.Pixels[0, 1] := RGB(64, 64, 64);
        ICanvas.Pixels[1, 1] := RGB(64, 64, 64);
        Result := True;
        Exit;
      end;
      if uTextureName = UpperCase(rsGray5) then
      begin
        IBitmap.PixelFormat := pf24bit;
        IBitmap.Width := 2;
        IBitmap.Height := 2;
        ICanvas.Pixels[0, 0] := RGB(80, 80, 80);
        ICanvas.Pixels[1, 0] := RGB(80, 80, 80);
        ICanvas.Pixels[0, 1] := RGB(80, 80, 80);
        ICanvas.Pixels[1, 1] := RGB(80, 80, 80);
        Result := True;
        Exit;
      end;
      if uTextureName = UpperCase(rsGray6) then
      begin
        IBitmap.PixelFormat := pf24bit;
        IBitmap.Width := 2;
        IBitmap.Height := 2;
        ICanvas.Pixels[0, 0] := RGB(96, 96, 96);
        ICanvas.Pixels[1, 0] := RGB(96, 96, 96);
        ICanvas.Pixels[0, 1] := RGB(96, 96, 96);
        ICanvas.Pixels[1, 1] := RGB(96, 96, 96);
        Result := True;
        Exit;
      end;
      if uTextureName = UpperCase(rsGray7) then
      begin
        IBitmap.PixelFormat := pf24bit;
        IBitmap.Width := 2;
        IBitmap.Height := 2;
        ICanvas.Pixels[0, 0] := RGB(112, 112, 112);
        ICanvas.Pixels[1, 0] := RGB(112, 112, 112);
        ICanvas.Pixels[0, 1] := RGB(112, 112, 112);
        ICanvas.Pixels[1, 1] := RGB(112, 112, 112);
        Result := True;
        Exit;
      end;
      if uTextureName = UpperCase(rsGray8) then
      begin
        IBitmap.PixelFormat := pf24bit;
        IBitmap.Width := 2;
        IBitmap.Height := 2;
        ICanvas.Pixels[0, 0] := clGray;
        ICanvas.Pixels[1, 0] := clGray;
        ICanvas.Pixels[0, 1] := clGray;
        ICanvas.Pixels[1, 1] := clGray;
        Result := True;
        Exit;
      end;
      if uTextureName = UpperCase(rsGray9) then
      begin
        IBitmap.PixelFormat := pf24bit;
        IBitmap.Width := 2;
        IBitmap.Height := 2;
        ICanvas.Pixels[0, 0] := RGB(144, 144, 144);
        ICanvas.Pixels[1, 0] := RGB(144, 144, 144);
        ICanvas.Pixels[0, 1] := RGB(144, 144, 144);
        ICanvas.Pixels[1, 1] := RGB(144, 144, 144);
        Result := True;
        Exit;
      end;
      if uTextureName = UpperCase(rsGray10) then
      begin
        IBitmap.PixelFormat := pf24bit;
        IBitmap.Width := 2;
        IBitmap.Height := 2;
        ICanvas.Pixels[0, 0] := RGB(160, 160, 160);
        ICanvas.Pixels[1, 0] := RGB(160, 160, 160);
        ICanvas.Pixels[0, 1] := RGB(160, 160, 160);
        ICanvas.Pixels[1, 1] := RGB(160, 160, 160);
        Result := True;
        Exit;
      end;
      if uTextureName = UpperCase(rsGray11) then
      begin
        IBitmap.PixelFormat := pf24bit;
        IBitmap.Width := 2;
        IBitmap.Height := 2;
        ICanvas.Pixels[0, 0] := RGB(176, 176, 176);
        ICanvas.Pixels[1, 0] := RGB(176, 176, 176);
        ICanvas.Pixels[0, 1] := RGB(176, 176, 176);
        ICanvas.Pixels[1, 1] := RGB(176, 176, 176);
        Result := True;
        Exit;
      end;
      if uTextureName = UpperCase(rsGray12) then
      begin
        IBitmap.PixelFormat := pf24bit;
        IBitmap.Width := 2;
        IBitmap.Height := 2;
        ICanvas.Pixels[0, 0] := clLtGray;
        ICanvas.Pixels[1, 0] := clLtGray;
        ICanvas.Pixels[0, 1] := clLtGray;
        ICanvas.Pixels[1, 1] := clLtGray;
        Result := True;
        Exit;
      end;
      if uTextureName = UpperCase(rsGray13) then
      begin
        IBitmap.PixelFormat := pf24bit;
        IBitmap.Width := 2;
        IBitmap.Height := 2;
        ICanvas.Pixels[0, 0] := RGB(208, 208, 208);
        ICanvas.Pixels[1, 0] := RGB(208, 208, 208);
        ICanvas.Pixels[0, 1] := RGB(208, 208, 208);
        ICanvas.Pixels[1, 1] := RGB(208, 208, 208);
        Result := True;
        Exit;
      end;
      if uTextureName = UpperCase(rsGray14) then
      begin
        IBitmap.PixelFormat := pf24bit;
        IBitmap.Width := 2;
        IBitmap.Height := 2;
        ICanvas.Pixels[0, 0] := RGB(224, 224, 224);
        ICanvas.Pixels[1, 0] := RGB(224, 224, 224);
        ICanvas.Pixels[0, 1] := RGB(224, 224, 224);
        ICanvas.Pixels[1, 1] := RGB(224, 224, 224);
        Result := True;
        Exit;
      end;
      if uTextureName = UpperCase(rsGray15) then
      begin
        IBitmap.PixelFormat := pf24bit;
        IBitmap.Width := 2;
        IBitmap.Height := 2;
        ICanvas.Pixels[0, 0] := RGB(240, 240, 240);
        ICanvas.Pixels[1, 0] := RGB(240, 240, 240);
        ICanvas.Pixels[0, 1] := RGB(240, 240, 240);
        ICanvas.Pixels[1, 1] := RGB(240, 240, 240);
        Result := True;
        Exit;
      end;
    end;
    if uTextureName = UpperCase(rsInvalid) then
    begin
      IBitmap.PixelFormat := pf32bit;
      IBitmap.Width := 16;
      IBitmap.Height := 16;
      ICanvas.Pen.Width := 1;
      ICanvas.Pen.Color := RGB(32, 32, 32);
      ICanvas.Brush.Color := RGB(255, 128, 128);
      ICanvas.Rectangle(0, 0, 16, 16);

      ICanvas.Pixels[7, 4] := RGB(32, 32, 32);
      ICanvas.Pixels[7, 5] := RGB(32, 32, 32);
      ICanvas.Pixels[7, 6] := RGB(32, 32, 32);
      ICanvas.Pixels[7, 7] := RGB(32, 32, 32);
      ICanvas.Pixels[7, 10] := RGB(32, 32, 32);

      Result := True;
      Exit;
    end;
  end;

  Result := False;
  NewGraphic := nil;
  if InvokeWAD then
  begin
    TextureName := GetExistedWadEntry(TextureName);
    if Wad.EntryExist(TextureName) then
    begin
      s := TMemoryStream.Create;
      try
        WAD.CopyToStream(TextureName, s);
        if not GetNewGraphicFromFileName(NewGraphic, TextureName) then
          raise EInvalidGraphic.CreateFmt(rsInvalidGraphic, [TextureName]);
        if NewGraphic <> nil then
        try
          NewGraphic.LoadFromStream(s);
        except
          NewGraphic.Free;
          NewGraphic := TBitmap.Create;
          NewGraphic.Width := 2;
          NewGraphic.Height := 2;
          (NewGraphic as TBitmap).Canvas.Pixels[0, 0] := clBlack;
          (NewGraphic as TBitmap).Canvas.Pixels[0, 1] := clBlack;
          (NewGraphic as TBitmap).Canvas.Pixels[1, 0] := clBlack;
          (NewGraphic as TBitmap).Canvas.Pixels[1, 1] := clBlack;
//        raise;
        end
        else
        begin
          NewGraphic := TBitmap.Create;
          NewGraphic.Width := 2;
          NewGraphic.Height := 2;
          (NewGraphic as TBitmap).Canvas.Pixels[0, 0] := clBlack;
          (NewGraphic as TBitmap).Canvas.Pixels[0, 1] := clBlack;
          (NewGraphic as TBitmap).Canvas.Pixels[1, 0] := clBlack;
          (NewGraphic as TBitmap).Canvas.Pixels[1, 1] := clBlack;
        end;
        IBitmap.Width := NewGraphic.Width;
        IBitmap.Height := NewGraphic.Height;
        ICanvas.Draw(0, 0, NewGraphic);
        NewGraphic.Free;
        Result := True;
      finally
        s.Free;
      end;
    end;
  end;
  if not Result then // ֱם הום גסטחךו ףפן WAD,  בם הום ץנסקוי WAD
  begin
    TextureName := GetExistedFileName(TextureName);
    Result := FileExists(TextureName) and (Pos('::', TextureName) = 0);
    if not Result then
    begin
      if TextureName[1] = 'C' then
        TextureName[1] := 'D'
      else if TextureName[1] = 'D' then
        TextureName[1] := 'C';
      Result := FileExists(TextureName) and (Pos('::', TextureName) = 0);
    end;
    if Result then
    begin
      s := TFileStream.Create(TextureName, fmOpenRead or fmShareDenyWrite);
      try
        if not GetNewGraphicFromFileName(NewGraphic, TextureName) then
          raise EInvalidGraphic.CreateFmt(rsInvalidGraphic, [TextureName]);
        if NewGraphic <> nil then
        try
          NewGraphic.LoadFromStream(s);
        except
          NewGraphic.Free;
          NewGraphic := TBitmap.Create;
          NewGraphic.Width := 2;
          NewGraphic.Height := 2;
          (NewGraphic as TBitmap).Canvas.Pixels[0, 0] := clBlack;
          (NewGraphic as TBitmap).Canvas.Pixels[0, 1] := clBlack;
          (NewGraphic as TBitmap).Canvas.Pixels[1, 0] := clBlack;
          (NewGraphic as TBitmap).Canvas.Pixels[1, 1] := clBlack;
//          Result := False;
//          raise;
        end
        else
          begin
          NewGraphic := TBitmap.Create;
          NewGraphic.Width := 2;
          NewGraphic.Height := 2;
          (NewGraphic as TBitmap).Canvas.Pixels[0, 0] := clBlack;
          (NewGraphic as TBitmap).Canvas.Pixels[0, 1] := clBlack;
          (NewGraphic as TBitmap).Canvas.Pixels[1, 0] := clBlack;
          (NewGraphic as TBitmap).Canvas.Pixels[1, 1] := clBlack;
        end;
        IBitmap.Width := NewGraphic.Width;
        IBitmap.Height := NewGraphic.Height;
        IBitmap.Canvas.Draw(0, 0, NewGraphic);
        NewGraphic.Free;
      finally
        s.Free;
      end;
    end
  end;
  if (not Result) and InvokeResource then // ֱם הום גסטחךו ךבי צשספ‏םןץלו בנ resource
  begin
    TextureName := GetExistedResourceEntry(TextureName);
    Ext := ExtractFileExt(TextureName);
    Delete(Ext, 1, 1);
    if IsValidInteger(TextureName) then
      s := TResourceStream.CreateFromID(HInstance, StrToInt(TextureName), PChar(UpperCase(Ext)))
    else
      s := TResourceStream.Create(HInstance, TextureName, PChar(UpperCase(Ext)));
    try
      if not GetNewGraphicFromFileName(NewGraphic, TextureName) then
        raise EInvalidGraphic.CreateFmt(rsInvalidGraphic, [TextureName]);
      if NewGraphic <> nil then
      try
        NewGraphic.LoadFromStream(s);
      except
        NewGraphic.Free;
        NewGraphic := TBitmap.Create;
        NewGraphic.Width := 2;
        NewGraphic.Height := 2;
        (NewGraphic as TBitmap).Canvas.Pixels[0, 0] := clBlack;
        (NewGraphic as TBitmap).Canvas.Pixels[0, 1] := clBlack;
        (NewGraphic as TBitmap).Canvas.Pixels[1, 0] := clBlack;
        (NewGraphic as TBitmap).Canvas.Pixels[1, 1] := clBlack;
//        raise;
      end
      else
      begin
        NewGraphic := TBitmap.Create;
        NewGraphic.Width := 2;
        NewGraphic.Height := 2;
        (NewGraphic as TBitmap).Canvas.Pixels[0, 0] := clBlack;
        (NewGraphic as TBitmap).Canvas.Pixels[0, 1] := clBlack;
        (NewGraphic as TBitmap).Canvas.Pixels[1, 0] := clBlack;
        (NewGraphic as TBitmap).Canvas.Pixels[1, 1] := clBlack;
      end;
      IBitmap.Width := NewGraphic.Width;
      IBitmap.Height := NewGraphic.Height;
      ICanvas.Draw(0, 0, NewGraphic);
      NewGraphic.Free;
      Result := True;
    finally
      s.Free;
    end;
  end;
  if Result and (Min(IBitmap.Width, IBitmap.Height) > 7) then
  begin
    case fTextureQuality of
      tqDouble:
        begin
          tmp := TPicture.Create;
          try
            tmp.Bitmap.Width := 2 * IBitmap.Width;
            tmp.Bitmap.Height := 2 * IBitmap.Height;
            MakeSquareBitmap(tmp.Bitmap, False);
            tmp.Bitmap.Canvas.StretchDraw(
              Rect(0, 0, tmp.Bitmap.Width, tmp.Bitmap.Height),
                IBitmap);
            IBitmap.Width := 2 * IBitmap.Width;
            IBitmap.Height := 2 * IBitmap.Height;
            ICanvas.Draw(0, 0, tmp.Bitmap);
          finally
            tmp.Bitmap.Width := 0;
            tmp.Bitmap.Height := 0;
            tmp.Free;
          end;
          OptimizeBitmap(IBitmap);
        end;
      tq50:
        begin
          ICanvas.StretchDraw(
            Rect(0, 0, (1 + IBitmap.Width) div 2, (1 + IBitmap.Height) div 2),
              IBitmap);
          IBitmap.Width := IBitmap.Width div 2;
          IBitmap.Height := IBitmap.Height div 2;
          MakeSquareBitmap(IBitmap, True);
        end;
      tq25:
        begin
          ICanvas.StretchDraw(
            Rect(0, 0, (2 + IBitmap.Width) div 4, (2 + IBitmap.Height) div 4),
              IBitmap);
          IBitmap.Width := IBitmap.Width div 4;
          IBitmap.Height := IBitmap.Height div 4;
          MakeSquareBitmap(IBitmap, True);
        end;
      tqOnlyColors:
        begin
          ICanvas.StretchDraw(Rect(0, 0, 2, 2), IBitmap);
          IBitmap.Width := 2;
          IBitmap.Height := 2;
        end;
    else
      MakeSquareBitmap(IBitmap, True);
    end;
  end
  else
  begin
    IBitmap.Width := 2;
    IBitmap.Height := 2;
    ICanvas.Pixels[0, 0] := clWhite;
    ICanvas.Pixels[1, 0] := clWhite;
    ICanvas.Pixels[0, 1] := clWhite;
    ICanvas.Pixels[1, 1] := clWhite;
  end;
end;

{$IFNDEF NO_D3DBILLBOARDS}
function TD3DScene.AddPictureToCollection(var TextureName: string): TPicture;
var i, index: integer;
begin
// ״קםןץלו בם פן Texture קוי צןפסשטו הח
  if (TextureName = '') then
  begin
    Result := nil;
    Exit;
  end;
  index := Textures.IndexOf(TextureName);
  if index = -1 then
    index := Textures.IndexOf(UpperCase(TextureName));
  if Index = -1 then
  begin
    for i := 0 to Textures.Count - 1 do
    begin
      if UpperCase(ExtractFileName(TextureName)) = UpperCase(ExtractFileName(Textures.Strings[i])) then
      begin
        Index := i;
        break;
      end;
    end;
  end;
  if index = -1 then
  begin
    if InvokeWad then
      index := Textures.IndexOf(GetExistedWadEntry(TextureName))
    else if InvokeResource then
      index := Textures.IndexOf(GetExistedResourceEntry(TextureName))
    else
      index := Textures.IndexOf(GetExistedFileName(TextureName));
  end;
  if (index = -1) or not (Textures.Objects[index] is TPicture) then
  begin
    Result := TPicture.Create;
    try
      if LoadTexture(TextureName) then
      begin
        Result.Bitmap.Width := fImageLoader.Picture.Graphic.Width;
        Result.Bitmap.Height := fImageLoader.Picture.Graphic.Height;
        Result.Bitmap.Canvas.Draw(0, 0, fImageLoader.Picture.Graphic);
        MakeSquareBitmap(Result.Bitmap, True);
      end
      else
        Result := nil;
      Textures.Objects[Textures.Add(TextureName)] := Result;
    except
      FreeAndNilSafe(Result);
    end
  end
  else
    Result := Textures.Objects[index] as TPicture;
end;
{$ENDIF}

{$IFNDEF NO_D3DBILLBOARDS}
function TD3DScene.AddPicturesToCollection(var TextureNames: TTextureNames):TDirect3DPictures;
var TN: TTextureNames;
    i, j0, j1: integer;
begin
  j0 := 0;
  j1 := 0;
  FillChar(TN,SizeOf(TN), Chr(0));
  for i := 0 to MAXTEXTURES - 1 do
  begin
    if TextureNames[i, 0] <> '' then
    begin
      TN[j0, 0] := TextureNames[i, 0];
      inc(j0);
    end;
    if TextureNames[i, 1] <> '' then
    begin
      TN[j1, 1] := TextureNames[i, 1];
      inc(j1);
    end;
  end;
  TextureNames := TN;
  for i := 0 to MAXTEXTURES - 1 do
  begin
    Result[i, 0] := nil;
    Result[i, 1] := nil;
  end;
  i := 0;
  while (Length(TextureNames[i, 0]) > 0) and (i<MAXTEXTURES - 1) do
  begin
    Result[i, 0] := AddPictureToCollection(TextureNames[i, 0]);
    if TextureNames[i, 1] <> '' then
      Result[i, 1] := AddPictureToCollection(TextureNames[i, 1])
    else
    begin
  { ¼פבם הום ץנסקוי לףךב, טפןץלו TransparentColor = RGB(0,0,0) }
      Result[i, 0].Bitmap.TransparentMode := tmFixed;
      Result[i, 0].Bitmap.TransparentColor := clBlack;
      Result[i, 0].Bitmap.Transparent := True;
      Result[i, 1] := Result[i, 0];
    end;
    inc(i);
  end;
end;
{$ENDIF}

procedure TD3DScene.AddTexturesToCollection(TextureNames: TDXStringList; doTransparent: boolean = True);
var i: integer;
{$IFNDEF NO_IDSOFTGAMESSUPPORT}
    WADFileName, Entry, s: string;
    TWADS: TDXStringList;
{$ENDIF}
{$IFNDEF NO_TOMBRAIDERSUPPORT}
    TrFileName, TrEntry, Trs: string;
    TTRS: TDXStringList;
{$ENDIF}
{$IFNDEF NO_DUKE3DSUPPORT}
    GrpFileName, GrpEntry, Grps: string;
    TGrpS: TDXStringList;
{$ENDIF}
begin
{$IFNDEF NO_IDSOFTGAMESSUPPORT}

{$IFNDEF NO_DOOMSUPPORT}
// ֱסקיך ומופזןץלו דיב Links בסקושם WAD
  TWADS := TDXStringList.Create;
  try
    for i := 0 to TextureNames.Count - 1 do
    begin
      s := TextureNames.Strings[i];
        // ִחליןץסדן‎לו לב הינכ ףץםהוהולםח כףפב לו נכחסןצןסוע דיב פב WAD links
      if IsWadLinkInfo(s) and
        GetWadLinkInfo(s, WADFileName, Entry) and
        (Textures.IndexOf(s) = -1) and
        (Textures.IndexOf(UpperCase(s)) = -1) then
      begin
        if TWADS.IndexOf(WADFileName) = -1 then
        begin
          TWADS.AddObject(WADFileName, TDXStringList.Create);
          (TWADS.Objects[TWADS.Count - 1] as TDXStringList).Add(Entry);
        end
        else
          (TWADS.Objects[TWADS.IndexOf(WADFileName)] as TDXStringList).Add(Entry);
      end
{      else if not GetPAKLinkInfo(s, WADFileName, Entry) then
      begin
        AddTextureToCollection(s, doTransparent);
        TextureNames.Strings[i] := s;
      end;}
    end;
  finally
    for i := 0 to TWADS.Count - 1 do
    begin
      CacheIDWADTextures(TWADS.Strings[i], '', TWADS.Objects[i] as TDXStringList);
      TWADS.Objects[i].Free;
    end;
    TWADS.Free;
  end;
{$ENDIF}

{$IFNDEF NO_QUAKESUPPORT}
// װ‏סב ומופזןץלו דיב Links בסקושם PAK
  TWADS := TDXStringList.Create;
  try
    for i := 0 to TextureNames.Count - 1 do
    begin
      s := TextureNames.Strings[i];
      // ִחליןץסדן‎לו לב הינכ ףץםהוהולםח כףפב לו נכחסןצןסוע דיב פב WAD links
      if GetPAKLinkInfo(s, WADFileName, Entry) and
        (Textures.IndexOf(s) = -1) and
        (Textures.IndexOf(UpperCase(s)) = -1) then
      begin
        if TWADS.IndexOf(WADFileName) = -1 then
        begin
          TWADS.AddObject(WADFileName, TDXStringList.Create);
          (TWADS.Objects[TWADS.Count - 1] as TDXStringList).Add(Entry);
        end
        else
          (TWADS.Objects[TWADS.IndexOf(WADFileName)] as TDXStringList).Add(Entry);
      end
{      else
      begin
        AddTextureToCollection(s, doTransparent);
        TextureNames.Strings[i] := s;
      end;}
    end;
  finally
    for i := 0 to TWADS.Count - 1 do
    begin
      CacheIDPAKTextures(TWADS.Strings[i], TWADS.Objects[i] as TDXStringList);
      TWADS.Objects[i].Free;
    end;
    TWADS.Free;
  end;
{$ENDIF}

{$ENDIF}
{$IFNDEF NO_DUKE3DSUPPORT}
  TGrpS := TDXStringList.Create;
  try
    for i := 0 to TextureNames.Count - 1 do
    begin
      Grps := TextureNames.Strings[i];
        // ִחליןץסדן‎לו לב הינכ ףץםהוהולםח כףפב לו נכחסןצןסוע דיב פב links
      if IsDuke3DLinkInfo(Grps) and
        GetDuke3DLinkInfo(Grps, GrpFileName, GrpEntry) and
        (Textures.IndexOf(Grps) = -1) and
        (Textures.IndexOf(UpperCase(Grps)) = -1) then
      begin
        if TGrpS.IndexOf(GrpFileName) = -1 then
        begin
          TGrpS.AddObject(GrpFileName, TDXStringList.Create);
          (TGrpS.Objects[TGrpS.Count - 1] as TDXStringList).Add(GrpEntry);
        end
        else
          (TGrpS.Objects[TGrpS.IndexOf(GrpFileName)] as TDXStringList).Add(GrpEntry);
      end
{      else if not GetPAKLinkInfo(s, WADFileName, Entry) then
      begin
        AddTextureToCollection(s, doTransparent);
        TextureNames.Strings[i] := s;
      end;}
    end;
  finally
    for i := 0 to TGrpS.Count - 1 do
    begin
      CacheDuke3DTextures(TGrpS.Strings[i], TGrpS.Objects[i] as TDXStringList);
      TGrpS.Objects[i].Free;
    end;
    TGrpS.Free;
  end;
{$ENDIF}
{$IFNDEF NO_TOMBRAIDERSUPPORT}
  TTRS := TDXStringList.Create;
  try
    for i := 0 to TextureNames.Count - 1 do
    begin
      Trs := TextureNames.Strings[i];
        // ִחליןץסדן‎לו לב הינכ ףץםהוהולםח כףפב לו נכחסןצןסוע דיב פב links
      if IsTrLinkInfo(Trs) and
        GetTrLinkInfo(Trs, TrFileName, TrEntry) and
        (Textures.IndexOf(Trs) = -1) and
        (Textures.IndexOf(UpperCase(Trs)) = -1) then
      begin
        if TTRS.IndexOf(TrFileName) = -1 then
        begin
          TTRS.AddObject(TrFileName, TDXStringList.Create);
          (TTRS.Objects[TTRS.Count - 1] as TDXStringList).Add(TrEntry);
        end
        else
          (TTRS.Objects[TTRS.IndexOf(TrFileName)] as TDXStringList).Add(TrEntry);
      end
{      else if not GetPAKLinkInfo(s, WADFileName, Entry) then
      begin
        AddTextureToCollection(s, doTransparent);
        TextureNames.Strings[i] := s;
      end;}
    end;
  finally
    for i := 0 to TTRS.Count - 1 do
    begin
      CacheTrTextures(TTRS.Strings[i], TTRS.Objects[i] as TDXStringList);
      TTRS.Objects[i].Free;
    end;
    TTRS.Free;
  end;
{$ENDIF}
  for i := 0 to TextureNames.Count - 1 do
     AddTextureToCollectionConst(TextureNames.Strings[i], doTransparent);
end;

function TD3DScene.AddTexturesToCollection(var TextureName: string; doTransparent: boolean = True):TDirect3DTextures2;
var
  TextureNames: TTextureNames;
begin
  FillChar(TextureNames, SizeOf(TextureNames), Chr(0));
  TextureNames[0, 0] := TextureName;
  Result := AddTexturesToCollection(TextureNames, doTransparent);
  TextureName := TextureNames[0, 0];
end;

function TD3DScene.AddTexturesToCollection(var TextureNames: TTextureNames; doTransparent: boolean = True): TDirect3DTextures2;
var
  i: integer;
{$IFDEF DESIGNER}
  TN: TTextureNames;
  j0, j1: integer;
{$ENDIF}
begin
{$IFDEF DESIGNER}
  j0 := 0;
  j1 := 0;
  FillChar(TN,SizeOf(TN), Chr(0));
  for i := 0 to MAXTEXTURES - 1 do
  begin
    if TextureNames[i, 0] <> '' then
    begin
      TN[j0, 0] := TextureNames[i, 0];
      inc(j0);
    end;
    if TextureNames[i, 1] <> '' then
    begin
      TN[j1, 1] := TextureNames[i, 1];
      inc(j1);
    end;
  end;
  TextureNames := TN;
{$ENDIF}
  for i := 0 to MAXTEXTURES - 1 do
  begin
    Result[i, 0] := nil;
    Result[i, 1] := nil;
  end;
  i := 0;
  while (Length(TextureNames[i, 0]) > 0) and (i < MAXTEXTURES - 1) do
  begin
    Result[i, 0] := AddTextureToCollection(TextureNames[i, 0], doTransparent);
    if TextureNames[i, 1] <> '' then
      Result[i, 1] := AddTextureToCollection(TextureNames[i, 1])
    else if doTransparent then
    begin
  { ¼פבם הום ץנסקוי לףךב, טפןץלו TransparentColor = RGB(0,0,0) }
      if Result[i, 0] <> nil then
        Result[i, 0].Surface.TransparentColor := 0;
      Result[i, 1] := Result[i, 0];
    end;
    inc(i);
  end;
end;

{$IFNDEF NO_D3DACTORS}
function TD3DScene.AddModelToCollection(var ModelName: string): TModel; // return: TModel@@@@
var
  i, index: integer;
  m: TStream;
  err: string;
  uModelName: string;
  uMext: string;
begin
  uModelName := UpperCase(TrimStr(ModelName));
  if uModelName = '' then
  begin
    Result := nil;
    Exit;
  end;
// ״קםןץלו בם פן לןםפכן קוי צןפסשטו הח
  if InvokeWad then
    index := Models.IndexOf(GetExistedWadEntry(ModelName))
  else if InvokeResource then
    index := Models.IndexOf(GetExistedResourceEntry(ModelName))
  else
    index := Models.IndexOf(GetExistedFileName(ModelName));
  if index = -1 then
  begin
    for i := 0 to Models.Count - 1 do
    begin
      if uModelName = UpperCase(Models.Strings[i]) then
      begin
        index := i;
        break;
      end;
    end;
  end;
  if index = -1 then
  begin
  // ִיבגזןץלו בנ פן WAD פן Entry לםן פבם פן Entry ץנסקוי
  // היבצןסופיך רקםןץלו םב פן גסן‎לו ףפןם הףךן
  // װי ךוסהזןץלו:
  //   ֱצםןםפבע םב לודכן wav וךפע פןץ WAD, ךוסהזןץלו
  //   נןכ‎ קסםן דכיפ‏םןםפבע פחם בנןףץלנוף פןץ, ךבט‏ע ךבי פן פי
  //   הום פן צןספ‏םןץלו ףפח לםלח
    if InvokeWad and Wad.EntryExist(GetExistedWadEntry(ModelName)) then
    begin
      m := TMemoryStream.Create;
      ModelName := GetExistedWadEntry(ModelName);
      Wad.CopyToStream(ModelName, m)
    end
    else if InvokeResource and (not FileExists(GetExistedFileName(ModelName))) then
    begin
      ModelName := GetExistedResourceEntry(ModelName);
      if IsValidInteger(ModelName) then
        m := TResourceStream.CreateFromID(HInstance, StrToInt(ModelName), PChar(rsRESModel))
      else
        m := TResourceStream.Create(HInstance, ModelName, PChar(rsRESModel));
    end
    else
    begin
      ModelName := GetExistedFileName(ModelName);
      m := TFileStream.Create(ModelName, fmOpenRead or fmShareDenyWrite);
    end;
    m.Position := 0;
    uMext := UpperCase(ExtractFileExt(ModelName));
    if uMext = UpperCase(rsExtMD2) then
      Result := TModelMD2.Create(ModelName, m)
    else if uMext = UpperCase(rsExtVRM) then
      Result := TModelVRM.Create(ModelName, m)
    else if uMext = UpperCase(rsExtVRT) then
      Result := TModelVRT.Create(ModelName, m)
    else if uMext = UpperCase(rsExtX) then
      Result := TModelX.Create(ModelName, m)
    else
      Result := TModel.Create(ModelName, m);

    Streams.AddObject(ModelName, m); // ׀סןףטפןץלו ףפח כףפב פן stream נןץ היבגזוי פן Result
    Models.Objects[Models.Add(ModelName)] := Result;

    err := ModelErrorToString(Result.LastError);
    if err <> '' then
      raise Exception.Create(err);
  end
  else
  begin
    ModelName := Models.Strings[index];
    Result := Models.Objects[index] as TModel
  end;
end;

{$ENDIF}

{$IFNDEF NO_D3DSOUNDS}
function TD3DScene.AddWaveToCollection(var SoundName: string; forceMemory: boolean = False):TWaveStream;
var
  i, index: integer;
  m: TStream;
  f: TStream;
  uSoundName: string;
begin
  uSoundName := UpperCase(TrimStr(SoundName));
  if uSoundName = '' then
  begin
    Result := nil;
    Exit;
  end;
// ״קםןץלו בם ן קןע קוי צןפסשטו הח
  if InvokeWad then
    index := Waves.IndexOf(GetExistedWadEntry(SoundName))
  else if InvokeResource then
    index := Waves.IndexOf(GetExistedResourceEntry(SoundName))
  else
    index := Waves.IndexOf(GetExistedFileName(SoundName));
  if index = -1 then
  begin
    for i := 0 to Waves.Count - 1 do
    begin
      if uSoundName = UpperCase(Waves.Strings[i]) then
      begin
        index := i;
        break;
      end;
    end;
  end;
  if index = -1 then
  begin
    uSoundName := ExtractFileName(uSoundName);
    for i := 0 to Waves.Count - 1 do
    begin
      if uSoundName = UpperCase(ExtractFileName(Waves.Strings[i])) then
      begin
        index := i;
        break;
      end;
    end;
  end;
  if index = -1 then
  begin
  // ִיבגזןץלו בנ פן WAD פן Entry לםן פבם פן Entry ץנסקוי
  // היבצןסופיך רקםןץלו םב פן גסן‎לו ףפןם הףךן
  // װי ךוסהזןץלו:
  //   ֱצםןםפבע םב לודכן wav וךפע פןץ WAD, ךוסהזןץלו
  //   נןכ‎ קסםן דכיפ‏םןםפבע פחם בנןףץלנוף פןץ, ךבט‏ע ךבי פן פי
  //   הום פן צןספ‏םןץלו ףפח לםלח
    if InvokeWad and Wad.EntryExist(GetExistedWadEntry(SoundName)) then
    begin
      m := TMemoryStream.Create;
      SoundName := GetExistedWadEntry(SoundName);
      Wad.CopyToStream(SoundName, m)
    end
    else if InvokeResource and (not FileExists(GetExistedFileName(SoundName))) then
    begin
      SoundName := GetExistedResourceEntry(SoundName);
      if IsValidInteger(SoundName) then
        m := TResourceStream.CreateFromID(HInstance, StrToInt(SoundName), PChar(rsRESWave))
      else
        m := TResourceStream.Create(HInstance, SoundName, PChar(rsRESWave));
    end
    else
    begin
      if forceMemory or fForceWavesInMemory then
      begin
        SoundName := GetExistedFileName(SoundName);
        f := TFileStream.Create(SoundName, fmOpenRead or fmShareDenyWrite);
        try
          m := TMemoryStream.Create;
          m.CopyFrom(f, 0);
        finally
          f.Free;
        end;
      end
      else
      begin
        SoundName := GetExistedFileName(SoundName);
        m := TFileStream.Create(SoundName, fmOpenRead or fmShareDenyWrite);
      end;
    end;
    m.Position := 0;
    Result := TWaveStream.Create(m);
    Result.Open(False);
    Streams.AddObject(SoundName, m); // ׀סןףטפןץלו ףפח כףפב פן stream נןץ היבגזוי פן Result
    Waves.Objects[Waves.Add(SoundName)] := Result;
  end
  else
  begin
    SoundName := Waves.Strings[index];
    Result := Waves.Objects[index] as TWaveStream
  end;
end;
{$ENDIF}

function TD3DScene.AddStreamToCollection(var StreamName: string): TStream;
var
  i, index: integer;
  m: TStream;
  uStreamName: string;
begin
  uStreamName := UpperCase(TrimStr(StreamName));
// ״קםןץלו בם פן stream קוי צןפסשטו הח
  if uStreamName = '' then
  begin
    Result := nil;
    Exit;
  end;
  if InvokeWad then
    index := Streams.IndexOf(GetExistedWadEntry(StreamName))
  else if InvokeResource then
    index := Streams.IndexOf(GetExistedResourceEntry(StreamName))
  else
    index := Streams.IndexOf(GetExistedFileName(StreamName));
  if index = -1 then
  begin
    for i := 0 to Streams.Count - 1 do
    begin
      if uStreamName = UpperCase(Streams.Strings[i]) then
      begin
        index := i;
        break;
      end;
    end;
  end;
  if index = -1 then
  begin
    uStreamName := ExtractFileName(uStreamName);
    for i := 0 to Streams.Count - 1 do
    begin
      if uStreamName = UpperCase(ExtractFileName(Streams.Strings[i])) then
      begin
        index := i;
        break;
      end;
    end;
  end;
  if (index = -1) then
  begin
  // ִיבגזןץלו בנ פן WAD פן Entry לםן פבם פן Entry ץנסקוי
  // היבצןסופיך רקםןץלו םב פן גסן‎לו ףפןם הףךן
    if InvokeWad and Wad.EntryExist(GetExistedWadEntry(StreamName)) then
    begin
      m := TMemoryStream.Create;
      StreamName := GetExistedWadEntry(StreamName);
      Wad.CopyToStream(StreamName, m)
    end
    else if InvokeResource then
    begin
      StreamName := GetExistedResourceEntry(StreamName);
      if IsValidInteger(StreamName) then
        m := TResourceStream.CreateFromID(HInstance, StrToInt(StreamName), PChar(rsRESData))
      else
        m := TResourceStream.Create(HInstance, StreamName, PChar(rsRESData));
    end
    else
    begin
      StreamName := GetExistedFileName(StreamName);
      m := TFileStream.Create(StreamName, fmOpenRead or fmShareDenyWrite);
    end;
    m.Position := 0;
    Result := m;
    Streams.AddObject(StreamName, m); // ׀סןףטפןץלו ףפח כףפב פן stream
  end
  else
  begin
    StreamName := Streams.Strings[index];
    Result := Streams.Objects[index] as TStream
  end;
end;

function TD3DScene.IsIntersectWith(aObject: TD3DObject): boolean;
var
  i: integer;
begin
  for i := 0 to Surfaces.Count - 1 do
    if (Surfaces.Objects[i] as TD3DObject).IsIntersectWith(aObject) then
    begin
      Result := True;
      Exit;
    end;
  Result := False;
end;

function TD3DScene.IsIntersectWith(aRadius: TD3DValue; aCenter: TD3DVector): boolean;
var
  i: integer;
begin
  for i := 0 to Surfaces.Count - 1 do
    if (Surfaces.Objects[i] as TD3DObject).IsIntersectWith(aRadius, aCenter) then
    begin
      Result := True;
      Exit;
    end;
  Result := False;
end;

function TD3DScene.ReplaceTexture(const index: integer; TextureName: string): boolean;
var
  oldTextureName: string;
begin
  Result := False;
  if IsIntegerInRange(index, 0, Textures.Count - 1) then
  begin
    oldTextureName := Textures.Strings[index];
    Result := ReplaceTexture(oldTextureName, TextureName);
  end;
end;

function TD3DScene.ReplaceTexture(oldTextureName: string; TextureName: string): boolean;
var
  m, m2: TMemoryStream;
  ilen: integer;
  sTNames: TDXStringList;
  TNames: string;
  c: char;
  i, index: integer;
  ver: integer;
  startPos: integer;
  endPos: integer;
{$IFDEF DESIGNER}
  oldCanSaveUndo: boolean;
{$ENDIF}
begin
{$IFDEF DESIGNER}
  SaveUndo;
  oldCanSaveUndo := CanSaveUndo;
  CanSaveUndo := False;
{$ENDIF}
  Result := False;
  index := Textures.IndexOf(oldTextureName);
  if index = -1 then
  begin
    oldTextureName := GetExistedFileName(oldTextureName);
    index := Textures.IndexOf(oldTextureName);
    if index = -1 then
      index := Textures.IndexOf(UpperCase(oldTextureName));
    if index = -1 then
      for i := 0 to Textures.Count - 1 do
      begin
        if UpperCase(ExtractFileName(oldTextureName)) = UpperCase(ExtractFileName(Textures.Strings[i])) then
        begin
          index := -1;
          break;
        end;
      end;
    if index = -1 then
    begin
    {$IFDEF DESIGNER}
      CanSaveUndo := oldCanSaveUndo;
    {$ENDIF}
      Exit;
    end;
  end;

{$IFNDEF NO_D3DSECTORCOLLECTIONS}
  for i := 0 to _CacheSectorCollections.Count - 1 do
    (_CacheSectorCollections.Objects[i] as TD3DSectorCollection).ReplaceImageEntry(
      oldTextureName, TextureName);
{$ENDIF}
  m := TMemoryStream.Create;
  try
    SaveToStream(m);

    iLen := Length(rsSIGNATURE);
    m.Seek(iLen, soFromBeginning);

    m.read(ver, SizeOf(ver));

    startPos := m.Position;

    m.read(iLen, SizeOf(iLen));

    TNames := '';
    for i := 1 to iLen do
    begin
      m.Read(c, SizeOf(c));
      TNames := TNames + c;
    end;

    endPos := m.Position;

    sTNames := TDXStringList.Create;
    sTNames.Text := TNames;
    TNames := '';

    index := sTNames.IndexOf(oldTextureName);
    if index = -1 then
    begin
      oldTextureName := GetExistedFileName(oldTextureName);
      index := sTNames.IndexOf(oldTextureName);
      if index = -1 then
        index := sTNames.IndexOf(UpperCase(oldTextureName));
      if index = -1 then
        for i := 0 to sTNames.Count - 1 do
        begin
          if UpperCase(ExtractFileName(oldTextureName)) = UpperCase(ExtractFileName(stNames.Strings[i])) then
          begin
            index := -1;
            break;
          end;
        end;
(*      begin
        sTNames.Free;
        m.Free;
      {$IFDEF DESIGNER}
        CanSaveUndo := oldCanSaveUndo;
      {$ENDIF}
        Exit;
      end;*)
    end;

    if index <> -1 then
      sTNames[index] := TextureName;
    TNames := sTNames.Text;
    sTNames.Free;

    m2 := TMemoryStream.Create;
    try
      m2.Size := m.Size + Length(TNames) - iLen;

      m.Seek(0, soFrombeginning);
      m2.CopyFrom(m, startPos);
      iLen := Length(TNames);
      m2.Write(iLen, SizeOf(iLen));
      for i := 1 to Length(TNames) do
        m2.Write(TNames[i], SizeOf(Char));
      m.Seek(endPos, soFromBeginning);
      m2.CopyFrom(m, m.Size - endPos);

      m2.Seek(0, soFrombeginning);

      {$IFNDEF NO_SCRIPTS}
      StopScriptEngine;
      {$ENDIF}

      Clear;
      AppendFromStream(m2);

      {$IFDEF DESIGNER}
      fModified := True;
      {$ENDIF}

      {$IFNDEF NO_SCRIPTS}
      StartScriptEngine;
      {$ENDIF}

    finally
      m2.Free;
    end;
  finally
    m.Free;
  end;
{$IFDEF DESIGNER}
  CanSaveUndo := oldCanSaveUndo;
{$ENDIF}
end;

function TD3DScene.SearchDeepIndexOfTexture(const TextureName: string): integer;
var
  txname: string;
  i: integer;
begin
  txname := UpperCase(ExtractFileNameOnly(TextureName));
  for i := 0 to Textures.Count - 1 do
    if txname = UpperCase(ExtractFileNameOnly(Textures.Strings[i])) then
    begin
      Result := i;
      Exit;
    end;
  Result := -1;
end;

function TD3DScene.GetNameForTexture(t: TDirect3DTexture2): string;
var
  i: integer;
begin
  for i := 0 to Textures.Count - 1 do
    if Textures.Objects[i] = t then
    begin
      Result := ExtractFileNameOnly(Textures.Strings[i]);
      Exit;
    end;
  Result := '';
end;

function TD3DScene.AddTextureToCollectionConst(TextureName: string;
  doTransparent: boolean = True): TDirect3DTexture2;
var
  s: string;
begin
  s := TextureName;
  Result := AddTextureToCollection(s, doTransparent);
end;

function TD3DScene.AddTextureToCollectionFromGraphic(const TextureName: string;
  grp: TGraphic):TDirect3DTexture2;
var
  index: integer;
  i: integer;
  uTextureName: string;
begin
  if (TextureName = '') then
  begin
    Result := nil;
    Exit;
  end;
  index := Textures.IndexOf(TextureName);
  if index = -1 then
  begin
    if InvokeWad then
      index := Textures.IndexOf(GetExistedWadEntry(TextureName))
    else if InvokeResource then
      index := Textures.IndexOf(GetExistedResourceEntry(TextureName))
    else
      index := Textures.IndexOf(GetExistedFileName(TextureName));
  end;
  if index = -1 then
  begin
    uTextureName := UpperCase(TextureName);
    for i := 0 to Textures.Count - 1 do
    begin
      if uTextureName = UpperCase(Textures.Strings[i]) then
      begin
        Index := i;
        break;
      end;
    end;
  end;
  if index = -1 then
  begin
    uTextureName := UpperCase(ExtractFileName(TextureName));
    for i := 0 to Textures.Count - 1 do
    begin
      if uTextureName = UpperCase(ExtractFileName(Textures.Strings[i])) then
      begin
        index := i;
        break;
      end;
    end;
  end;
  if (index = -1) or not (Textures.Objects[index] is TDirect3DTexture2) then
  begin
    Result := TDirect3DTexture2.Create(DXDraw, grp, False);
    Textures.Objects[Textures.Add(TextureName)] := Result;
    Exit;
  end;
  Result := Textures.Objects[index] as TDirect3DTexture2;
end;

function TD3DScene.AddTextureToCollection(const TextureName: string;
  bmp: TBitmap): TDirect3DTexture2;
var
  index: integer;
  i: integer;
  uTextureName: string;
begin
  if (TextureName = '') then
  begin
    Result := nil;
    Exit;
  end;
  index := Textures.IndexOf(TextureName);
  if index = -1 then
  begin
    if InvokeWad then
      index := Textures.IndexOf(GetExistedWadEntry(TextureName))
    else if InvokeResource then
      index := Textures.IndexOf(GetExistedResourceEntry(TextureName))
    else
      index := Textures.IndexOf(GetExistedFileName(TextureName));
  end;
  if index = -1 then
  begin
    uTextureName := UpperCase(TextureName);
    for i := 0 to Textures.Count - 1 do
    begin
      if uTextureName = UpperCase(Textures.Strings[i]) then
      begin
        Index := i;
        break;
      end;
    end;
  end;
  if index = -1 then
  begin
    uTextureName := UpperCase(ExtractFileName(TextureName));
    for i := 0 to Textures.Count - 1 do
    begin
      if uTextureName = UpperCase(ExtractFileName(Textures.Strings[i])) then
      begin
        index := i;
        break;
      end;
    end;
  end;
  if (index = -1) or not (Textures.Objects[index] is TDirect3DTexture2) then
  begin
    if bmp.PixelFormat in [pf1bit, pf4bit] then
      bmp.PixelFormat := pf8bit
{    else if bmp.PixelFormat in [pf15bit, pf16bit] then
      bmp.PixelFormat := pf24bit}
    else if not (bmp.PixelFormat in [pf24bit, pf32bit]) then
      bmp.PixelFormat := pf24bit;
    MakeSquareBitmap(bmp, True);
    Result := TDirect3DTexture2.Create(DXDraw, bmp, False);
    Textures.Objects[Textures.Add(TextureName)] := Result;
    Exit;
  end;
  Result := Textures.Objects[index] as TDirect3DTexture2;
end;

function TD3DScene.AddDoom3TextureToCollection(var TextureName: string;
  doTransparent: boolean = True): TDirect3DTexture2;
const
  rsSfxblack = 'TEXTURES\SFX\BLACK.TGA';
var
  index: integer;
  i, j, h, w, numbytes : integer;
  P1: PByteArray;
  pA, pB, pC: PByte;
  bmp: TBitmap;
begin
  if (TextureName = '') then
  begin
    Result := nil;
    Exit;
  end;

  TextureName := UpperCase(GetExistedFileName(TextureName));
  index := Textures.IndexOfFromLast(TextureName);
  if index >= 0 then
  begin
    Result := Textures.Objects[index] as TDirect3DTexture2;
    Exit;
  end;

  if RightStr(TextureName, Length(rsSfxblack)) = rsSfxblack then
  begin
    TextureName := rsGray1;
    index := Textures.IndexOfFromLast(TextureName);
    if index >= 0 then
    begin
      Result := Textures.Objects[index] as TDirect3DTexture2;
      Exit;
    end;
    bmp := TBitmap.Create;
    try
      bmp.PixelFormat := pf24bit;
      bmp.Width := 2;
      bmp.Height := 2;
      bmp.Canvas.Pixels[0, 0] := $101010;
      bmp.Canvas.Pixels[0, 1] := $101010;
      bmp.Canvas.Pixels[1, 0] := $101010;
      bmp.Canvas.Pixels[1, 1] := $101010;

      Result := TDirect3DTexture2.Create(DXDraw, bmp, False);
      Textures.Objects[Textures.Add(TextureName)] := Result;

    finally
      bmp.Free;
    end;
    Exit;
  end;

  if LoadTexture(TextureName) then
  begin

    w := fImageLoader.Picture.Bitmap.Width;
    fImageLoader.Picture.Bitmap.PixelFormat := pf24bit;
    numBytes := 3 * w;

    h := fImageLoader.Picture.Bitmap.Height;

    if not doTransparent then
    begin
      for i := 0 to h - 1 do
      begin
        P1 := fImageLoader.Picture.Bitmap.ScanLine[i];
        pA := @P1[0];
        for j := 0 to numBytes - 1 do
        begin
          if pA^ < 8 then
            pA^ := 8;
          inc(pA);
        end;
      end
    end
    else
    begin
      for i := 0 to h - 1 do
      begin
        P1 := fImageLoader.Picture.Bitmap.ScanLine[i];
        pA := @P1[0];
        pB := @P1[1];
        pC := @P1[2];
        for j := 0 to w - 2 do
        begin
          if ((pB^ < 50) and (pA^ > 100) and (abs(pA^ - pC^) < 32)) or
             ((pB^ < 6) and (pA^ > 44) and (abs(pA^ - pC^) < 16)) then
//          if (pA^ > 240) and (pB^ < 16) and (pC^ > 240) then
          begin
            pA^ := $00;
            pC^ := $00;
          end;
          inc(pA, 3);
          inc(pB, 3);
          inc(pC, 3);
        end;
      end

    end;

    Result := TDirect3DTexture2.Create(DXDraw, fImageLoader.Picture.Bitmap, False);
    Textures.Objects[Textures.Add(TextureName)] := Result;

  end
  else
    Result := nil;
end;

function TD3DScene.AddTextureToCollection(var TextureName: string;
  doTransparent: boolean = True): TDirect3DTexture2;
var
  i, j, numBytes: integer;
  tex: TBitmap;
  index: integer;
  uvFactor: double; // ַ בםבכןדב פשם נכוץס‏ם פחע ויךםבע
  P1: PByteArray;
  uTextureNameExt, uTexName: string;
{$IFNDEF NO_IDSOFTGAMESSUPPORT}
  Entry: string;
  WADFileName: string;
{$ENDIF}
{$IFNDEF NO_TOMBRAIDERSUPPORT}
  TrEntry: string;
  TrlFileName: string;
{$ENDIF}
{$IFNDEF NO_DUKE3DSUPPORT}
  DukeEntry: integer;
  DukeFileName: string;
{$ENDIF}
begin
  if (TextureName = '') then
  begin
    Result := nil;
    Exit;
  end;
  uTextureNameExt := UpperCase(ExtractFileExt(TextureName));
  if uTextureNameExt = UpperCase(rsDefaultD3DExtention) then
  begin
    Result := nil;
    Exit;
  end;

{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_QUAKESUPPORT}
  if uTextureNameExt = UpperCase(rsExtBsp) then
  begin
    Result := nil;
    Exit;
  end;
  if uTextureNameExt = UpperCase(rsExtPK3) then
  begin
    Result := nil;
    Exit;
  end;
  if uTextureNameExt = UpperCase(rsExtPAK) then
  begin
    Result := nil;
    Exit;
  end;
{$ENDIF}
{$IFNDEF NO_DOOMSUPPORT}
  if uTextureNameExt = UpperCase(rsDefaultWADExtention) then
  begin
    Result := nil;
    Exit;
  end;
{$ENDIF}
{$ENDIF}

{$IFNDEF NO_TOMBRAIDERSUPPORT}
  if uTextureNameExt = UpperCase(rsExtTombRaider1) then
  begin
    Result := nil;
    Exit;
  end;
  if uTextureNameExt = UpperCase(rsExtTombRaiderUB) then
  begin
    Result := nil;
    Exit;
  end;
  if uTextureNameExt = UpperCase(rsExtTombRaider2) then
  begin
    Result := nil;
    Exit;
  end;
  if uTextureNameExt = UpperCase(rsExtTombRaider4) then
  begin
    Result := nil;
    Exit;
  end;
  if uTextureNameExt = UpperCase(rsExtTombRaiderCronicles) then
  begin
    Result := nil;
    Exit;
  end;
{$ENDIF}

// ״קםןץלו בם פן Texture קוי צןפסשטו הח
  index := Textures.IndexOf(TextureName);
  if index = -1 then
    index := SearchDeepIndexOfTexture(TextureName);
  if index = -1 then
  begin
{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_DOOMSUPPORT}
    if IsWadLinkInfo(TextureName) and GetWadLinkInfo(TextureName, WADFileName, Entry) then
    begin
      CacheIDWADTexture(WADFileName, Entry);
      index := Textures.IndexOf(TextureName);
    end
    else {$ENDIF} {$IFNDEF NO_QUAKESUPPORT} if IsPAKLinkInfo(TextureName) and GetPAKLinkInfo(TextureName, WADFileName, Entry) then
    begin
      CacheIDPAKTexture(WADFileName, Entry);
      index := Textures.IndexOf(TextureName);
    end
    else {$ENDIF}{$ENDIF} {$IFNDEF NO_TOMBRAIDERSUPPORT} if IsTRLinkInfo(TextureName) and GetTrLinkInfo(TextureName, TrlFileName, TrEntry) then
    begin
      CacheTrTexture(TrlFileName, TrEntry);
      index := Textures.IndexOf(TextureName);
    end
    else {$ENDIF} {$IFNDEF NO_DUKE3DSUPPORT} if IsDuke3DLinkInfo(TextureName) and GetDuke3DLinkInfo(TextureName, DukeFileName, DukeEntry) then
    begin
      CacheDuke3DTexture(DukeFileName, IntToStr(DukeEntry));
      index := Textures.IndexOf(TextureName);
    end
    else {$ENDIF} if InvokeWad then
      index := Textures.IndexOf(GetExistedWadEntry(TextureName))
    else if InvokeResource then
      index := Textures.IndexOf(GetExistedResourceEntry(TextureName))
    else
      index := Textures.IndexOf(GetExistedFileName(TextureName));
  end
  else
  begin
    TextureName := Textures.Strings[index]; // ִםןץלו פן םןלב ףפן TextureName
    Result := Textures.Objects[index] as TDirect3DTexture2;
    Exit;
  end;

  if index = -1 then
  begin
    uTexName := UpperCase(TextureName);
    for i := 0 to Textures.Count - 1 do
    begin
      if uTexName = UpperCase(Textures.Strings[i]) then
      begin
        index := i;
        break;
      end;
    end;
  end;
  if index = -1 then
  begin
    uTexName := UpperCase(ExtractFileName(TextureName));
    for i := 0 to Textures.Count - 1 do
    begin
      if uTexName = UpperCase(ExtractFileName(Textures.Strings[i])) then
      begin
        index := i;
        break;
      end;
    end;
  end;
  if (index = -1) or not (Textures.Objects[index] is TDirect3DTexture2) then
  begin
    try
      if LoadTexture(TextureName) then
      begin
        // ֱם הום וםבי פופסדשםן פן texture, פפו פן ךםןץלו לו פן זסי!
        if fImageLoader.Picture.Width <> fImageLoader.Picture.Height then
        begin
          tex := TBitmap.Create;
          try
            tex.Width := Max(fImageLoader.Picture.Width, fImageLoader.Picture.Height);
            tex.Height := tex.Width;
            uvFactor := fImageLoader.Picture.Width / fImageLoader.Picture.Height;
            if uvFactor < 1 then // װן width פןץ texture פבם ליךספוסן
            begin
              for i := 1 to trunc(1 / uvFactor) + 1 do
                tex.Canvas.CopyRect(
                  Rect((i - 1) * fImageLoader.Picture.Width, 0, i * fImageLoader.Picture.Width, fImageLoader.Picture.Height),
                  fImageLoader.Picture.Bitmap.Canvas,
                  Rect(0, 0, fImageLoader.Picture.Width - 1, fImageLoader.Picture.Height - 1));
            end
            else // װן height פןץ Texture פבם ליךספוסן
            begin
              for i := 1 to trunc(uvFactor) + 1 do
                tex.Canvas.CopyRect(
                  Rect(0, (i - 1) * fImageLoader.Picture.Height, fImageLoader.Picture.Width, i * fImageLoader.Picture.Height),
                  fImageLoader.Picture.Bitmap.Canvas,
                  Rect(0, 0, fImageLoader.Picture.Width - 1, fImageLoader.Picture.Height - 1));
            end;
            fImageLoader.Picture.Bitmap.Width := tex.Width;
            fImageLoader.Picture.Bitmap.Height := tex.Height;
            fImageLoader.Picture.Bitmap.Canvas.CopyRect(
              Rect(0, 0, fImageLoader.Picture.Width - 1, fImageLoader.Picture.Height - 1),
              tex.Canvas,
              Rect(0, 0, tex.Width - 1, tex.Height - 1));
          finally
            tex.Free;
          end;
        end;

        if fImageLoader.Picture.Bitmap.PixelFormat in [pf1bit, pf4bit] then
        begin
          if doTransparent then
            fImageLoader.Picture.Bitmap.PixelFormat := pf8bit
          else
            fImageLoader.Picture.Bitmap.PixelFormat := pf24bit
        end
{//        else if Image.Picture.Bitmap.PixelFormat in [pf15bit, pf16bit] then
        else if Image.Picture.Bitmap.PixelFormat = pf15bit then
//          Image.Picture.Bitmap.PixelFormat := pf24bit
          Image.Picture.Bitmap.PixelFormat := pf16bit}
        else if not (fImageLoader.Picture.Bitmap.PixelFormat in [pf24bit, pf32bit]) then
          fImageLoader.Picture.Bitmap.PixelFormat := pf24bit;

        if not doTransparent then
        begin
          if fImageLoader.Picture.Bitmap.PixelFormat = pf24Bit then
            numBytes := 3 * fImageLoader.Picture.Bitmap.Width
          else if fImageLoader.Picture.Bitmap.PixelFormat = pf32Bit then
            numBytes := 4 * fImageLoader.Picture.Bitmap.Width
          else
          begin
            fImageLoader.Picture.Bitmap.PixelFormat := pf24bit;
            numBytes := 3 * fImageLoader.Picture.Bitmap.Width;
          end;

          for i := 0 to fImageLoader.Picture.Bitmap.Height - 1 do
          begin
            P1 := fImageLoader.Picture.Bitmap.ScanLine[i];
            for j := 0 to numBytes - 1 do
              if P1^[j] < 8 then
                P1^[j] := 8;
          end
        end;

        Result := TDirect3DTexture2.Create(DXDraw, fImageLoader.Picture, False); // VJ ??????
//        Result.Transparent := True;
//        Result.TransparentColor := RGB(0, 0, 0);
{        Graphic.Bitmap.Dormant;             // Free up GDI resources
        Graphic.Bitmap.FreeImage;           // Free up Memory.}

        Textures.Objects[Textures.Add(TextureName)] := Result;
      end
      else
        Result := nil
    finally
    end
  end
  else
  begin
    TextureName := Textures.Strings[index]; // ִםןץלו פן םןלב ףפן TextureName
    Result := Textures.Objects[index] as TDirect3DTexture2;
  end;
end;

function TD3DScene.GetDLLTextureBmp(DllFileName: string; TextureName: string): TBitmap;
var
  Hnst: THandle;
begin
  Hnst := LoadLibrary(PChar(DllFileName));
  if Hnst = 0 then
  begin
    DllFileName := GetExistedFileName(DllFileName);
    if Hnst = 0 then
    begin
      Result := nil;
      Exit;
    end;
  end;

  Result := TBitmap.Create;
  try
    if IsValidInteger(TextureName) then
      Result.LoadFromResourceID(Hnst, StrToInt(TextureName))
    else
      Result.LoadFromResourceName(Hnst, TextureName);
  finally
    FreeLibrary(Hnst);
  end;
end;

function TD3DScene.GetDLLTextureBmp(EntryName: string): TBitmap;
var
  DLLFileName: string;
  TextureName: string;
begin
  if GetDLLLinkInfo(EntryName, DLLFileName, TextureName) then
    Result := GetDLLTextureBmp(DLLFileName, TextureName)
  else
    Result := nil;
end;

function TD3DScene.CacheDLLTexture(DllFileName: string; TextureName: string): TDirect3DTexture2;
var
  bmp: TBitmap;
  Hnst: THandle;
  entry: string;
begin
  entry := GetDllLinkDescription(DllFileName, TextureName);
  if (Textures.IndexOf(entry) > -1) and
     (Textures.Objects[Textures.IndexOf(entry)] is TDirect3DTexture2) then
    Result := Textures.Objects[Textures.IndexOf(entry)] as TDirect3DTexture2
  else
  begin
    Hnst := LoadLibrary(PChar(DllFileName));
    bmp := TBitmap.Create;
    try
      if IsValidInteger(TextureName) then
        bmp.LoadFromResourceID(Hnst, StrToInt(TextureName))
      else
        bmp.LoadFromResourceName(Hnst, TextureName);
      if bmp.PixelFormat = pf1bit then
        bmp.PixelFormat := pf4bit;
      MakeSquareBitmap(bmp, True);
      Result := TDirect3DTexture2.Create(DXDraw, bmp, False);
      if Result <> nil then
      begin
        Textures.Objects[Textures.Add(entry)] := Result;
        Result.Transparent := True;
        Result.TransparentColor := clBlack;
      end;
    finally
      bmp.Free;
      FreeLibrary(Hnst);
    end;
  end;
end;

{$IFNDEF NO_DUKE3DSUPPORT}
function TD3DScene.GetDuke3DTextureBmp(const EntryName: string): TBitmap;
var
  sprdim: PDuke3DSprDimentions;
  GRPFile: string;
  s: TDXStringList;
  id: integer;
begin
  if isDuke3DLinkInfo(EntryName) then
  begin
    GetDuke3DLinkInfo(EntryName, GRPFile, id);
    GRPFile := UpperCase(GRPFile);
    sprdim := nil;
    s := TDXStringList.Create;
    try
      s.Add(IntToStr(id));
      CacheDuke3DTextures(GRPFile, s, sprdim);
    finally
      s.Free;
      FreeMem(sprdim);
    end;
    Result := GetTextureBmp(UpperCase(EntryName));
  end
  else
    Result := nil;
end;

function TD3DScene.GetDuke3DTextureBmp(const GRPFile: string;
  const EntryName: string): TBitmap;
var
  sprdim: PDuke3DSprDimentions;
  s: TDXStringList;
begin
  if isDuke3DLinkInfo(EntryName) then
  begin
    sprdim := nil;
    s := TDXStringList.Create;
    try
      s.Add(UpperCase(EntryName));
      CacheDuke3DTextures(UpperCase(GRPFile), s, sprdim);
    finally
      s.Free;
      FreeMem(sprdim);
    end;
    Result := GetTextureBmp(UpperCase(EntryName));
  end
  else
    Result := nil;
end;

function TD3DScene.CacheDuke3DTexture(GRPFile: TFileName; TextureName: string): boolean;
// VJ ??? Maybe texturename : var & TextureName = s.Strings[0] after CacheDuke3DTextures() call
var
  s: TDXStringList;
begin
  s := TDXStringList.Create;
  try
    s.Add(TextureName);
    Result := CacheDuke3DTextures(GRPFile, s);
  finally
    s.Free;
  end;
end;

function TD3DScene.CacheDuke3DTextures(GRPFile: TFileName; TextureNames: TDXStringList;
  doSquare: boolean = True;
  DIR: PDuke3DDirectories = nil; numEntries: integer = -1;
  lightboost: integer = 0): boolean;
var
  sprdim: PDuke3DSprDimentions;
begin
  Result := CacheDuke3DTextures(GRPFile, TextureNames, sprdim, doSquare,
              DIR, numEntries, lightboost);
  FreeMem(sprdim);
end;

function TD3DScene.CacheDuke3DTextures(GRPFile: TFileName;
  pb: PBooleanArray; maxtex: integer;
  var sprdim: PDuke3DSprDimentions; doSquare: boolean = True;
  DIR: PDuke3DDirectories = nil; numEntries: integer = -1;
  lightboost: integer = 0): boolean;
var
  pal: TDuke3DPalette;
  entry: string;
  entrynum: integer;
  f1: TFileStream;
  f2: TFileStream;
  f: TFileStream;
  i_tilestart: integer;
  tilestart: integer;
  tileend: integer;
  tilenum: integer;
  id, i, j, k: integer;
  tmp: integer;
  bmp: TBitmap;
  bmpHeight: integer;
  bmpWidth: integer;
  P: PByteArray;
  widths: packed array[0..$FFF] of word;
  heights: packed array[0..$FFF] of word;
  lpal: PLogPalette;
  hpal: HPALETTE;
  buf: PByteArray;
  pbb: PByte;
  bufSize: integer;
  curSize: integer;
  maxColor: byte;
  factor: extended;
  s: string;
  TextureIDs: PIntegerArray;
  Textures2: TDXStringList;

  procedure SetBufSize(newSize: integer);
  begin
    if newSize > bufSize then
    begin
      bufSize := newSize;
      ReAllocMem(buf, bufSize);
    end;
  end;

begin
  if maxtex < 0 then
  begin
    Result := False;
    Exit;
  end;

  if (DIR = nil) or (numEntries = -1) then
  begin
    numEntries := ReadDuke3DDirectory(GRPFile, DIR);
    if (DIR = nil) or (numEntries = -1) then
    begin
      Result := False;
      Exit;
    end;
  end;

  bufSize := 0;
  buf := nil;

  f1 := TCachedFileStream.Create(GRPFile, fmOpenRead or fmShareDenyWrite);
  try
    entrynum := FindDuke3DDIREntry('PALETTE.DAT', DIR, numEntries);
    if entrynum >= 0 then
    begin
      f1.Seek(DIR[entrynum].Position, soFromBeginning);
      f1.Read(pal, SizeOf(pal));
    end
    else
    begin
      if FileExists('PALETTE.DAT') then
      begin
        f2 := TCachedFileStream.Create('PALETTE.DAT', fmOpenRead or fmShareDenyWrite);
        try
          f2.Read(pal, SizeOf(pal));
        finally
          f2.Free;
        end;
      end
      else
      begin
        f1.Free;
        Result := False;
        Exit;
      end;
    end;

    GetMem(lpal, SizeOf(TLogPalette) + SizeOf(TPaletteEntry) * 255);
    maxColor := 0;
    for j := 0 to 255 do
    begin
      maxColor := Max(maxColor, pal[j].r);
      maxColor := Max(maxColor, pal[j].g);
      maxColor := Max(maxColor, pal[j].b);
    end;
    if not (maxColor in [0, 255]) then
    begin
      factor := 256 / (maxColor + 1);
      for j := 0 to 255 do
      begin
        pal[j].r := trunc(pal[j].r * factor);
        pal[j].g := trunc(pal[j].g * factor);
        pal[j].b := trunc(pal[j].b * factor);
      end;
    end;

    lpal.palVersion := $300;
    lpal.palNumEntries := 256;
    lpal.palPalEntry[0].peRed := 0;
    lpal.palPalEntry[0].peGreen := 0;
    lpal.palPalEntry[0].peBlue := 0;
    if lightboost <> 0 then
    begin
      for j := 1 to 254 do
      begin
        pal[j].r := Max(Min(pal[j].r + lightboost, 255), 8);
        pal[j].g := Max(Min(pal[j].g + lightboost, 255), 8);
        pal[j].b := Max(Min(pal[j].b + lightboost, 255), 8);
        lpal.palPalEntry[j].peRed := pal[j].r;
        lpal.palPalEntry[j].peGreen := pal[j].g;
        lpal.palPalEntry[j].peBlue := pal[j].b;
      end;
      j := 255;
      lpal.palPalEntry[j].peRed := Max(Min(round(pal[0].r * (1 + lightboost) / 255), 255), 8);
      lpal.palPalEntry[j].peGreen := Max(Min(round(pal[0].g * (1 + lightboost) / 255), 255), 8);
      lpal.palPalEntry[j].peBlue := Max(Min(round(pal[0].b * (1 + lightboost) / 255), 255), 8);
{      lpal.palPalEntry[j].peRed := Max(Min(pal[0].r + lightboost, 255), 8);
      lpal.palPalEntry[j].peGreen := Max(Min(pal[0].g + lightboost, 255), 8);
      lpal.palPalEntry[j].peBlue := Max(Min(pal[0].b + lightboost, 255), 8);}
    end
    else
    begin
      for j := 1 to 254 do
      begin
        pal[j].r := Max(pal[j].r, 8);
        pal[j].g := Max(pal[j].g, 8);
        pal[j].b := Max(pal[j].b, 8);
        lpal.palPalEntry[j].peRed := pal[j].r;
        lpal.palPalEntry[j].peGreen := pal[j].g;
        lpal.palPalEntry[j].peBlue := pal[j].b;
      end;
      j := 255;
      lpal.palPalEntry[j].peRed := Max(pal[0].r, 8);
      lpal.palPalEntry[j].peGreen := Max(pal[0].g, 8);
      lpal.palPalEntry[j].peBlue := Max(pal[0].b, 8);
    end;

    hpal := CreatePalette(lpal^);

    if sprdim = nil then
      GetMem(sprdim, (maxtex + 1) * SizeOf(TDuke3DSprDimention));

    Textures.Sorted := True;
    Textures2 := TDXStringList.Create;
    bmp := TBitmap.Create;
    try
      bmp.PixelFormat := pf8bit;
      if hpal <> 0 then
        bmp.Palette := hpal;

      id := -1;
      while id < 999 do
      begin
        inc(id);
        entry := 'TILES' + {$IFNDEF NO_DXTABLES}TABLE_INTTOSTR3[id]{$ELSE}IntToStr3(id){$ENDIF} + '.ART';
        entrynum := FindDuke3DDIREntry(entry, DIR, numEntries);
        if entrynum >= 0 then
        begin
          f2 := nil;
          f1.Seek(DIR[entrynum].Position, soFromBeginning);
        end
        else
        begin
          entrynum := -1;
          if FileExists(entry) then
          begin
            f2 := TCachedFileStream.Create(entry, fmOpenRead or fmShareDenyWrite);
          end
        end;
        if (f2 <> nil) or (entrynum >= 0) then
        begin
          if f2 <> nil then
            f := f2
          else
            f := f1;

          f.Read(tmp, SizeOf(tmp));
          if tmp <> 1 then
          begin
            Result := False;
            break;
          end;
          f.Read(tmp, SizeOf(tmp));
          f.Read(tilestart, SizeOf(tilestart));
          f.Read(tileend, SizeOf(tileend));
          tilenum := tileend - tilestart + 1;
          f.Read(widths, tilenum * SizeOf(word));
          f.Read(heights, tilenum * SizeOf(word));
          f.Seek(tilenum * SizeOf(longint), soFromCurrent);
          for i := 0 to tilenum - 1 do
          begin
            i_tilestart := i + tilestart;
            if i_tilestart > maxtex then
              id := 999
            else
            begin
              curSize := widths[i] * heights[i];
              if pb[i_tilestart] then
              begin
                if curSize > 0 then
                begin
                  s := GetDuke3DLinkDescription(GRPFile, i_tilestart);
                  if Textures.IndexOf(s) = -1 then
                  begin
                    bmpHeight := heights[i];
                    bmp.Height := bmpHeight;
                    bmpWidth := widths[i];
                    bmp.Width := bmpWidth;
                    SetBufSize(curSize);
                    f.Read(buf^, curSize);

                    for j := 0 to bmpHeight - 1 do
                    begin
                      P := bmp.ScanLine[j];
                      for k := 0 to bmpWidth - 1 do
                      begin
                        pbb := @buf[j + k * bmpHeight];
                        if pbb^ = $FF then
                          P[k] := 0
                        else if pbb^ = 0 then
                          P[k] := $FF
                        else
                          P[k] := pbb^;
                      end;
                    end;

                    sprdim[i_tilestart].Width := bmpWidth;
                    sprdim[i_tilestart].Height := bmpHeight;
//     bmp.SaveToFile('d:\duketextures\' + IntToStr(i) + '.bmp');
                    if doSquare then
                      MakeSquareBitmap(bmp, True)
                    else
                      MakePowerOf2BitmapFast(bmp);
//     bmp.SaveToFile('d:\duketextures\' + IntToStr(i) + '_2.bmp');
                    sprdim[i_tilestart].transWidth := bmp.width;
                    sprdim[i_tilestart].transHeight := bmp.height;
//                    bmp.Canvas.TextOut(5, 5, IntToStr(i_tilestart));
                    Textures2.Objects[Textures2.Add(s)] :=
                      TDirect3DTexture2.Create(DXDraw, bmp, False);
                  end;
                  pb[i_tilestart] := False;
                end;
              end
              else
                f.Seek(curSize, soFromCurrent);

            end;
          end;
          if f2 <> nil then
          begin
            FreeAndNilSafe(f2);
          end;
        end
        else
          id := 999;
      end;

      bmp.Width := 16;
      bmp.Height := 16;
      bmp.Canvas.Pen.Width := 1;
      bmp.Canvas.Pen.Color := clGray;
      bmp.Canvas.Brush.Color := clWhite;
      bmp.Canvas.Rectangle(0, 0, 16, 16);

      for i := 1 to maxtex do
        if pb[i] then
        begin
          s := GetDuke3DLinkDescription(GRPFile, i);
          if Textures.IndexOf(s) = -1 then
          begin
            sprdim[i].Width := 16;
            sprdim[i].Height := 16;
            Textures2.Objects[Textures2.Add(s)] :=
              TDirect3DTexture2.Create(DXDraw, bmp, False);
          end;
        end;

      for i := 0 to Textures2.Count - 1 do
        Textures.AddObject(Textures2.Strings[i], Textures2.Objects[i]);

    finally
      bmp.Free;
      Textures2.Free;
    end;

    FreeMem(lpal);
    DeleteObject(hpal);

    if buf <> nil then
      ReAllocMem(buf, 0);

  finally
    f1.Free;
  end;
end;

function TD3DScene.CacheDuke3DTextures(GRPFile: TFileName; TextureNames: TDXStringList;
  var sprdim: PDuke3DSprDimentions; doSquare: boolean = True;
  DIR: PDuke3DDirectories = nil; numEntries: integer = -1;
  lightboost: integer = 0): boolean;
var id, i: integer;
    pb: PBooleanArray;
    maxtex: integer;
    TextureIDs: PIntegerArray;

begin
  if (DIR = nil) or (numEntries = -1) then
  begin
    numEntries := ReadDuke3DDirectory(GRPFile, DIR);
    if (DIR = nil) or (numEntries = -1) then
    begin
      Result := False;
      Exit;
    end;
  end;

  if TextureNames <> nil then
  begin
    GetMem(TextureIDs, TextureNames.Count * SizeOf(integer));
    try
      maxtex := 0;
      for i := 0 to TextureNames.Count - 1 do
      begin
        TextureIDs[i] := StrToIntDef(TextureNames.Strings[i], -1);
        maxtex := max(maxtex, TextureIDs[i]);
      end;
      GetMem(pb, (maxtex + 1) * SizeOf(boolean));
      GetMem(sprdim, (maxtex + 1) * SizeOf(TDuke3DSprDimention));
      FillChar(sprdim^, (maxtex + 1) * SizeOf(TDuke3DSprDimention), Chr(0));
      for i := 0 to maxtex do
        pb[i] := False;

      for i := 0 to TextureNames.Count - 1 do
      begin
        id := TextureIDs[i];
        if id <> -1 then
          pb[id] := True;
      end;
    finally
      FreeMem(TextureIDs, TextureNames.Count * SizeOf(integer));
    end;
  end
  else
  begin
    maxtex := $FFFE;
    GetMem(pb, (maxtex + 1) * SizeOf(boolean));
    GetMem(sprdim, (maxtex + 1) * SizeOf(TDuke3DSprDimention));
    FillChar(sprdim^, (maxtex + 1) * SizeOf(TDuke3DSprDimention), Chr(0));
    for i := 0 to maxtex do
      pb[i] := True;
  end;

  Result := CacheDuke3DTextures(GRPFile, pb, maxtex, sprdim, doSquare, DIR, numEntries, lightboost);

  FreeMem(pb, (maxtex + 1) * SizeOf(boolean));

end;
{$ENDIF}

{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_DOOMSUPPORT}
function TD3DScene.CacheIDWADTexture(MainWAD: TFileName; TextureName: string;
  doSquare: boolean = True {$IFNDEF DOOMVIEWER}; defaultExt: string = '' {$ENDIF}): boolean;
var
  s: TDXStringList;
begin
  s := TDXStringList.Create;
  try
    s.Add(TextureName);
    Result := CacheIDWADTextures(MainWAD, '', s, doSquare{$IFNDEF DOOMVIEWER} , defaultExt {$ENDIF});
  finally
    s.Free;
  end;
end;
{$ENDIF}
{$ENDIF}

{$IFNDEF NO_IDSOFTGAMESSUPPORT}
procedure FastTransBltBitmaps8bit(bmp, bmp2: TBitmap; xofs, yofs: integer);
var
  xdd, ydd: integer;
  xddstart, yddstart: integer;
  xddend, yddend: integer;
  pdd, pdd2: PByteArray;
  pbdd, pbdd2: PByte;
begin
  xddstart := Max(0, -xofs);
  xddend := Min(bmp2.Width, bmp.Width - xofs) - 1;
  yddstart := Max(0, -yofs);
  yddend := Min(bmp2.Height, bmp.Height - yofs) - 1;

  for ydd := yddstart to yddend do
  begin
    pdd := bmp.ScanLine[ydd + yofs];
    pdd2 := bmp2.ScanLine[ydd];
    pbdd2 := @pdd2[xddstart];
    pbdd := @pdd[xofs + xddstart];
    for xdd := xddstart to xddend do
    begin
      if integer(pbdd2^) <> 0 then
        pbdd^ := pbdd2^;
      inc(pbdd);
      inc(pbdd2);
    end;
  end;
end;

{$IFNDEF NO_DOOMSUPPORT}
function TD3DScene.CacheIDWADTextures(MainWAD, PWAD: TFileName; TextureNames: TDXStringList;
  doSquare: boolean = True; {$IFNDEF DOOMVIEWER} defaultExt: string = ''; {$ENDIF}
  DIR: PDoomDirectory = nil;
  numEntries: integer = -1; wadType: TIDSoftWADType = idUnknown;
  lCachedTexturesInfo: PDoomTexturesInfo = nil; numCachedTextures: integer = -1;
  doompal: PDoomPalette = nil; doStubBmps: boolean = True): boolean;
var
  pal: TDoomPalette;
  pEntry: PPalEntry;
  f: TCachedFileStream;
  i, j, k, l, count: integer;
  last_pnameid: smallint;
  xdd, ydd: integer;
  xddstart, yddstart: integer;
  xddend, yddend: integer;
  pdd, pdd2: PByteArray;
  pbdd, pbdd2: PByte;
  IDSoftDataModule: TIDSoftDataModule;
  FLOORSDIR: PDoomDirectory;
  numFloors: integer;
  WALLSDIR: PDoomDirectory;
  numWalls: integer;
  SPRITESDIR: PDoomDirectory;
  numSprites: integer;
  found: boolean;
  bmp, bmp2: TBitmap;
  lpal: PLogPalette;
  hpal: HPALETTE;
  plpale: PPaletteEntry;
  plpalen: PPaletteEntry;
  y: integer;
  m: TMemoryStream;
  s: string;
  PNames: PPatchNames;
  numPNames: integer;
  lTexturesInfo: PDoomTexturesInfo;
  lti: PDoomTextureInfo;
  numTextures: integer;
  pnameind: smallint;    // patch name index in PNAMES table
  xofs, yofs: smallint; // offset in texture space for the wall patch
  nearBlack: byte; // Index פחע נבכפפבע ךןםפ ףפן לב‎סן
  Cache: PByteArray;
  pB, pB2: PByte;
  OffSets: TOffsetList;
  nb: TColor;
//    RowBuff: array[1..320] of byte;
  ScanLines: array[0..255] of PByteArray;
  DEntryName: string;
  pDIRi, pDIRiEnd: PDoomDirEntry;
  Textures2: TDXStringList;
  TextureNames2: TDXStringList;
  dmChr1, dmChr2, dmChr3: TDoomCharArray;

  procedure CopyTextures;
  var
    local_i: integer;
  begin
    Textures.Sorted := False;
    for local_i := 0 to Textures2.Count - 1 do
      Textures.AddObject(Textures2.Strings[local_i], Textures2.Objects[local_i]);
    Textures.Sorted := True;
    Textures2.Clear;
  end;

  function IsValidTextureDimention(const d: integer): boolean;
  begin
    Result := (d = 8) or (d = 16) or (d = 32) or (d = 64) or (d = 128) or
              (d = 256) or (d = 512) or (d = 1024);
  end;

  function CreateIDWADWallBMP(bitmap: TBitmap; doPad: boolean = False; texName: string = ''): boolean;
  var
    sd: TSpDim;
    x, y: integer;
    sRow: byte;
    rowLen: integer;
    spSize: integer;
    sdxSize, sdySize: integer;
{$IFNDEF NO_DOOMTHINGS}
    bmpTmp: TBitmap;
    cCanvas: TCanvas;
    cCanvasTmp: TCanvas;
    animEnd: char;
{$ENDIF}
    fRead: integer;
    RowBuf: PByteArray;
    ry: PByte;
    psl: ^PByteArray;
  begin
    Result := False;
    f.Read(sd, SizeOf(sd));
    sdxSize := sd.xSize;
    sdySize := sd.ySize;
    spSize := sdxSize * sdySize;
    if (spSize <= MAXWALLSIZE) and
       (sdxSize <= 320) and (sdxSize > 0) and
       (sdySize <= 256) and (sdySize > 0) then
    begin
      bitmap.Width := sdxSize;
      bitmap.Height := sdySize;
{      bitmap.Canvas.Brush.Color := clBlack;
      bitmap.Canvas.FillRect(Rect(0, 0, sd.xSize, sd.ySize));}
//      GetMem(Offsets, sd.xSize * 4);  {Allocate Row Offset Buffer}
      f.Read(Offsets, sdxSize * 4); {Read Row Offset Buffer}
      f.Read(Cache^, Offsets[sdxSize - 1] + sdySize + 2);
      fRead := integer(Cache);
/////////////////////////////////////////////////
      for y := 0 to sdySize - 1 do
      begin
        ScanLines[y] := bitmap.ScanLine[y];
        FillChar(ScanLines[y]^, sd.xSize, 0);
      end;

      for x := 0 to sdxSize - 1 do
      begin
        sRow := byte(pointer(fRead)^);
        inc(fRead);
        while sRow <> 255 do
        begin
          rowLen := byte(pointer(fRead)^);
          inc(fRead, 3); // skip 2 bytes
          RowBuf := pointer(fRead);
          inc(fRead, rowLen);
          ry := @RowBuf[0];
          psl := @ScanLines[sRow];
          for y := 0 to rowLen - 1 do
          begin
            if ry^ = 0 then
              psl^[x] := nearBlack
            else
              psl^[x] := ry^;
            inc(psl);
//            ScanLines[y + sRow][x] := ry^;
            inc(ry);
          end;
          sRow := byte(pointer(fRead)^);
          inc(fRead);
        end;
      end;
/////////////////////////////////////////////////////////////////////
(********************************************************
      for x := 0 to sd.xSize - 1 do
      begin
        sRow := byte(pointer(fRead)^);
        inc(fRead);
        while sRow <> 255 do
        begin
          RowLen := byte(pointer(fRead)^);
          inc(fRead, 3); // skip 2 bytes
          RowBuf := pointer(fRead);
          inc(fRead, RowLen);
          for y := 0 to rowLen - 1 do
          begin
            ry := RowBuf[y];
            if ry = 0 then
            begin
//              PByteArray(bitmap.ScanLine[y + sRow])[x] := nearBlack;
//              PByteArray(bitmap.ScanLine[x])[y + sRow] := nearBlack;

//              pEntry := @pal[nearBlack];
//              (ScanLines[y + sRow])[x] := nearBlack
//              PByteArray(bitmap.ScanLine[y + sRow])[x] := nearBlack;
              cCanvas.Pixels[x, (y + sRow)] := nb;
//                RGB(pEntry.r, pEntry.g, pEntry.b)
            end
            else
            begin
              pEntry := @pal[ry];
//              (ScanLines[y + sRow])[x] := RowBuf[y];
//              PByteArray(bitmap.ScanLine[y + sRow])[x] := RowBuf[y];
              cCanvas.Pixels[x, (y + sRow)] :=
                RGB(pEntry.r, pEntry.g, pEntry.b);
            end;
          end;

          sRow := byte(pointer(fRead)^);
          inc(fRead);
        end; {while}
      end; {for x}
//      FreeMem(Offsets, sd.xSize * 4); {Free Row Offset Buffer}
********************************************************)

{$IFNDEF NO_DOOMTHINGS}
      if doPad then
      begin
        cCanvas := bitmap.Canvas;

        if texName <> '' then
        begin
          if GetPredefinedTextureDimentions(wadType, texName, x, y, animEnd) then
          begin
            bmpTmp := TBitmap.Create;
            try
              bmpTmp.Assign(bitmap);
              cCanvasTmp := bmpTmp.Canvas;
              bmpTmp.Width := x;
              bmpTmp.Height := y;
              cCanvasTmp.Brush.Color := clBlack;
              cCanvasTmp.FillRect(Rect(0, 0, x, y));
              cCanvasTmp.Draw(x div 2 - sd.xOffs, y - sdySize, bitmap);
              bmpTmp.Transparent := False;
              bitmap.Width := x;
              bitmap.Height := y;
              cCanvas.Draw(0, 0, bmpTmp);
              doPad := False;
            finally
              bmpTmp.Free;
            end;
          end;
        end;

        if doPad and (sdxSize < 129) and (sdySize < 129) then
        begin
          bmpTmp := TBitmap.Create;
          try
            bmpTmp.Assign(bitmap);
            cCanvasTmp := bmpTmp.Canvas;
            bmpTmp.Width := 128;
            bmpTmp.Height := 128;
            cCanvasTmp.Brush.Color := clBlack;
            cCanvasTmp.FillRect(Rect(0, 0, 128, 128));
            if (sd.xOffs > 64) or
               (sd.yOffs > 128) then
            else
            begin
              cCanvasTmp.Draw(64 - sd.xOffs, 128 - sdySize, bitmap);
              bmpTmp.Transparent := False;
              bitmap.Width := 128;
              bitmap.Height := 128;
              cCanvas.Draw(0, 0, bmpTmp);
              doPad := False;
            end;
          finally
            bmpTmp.Free;
          end;
        end;

        if doPad and (sdxSize < 258) and (sdySize < 258) then
        begin
          bmpTmp := TBitmap.Create;
          try
            bmpTmp.Assign(bitmap);
            cCanvasTmp := bmpTmp.Canvas;
            bmpTmp.Width := 256;
            bmpTmp.Height := 256;
            cCanvasTmp.Brush.Color := clBlack;
            cCanvasTmp.FillRect(Rect(0, 0, 256, 256));
            if ((128 - sd.xOffs) + bitmap.Width > 256 * 1.2) or
               ((128 - sd.yOffs) + bitmap.Height > 256 * 1.2) then
            else
            begin
              cCanvasTmp.Draw(128 - sd.xOffs, 256 - sdySize, bitmap);
              bmpTmp.Transparent := False;
              bitmap.Width := 256;
              bitmap.Height := 256;
              cCanvas.Draw(0, 0, bmpTmp);
            end;
          finally
            bmpTmp.Free;
          end;
        end;
      end;
{$ENDIF}

      Result := True;
    end;
  end;

  procedure AddTextureInfoInList(idx: PDoomDirEntry);
  var
    numTex: integer;
    n: integer;
    offSets: PIntegerArray;
    doSeek: boolean;
    flds: smallint;
  begin
    f.Seek(idx.position, soFromBeginning);
    f.Read(numTex, 4); // ִיבגזןץלו פןם בסיטל פשם Textures
    GetMem(offSets, numTex * SizeOf(integer));
    f.Read(offSets^, numTex * SizeOf(integer));

    if (wadtype in [idStrife, idUnKnown]) and (numTex > 1) then
    begin
      f.Seek(idx.Position + Offsets[0] + 16, soFrombeginning);
      f.Read(flds, 2);
      if offsets[1] - offsets[0] = 18 + flds * 6 then
      begin
        f.Seek(idx.Position + Offsets[0] + 20, soFrombeginning);
        f.Read(flds, 2);
        doSeek := offsets[1] - offsets[0] = 20 + flds * 8;
        if not doSeek then
          wadtype := idStrife2;
      end
      else
        doSeek := True;
    end
    else
      doSeek := wadtype <> idStrife2;

    n := 0;

    if doSeek then
    begin
      repeat
        lti := @lTexturesInfo[numTextures];
        lti.texofs := idx.Position + offSets[n];
        f.Seek(lti.texofs, soFromBeginning);
        f.Read(lti.Name, 8);
        f.Seek(lti.texofs + 12, soFrombeginning);
        f.Read(lti.dimentions, 4);
//      f.Read(lti.w, 2);
//      f.Read(lti.h, 2);
        f.Seek(lti.texofs + 20, soFrombeginning);
        f.Read(lti.fields, 2);
        inc(numTextures);
        inc(n);
      until (n = numTex);
    end
    else
    begin
      repeat
        lti := @lTexturesInfo[numTextures];
        lti.texofs := idx.Position + offSets[n];
        f.Seek(lti.texofs, soFromBeginning);
        f.Read(lti.Name, 8);
        f.Seek(lti.texofs + 12, soFrombeginning);
        f.Read(lti.dimentions, 4);
//      f.Read(lti.w, 2);
//      f.Read(lti.h, 2);
        f.Read(lti.fields, 2);
        inc(numTextures);
        inc(n);
      until (n = numTex);
    end;
    FreeMem(offSets, numTex * SizeOf(integer));
  end;

const
  PWADFLAG = 'usingPWAD';
var
  isUsingPWAD: boolean;
begin
  Result := False;
  isUsingPWAD := TextureNames.IndexOf(PWADFLAG) > -1;

  if isUsingPWAD then
  begin
    TextureNames.Delete(TextureNames.IndexOf(PWADFLAG));
    isUsingPWAD := (PWAD <> MainWAD) and (PWAD <> '');
  end;

  Textures.Sorted := True;

  Textures2 := TDXStringList.Create;

  try
    for i := TextureNames.Count - 1 downto 0 do
    begin
      s := TextureNames.Strings[i];
      if IsSpecialTextureName(s) then
      begin
        if LoadTexture(s) then
        begin
          if Textures.IndexOf(s) = -1 then
            Textures2.Objects[Textures2.Add(s)] :=
              TDirect3DTexture2.Create(DXDraw, fImageLoader.Picture.bitmap, False);

          s := GetWADLinkDescription(MAINWAD, s);
          if Textures.IndexOf(s) = -1 then
            Textures2.Objects[Textures2.Add(s)] :=
              TDirect3DTexture2.Create(DXDraw, fImageLoader.Picture.bitmap, False);

          TextureNames.Delete(i);
        end;
      end;
    end;
  finally
  end;

  if isUsingPWAD then
    PWAD := GetExistedFileName(PWAD)
  else
    MainWAD := GetExistedFileName(MainWAD);

  if wadType = idUnknown then
  begin
    if (DIR = nil) or (numEntries = -1) then
    begin
      if isUsingPWAD then
        wadType := GetWadType(PWAD)
      else
        wadType := GetWadType(MainWAD)
    end
    else
      wadType := GetWadType(DIR, numEntries);
  end;

  if wadType in [idInvalid, idVJ] then
    Exit;

  TextureNames.Sorted := True;

  if isUsingPWAD then
    f := TCachedFileStream.Create(PWAD, fmOpenRead or fmShareDenyWrite, $4000)
  else
    f := TCachedFileStream.Create(MainWAD, fmOpenRead or fmShareDenyWrite, $4000);

  try
    if (DIR = nil) or (numEntries = -1) then
    begin
      f.Seek(4, soFromBeginning);
      f.Read(count, SizeOf(count));
      f.Read(l, SizeOf(l));
      f.Seek(l, soFromBeginning);
      GetMem(DIR, count * SizeOf(TDoomDirEntry));
      f.Read(DIR^, count * SizeOf(TDoomDirEntry));
      AdjustWadDirectory(dir, count);
    end
    else
      count := numEntries;

    pDIRiEnd := @DIR[count];

    if doompal <> nil then
      Pal := doompal^
    else
    begin
      dmChr1 := DoomStringName(rsPlayPal);
      dmChr2 := DoomStringName(rsPal);

      pDIRi := @DIR[0];
      repeat
        found := DoomEntryNamesEqual(pDIRi.Name, dmChr1, dmChr2);
        inc(pDIRi);
      until found or (pDIRi = pDIRiEnd);

      if found then
      begin
        dec(pDIRi);
        f.Seek(pDIRi.position, soFromBeginning);
        f.Read(Pal, SizeOf(Pal));
      end
      else
      begin
        m := TMemoryStream.Create;
        IDSoftDataModule := TIDSoftDataModule.Create(nil);
        try
          case wadType of
            idDoom, idNew, idUnknown:
              IDSoftDataModule.DefaultDoomPalette.SaveToStream(m, False);
            idHeretic:
              IDSoftDataModule.DefaultHereticPalette.SaveToStream(m, False);
            idHexen:
              IDSoftDataModule.DefaultHexenPalette.SaveToStream(m, False);
            idStrife:
              IDSoftDataModule.DefaultStrifePalette.SaveToStream(m, False);
          else
            IDSoftDataModule.DefaultDoomPalette.SaveToStream(m, False);
          end;
          m.Seek(0, soFromBeginning);
          m.Read(Pal, SizeOf(Pal));
        finally
          m.Free;
          IDSoftDataModule.Free;
        end;
      end;
    end;

    // ִחליןץסדן‎לו פן bitmap
    bmp := TBitmap.Create;
    bmp.PixelFormat := pf8bit;

    // ִחליןץסדן‎לו פחם נבכפפב
    GetMem(lpal, SizeOf(TLogPalette) + SizeOf(TPaletteEntry) * 255);
    lpal.palVersion := $300;
    lpal.palNumEntries := 256;
    plpale := @lpal.palPalEntry[0];
    plpale.peRed := 0;
    plpale.peGreen := 0;
    plpale.peBlue := 0;
    for j := 1 to 255 do
    begin
      pEntry := @pal[j];
      pEntry.r := Max(pEntry.r, 8);
      pEntry.g := Max(pEntry.g, 8);
      pEntry.b := Max(pEntry.b, 8);

      plpale := @lpal.palPalEntry[j];
      plpale.peRed := pEntry.r;
      plpale.peGreen := pEntry.g;
      plpale.peBlue := pEntry.b;
    end;
    nearBlack := 1;
    plpalen := @lpal.palPalEntry[nearBlack];
    // RGB(0,0,0) holds transparency information, so we change it to RGB(1,1,1)
    for j := 255 downto 1 do
    begin
      plpale := @lpal.palPalEntry[j];
      if ((plpale.peRed +
           plpale.peGreen +
           plpale.peBlue) <
          (plpalen.peRed +
           plpalen.peGreen +
           plpalen.peBlue)) and
         ((plpale.peRed +
           plpale.peGreen +
           plpale.peBlue) <> 0) then
      begin
        nearBlack := j;
        plpalen := @lpal.palPalEntry[nearBlack];
      end;
    end;

    pEntry := @pal[nearBlack];
    nb := RGB(pEntry.r, pEntry.g, pEntry.b);

    for j := 255 downto 1 do
    begin
      plpale := @lpal.palPalEntry[j];
      if plpale.peRed = 0 then
        if plpale.peGreen = 0 then
          if plpale.peBlue = 0 then
            plpale^ := plpalen^;
    end;
    hpal := CreatePalette(lpal^);
    if hpal <> 0 then
      bmp.Palette := hpal;

    // FLOORS //
    bmp.Width := 64;
    bmp.Height := 64;
    // ִיבגזןץלו פב נבפ‏לבפב
    GetMem(FLOORSDIR, count * SizeOf(TDoomDirEntry));
    dmChr1 := DoomStringName(rsF_START);
    dmChr2 := DoomStringName(rsFF_START);
    pDIRi := @DIR[0];
    repeat
      found := DoomEntryNamesEqual(pDIRi.Name, dmChr1, dmChr2);
      inc(pDIRi);
    until (pDIRi = pDIRiEnd) or found;
    numFloors := 0;
    if found then
    begin
      found := False;
      dmChr1 := DoomStringName(rsF_END);
      dmChr2 := DoomStringName(rsFF_END);
      dec(pDIRi);
      repeat
        if DoomEntryNamesEqual(pDIRi.Name, dmChr1, dmChr2) then
          found := True
        else
        begin
          if pDIRi.Size > 0 then
          begin
            FLOORSDIR[numFloors] := pDIRi^;
            inc(numFloors);
          end;
        end;
        inc(pDIRi);
      until (pDIRi = pDIRiEnd) or found;
    end;
    // Cache דיב פחם בםדםשףח פשם נבפשלפשם
    GetMem(Cache, 64 * 64);

    pDIRi := @FLOORSDIR[0];
    for i := 0 to numFloors - 1 do
    begin
      s := DoomEntryName(pDIRi.Name);
      if TextureNames.IndexOf(s) > -1 then
      begin
      {$IFNDEF DOOMVIEWER}
        if defaultExt <> '' then
        begin
          if defaultExt[1] = '.' then
            s := s + defaultExt
          else
            s := s + '.' + defaultExt;
        end
        else {$ENDIF}
          s := GetWadLinkDescription(MainWAD, s);
        if Textures.IndexOf(s) < 0 then
        begin
          f.Seek(pDIRi.position, soFromBeginning);
          f.ReadNoBuffer(Cache^, 64 * 64);
          pB := @Cache[0];
          pB2 := @Cache[64 * 64];
          while pB <> pB2 do
          begin
            if pB^ = 0 then
              pB^ := nearblack;
            inc(pB);
          end;
{          for j := 0 to 64 * 64 - 1 do // Optimization ????
            if pB^ = 0 then
              pB^ := nearblack;}
          SetBitmapBits(bmp.Handle, 64 * 64, Cache);
//     bmp.SaveToFile('d:\doomtextures\' + GetWadLinkEntryName(s) + '.bmp');
          Textures2.Objects[Textures2.Add(s)] := TDirect3DTexture2.Create(DXDraw, bmp, False);
        end;
      end;
      inc(pDIRi);
    end;

    // WALLS //
    ReAllocMem(Cache, 320 * 256);
    WALLSDIR := FLOORSDIR;
    found := False;
    dmChr1 := DoomStringName(rsP_START);
    dmChr2 := DoomStringName(rsPP_START);
    pDIRi := @DIR[0];
    repeat
      if DoomEntryNamesEqual(pDIRi.Name, dmChr1, dmChr2) then
        found := True;
      inc(pDIRi);
    until (pDIRi = pDIRiEnd) or found;
    numWalls := 0;
    if found then
    begin
      found := False;
      dmChr1 := DoomStringName(rsP_END);
      dmChr2 := DoomStringName(rsPP_END);
      repeat
        if DoomEntryNamesEqual(pDIRi.Name, dmChr1, dmChr2) then
          found := True
        else if pDIRi.Size > 0 then
        begin
          WALLSDIR[numWalls] := pDIRi^;
          inc(numWalls);
        end;
        inc(pDIRi);
      until (pDIRi = pDIRiEnd) or found;
      found := False;
    end;
    QuickSortDoomDirectory(WALLSDIR, numWalls);

    dmChr1 := DoomStringName(rsPNAMES);
    pDIRi := @DIR[0];
    repeat
      if DoomEntryNamesEqual(pDIRi.Name, dmChr1) then
        found := True
      else
        inc(pDIRi)
    until (pDIRi = pDIRiEnd) or found;
    numPNames := 0;
    if found then
    begin
      f.Seek(pDIRi.position, soFromBeginning);
      f.Read(numPNames, SizeOf(numPNames));
      GetMem(PNames, numPNames * 8);
      f.Read(PNames^, numPNames * 8);
      AdjustPatchNames(PNames, numPNames);
    end
    else
      PNames := nil;

    if (lCachedTexturesInfo = nil) or (numCachedTextures = -1) then
    begin
      System.new(lTexturesInfo);
      numTextures := 0;

      dmChr1 := DoomStringName(rsTexture1);
      dmChr2 := DoomStringName(rsTexture2);
      dmChr3 := DoomStringName(rsTexture3);
      pDIRi := @DIR[0];
      repeat
        if DoomEntryNamesEqual(pDIRi.Name, dmChr1, dmChr2, dmChr3) then
          AddTextureInfoInList(pDIRi);
        inc(pDIRi);
      until pDIRi = pDIRiEnd;
    end
    else
    begin
      lTexturesInfo := lCachedTexturesInfo;
      numTextures := numCachedTextures;
    end;

    bmp2 := TBitmap.Create;
    bmp2.pixelFormat := pf8bit;
    if hpal <> 0 then
      bmp2.Palette := hpal;
    last_pnameid := -2;

    if numTextures > 0 then
    begin
      lti := @lTexturesInfo[0];
      for i := 0 to numTextures - 1 do
      begin
        s := DoomEntryName(lti.Name);
        if TextureNames.IndexOf(s) > -1 then
        begin
        {$IFNDEF DOOMVIEWER}
          if defaultExt <> '' then
          begin
            if defaultExt[1] = '.' then
              s := s + defaultExt
            else
              s := s + '.' + defaultExt;
          end
          else {$ENDIF}
            s := GetWadLinkDescription(MainWAD, s);
          if Textures.IndexOf(s) < 0 then
          begin
            if PNames = nil then
            begin
              bmp.Width := 2;
              bmp.Height := 2;
              bmp.Canvas.Pixels[0, 0] := clWhite;
              bmp.Canvas.Pixels[1, 0] := clWhite;
              bmp.Canvas.Pixels[0, 1] := clWhite;
              bmp.Canvas.Pixels[1, 1] := clWhite;
              Textures2.Objects[Textures2.Add(s)] := TDirect3DTexture2.Create(DXDraw, bmp, False);
            end
            else
            begin
              bmp.Width := lti.w;
              bmp.Height := lti.h;
              bmp.Canvas.Brush.Color := clBlack;
              bmp.Canvas.FillRect(Rect(0, 0, lti.w, lti.h));
              for j := 0 to lti.fields - 1 do
              begin
                if wadtype = idStrife2 then
                  f.Seek(lti.texofs + 18 + j * 6, soFromBeginning)
                else
                  f.Seek(lti.texofs + 22 + j * 10, soFromBeginning);
                f.Read(xofs, 2);
                f.Read(yofs, 2);
                f.Read(pnameind, 2);

                if pnameind <> last_pnameid then
                begin
                  last_pnameid := pnameind;
                  k := SearchSortedDoomDirectory(WALLSDIR, numWalls, PNames[pnameind]);

                  if k >= 0 then
                  begin
                    begin
                      f.Seek(WALLSDIR[k].position, soFromBeginning);
                      CreateIDWADWallBMP(bmp2);
  //     bmp2.SaveToFile('d:\doomtextures\' + DoomEntryName(PNames[pnameind]) + '.bmp');
                    end;
                  end
                  else
                  begin
                    bmp2.Canvas.Brush.Color := clWhite;
                    bmp2.Canvas.FillRect(Rect(0, 0, bmp2.Width, bmp2.Height));
                  end;
                end;

                FastTransBltBitmaps8bit(bmp, bmp2, xofs, yofs);

              end;

              if doSquare or
                (not IsValidTextureDimention(lti.w)) or
                (not IsValidTextureDimention(lti.h)) then
                  MakePowerOf2BitmapFast(bmp);
//     bmp.SaveToFile('d:\doomtextures\' + GetWadLinkEntryName(s) + '.bmp');
              Textures2.Objects[Textures2.Add(s)] := TDirect3DTexture2.Create(DXDraw, bmp, False);
            end;
          end;

        end;
        inc(lti);
      end;
    end;

    if (lCachedTexturesInfo = nil) or (numCachedTextures = -1) then
      System.Dispose(lTexturesInfo);

    if PNames <> nil then
      FreeMem(PNames, numPNames * 8);

    // SPRITES //
    SPRITESDIR := WALLSDIR;
    found := False;
    dmChr1 := DoomStringName(rsS_START);
    dmChr2 := DoomStringName(rsSS_START);
    pDIRi := @DIR[0];
    repeat
      if DoomEntryNamesEqual(pDIRi.Name, dmChr1, dmChr2) then
        found := True;
      inc(pDIRi);
    until (pDIRi = pDIRiEnd) or found;
    numSprites := 0;
    if found then
    begin
      found := False;
      dmChr1 := DoomStringName(rsS_END);
      dmChr2 := DoomStringName(rsSS_END);
      repeat
       if DoomEntryNamesEqual(pDIRi.Name, dmChr1, dmChr2) then
          found := True
        else if pDIRi.Size > 0 then
        begin
          if pDIRi.Name[5] in [#0, 'A', 'B', 'C', 'D'] then
          begin
            SPRITESDIR[numSprites] := pDIRi^;
            inc(numSprites);
          end;
        end;
        inc(pDIRi);
      until (pDIRi = pDIRiEnd) or found;
    end;

    pDIRi := @SPRITESDIR[0];
    for i := 0 to numSprites - 1 do
    begin
      DEntryName := DoomEntryName(pDIRi.Name);
      if TextureNames.IndexOf(DEntryName) > -1 then
      begin
      {$IFNDEF DOOMVIEWER}
        if defaultExt <> '' then
        begin
          if defaultExt[1] = '.' then
            s := DEntryName + defaultExt
          else
            s := DEntryName + '.' + defaultExt;
        end
        else {$ENDIF}
          s := GetWadLinkDescription(MainWAD, DEntryName);
        if Textures.IndexOf(s) < 0 then
        begin
          f.Seek(pDIRi.position, soFromBeginning);
          CreateIDWADWallBMP(bmp, True, DEntryName);
//     bmp.SaveToFile('d:\doomtextures\' + GetWadLinkEntryName(s) + '.bmp');
          Textures2.Objects[Textures2.Add(s)] := TDirect3DTexture2.Create(DXDraw, bmp, False);
        end;
      end;
      inc(pDIRi);
    end;
    FreeMem(SPRITESDIR, count * SizeOf(TDoomDirEntry));

    ReAllocMem(Cache, 0);

    CopyTextures;

    if (PWAD = '') or isUsingPWAD or (MAINWAD = PWAD) then
    begin
      if doStubBmps then
      begin
        bmp.Width := 2;
        bmp.Height := 2;
        bmp.Canvas.Pixels[0, 0] := clWhite;
        bmp.Canvas.Pixels[1, 0] := clWhite;
        bmp.Canvas.Pixels[0, 1] := clWhite;
        bmp.Canvas.Pixels[1, 1] := clWhite;
        for i := 0 to TextureNames.Count - 1 do
          if Textures.IndexOf(GetWadLinkDescription(MainWAD, TextureNames.Strings[i])) < 0 then
          begin
            Textures2.Objects[Textures2.Add(GetWADLinkDescription(MainWAD, TextureNames.Strings[i]))] :=
              TDirect3DTexture2.Create(DXDraw, bmp, False);
          end;
        CopyTextures;
      end;
    end
    else
    begin
      TextureNames2 := TDXStringList.Create;
      try
        TextureNames2.Add(PWADFLAG);
        for i := 0 to TextureNames.Count - 1 do
          if Textures.IndexOf(GetWadLinkDescription(MainWAD, TextureNames.Strings[i])) < 0 then
            TextureNames2.Add(TextureNames.Strings[i]);
        if TextureNames2.Count > 1 then
          CacheIDWADTextures(MainWAD, PWAD, TextureNames2,
            True,{$IFNDEF DOOMVIEWER} '',{$ENDIF}
            nil, -1, idUnknown,
            nil, -1, nil);
//          CacheIDWADTextures(MainWAD, PWAD, TextureNames2,
//            True,{$IFNDEF DOOMVIEWER} '',{$ENDIF}
//            nil, -1, wadType,
//            nil, -1, @pal);
      finally
        TextureNames2.Free;
      end;
    end;

    if numEntries = -1 then
      FreeMem(DIR, count * SizeOf(TDoomDirEntry));

    FreeMem(lpal, SizeOf(TLogPalette) + SizeOf(TPaletteEntry) * 255);
    bmp2.Free;
    bmp.Free;
    DeleteObject(hpal);
    Result := True; // no error
  finally
    Textures2.Free;
    f.Free;
  end;
end;
{$ENDIF}

{$ENDIF}

{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_DOOMSUPPORT}
function TD3DScene.GetIDWADTextureBmp(EntryName: string): TBitmap;
var
  WADFileName: string;
  TextureName: string;
begin
  if GetWadLinkInfo(EntryName, WADFileName, TextureName) then
    Result := GetIDWADTextureBmp(WADFileName, TextureName)
  else
    Result := nil;
end;
{$ENDIF}
{$ENDIF}

{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_DOOMSUPPORT}
function TD3DScene.GetIDWADTextureBmp(MainWAD: TFileName; TextureName: string): TBitmap;
var
  pal: TDoomPalette;
  f: TFileStream;
  i, j, k, l, count: integer;
  DIR: PDoomDirectory;
  IDSoftDataModule: TIDSoftDataModule;
  wadType: TIDSoftWADType;
  FLOORSDIR: PDoomDirectory;
  numFloors: integer;
  WALLSDIR: PDoomDirectory;
  numWalls: integer;
  SPRITESDIR: PDoomDirectory;
  numSprites: integer;
  found: boolean;
  bmp2: TBitmap;
  lpal: PLogPalette;
  hpal: HPALETTE;
  y: integer;
  P : PByteArray;
  m: TMemoryStream;
  s: string;
  PNames: PPatchNames;
  numPNames: integer;
  lTexturesInfo: PDoomTexturesInfo;
  numTextures: integer;
  pnameind: smallint;   // patch name index in PNAMES table
  xofs, yofs: smallint; // offset in texture space for the wall patch
  nearBlack: byte;      // Index פחע נבכפפבע ךןםפ ףפן לב‎סן

  function CreateIDWADWallBMP(bitmap: TBitmap; doPad: boolean = False; texName: string = ''): boolean;
  var
    sd: TSpDim;
    Offsets: POffsetList;
    x, y, y_plus2: integer;
     // startPos: integer;
    sRow, rowLen: byte;
    RowBuff: array[1..320] of byte;
    spSize:word;
{$IFNDEF NO_DOOMTHINGS}
    bmpTmp: TBitmap;
    animEnd: char;
{$ENDIF}
  begin
    Result := False;
//    startPos := f.Position;
    f.Read(sd, SizeOf(sd));
    spSize := sd.xSize * sd.ySize;
    if (spSize <= MAXWALLSIZE) and
       (sd.xSize <= 320) and (sd.xSize > 0) and
       (sd.ySize <= 256) and (sd.ySize > 0) then
    begin
{      bitmap.Width := 0;
      bitmap.Height := 0;}
      bitmap.Width := sd.xSize;
      bitmap.Height := sd.ySize;
      bitmap.Canvas.Brush.Color := clBlack;
      bitmap.Canvas.FillRect(Rect(0, 0, sd.xSize, sd.ySize));
      GetMem(Offsets, sd.xSize * 4);  {Allocate Row Offset Buffer}
      f.Read(Offsets^, sd.xSize * 4); {Read Row Offset Buffer}
      for x := 0 to sd.xSize - 1 do
      begin
//        f.Seek(startPos + Offsets^[x], soFromBeginning);
        f.Read(sRow, SizeOf(sRow));
        while sRow <> 255 do
        begin
          f.Read(rowLen, 1);
          f.Read(RowBuff, RowLen + 2);
          for y := 0 to rowLen do
          begin
            y_plus2 := y + 2;
          // RGB(0,0,0) = transparency, so we change it to RGB(1,1,1)
//            if RGB(pal[RowBuff[y + 2]].r, pal[RowBuff[y + 2]].g, pal[RowBuff[y + 2]].b) = RGB(0, 0, 0) then
            if (pal[RowBuff[y_plus2]].r = 0) and (pal[RowBuff[y_plus2]].g = 0) and (pal[RowBuff[y_plus2]].b = 0) then
              bitmap.Canvas.Pixels[x, (y + sRow)] := RGB(pal[nearBlack].r, pal[nearBlack].g, pal[nearBlack].b)
            else
              bitmap.Canvas.Pixels[x, (y + sRow)] :=
                RGB(pal[RowBuff[y_plus2]].r, pal[RowBuff[y_plus2]].g, pal[RowBuff[y_plus2]].b);
          end;
          f.Read(sRow, SizeOf(sRow));
        end; {while}
      end; {for x}
      FreeMem(Offsets, sd.xSize * 4); {Free Row Offset Buffer}

(*      if doPad and (sd.xSize < 65) and (sd.ySize < 65) then
      begin
        bmpTmp := TBitmap.Create;
        try
          bmpTmp.Assign(bitmap);
          bmpTmp.Width := 64;
          bmpTmp.Height := 64;
          bmpTmp.Canvas.Brush.Color := clBlack;
          bmpTmp.Canvas.FillRect(Rect(0, 0, 64, 64));
{          if (sd.xOffs < 32) or
             (sd.yOffs < 32) then}
          if (sd.xOffs - xofs > 32) or
             (sd.yOffs - yofs > 64) then
          else
          begin
            bmpTmp.Canvas.Draw(32 - sd.xOffs + xofs, 64 - sd.yOffs + xofs, bitmap);
            bmpTmp.Transparent := False;
            bitmap.Width := 64;
            bitmap.Height := 64;
            bitmap.Canvas.Draw(0, 0, bmpTmp);
            doPad := False;
          end;
        finally
          bmpTmp.Free;
        end;
      end;*)

{$IFNDEF NO_DOOMTHINGS}
      if doPad and (texName <> '') then
      begin
        if GetPredefinedTextureDimentions(wadType, texName, x, y, animEnd) then
        begin
          bmpTmp := TBitmap.Create;
          try
            bmpTmp.Assign(bitmap);
            bmpTmp.Width := x;
            bmpTmp.Height := y;
            bmpTmp.Canvas.Brush.Color := clBlack;
            bmpTmp.Canvas.FillRect(Rect(0, 0, x, y));
            bmpTmp.Canvas.Draw(x div 2 - sd.xOffs, y - sd.ySize, bitmap);
            bmpTmp.Transparent := False;
            bitmap.Width := x;
            bitmap.Height := y;
            bitmap.Canvas.Draw(0, 0, bmpTmp);
            doPad := False;
          finally
            bmpTmp.Free;
          end;
        end;
      end;

      if doPad and (sd.xSize < 129) and (sd.ySize < 129) then
      begin
        bmpTmp := TBitmap.Create;
        try
          bmpTmp.Assign(bitmap);
          bmpTmp.Width := 128;
          bmpTmp.Height := 128;
          bmpTmp.Canvas.Brush.Color := clBlack;
          bmpTmp.Canvas.FillRect(Rect(0, 0, 128, 128));
{          if (sd.xOffs < 64) or
             (sd.yOffs < 64) then}
{          if (sd.xOffs - xofs > 64) or
             (sd.yOffs - yofs > 128) then}
          if (sd.xOffs > 64) or
             (sd.yOffs > 128) then
          else
          begin
//            bmpTmp.Canvas.Draw(64 - sd.xOffs + xofs, 128 - sd.yOffs + xofs, bitmap);
            bmpTmp.Canvas.Draw(64 - sd.xOffs, 128 - sd.ySize, bitmap);
            bmpTmp.Transparent := False;
            bitmap.Width := 128;
            bitmap.Height := 128;
            bitmap.Canvas.Draw(0, 0, bmpTmp);
            doPad := False;
          end;
        finally
          bmpTmp.Free;
        end;
      end;

      if doPad and (sd.xSize < 258) and (sd.ySize < 258) then
      begin
        bmpTmp := TBitmap.Create;
        try
          bmpTmp.Assign(bitmap);
          bmpTmp.Width := 256;
          bmpTmp.Height := 256;
          bmpTmp.Canvas.Brush.Color := clBlack;
          bmpTmp.Canvas.FillRect(Rect(0, 0, 256, 256));
          if ((128 - sd.xOffs) + bitmap.Width > 256 * 1.2) or
             ((128 - sd.yOffs) + bitmap.Height > 256 * 1.2) then
          else
          begin
//            bmpTmp.Canvas.Draw(128 - sd.xOffs + xofs, 256 - sd.yOffs + xofs, bitmap);
            bmpTmp.Canvas.Draw(128 - sd.xOffs, 256 - sd.ySize, bitmap);
            bmpTmp.Transparent := False;
            bitmap.Width := 256;
            bitmap.Height := 256;
            bitmap.Canvas.Draw(0, 0, bmpTmp);
          end;
        finally
          bmpTmp.Free;
        end;
      end;
{$ENDIF}
      Result := True;
    end;
  end;

  procedure AddTextureInfoInList(index: integer);
  var
    numTex: integer;
    n: integer;
    offSets: PIntegerArray;
    doSeek: boolean;
    flds: smallint;
    idx: PDoomDirEntry;
    lti: PDoomTextureInfo;
  begin
    idx := @DIR[index];
    f.Seek(idx.position, soFromBeginning);
    f.Read(numTex, 4); // ִיבגזןץלו פןם בסיטל פשם Textures
    GetMem(offSets, numTex * SizeOf(integer));
    f.Read(offSets^, numTex * SizeOf(integer));

    if (wadtype in [idStrife, idUnKnown]) and (numTex > 1) then
    begin
      f.Seek(idx.Position + Offsets[0] + 16, soFrombeginning);
      f.Read(flds, 2);
      if offsets[1] - offsets[0] = 18 + flds * 6 then
      begin
        f.Seek(idx.Position + Offsets[0] + 20, soFrombeginning);
        f.Read(flds, 2);
        doSeek := offsets[1] - offsets[0] = 20 + flds * 8;
        if not doSeek then
          wadtype := idStrife2;
      end
      else
        doSeek := True;
    end
    else
      doSeek := wadtype <> idStrife2;

    n := 0;

    if doSeek then
    begin
      repeat
        lti := @lTexturesInfo[numTextures];
        lti.texofs := idx.Position + offSets[n];
        f.Seek(lti.texofs, soFromBeginning);
        f.Read(lti.Name, 8);
        f.Seek(lti.texofs + 12, soFrombeginning);
        f.Read(lti.dimentions, 4);
//      f.Read(lti.w, 2);
//      f.Read(lti.h, 2);
        f.Seek(lti.texofs + 20, soFrombeginning);
        f.Read(lti.fields, 2);
        inc(numTextures);
        inc(n);
      until (n = numTex);
    end
    else
    begin
      repeat
        lti := @lTexturesInfo[numTextures];
        lti.texofs := idx.Position + offSets[n];
        f.Seek(lti.texofs, soFromBeginning);
        f.Read(lti.Name, 8);
        f.Seek(lti.texofs + 12, soFrombeginning);
        f.Read(lti.dimentions, 4);
//      f.Read(lti.w, 2);
//      f.Read(lti.h, 2);
        f.Read(lti.fields, 2);
        inc(numTextures);
        inc(n);
      until (n = numTex);
    end;
    FreeMem(offSets, numTex * SizeOf(integer));
  end;

{  procedure AddTextureInfoInList(index: integer);
  var numTex: integer;
      n: integer;
      offSets: PIntegerArray;
  begin
    f.Seek(DIR[index].position, soFromBeginning);
    f.Read(numTex, 4); // ִיבגזןץלו פןם בסיטל פשם Textures
    GetMem(offSets, numTex * SizeOf(integer));
    f.Read(offSets^, numTex * SizeOf(integer));
    n := 0;
    repeat
      lTexturesInfo[numTextures].texofs := DIR[index].Position + offSets[n];
      f.Seek(lTexturesInfo[numTextures].texofs, soFromBeginning);
      f.Read(lTexturesInfo[numTextures].Name, 8);
      f.Seek(lTexturesInfo[numTextures].texofs + 12, soFrombeginning);
      f.Read(lTexturesInfo[numTextures].w, 2);
      f.Read(lTexturesInfo[numTextures].h, 2);
      f.Seek(lTexturesInfo[numTextures].texofs + 20, soFrombeginning);
      f.Read(lTexturesInfo[numTextures].fields, 2);
      inc(numTextures);
      inc(n);
    until (n = numTex);
    FreeMem(offSets, numTex * SizeOf(integer));
  end;}

begin
  Result := nil;

  if not FileExists(MainWAD) then
    MainWAD := GetExistedFileName(MainWAD);
  if not FileExists(MainWAD) then
    Exit;

  TextureName := UpperCase(TextureName);

  wadType := GetWadType(MainWAD);
  if wadType in [idInvalid, idVJ] then
    Exit;
  f := TFileStream.Create(MainWAD, fmOpenRead or fmShareDenyWrite);
  try
    f.Seek(4, soFromBeginning);
    f.Read(count, SizeOf(count));
    f.Read(l, SizeOf(l));
    f.Seek(l, soFromBeginning);
    GetMem(DIR, count * SizeOf(TDoomDirEntry));
    f.Read(DIR^, count * SizeOf(TDoomDirEntry));
    AdjustWadDirectory(DIR, count);

    i := -1;
    repeat
      inc(i);
    until (DoomEntryName(DIR[i].Name) = rsPlayPal) or (DoomEntryName(DIR[i].Name) = rsPal) or (i = count - 1);
    if (DoomEntryName(DIR[i].Name) = rsPlayPal) or (DoomEntryName(DIR[i].Name) = rsPal) then
    begin
      f.Seek(DIR[i].position, soFromBeginning);
      f.Read(Pal, SizeOf(Pal));
    end
    else
    begin
      m := TMemoryStream.Create;
      IDSoftDataModule := TIDSoftDataModule.Create(nil);
      try
        case wadType of
          idDoom, idNew, idUnknown:
            IDSoftDataModule.DefaultDoomPalette.SaveToStream(m, False);
          idHeretic:
            IDSoftDataModule.DefaultHereticPalette.SaveToStream(m, False);
          idHexen:
            IDSoftDataModule.DefaultHexenPalette.SaveToStream(m, False);
          idStrife:
            IDSoftDataModule.DefaultStrifePalette.SaveToStream(m, False);
        else
          IDSoftDataModule.DefaultDoomPalette.SaveToStream(m, False);
        end;
        m.Seek(0, soFromBeginning);
        m.Read(Pal, SizeOf(Pal));
      finally
        m.Free;
        IDSoftDataModule.Free;
      end;
    end;
    // ִיבגזןץלו פב נבפ‏לבפב
    GetMem(FLOORSDIR, count * SizeOf(TDoomDirEntry));
    found := False;
    i := 0;
    repeat
      if DoomEntryName(DIR[i].Name) = rsF_START then
        found := True;
      inc(i);
    until (i = count) or found;
    numFloors := 0;
    if found then
    begin
      found := False;
      repeat
        if DoomEntryName(DIR[i].Name) = rsF_END then
          found := True
        else
        begin
          if DIR[i].Size > 0 then
            FLOORSDIR[numFloors] := DIR[i];
          inc(numFloors);
        end;
        inc(i);
      until (i = count) or found;
    end;
    // ִחליןץסדן‎לו פחם נבכפפב
    GetMem(lpal, SizeOf(TLogPalette) + SizeOf(TPaletteEntry) * 255);
    lpal.palVersion := $300;
    lpal.palNumEntries := 256;
    lpal.palPalEntry[0].peRed := 0;
    lpal.palPalEntry[0].peGreen := 0;
    lpal.palPalEntry[0].peBlue := 0;
    for j := 1 to 255 do
    begin
      pal[j].r := Max(pal[j].r, 8);
      pal[j].g := Max(pal[j].g, 8);
      pal[j].b := Max(pal[j].b, 8);
      lpal.palPalEntry[j].peRed := pal[j].r;
      lpal.palPalEntry[j].peGreen := pal[j].g;
      lpal.palPalEntry[j].peBlue := pal[j].b;
    end;
    nearBlack := 1;
    // RGB(0,0,0) holds transparency information, so we change it to RGB(1,1,1)
    for j := 255 downto 1 do
    begin
      if ((lpal.palPalEntry[j].peRed +
           lpal.palPalEntry[j].peGreen +
           lpal.palPalEntry[j].peBlue) <
          (lpal.palPalEntry[nearBlack].peRed +
           lpal.palPalEntry[nearBlack].peGreen +
           lpal.palPalEntry[nearBlack].peBlue)) and
         ((lpal.palPalEntry[j].peRed +
           lpal.palPalEntry[j].peGreen +
           lpal.palPalEntry[j].peBlue) <> 0) then
            nearBlack := j;
    end;
    for j := 255 downto 1 do
    begin
      if lpal.palPalEntry[j].peRed + lpal.palPalEntry[j].peGreen + lpal.palPalEntry[j].peBlue = 0 then
        lpal.palPalEntry[j] := lpal.palPalEntry[nearBlack];
    end;
    hpal := CreatePalette(lpal^);
    // ִחליןץסדן‎לו פן bitmap
    Result := TBitmap.Create;
    Result.PixelFormat := pf8bit;
    Result.Width := 64;
    Result.Height := 64;
    if hpal <> 0 then
      Result.Palette := hpal;
    for i := 0 to numFloors - 1 do
    begin
      if TextureName = UpperCase(DoomEntryName(FLOORSDIR[i].Name)) then
      begin
        f.Seek(FLOORSDIR[i].position, soFromBeginning);
        for y := 0 to 63 do
        begin
          P := Result.ScanLine[y];
          f.Read(P^, 64);
          for j := 0 to 63 do
            if P[j] = 0 then
              P[j] := nearBlack;
        end;
        break;
      end;
    end;
    FreeMem(FLOORSDIR, count * SizeOf(TDoomDirEntry));
    GetMem(WALLSDIR, count * SizeOf(TDoomDirEntry));
    found := False;
    i := 0;
    repeat
      if (DoomEntryName(DIR[i].Name) = rsP_START) or
         (DoomEntryName(DIR[i].Name) = rsPP_START) then
          found := True;
      inc(i);
    until (i = count) or found;
    numWalls := 0;
    if found then
    begin
      found := False;
      repeat
        if (DoomEntryName(DIR[i].Name) = rsP_END) or
           (DoomEntryName(DIR[i].Name) = rsPP_END) then
          found := True
        else if DIR[i].Size > 0 then
        begin
          WALLSDIR[numWalls] := DIR[i];
          inc(numWalls);
        end;
        inc(i);
      until (i = count) or found;
      found := False;
    end;
    for i := 0 to numWalls - 1 do
    begin
      if TextureName = UpperCase(DoomEntryName(WALLSDIR[i].Name)) then
      begin
        f.Seek(WALLSDIR[i].position, soFromBeginning);
        CreateIDWADWallBMP(Result);
        break;
      end;
    end;
    i := 0;
    repeat
      if (DoomEntryName(DIR[i].Name) = rsPNAMES) then
        found := True
      else
        inc(i)
    until (i = count) or found;
    numPNames := 0;
    if found then
    begin
      f.Seek(DIR[i].position, soFromBeginning);
      f.Read(numPNames, SizeOf(numPNames));
      GetMem(PNames, numPNames * 8);
      f.Read(PNames^, numPNames * 8);
      AdjustPatchNames(PNames, numPNames);
    end
    else
      PNames := nil;
    System.new(lTexturesInfo);
    numTextures := 0;
    i := 0;
    repeat
      s := DoomEntryName(DIR[i].Name);
      if (s =  rsTexture1) or (s =  rsTexture2) or (s =  rsTexture3) then
        AddTextureInfoInList(i);
      inc(i);
    until i = count;
    bmp2 := TBitmap.Create;
    if hpal <> 0 then
      bmp2.Palette := hpal;
    for i := 0 to numTextures - 1 do
    begin
      if TextureName = UpperCase(DoomEntryName(lTexturesInfo[i].Name)) then
      begin
        for j := 0 to lTexturesInfo[i].fields - 1 do
        begin
          if j = 0 then
          begin
            Result.Width := 0;
            Result.Height := 0;
            Result.Width := lTexturesInfo[i].w;
            Result.Height := lTexturesInfo[i].h;
            Result.Canvas.Brush.Color := clBlack;
            Result.Canvas.FillRect(Rect(0, 0, Result.Width, Result.Height));
          end;
          f.Seek(lTexturesInfo[i].texofs + 22 + j * 10, soFromBeginning);
          f.Read(xofs, 2);
          f.Read(yofs, 2);
          f.Read(pnameind, 2);
        // OK, now look up the pic's name in the PNAMES entry.

          k := 0;
          found := False;
          repeat
            if DoomEntryName(PNames[pnameind]) = DoomEntryName(WALLSDIR[k].Name) then
              found := True
            else
              inc(k);
          until found or (k = numWalls);
          if found then
          begin
            f.Seek(WALLSDIR[k].position, soFromBeginning);
            CreateIDWADWallBMP(bmp2);
            bmp2.TransparentColor := clBlack;
            bmp2.Transparent := True;
            Result.Canvas.Draw(xofs, yofs, bmp2);
          end;
        end;
        break;
      end;
    end;
    System.Dispose(lTexturesInfo);
    if PNames <> nil then
      FreeMem(PNames, numPNames * 8);
    FreeMem(WALLSDIR, count * SizeOf(TDoomDirEntry));

    GetMem(SPRITESDIR, count * SizeOf(TDoomDirEntry));
    found := False;
    i := 0;
    repeat
      if (DoomEntryName(DIR[i].Name) = rsS_START) or
         (DoomEntryName(DIR[i].Name) = rsSS_START) then
        found := True;
      inc(i);
    until (i = count) or found;
    numSprites := 0;
    if found then
    begin
      found := False;
      repeat
        if (DoomEntryName(DIR[i].Name) = rsS_END) or
           (DoomEntryName(DIR[i].Name) = rsSS_END) then
          found := True
        else if DIR[i].Size > 0 then
        begin
          SPRITESDIR[numSprites] := DIR[i];
          inc(numSprites);
        end;
        inc(i);
      until (i = count) or found;
    end;
    for i := 0 to numSprites - 1 do
    begin
      if TextureName = UpperCase(DoomEntryName(SPRITESDIR[i].Name)) then
      begin
        f.Seek(SPRITESDIR[i].position, soFromBeginning);
        CreateIDWADWallBMP(Result, True, DoomEntryName(SPRITESDIR[i].Name));
        Result.TransparentColor := clBlack;
        Result.Transparent := True;
        break;
      end;
    end;
    FreeMem(SPRITESDIR, count * SizeOf(TDoomDirEntry));

    FreeMem(DIR, count * SizeOf(TDoomDirEntry));
    FreeMem(lpal, SizeOf(TLogPalette) + SizeOf(TPaletteEntry) * 255);
    bmp2.Free;
    DeleteObject(hpal);
  finally
    f.Free;
  end;
end;
{$ENDIF}

{$IFNDEF NO_IDSOFTGAMESSUPPORT}

{$IFNDEF NO_QUAKESUPPORT}
function Q2Pal2LPal(const Q2Pal: TQuake2Palette; var lpal: PLogPalette; Gamma: single = 1.6): integer;
var
  j: integer;
  tmpQ2Pal: TQuake2Palette;
  Bb: integer;
begin
  // Adjust "gamma"
  for j := 0 to 255 do
  begin
    Bb := Round(Q2Pal[j].R * Gamma);
    if Bb > 255 then
      Bb := 255
    else if Bb < 8 then
      Bb := 8;
    tmpQ2Pal[j].R := Bb;
    Bb := Round(Q2Pal[j].G * Gamma);
    if Bb > 255 then
      Bb := 255
    else if Bb < 8 then
      Bb := 8;
    tmpQ2Pal[j].G := Bb;
    Bb := Round(Q2Pal[j].B * Gamma);
    if Bb > 255 then
      Bb := 255
    else if Bb < 8 then
      Bb := 8;
    tmpQ2Pal[j].B := Bb;
  end;

  GetMem(lpal, SizeOf(TLogPalette) + SizeOf(TPaletteEntry) * 255);
  lpal.palVersion := $300;
  lpal.palNumEntries := 256;
  lpal.palPalEntry[0].peRed := 8;
  lpal.palPalEntry[0].peGreen := 8;
  lpal.palPalEntry[0].peBlue := 8;
  for j := 1 to 255 do
  begin
    lpal.palPalEntry[j].peRed := tmpQ2Pal[j].r;
    lpal.palPalEntry[j].peGreen := tmpQ2Pal[j].g;
    lpal.palPalEntry[j].peBlue := tmpQ2Pal[j].b;
  end;
  Result := 1;

  // RGB(0,0,0) holds transparency information, so we change it to RGB(8, 8, 8)
  for j := 255 downto 1 do
  begin
    if ((lpal.palPalEntry[j].peRed +
         lpal.palPalEntry[j].peGreen +
         lpal.palPalEntry[j].peBlue) <
        (lpal.palPalEntry[Result].peRed +
         lpal.palPalEntry[Result].peGreen +
         lpal.palPalEntry[Result].peBlue)) and
       ((lpal.palPalEntry[j].peRed +
         lpal.palPalEntry[j].peGreen +
         lpal.palPalEntry[j].peBlue) <> 0) then
          Result := j;
  end;
  for j := 255 downto 1 do
  begin
    if lpal.palPalEntry[j].peRed + lpal.palPalEntry[j].peGreen + lpal.palPalEntry[j].peBlue = 0 then
      lpal.palPalEntry[j] := lpal.palPalEntry[Result];
  end;
end;

function HLPal2LPal(const Q2Pal: TQuake2Palette; var lpal: PLogPalette; isTransparent: boolean; Gamma: single = 1.6): integer;
var
  j: integer;
  tmpQ2Pal: TQuake2Palette;
  Bb: integer;
begin
  // Adjust "gamma"
  for j := 0 to 255 do
  begin
// HalfLife transparent color is RGB(0, 0, 255)
    if isTransparent and (Q2Pal[j].R = 0) and (Q2Pal[j].G = 0) and (Q2Pal[j].B = 255) then
    begin
      tmpQ2Pal[j].R := 0;
      tmpQ2Pal[j].G := 0;
      tmpQ2Pal[j].B := 0;
    end
    else
    begin
      Bb := Round(Q2Pal[j].R * Gamma);
      if Bb > 255 then
        Bb := 255
      else if Bb < 8 then
        Bb := 8;
      tmpQ2Pal[j].R := Bb;
      Bb := Round(Q2Pal[j].G * Gamma);
      if Bb > 255 then
        Bb := 255
      else if Bb < 8 then
        Bb := 8;
      tmpQ2Pal[j].G := Bb;
      Bb := Round(Q2Pal[j].B * Gamma);
      if Bb > 255 then
        Bb := 255
      else if Bb < 8 then
        Bb := 8;
      tmpQ2Pal[j].B := Bb;
    end;
  end;

  if isTransparent then
  begin
    tmpQ2Pal[0].R := 0;
    tmpQ2Pal[0].G := 0;
    tmpQ2Pal[0].B := 0;
  end;

  GetMem(lpal, SizeOf(TLogPalette) + SizeOf(TPaletteEntry) * 255);
  lpal.palVersion := $300;
  lpal.palNumEntries := 256;
  for j := 0 to 255 do
  begin
    lpal.palPalEntry[j].peRed := tmpQ2Pal[j].r;
    lpal.palPalEntry[j].peGreen := tmpQ2Pal[j].g;
    lpal.palPalEntry[j].peBlue := tmpQ2Pal[j].b;
  end;

  Result := 0;

  if not isTransparent then
  begin
    for j := 255 downto 1 do
    begin
      if ((sqr(lpal.palPalEntry[j].peRed - Q2Pal[0].R) +
           sqr(lpal.palPalEntry[j].peGreen - Q2Pal[0].G) +
           sqr(lpal.palPalEntry[j].peBlue - Q2Pal[0].B)) <
          (sqr(lpal.palPalEntry[Result].peRed - Q2Pal[0].R) +
           sqr(lpal.palPalEntry[Result].peGreen  - Q2Pal[0].G) +
           sqr(lpal.palPalEntry[Result].peBlue - Q2Pal[0].B))) and
         ((lpal.palPalEntry[j].peRed +
           lpal.palPalEntry[j].peGreen +
           lpal.palPalEntry[j].peBlue) <> 0) then
            Result := j;
    end;
    for j := 255 downto 1 do
    begin
      if lpal.palPalEntry[j].peRed + lpal.palPalEntry[j].peGreen + lpal.palPalEntry[j].peBlue = 0 then
        lpal.palPalEntry[j] := lpal.palPalEntry[Result];
    end;
  end
{  else
  begin
    for j := 255 downto 1 do
    begin
      if ((lpal.palPalEntry[j].peRed +
           lpal.palPalEntry[j].peGreen +
           lpal.palPalEntry[j].peBlue) <
          (lpal.palPalEntry[Result].peRed +
           lpal.palPalEntry[Result].peGreen +
           lpal.palPalEntry[Result].peBlue)) and
         ((lpal.palPalEntry[j].peRed +
           lpal.palPalEntry[j].peGreen +
           lpal.palPalEntry[j].peBlue) <> 0) then Result := j;
    end;
    for j := 255 downto 1 do
    begin
      if lpal.palPalEntry[j].peRed + lpal.palPalEntry[j].peGreen + lpal.palPalEntry[j].peBlue = 0 then
        lpal.palPalEntry[j] := lpal.palPalEntry[Result];
    end;
  end;}

end;
{$ENDIF}
{$ENDIF}

{$IFNDEF NO_QUAKESUPPORT}
function TD3DScene.CacheIDPAKTextures(PAK: TFileName; TextureNames: TDXStringList;
  PakVer: integer = -1; BspVer: integer = -1;
  QDir: TPakDir = nil; defaultExt: string = ''): boolean;
var
  idx, i, j, k: integer;
  isLink: boolean;
  pakDir: TPakDir;
  EntryData: PakFile;
  b: boolean;
  m8: boolean;
  T: Miptex_S;
  pNfo: Miptex_T_P;
  pTData: pointer;
  T_v1: Miptex_S_v1;
  T_m8: Miptex_S_m8;
  m: TMemoryStream;
  IDSoftDataModule: TIDSoftDataModule;
  Q2Pal: TQuake2Palette;
  bmp: TBitmap;
  SLN: PByteArray;
  lpal, lpal_m8: PLogPalette;
  hpal: HPALETTE;
  nearBlack: byte;
  Entry, s, s2: string;
  maxDataSize, nfoDataSize, nfoWidth, nfoHeight: integer;
  isTransparent: boolean;
  texid: integer;
  data: pointer;
  size: integer;
  bmp2: TBitmap;
  tgaimage: TTGABitmap;//Graphic;
  jimage: TJPEGImage;
  sTmp2: string;
  sTmp: string;
  TexturesCreated: PBooleanArray;
  r: TRect;

  procedure MakeStubUnLoadedTextures;
  var
    local_i: integer;
    stubbmp: TBitmap;
  begin
    stubbmp := TBitmap.Create;
    try
      stubbmp.Width := 16;
      stubbmp.Height := 16;
      stubbmp.PixelFormat := pf8Bit;
      with stubbmp.Canvas do
      begin
        Pen.Width := 1;
        Pen.Color := clGray;
        Brush.Color := clWhite;
        Rectangle(0, 0, 16, 16);
      end;

      for local_i := 0 to TextureNames.Count - 1 do
      begin
        if not TexturesCreated[local_i] then
        begin
          TextureNames.Strings[local_i] := GetPakLinkDescription(PAK, TextureNames.Strings[local_i]);
          TextureNames.Objects[local_i] := TDirect3DTexture2.Create(DXDraw, stubbmp, False);
          Textures.Objects[Textures.Add(TextureNames.Strings[local_i])] :=
            TextureNames.Objects[local_i];
        end;
      end;
    finally
      stubbmp.Free;
    end;
    FreeMem(TexturesCreated);
  end;

  procedure SearchQ3TexturesInPath(id: integer);
  begin
    sTmp := GetExistedFileName(sTmp);
    if FileExists(sTmp) then
    begin
      // Search all search paths to find the texture
      TextureNames.Objects[i] := AddTextureToCollection(sTmp);
      TexturesCreated[id] := TextureNames.Objects[i] <> nil;
      if TexturesCreated[id] then
        TextureNames.Strings[id] := sTmp;
    end;
  end;

begin
  if BspVer = -1 then
    BspVer := GetBspVersion(PAK);
  if PakVer = -1 then
    PakVer := GetQuakeVersion(BspVer);

  Result := (PakVer = 1) or (PakVer = 2) or (PakVer = 3);
  if not Result then
    Exit;
{  for i := 0 to TextureNames.Count - 1 do
  begin
    if Length(TextureNames.Strings[i]) > Length(rsExtWal) then
      if UpperCase(RightStr(TextureNames.Strings[i], Length(rsExtWal))) <> UpperCase(rsExtWal) then
        TextureNames.Strings[i] := TextureNames.Strings[i] + rsExtWal;
    TextureNames.Strings[i] := AdjustQuake2EntryName(TextureNames.Strings[i]);
  end;}

  if QDir = nil then
  begin
    PAK := GetExistedFileName(PAK);
    pakDir := TPakDir.Create(PAK, '');
  end
  else
    pakDir := QDir;

  GetMem(TexturesCreated, TextureNames.Count * SizeOf(boolean));
  for i := 0 to TextureNames.Count - 1 do
    TexturesCreated[i] := False;

  // Special treatment for pk3 files...
  if PakVer = 3 then
  begin
    bmp := TBitmap.Create;
    try
      bmp.PixelFormat := pf24bit;
      for i := 0 to TextureNames.Count - 1 do
      begin
        sTmp := TextureNames.Strings[i];
        b := pakDir.Openfile(EntryData, sTmp);
        if not b then
          b := pakDir.OpenfileExtSearch(EntryData, sTmp);
        if not b then
        begin
          sTmp2 := sTmp + rsExtJpg;
          b := pakDir.OpenfileExtSearch(EntryData, sTmp2);
          if b then
            sTmp := sTmp2;
        end;
        if not b then
        begin
          sTmp2 := sTmp + rsExtTGA;
          b := pakDir.OpenfileExtSearch(EntryData, sTmp2);
          if b then
            sTmp := sTmp2;
        end;
        if b then
        begin
          size := pakDir.Qfilesize(EntryData);
          GetMem(data, size);
          pakDir.Qblockread(EntryData, data^, size);
          pakDir.Closefile(EntryData);

          m := TMemoryStream.Create;
          try
            m.Write(data^, size);
            FreeMem(data, size);
            m.Seek(0, soFromBeginning);
            if UpperCase(RightStr(sTmp, 4)) = UpperCase(rsExtJpg) then
            begin
              jimage := TJPEGImage.Create{(Application)};
              try
                jimage.LoadFromStream(m);
                bmp.Assign(jimage);
                {bmp.Width := jimage.Width;
                bmp.Height := jimage.Height;
                SetRect(r, 0, 0, bmp.Width, bmp.Height);
                bmp.Canvas.CopyRect(r, jimage.canvas, r);}
                EliminateBlackPixels(bmp);
              finally
                jimage.Free;
              end;
              MakePowerOf2BitmapFast(bmp);
//            AddTextureToCollectionFromGraphic(GetPakLinkDescription(PAK, sTmp), graphic);
              sTmp := GetPakLinkDescription(PAK, sTmp);
              TextureNames.Objects[i] := AddTextureToCollection(sTmp, bmp);
              TexturesCreated[i] := TextureNames.Objects[i] <> nil;
              if TexturesCreated[i] then
                TextureNames.Strings[i] := sTmp;
            end
            else if UpperCase(RightStr(sTmp, 4)) = UpperCase(rsExtTGA) then
            begin
              tgaimage := TTGABitmap.Create;
              try
                tgaimage.AllowExceptions := False;
                tgaimage.LoadFromStream(m);
//                EliminateBlackPixels(tgaimage);
                bmp2 := MakePowerOf2TGAToBitmap(tgaimage);
              finally
                tgaimage.Free;
              end;
{              if bspVer = Bspversion_47 then
                if Pos('\ALPHA\', sTmp) > 0 then
                  MakeBlackRangePixels(bmp, 17);}
              sTmp := GetPakLinkDescription(PAK, sTmp);
              TextureNames.Objects[i] := AddTextureToCollection(sTmp, bmp2);
              TexturesCreated[i] := TextureNames.Objects[i] <> nil;
              if TexturesCreated[i] then
                TextureNames.Strings[i] := sTmp;
              bmp2.Free;
            end
            else
              // Search all search paths to find the texture
              SearchQ3TexturesInPath(i);
          finally
            m.Free;
          end;
        end
        else
        // Search all search paths to find the texture
          SearchQ3TexturesInPath(i);
      end;

    finally
      if QDir = nil then
        pakDir.Free;
      bmp.Free;
      MakeStubUnLoadedTextures;
    end;
    Exit;
  end;

  lpal := nil;
  hpal := 0;

  case fTextureQuality of
    tq100, tqDouble:
      maxDataSize := 256 * 256;
    tq50:
      maxDataSize := 128 * 128;
    tq25:
      maxDataSize :=  64 *  64;
  else
    maxDataSize :=  32 *  32;
  end;

  T.Data := nil;
  pNfo := @T.Nfo;

  ReAllocMem(T.Data, maxDataSize);
  pTData := T.Data;

  isLink := (UpperCase(ExtractFileExt(PAK)) = UpperCase(rsExtPak)) or
            (UpperCase(ExtractFileExt(PAK)) = UpperCase(rsExtBsp)) or
            (UpperCase(ExtractFileExt(PAK)) = UpperCase(rsExtPK3));

  bmp := TBitmap.Create;
  try
    with pakDir do
    begin
      if PakVer = 2 then
        b := (Openfile(EntryData, rsQuake2ColorMapEntry)) or
             (Openfile(EntryData, rsParentDir + rsQuake2ColorMapEntry)) or
             (Openfile(EntryData, rsParentDir + rsParentDir + rsQuake2ColorMapEntry)) or
             (Openfile(EntryData, GetExistedFileName(rsQuake2ColorMapEntry))) or
             (Openfile(EntryData, GetExistedFileName(rsQuake2TexturesDIR + rsQuake2ColorMapEntry)))
      else
        b := (Openfile(EntryData, rsQuake1ColorMapEntry)) or
             (Openfile(EntryData, rsParentDir + rsQuake1ColorMapEntry)) or
             (Openfile(EntryData, rsParentDir + rsParentDir + rsQuake1ColorMapEntry)) or
             (Openfile(EntryData, GetExistedFileName(rsQuake1ColorMapEntry)));
    end;
    if not b then
    begin
      IDSoftDataModule := TIDSoftDataModule.Create(nil);
      m := TMemoryStream.Create;
      try
        if PakVer = 1 then
        begin
          if BspVer = BspVersion_30 then
            IDSoftDataModule.DefaultHalfLifePalette.SaveToStream(m, False)
          else
            IDSoftDataModule.DefaultQuake1Palette.SaveToStream(m, False)
        end
        else
          IDSoftDataModule.DefaultQuake2Palette.SaveToStream(m, False);
        m.Seek(0, soFromBeginning);
        m.Read(Q2Pal, 768);
      finally
        IDSoftDataModule.Free;
        m.Free;
      end;
    end
    else
    begin
      pakDir.Qseek(EntryData, pakDir.Qfilesize(EntryData) - 768);
      pakDir.Qblockread(EntryData, Q2Pal, 768);
      pakDir.Closefile(EntryData);
    end;

    nearBlack := Q2Pal2LPal(Q2Pal, lpal);
    hpal := CreatePalette(lpal^);

    bmp.PixelFormat := pf8bit;
    if hpal <> 0 then
      bmp.Palette := hpal;

    for i := 0 to TextureNames.Count - 1 do
    begin
      isTransparent := (BspVer = BspVersion_30) and (TextureNames.Strings[i][1] = '{');
      s := GetPAKLinkDescription(PAK, TextureNames.Strings[i]);
      if Textures.IndexOf(s) >= 0 then
        continue;
      if Textures.IndexOf(UpperCase(s)) >= 0 then
        continue;

      if GetPAKLinkInfo(s, s2, Entry) then
        if UpperCase(ExpandFileName(s2)) <> UpperCase(ExpandFileName(PAK)) then
          if FileExists(GetExistedFileName(s2)) then
            pakDir.AddPak(GetExistedFileName(s2));

      m8 := False;

      b := pakDir.Openfile(EntryData, Entry);
      if not b then
        b := pakDir.Openfile(EntryData, rsQuake2TexturesDIR + Entry);
      if not b then
        b := pakDir.Openfile(EntryData, GetExistedFileName(Entry));
      if not b then
        b := pakDir.Openfile(EntryData, GetExistedFileName(rsQuake2TexturesDIR + Entry));

      if not b then
        b := pakDir.Openfile(EntryData, Entry + rsExtWal);
      if not b then
        b := pakDir.Openfile(EntryData, rsQuake2TexturesDIR + Entry + rsExtWal);
      if not b then
        b := pakDir.Openfile(EntryData, GetExistedFileName(Entry + rsExtWal));
      if not b then
        b := pakDir.Openfile(EntryData, GetExistedFileName(rsQuake2TexturesDIR + Entry + rsExtWal));

      if not b then
      begin
        b := pakDir.Openfile(EntryData, Entry + rsExtM8);
        m8 := b;
      end;
      if not b then
      begin
        b := pakDir.Openfile(EntryData, rsQuake2TexturesDIR + Entry + rsExtM8);
        m8 := b;
      end;
      if not b then
      begin
        b := pakDir.Openfile(EntryData, GetExistedFileName(Entry + rsExtM8));
        m8 := b;
      end;
      if not b then
      begin
        b := pakDir.Openfile(EntryData, GetExistedFileName(rsQuake2TexturesDIR + Entry + rsExtM8));
        m8 := b;
      end;

      if b then
      begin
        if m8 then   // Heretic II support
        begin
          pakDir.Qblockread(EntryData, T_m8.Nfo, SizeOf(T_m8.Nfo));
          pNfo.Width := T_m8.Nfo.Widths[0];
          pNfo.Height := T_m8.Nfo.Heights[0];
          for j := 0 to 3 do
            pNfo.Offsets[j] := T_m8.Nfo.Offsets[j];
          for j := 0 to 31 do
          begin
            pNfo.Name[j] := T_m8.Nfo.Name[j];
            pNfo.AnimName[j] := T_m8.Nfo.AnimName[j];
          end;
          pNfo.Flags := T_m8.Nfo.Flags;
          pNfo.Contents := T_m8.Nfo.Contents;
          pNfo.Value := T_m8.Nfo.Value;

          if lpal <> nil then
            FreeMem(lpal, SizeOf(TLogPalette) + SizeOf(TPaletteEntry) * 255);
          if hpal <> 0 then
            DeleteObject(hpal);

          nearBlack := Q2Pal2LPal(T_m8.Nfo.Palette, lpal);
          hpal := CreatePalette(lpal^);
          if hpal <> 0 then
            bmp.Palette := hpal;

        end
        else if (PakVer = 1) then // Quake1, Hexen2 version support
        begin
          pakDir.Qblockread(EntryData, T_v1.Nfo, SizeOf(T_v1.Nfo));

          for j := 0 to 15 do
            pNfo.Name[j] := T_v1.Nfo.Name[j];
          for j := 16 to 31 do
            pNfo.Name[j] := #0;

          pNfo.Width := T_v1.Nfo.Width;
          pNfo.Height := T_v1.Nfo.Height;

          for j := 0 to Miplevels - 1 do
            pNfo.Offsets[j] := T_v1.Nfo.Offsets[j];
        end
        else
          pakDir.Qblockread(EntryData, pNfo^, SizeOf(T.Nfo));

        // Textures for Half-Life have here the pallete
        if (BspVer = BspVersion_30) then
          if pNfo.Offsets[0] <> 0 then // Data exist (Data הום ץנסקןץם ףפן bsp, בככ ףפן WAD)!
            if pakDir.Qfilesize(EntryData) >= pNfo.Offsets[3] + (pNfo.Width * pNfo.Height) div 64 + 770 then
            begin
              pakDir.Qseek(EntryData, pNfo.Offsets[3] + (pNfo.Width * pNfo.Height) div 64 + 2);

              pakDir.Qblockread(EntryData, Q2Pal, 768);
              if lpal <> nil then
                FreeMem(lpal, SizeOf(TLogPalette) + SizeOf(TPaletteEntry) * 255);
              if hpal <> 0 then
                DeleteObject(hpal);

              nearBlack := HLPal2LPal(Q2Pal, lpal, isTransparent);
              hpal := CreatePalette(lpal^);
              if hpal <> 0 then
                bmp.Palette := hpal;
            end;

        // Load Mip-Map
        // ׃חלושףח:
        //   ױנסקןץם 4 Mip-Map ףפן בסקון .wal, ףפיע טףויע (offsets)
        //   נןץ ןסזןםפבי בנ פן T.Nfo.Offsets[x], (x = 0..3)
        //   ִיבגזןץלו נםפב פן בםכןדן offset
        if pNfo.Offsets[0] = 0 then // A single HalfLife bsp openned, no data in Nfo!
        begin
          bmp.Width := 16;
          bmp.Height := 16;
{          bmp.Canvas.Pen.Width := 1;
          bmp.Canvas.Pen.Color := clGray;
          bmp.Canvas.Brush.Color := clWhite;
          bmp.Canvas.Rectangle(0, 0, 16, 16);}
          with bmp.Canvas do
          begin
            Pen.Width := 1;
            Pen.Color := clGray;
            Brush.Color := clWhite;
            Rectangle(0, 0, 16, 16);
          end;

        end
        else
        begin
          case fTextureQuality of
            tq100, tqDouble:
              begin
                pakDir.Qseek(EntryData, pNfo.Offsets[0]);
              end;
            tq50:
              begin
                pakDir.Qseek(EntryData, pNfo.Offsets[1]);
                pNfo.Width := pNfo.Width shr 1;
                pNfo.Height := pNfo.Height shr 1;
              end;
            tq25:
              begin
                pakDir.Qseek(EntryData, pNfo.Offsets[2]);
                pNfo.Width := pNfo.Width shr 2;
                pNfo.Height := pNfo.Height shr 2;
              end;
          else //tqOnlyColors, tqWireframe, tqPoint
            begin
              pakDir.Qseek(EntryData, pNfo.Offsets[3]);
              pNfo.Width := pNfo.Width shr 3;
              pNfo.Height := pNfo.Height shr 3;
            end;
          end;

          nfoWidth := pNfo.Width;
          nfoHeight := pNfo.Height;
          nfoDataSize := nfoWidth * nfoHeight;
          if nfoDataSize > maxDataSize then
          begin
            maxDataSize := nfoDataSize;
            ReAllocMem(T.Data, maxDataSize);
            pTData := T.Data;
          end;

          pakDir.Qblockread(EntryData, pTData^, nfoDataSize);
          pakDir.Closefile(EntryData);

          bmp.Width := nfoWidth;
          bmp.Height := nfoHeight;
//          if not IsTransparent then
          if BspVer <> BspVersion_30 then
          begin
            for j := 0 to nfoHeight - 1 do
            begin
              SLN := bmp.ScanLine[j];
              idx := j * nfoWidth; // speed optimization
              for k := 0 to nfoWidth - 1 do // Quake textures are not transparent!
              begin
                if (PByteArray(pTData)[idx] = 0) then
                  SLN[k] := nearBlack
                else
                  SLN[k] := PByteArray(pTData)[idx];
                inc(idx);
              end;
            end
          end
          else if isTransparent then
          begin
            SetBitMapBits(bmp.Handle, nfoDataSize {nfoWidth * nfoHeight}, pTData);
          end
          else
          begin
            for j := 0 to nfoHeight - 1 do
            begin
              SLN := bmp.ScanLine[j];
              idx := j * nfoWidth; // speed optimization
              for k := 0 to nfoWidth - 1 do // Quake textures are not transparent!
              begin
                if (PByteArray(pTData)[idx] = 0) then
                  SLN[k] := nearBlack
                else
                  SLN[k] := PByteArray(pTData)[idx];
                inc(idx);
              end;
            end;
          end;

          MakePowerOf2BitmapFast(bmp);
        end;

//        if (UpperCase(ExtractFileExt(PAK)) = UpperCase(rsExtPak)) or
//           (UpperCase(ExtractFileExt(PAK)) = UpperCase(rsExtBsp)) then
        if isLink then
          texid := Textures.Add(GetPAKLinkDescription(PAK, TextureNames.Strings[i]))
        else
          texid := Textures.Add(TextureNames.Strings[i]);

        if not isTransparent and (BspVer = BspVersion_30) then
        begin
          bmp.PixelFormat := pf24bit;
          Textures.Objects[texid] := TDirect3DTexture2.Create(DXDraw, bmp, False);
          TexturesCreated[i] :=  Textures.Objects[texid] <> nil;
          bmp.PixelFormat := pf8bit;
          if hpal <> 0 then
            bmp.Palette := hpal;
        end
        else
        begin
          Textures.Objects[texid] := TDirect3DTexture2.Create(DXDraw, bmp, False);
          TexturesCreated[i] := Textures.Objects[texid] <> nil;
        end;

        if m8 then // restore old palette
        begin
          if lpal <> nil then
            FreeMem(lpal, SizeOf(TLogPalette) + SizeOf(TPaletteEntry) * 255);
          if hpal <> 0 then
            DeleteObject(hpal);
          nearBlack := Q2Pal2LPal( Q2Pal, lpal);
          hpal := CreatePalette(lpal^);
          bmp.Palette := hpal;
        end;
      end
      else
      begin
        bmp.Width := 16;
        bmp.Height := 16;
        bmp.pixelformat := pf4bit;
        bmp.Canvas.Pen.Width := 1;
        bmp.Canvas.Pen.Color := clGray;
        bmp.Canvas.Brush.Color := clWhite;
        bmp.Canvas.Rectangle(0, 0, 16, 16);
//        if (UpperCase(ExtractFileExt(PAK)) = UpperCase(rsExtPak)) or
//           (UpperCase(ExtractFileExt(PAK)) = UpperCase(rsExtBsp)) then
        if isLink then
          texid := Textures.Add(GetPAKLinkDescription(PAK, TextureNames.Strings[i]))
        else
          texid := Textures.Add(TextureNames.Strings[i]);
        Textures.Objects[texid] := TDirect3DTexture2.Create(DXDraw, bmp, False);
        TexturesCreated[i] := Textures.Objects[texid] <> nil;
        bmp.PixelFormat := pf8bit;
        if hpal <> 0 then
          bmp.Palette := hpal;
        Result := False;
      end;
    end;
  finally
    if QDir = nil then
      pakDir.Free;
    bmp.Free;
    if lpal <> nil then
      FreeMem(lpal, SizeOf(TLogPalette) + SizeOf(TPaletteEntry) * 255);
    if hpal <> 0 then
      DeleteObject(hpal);
    ReAllocMem(T.Data, 0);
    MakeStubUnLoadedTextures;
  end;
end;
{$ENDIF}
{$ENDIF}

{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_QUAKESUPPORT}
function TD3DScene.CacheIDPAKTexture(PAK: TFileName; TextureName: string; defaultExt: string = ''): boolean;
var
  s: TDXStringList;
begin
  s := TDXStringList.Create;
  try
    s.Add(TextureName);
    Result := CacheIDPAKTextures(PAK, s, -1, -1, nil, defaultExt);
  finally
    s.Free;
  end;
end;
{$ENDIF}
{$ENDIF}

{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_QUAKESUPPORT}
function TD3DScene.GetIDPAKTextureBmp(PAK: TFileName; TextureName: string): TBitmap;
var
  idx, j, k: integer;
  pakDir: TPakDir;
  EntryData: PakFile;
  b: boolean;
  T: Miptex_S;
  T_v1: Miptex_S_v1;
  T_m8: Miptex_S_m8;
  m: TMemoryStream;
  IDSoftDataModule: TIDSoftDataModule;
  Q2Pal: TQuake2Palette;
  SLN: PByteArray;
  lpal: PLogPalette;
  hpal: HPALETTE;
  nearBlack: byte;
  Entry, s, s2: string;
  m8: boolean;
  PakVer, BspVer: integer;
  isTransparent: boolean;
begin
  BspVer := GetBspVersion(PAK);
  PakVer := GetQuakeVersion(BspVer);

  isTransparent := (BspVer = BspVersion_30) and (Pos('{', TextureName) > 0);

  Result := nil;
  if not ((PakVer = 1) or (PakVer = 2)) then
    Exit;

  lpal := nil;
  hpal := 0;

  T.Data := nil;

  PAK := GetExistedFileName(PAK);
  pakDir := TPakDir.Create(PAK, '');
  Result := TBitmap.Create;
  try
    if PakVer = 2 then
      b := (pakDir.Openfile(EntryData, rsQuake2ColorMapEntry)) or
           (pakDir.Openfile(EntryData, GetExistedFileName(rsQuake2ColorMapEntry))) or
           (pakDir.Openfile(EntryData, GetExistedFileName(rsQuake2TexturesDIR + rsQuake2ColorMapEntry)))
    else
      b := (pakDir.Openfile(EntryData, rsQuake1ColorMapEntry)) or
           (pakDir.Openfile(EntryData, GetExistedFileName(rsQuake1ColorMapEntry)));
    if not b then
    begin
      IDSoftDataModule := TIDSoftDataModule.Create(nil);
      m := TMemoryStream.Create;
      try
        if PakVer = 1 then
        begin
          if BspVer = BspVersion_30 then
            IDSoftDataModule.DefaultHalfLifePalette.SaveToStream(m, False)
          else
            IDSoftDataModule.DefaultQuake1Palette.SaveToStream(m, False)
        end
        else
          IDSoftDataModule.DefaultQuake2Palette.SaveToStream(m, False);
        m.Seek(0, soFromBeginning);
        m.Read(Q2Pal, 768);
      finally
        IDSoftDataModule.Free;
        m.Free;
      end;
    end
    else
    begin
      pakDir.Qseek(EntryData, pakDir.Qfilesize(EntryData) - 768);
      pakDir.Qblockread(EntryData, Q2Pal, 768);
      pakDir.Closefile(EntryData);
    end;

// Default Palette, for Half-Life we'll try later...
    nearBlack := Q2Pal2LPal(Q2Pal, lpal);

    hpal := CreatePalette(lpal^);

    Result.PixelFormat := pf8bit;
    if hpal <> 0 then
      Result.Palette := hpal;

    s := GetPAKLinkDescription(PAK, TextureName);

    if GetPAKLinkInfo(s, s2, Entry) then
      if UpperCase(ExpandFileName(s2)) <> UpperCase(ExpandFileName(PAK)) then
        if FileExists(GetExistedFileName(s2)) then
          pakDir.AddPak(GetExistedFileName(s2));

    m8 := False;

    b := pakDir.Openfile(EntryData, Entry);
    if not b then
      b := pakDir.Openfile(EntryData, rsQuake2TexturesDIR + Entry);
    if not b then
      b := pakDir.Openfile(EntryData, GetExistedFileName(Entry));
    if not b then
      b := pakDir.Openfile(EntryData, GetExistedFileName(rsQuake2TexturesDIR + Entry));

    if not b then
      b := pakDir.Openfile(EntryData, Entry + rsExtWal);
    if not b then
      b := pakDir.Openfile(EntryData, rsQuake2TexturesDIR + Entry + rsExtWal);
    if not b then
      b := pakDir.Openfile(EntryData, GetExistedFileName(Entry + rsExtWal));
    if not b then
      b := pakDir.Openfile(EntryData, GetExistedFileName(rsQuake2TexturesDIR + Entry + rsExtWal));

    if not b then
    begin
      b := pakDir.Openfile(EntryData, Entry + rsExtM8);
      m8 := b;
    end;
    if not b then
    begin
      b := pakDir.Openfile(EntryData, rsQuake2TexturesDIR + Entry + rsExtM8);
      m8 := b;
    end;
    if not b then
    begin
      b := pakDir.Openfile(EntryData, GetExistedFileName(Entry + rsExtM8));
      m8 := b;
    end;
    if not b then
    begin
      b := pakDir.Openfile(EntryData, GetExistedFileName(rsQuake2TexturesDIR + Entry + rsExtM8));
      m8 := b;
    end;

    if b then
    begin
      if m8 then   // Heretic II support
      begin
        pakDir.Qblockread(EntryData, T_m8.Nfo, SizeOf(T_m8.Nfo));
        T.Nfo.Width := T_m8.Nfo.Widths[0];
        T.Nfo.Height := T_m8.Nfo.Heights[0];
        for j := 0 to 3 do
          T.Nfo.Offsets[j] := T_m8.Nfo.Offsets[j];
        for j := 0 to 31 do
        begin
          T.Nfo.Name[j] := T_m8.Nfo.Name[j];
          T.Nfo.AnimName[j] := T_m8.Nfo.AnimName[j];
        end;
        T.Nfo.Flags := T_m8.Nfo.Flags;
        T.Nfo.Contents := T_m8.Nfo.Contents;
        T.Nfo.Value := T_m8.Nfo.Value;


        if lpal <> nil then
          FreeMem(lpal, SizeOf(TLogPalette) + SizeOf(TPaletteEntry) * 255);
        if hpal <> 0 then
          DeleteObject(hpal);

        nearBlack := Q2Pal2LPal(T_m8.Nfo.Palette, lpal);
        hpal := CreatePalette(lpal^);
        if hpal <> 0 then
          Result.Palette := hpal;

      end
      else if (PakVer = 1) then
      begin
        pakDir.Qblockread(EntryData, T_v1.Nfo, SizeOf(T_v1.Nfo));

        for j := 0 to 15 do
          T.Nfo.Name[j] := T_v1.Nfo.Name[j];
        for j := 16 to 31 do
          T.Nfo.Name[j] := #0;

        T.Nfo.Width := T_v1.Nfo.Width;
        T.Nfo.Height := T_v1.Nfo.Height;

        for j := 0 to Miplevels - 1 do
          T.Nfo.Offsets[j] := T_v1.Nfo.Offsets[j];
      end
      else
        pakDir.Qblockread(EntryData, T.Nfo, SizeOf(T.Nfo));

      // Load Mip-Map
      // ׃חלושףח:
      //   ױנסקןץם 4 Mip-Map ףפן בסקון .wal, ףפיע טףויע (offsets)
      //   נןץ ןסזןםפבי בנ פן T.Nfo.Offsets[x], (x = 0..3)
      //   ׃ו בץפ פחם ףץםספחףח היבגזןץלו נםפב פן נס‏פן offset

      // Textures for Half-Life have here the pallete
      if (BspVer = BspVersion_30) then
        if T.Nfo.Offsets[0] <> 0 then // Data exist (Data הום ץנסקןץם ףפן bsp, בככ ףפן WAD)!
          if pakDir.Qfilesize(EntryData) >= T.Nfo.Offsets[3] + (T.Nfo.Width * T.Nfo.Height) div 64 + 770 then
          begin
            pakDir.Qseek(EntryData, T.Nfo.Offsets[3] + (T.Nfo.Width * T.Nfo.Height) div 64 + 2);

            pakDir.Qblockread(EntryData, Q2Pal, 768);
            if lpal <> nil then
              FreeMem(lpal, SizeOf(TLogPalette) + SizeOf(TPaletteEntry) * 255);
            if hpal <> 0 then
              DeleteObject(hpal);

            nearBlack := HLPal2LPal(Q2Pal, lpal, isTransparent);
            hpal := CreatePalette(lpal^);
            if hpal <> 0 then
              Result.Palette := hpal;
          end;

      // Load Mip-Map
      // ׃חלושףח:
      //   ױנסקןץם 4 Mip-Map ףפן בסקון .wal, ףפיע טףויע (offsets)
      //   נןץ ןסזןםפבי בנ פן T.Nfo.Offsets[x], (x = 0..3)
      //   ִיבגזןץלו נםפב פן בםכןדן offset
      if T.Nfo.Offsets[0] = 0 then // A single HalfLife bsp openned, no data in Nfo!
      begin
        Result.Width := 16;
        Result.Height := 16;
        Result.Canvas.Pen.Width := 1;
        Result.Canvas.Pen.Color := clGray;
        Result.Canvas.Brush.Color := clWhite;
        Result.Canvas.Rectangle(0, 0, 16, 16);
      end
      else
      begin

        pakDir.Qseek(EntryData, T.Nfo.Offsets[0]);

        ReAllocMem(T.Data, T.Nfo.Width * T.Nfo.Height);

        pakDir.Qblockread(EntryData, T.Data^, T.Nfo.Width * T.Nfo.Height);
        pakDir.Closefile(EntryData);

        Result.Width := T.Nfo.Width;
        Result.Height := T.Nfo.Height;
        for j := 0 to T.Nfo.Height - 1 do
        begin
          SLN := Result.ScanLine[j];
          idx := j * T.Nfo.Width; // speed optimization
          for k := 0 to T.Nfo.Width - 1 do // Quake textures are not transparent!
          begin
            if PByteArray(T.Data)[idx] = 255 then
              SLN[k] := 0
            else if PByteArray(T.Data)[idx] = 0 then
              SLN[k] := nearBlack
            else
              SLN[k] := PByteArray(T.Data)[idx];
            inc(idx);
          end;
        end;
      end;
    end
    else
      FreeAndNilSafe(Result);
  finally
    pakDir.Free;
    if lpal <> nil then
      FreeMem(lpal, SizeOf(TLogPalette) + SizeOf(TPaletteEntry) * 255);
    if hpal <> 0 then
      DeleteObject(hpal);
    ReAllocMem(T.Data, 0);
  end;
end;
{$ENDIF}
{$ENDIF}

{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_QUAKESUPPORT}
function TD3DScene.GetIDPAKTextureBmp(EntryName: string): TBitmap;
var
  PAKFileName: string;
  TextureName: string;
begin
  if GetPAKLinkInfo(EntryName, PAKFileName, TextureName) then
    Result := GetIDPAKTextureBmp(PAKFileName, TextureName)
  else
    Result := nil;
end;
{$ENDIF}
{$ENDIF}

{$IFNDEF NO_TOMBRAIDERSUPPORT}
function TD3DScene.CacheTrTextures(MainLevel: TFileName; TextureNames: TDXStringList): boolean;
var
  l: TTombRaiderLevel;
begin
  l := TTombRaiderLevel.Create(self);
  try
    l.Load_level(MainLevel, True);
    Result := l.LoadTextures256(TextureNames) > 0;
  finally
    l.Free;
  end;
end;
{$ENDIF}

{$IFNDEF NO_TOMBRAIDERSUPPORT}
function TD3DScene.CacheTrTexture(MainLevel: TFileName; TextureName: string): boolean;
var
  s: TDXStringList;
begin
  s := TDXStringList.Create;
  try
    s.Add(TextureName);
    Result := CacheTrTextures(MainLevel, s);
  finally
    s.Free;
  end;

end;
{$ENDIF}

{$IFNDEF NO_TOMBRAIDERSUPPORT}
function TD3DScene.GetTrTextureBmp(MainLevel: TFileName; TextureName: string): TBitmap;
var
  l: TTombRaiderLevel;
begin
  l := TTombRaiderLevel.Create(self);
  try
    l.Load_level(MainLevel, True);
    Result := l.GetTexture256Bmp(TextureName);
  finally
    l.Free;
  end;
end;
{$ENDIF}

{$IFNDEF NO_TOMBRAIDERSUPPORT}
function TD3DScene.GetTrTextureBmp(EntryName: string): TBitmap;
var
  TrFileName: string;
  TextureName: string;
begin
  if IsTrLinkInfo(EntryName) and GetTrLinkInfo(EntryName, TrFileName, TextureName) then
    Result := GetTrTextureBmp(TrFileName, TextureName)
  else
    Result := nil;
end;
{$ENDIF}

function TD3DScene.GetTextureBmp(EntryID: integer): TBitmap;
begin
  Result := GetTextureBmp(IntToStrTable(EntryID));
end;

function TD3DScene.GetTextureBmp(EntryName: string): TBitmap;
var
  i, index: integer;
  obj: TObject;
  s_wad, s_entry: string;
begin
  Result := nil;
  index := Textures.IndexOf(EntryName);
  if index = -1 then
  begin
    EntryName := GetExistedFileName(Trim(EntryName));
    index := Textures.IndexOf(EntryName);
    if index = -1 then
    begin
      EntryName := ExtractFileName(UpperCase(EntryName));
      for i := 0 to Textures.Count - 1 do
        if EntryName = UpperCase(ExtractFileName(Textures.Strings[i])) then
        begin
          index := i;
          break;
        end;
    end;
  end;
  if index = -1 then
  begin
    EntryName := UpperCase(ExtractFileNameOnly(EntryName));
    for i := 0 to Textures.Count - 1 do
    begin
      GetWadLinkInfo(Textures.Strings[i], s_wad, s_entry);
      s_entry := UpperCase(ExtractFileNameOnly(s_entry));
      if EntryName = s_entry then
      begin
        index := i;
        break;
      end;
    end;
  end;
  if index > -1 then
  begin
    Result := TBitmap.Create;
    obj := Textures.Objects[index];
    if obj is TDirect3DTexture2 then
    begin
      Result.Width := (obj as TDirect3DTexture2).Surface.Width;
      Result.Height := (obj as TDirect3DTexture2).Surface.Height;
      Result.PixelFormat := pf24bit;
      Result.Canvas.CopyRect(
        Rect(0, 0, Result.Width, Result.Height),
        (obj as TDirect3DTexture2).Surface.Canvas,
        Rect(0, 0, Result.Width, Result.Height));
    end
    else if obj is TPicture then
    begin
      Result.Width := (obj as TPicture).Width;
      Result.Height := (obj as TPicture).Height;
      Result.PixelFormat := pf24bit;
      Result.Canvas.CopyRect(
        Rect(0, 0, Result.Width, Result.Height),
        (obj as TPicture).Bitmap.Canvas,
        Rect(0, 0, Result.Width, Result.Height));
    end
  end;
end;

// װן pInfo הום קסויזופבי םב היבףנבףפו, ךבכופבי לףב בנ פחם MergeTessalation
function TD3DScene.AddTessalatedPolygon(pInfo: PD3DTessalationInfo): TD3DObject;
var
  pol: PD3DPolygonInfo;
  spoly: TD3DPolygon;
  i: integer;
{$IFDEF DESIGNER}
  oldCanSaveUndo: boolean;
{$ENDIF}
begin
  Result := nil;
  system.new(pol);
  try
    pol.key := GenGlobalID;
    pol.C := $FFFFFF;
    pol.u := 1.0;
    pol.v := 1.0;
    pol.du := 0.0;
    pol.dv := 0.0;
    pol.UseFlatUV := False;
    pol.NumVertexes := 0;//pInfo.NumVertexes;
    pol.NumTextures := 1;
    pol.zOrder := 0;
    pol.Interval := 0.0;
    pol.PrimitiveType := pinfo.PrimitiveType;
//    pol.PrimitiveType := D3DPT_TRIANGLESTRIP;
    pol.Transparency := 0;
    pol.Cull := pInfo.Cull;
    FillChar(pol.TextureNames, SizeOf(pol.TextureNames), Chr(0));
    pol.TextureNames[0, 0] := pInfo.TextureName;
    for i := 0 to pInfo.NumVertexes - 1 do
      pol.Vertexes[i] := NULLVECTOR;

    spoly := TD3DPolygon.Create(DXDraw, AddTexturesToCollection(pInfo.TextureName), pol^);
    spoly.MaxPolygonVertexes := fMaxPolygonVertexes;
//    spoly := AddSurface(ID3D_Polygon, pol);

  finally
    dispose(pol);
  end;

{$IFDEF DESIGNER}
  SaveUndo;
  oldCanSaveUndo := CanSaveUndo;
  CanSaveUndo := False;
{$ENDIF}
  if spoly <> nil then
  begin
    if (spoly is TD3DPolygon) then
    begin
      (spoly as TD3DPolygon).RunTimeOnly := True;
      (spoly as TD3DPolygon).SizeNumVertexes(pInfo.NumVertexes);
      for i := 0 to pInfo.NumVertexes - 1 do
        (spoly as TD3DPolygon).TheVertexes[i] := pInfo.Vertexes[i];
    end;

    Result := Addsurface(spoly);
  end;
//  MergePolygonData(spoly);
{$IFDEF DESIGNER}
  CanSaveUndo := oldCanSaveUndo;
{$ENDIF}
end;

function TD3DScene.MergeTessalation(pInfo: PD3DTessalationInfo): boolean;
const
  VERY_BIG = 1.0e+10;
  ANGLETOLERANCE = 0.0001;
var
  i, j: integer;
  tri: PD3DGenericTriangleInfo;
  angle: TD3DValue;
  dist, mindist: TD3DValue;
  pos: integer;
  pInfo1: PD3DTessalationInfo;
  pVi: PD3DLVertex;
  i_mod: integer;
{$IFDEF DESIGNER}
  oldCanSaveUndo: boolean;
{$ENDIF}
begin
  Result := False;

  if pInfo.PrimitiveType <> D3DPT_TRIANGLEFAN then
  begin // Nothing to do....
    AddTessalatedPolygon(pInfo);
    Exit;
  end;

  if pInfo.NumVertexes < 3 then
    Exit;

  if pInfo.NumVertexes = 3 then
  begin
{$IFDEF DESIGNER}
    SaveUndo;
    oldCanSaveUndo := CanSaveUndo;
    CanSaveUndo := False;
{$ENDIF}
    system.new(tri);
    try
      tri.TextureName := pInfo.TextureName;
      System.Move(pInfo.Vertexes, tri.Vertexes, 3 * SizeOf(TD3DLVertex));
{      tri.Vertexes[0] := pInfo.Vertexes[0];
      tri.Vertexes[1] := pInfo.Vertexes[1];
      tri.Vertexes[2] := pInfo.Vertexes[2];}
//      MergePolygonData(ID3D_GenericTriangle, tri);
      AddSurface(ID3D_GenericTriangle, tri);
    finally
      dispose(tri);
    end;
{$IFDEF DESIGNER}
    CanSaveUndo := oldCanSaveUndo;
{$ENDIF}
    Exit;
  end;

{$IFDEF DESIGNER}
  SaveUndo;
  oldCanSaveUndo := CanSaveUndo;
  CanSaveUndo := False;
{$ENDIF}
  i := 0;
  pVi := @pInfo.Vertexes[0];
  repeat
    i_mod := (i + pInfo.NumVertexes - 1) mod pInfo.NumVertexes;
    angle := GetAngle(
              MakeFloatPoint(pInfo.Vertexes[i_mod]),
              MakeFloatPoint(pVi^),
              MakeFloatPoint(pInfo.Vertexes[(i + 1) mod pInfo.NumVertexes]));
    if angle < 0 then
      angle := angle + g_2_PI;
    if angle > g_PI + ANGLETOLERANCE then
    begin
      Result := True; // װן tessalation וםבי ךץספ
      mindist := VERY_BIG;
      pos := 0; // ׃חלון לו פחם ליךספוסח בנףפבףח

      for j := 0 to pInfo.NumVertexes - 1 do
        if (j <> i_mod) and
           (j <> i) and
           (j <> (i + 1) mod pInfo.NumVertexes) then // קי ףפב ףחלוב נןץ ןסזןץם פחם דשםב
        begin
          dist := GetProjVertexSqrDistance(pVi^, pInfo.Vertexes[j]);
          if dist < mindist then
          begin
          // ֱם ח בנףפבףח פוםוי ףפן 0, הום ומופזןץלו פחם דשםב
            if dist < g_EPSILON then
            begin
              mindist := dist;
              pos := j;
            end
            else if IsLVertexInAngle(pInfo.Vertexes[j],
                                     pInfo.Vertexes[i_mod],
                                     pVi^,
                                     angle) then
            begin
              mindist := dist;
              pos := j; // ׃חלון לו פחם ךןםפיםפוסח בנףפבףח
            end;
          end;
        end;

      if mindist < VERY_BIG / 2 then // ֱם גסטחךו ףחלון ףקופיך ךןםפ
      begin
        system.new(pInfo1);
        try
          pInfo1.Cull := pInfo.Cull;
          pInfo1.PrimitiveType := D3DPT_TRIANGLEFAN;
          pInfo1.TextureName := pInfo.TextureName;

          pInfo1.NumVertexes := 0;
          if pos > i then
          begin
            System.Move(pInfo.Vertexes[pos],
                        pInfo1.Vertexes[pInfo1.NumVertexes],
                        (pInfo.NumVertexes - pos) * SizeOf(TD3DLVertex));
            pInfo1.NumVertexes := pInfo1.NumVertexes + pInfo.NumVertexes - pos;
            System.Move(pInfo.Vertexes[0],
                        pInfo1.Vertexes[pInfo1.NumVertexes],
                        (i + 1) * SizeOf(TD3DLVertex));
            pInfo1.NumVertexes := pInfo1.NumVertexes + i + 1;
{            for j := pos to pInfo.NumVertexes - 1 do
            begin
              pInfo1.Vertexes[pInfo1.NumVertexes] := pInfo.Vertexes[j];
              inc(pInfo1.NumVertexes);
            end;
            for j := 0 to i do
            begin
              pInfo1.Vertexes[pInfo1.NumVertexes] := pInfo.Vertexes[j];
              inc(pInfo1.NumVertexes);
            end;}
          end
          else
          begin
            System.Move(pInfo.Vertexes[pos],
                        pInfo1.Vertexes[pInfo1.NumVertexes],
                        (i - pos + 1) * SizeOf(TD3DLVertex));
            pInfo1.NumVertexes := pInfo1.NumVertexes + i - pos + 1;
{            for j := pos to i do
            begin
              pInfo1.Vertexes[pInfo1.NumVertexes] := pInfo.Vertexes[j];
              inc(pInfo1.NumVertexes);
            end;}
          end;
          MergeTessalation(pInfo1);

          pInfo1.NumVertexes := 0;
          if pos > i then
          begin
            System.Move(pInfo.Vertexes[i],
                        pInfo1.Vertexes[pInfo1.NumVertexes],
                        (pos - i + 1) * SizeOf(TD3DLVertex));
            pInfo1.NumVertexes := pInfo1.NumVertexes + pos - i + 1;
{            for j := i to pos do
            begin
              pInfo1.Vertexes[pInfo1.NumVertexes] := pInfo.Vertexes[j];
              inc(pInfo1.NumVertexes);
            end;}
          end
          else
          begin
            System.Move(pInfo.Vertexes[i],
                        pInfo1.Vertexes[pInfo1.NumVertexes],
                        (pInfo.NumVertexes - i) * SizeOf(TD3DLVertex));
            pInfo1.NumVertexes := pInfo1.NumVertexes + pInfo.NumVertexes - i;
            System.Move(pInfo.Vertexes[0],
                        pInfo1.Vertexes[pInfo1.NumVertexes],
                        (pos + 1) * SizeOf(TD3DLVertex));
            pInfo1.NumVertexes := pInfo1.NumVertexes + pos + 1;
{            for j := i to pInfo.NumVertexes - 1 do
            begin
              pInfo1.Vertexes[pInfo1.NumVertexes] := pInfo.Vertexes[j];
              inc(pInfo1.NumVertexes);
            end;
            for j := 0 to pos do
            begin
              pInfo1.Vertexes[pInfo1.NumVertexes] := pInfo.Vertexes[j];
              inc(pInfo1.NumVertexes);
            end;}
          end;
          MergeTessalation(pInfo1);

          Result := True;
        finally
          dispose(pInfo1);
        end;
      end;
    end;
    inc(i);
    inc(pVi);
  until Result or (i = pInfo.NumVertexes);

  if not Result then
    AddTessalatedPolygon(pInfo);
{$IFDEF DESIGNER}
  CanSaveUndo := oldCanSaveUndo;
{$ENDIF}
end;

function TD3DScene.MergeTriangeTessalation2(const inf: TD3DGenericTriangleInfo;
  const level: integer = 2): boolean;
// ֱםבהסןליך היבףנוי פן ךטו פסדשםן ףו 2 פסדשםב
var
  inf1: TD3DGenericTriangleInfo;
{$IFDEF DESIGNER}
  oldCanSaveUndo: boolean;
{$ENDIF}
begin
{$IFDEF DESIGNER}
  SaveUndo;
  oldCanSaveUndo := CanSaveUndo;
  CanSaveUndo := False;
{$ENDIF}
  if level < 2 then
  begin
    MergePolygonData(ID3D_GenericTriangle, @inf);
    Result := False;
  end
  else
  begin
    inf1.TextureName := inf.TextureName;
    inf1.Vertexes[0] := inf.Vertexes[0];
    inf1.Vertexes[1] := inf.Vertexes[2];
    inf1.Vertexes[2] := MakeD3DLVertex(
      (inf.Vertexes[0].x + inf.Vertexes[1].x) / 2,
      (inf.Vertexes[0].y + inf.Vertexes[1].y) / 2,
      (inf.Vertexes[0].z + inf.Vertexes[1].z) / 2,
      (inf.Vertexes[0].Color div 2 + inf.Vertexes[1].Color div 2),
      (inf.Vertexes[0].Specular div 2 + inf.Vertexes[1].Specular div 2),
      (inf.Vertexes[0].tu + inf.Vertexes[1].tu) / 2,
      (inf.Vertexes[0].tv + inf.Vertexes[1].tv) / 2);
    MergeTriangeTessalation2(inf1, level - 1);

    inf1.Vertexes[0] := inf1.Vertexes[2];
    inf1.Vertexes[1] := inf.Vertexes[2];
    inf1.Vertexes[2] := inf.Vertexes[1];
    MergeTriangeTessalation2(inf1, level - 1);

    Result := True;
  end;
{$IFDEF DESIGNER}
  CanSaveUndo := oldCanSaveUndo;
{$ENDIF}
end;

function TD3DScene.MergeTriangeTessalation3(const inf: TD3DGenericTriangleInfo;
  const level: integer = 2): boolean;
// ֱםבהסןליך היבףנוי פן ךטו פסדשםן ףו 3 פסדשםב
var
  inf1: TD3DGenericTriangleInfo;
  vCenter: TD3DLVertex;
{$IFDEF DESIGNER}
    oldCanSaveUndo: boolean;
{$ENDIF}
begin
{$IFDEF DESIGNER}
  SaveUndo;
  oldCanSaveUndo := CanSaveUndo;
  CanSaveUndo := False;
{$ENDIF}
  if level < 2 then
  begin
    MergePolygonData(ID3D_GenericTriangle, @inf);
    Result := False;
  end
  else
  begin
    vCenter := MakeD3DLVertex(
      (inf.Vertexes[0].x + inf.Vertexes[1].x + inf.Vertexes[2].x) / 3,
      (inf.Vertexes[0].y + inf.Vertexes[1].y + inf.Vertexes[2].y) / 3,
      (inf.Vertexes[0].z + inf.Vertexes[1].z + inf.Vertexes[2].z) / 3,
      (inf.Vertexes[0].Color div 3 + inf.Vertexes[1].Color div 3 + inf.Vertexes[2].Color div 3),
      (inf.Vertexes[0].Specular div 3 + inf.Vertexes[1].Specular div 3 + inf.Vertexes[2].Specular div 3),
      (inf.Vertexes[0].tu + inf.Vertexes[1].tu + inf.Vertexes[2].tu) / 3,
      (inf.Vertexes[0].tv + inf.Vertexes[1].tv + inf.Vertexes[2].tv) / 3);

    inf1.TextureName := inf.TextureName;

    inf1.Vertexes[0] := inf.Vertexes[0];
    inf1.Vertexes[1] := inf.Vertexes[1];
    inf1.Vertexes[2] := vCenter;
    MergeTriangeTessalation3(inf1, level - 1);

    inf1.Vertexes[0] := inf.Vertexes[1];
    inf1.Vertexes[1] := inf.Vertexes[2];
    MergeTriangeTessalation3(inf1, level - 1);

    inf1.Vertexes[0] := inf.Vertexes[2];
    inf1.Vertexes[1] := inf.Vertexes[0];
    MergeTriangeTessalation3(inf1, level - 1);

    Result := True;
  end;
{$IFDEF DESIGNER}
  CanSaveUndo := oldCanSaveUndo;
{$ENDIF}
end;

function TD3DScene.MergeQuadTessalation4(const inf: TD3DGenericQuadrangleInfo;
// ֱםבהסןליך היבףנוי פן ךטו פופסדשםן ףו ככב 4 פופסדשםב
  const level: integer = 2): boolean;
var
  inf1: TD3DGenericQuadrangleInfo;
  vCenter, vCenter01, vCenter02, vCenter13, vCenter23: TD3DLVertex;
{$IFDEF DESIGNER}
  oldCanSaveUndo: boolean;
{$ENDIF}
begin
{$IFDEF DESIGNER}
  SaveUndo;
  oldCanSaveUndo := CanSaveUndo;
  CanSaveUndo := False;
{$ENDIF}
  if level < 2 then
  begin
    MergePolygonData(ID3D_GenericQuadrangle, @inf);
    Result := False;
  end
  else
  begin
    vCenter := MakeD3DLVertex(
      (inf.Vertexes[0].x + inf.Vertexes[1].x + inf.Vertexes[2].x + inf.Vertexes[3].x) / 4,
      (inf.Vertexes[0].y + inf.Vertexes[1].y + inf.Vertexes[2].y + inf.Vertexes[3].y) / 4,
      (inf.Vertexes[0].z + inf.Vertexes[1].z + inf.Vertexes[2].z + inf.Vertexes[3].z) / 4,
      (inf.Vertexes[0].Color div 4 + inf.Vertexes[1].Color div 4 + inf.Vertexes[2].Color div 4 + inf.Vertexes[3].Color div 4),
      (inf.Vertexes[0].Specular div 4 + inf.Vertexes[1].Specular div 4 + inf.Vertexes[2].Specular div 4 + inf.Vertexes[3].Specular div 4),
      (inf.Vertexes[0].tu + inf.Vertexes[1].tu + inf.Vertexes[2].tu + inf.Vertexes[3].tu) / 4,
      (inf.Vertexes[0].tv + inf.Vertexes[1].tv + inf.Vertexes[2].tv + inf.Vertexes[3].tv) / 4);

    vCenter01 := MakeD3DLVertex(
      (inf.Vertexes[0].x + inf.Vertexes[1].x) / 2,
      (inf.Vertexes[0].y + inf.Vertexes[1].y) / 2,
      (inf.Vertexes[0].z + inf.Vertexes[1].z) / 2,
      (inf.Vertexes[0].Color div 2 + inf.Vertexes[1].Color div 2),
      (inf.Vertexes[0].Specular div 2 + inf.Vertexes[1].Specular div 2),
      (inf.Vertexes[0].tu + inf.Vertexes[1].tu) / 2,
      (inf.Vertexes[0].tv + inf.Vertexes[1].tv) / 2);

    vCenter02 := MakeD3DLVertex(
      (inf.Vertexes[0].x + inf.Vertexes[2].x) / 2,
      (inf.Vertexes[0].y + inf.Vertexes[2].y) / 2,
      (inf.Vertexes[0].z + inf.Vertexes[2].z) / 2,
      (inf.Vertexes[0].Color div 2 + inf.Vertexes[2].Color div 2),
      (inf.Vertexes[0].Specular div 2 + inf.Vertexes[2].Specular div 2),
      (inf.Vertexes[0].tu + inf.Vertexes[2].tu) / 2,
      (inf.Vertexes[0].tv + inf.Vertexes[2].tv) / 2);

    vCenter13 := MakeD3DLVertex(
      (inf.Vertexes[1].x + inf.Vertexes[3].x) / 2,
      (inf.Vertexes[1].y + inf.Vertexes[3].y) / 2,
      (inf.Vertexes[1].z + inf.Vertexes[3].z) / 2,
      (inf.Vertexes[1].Color div 2 + inf.Vertexes[3].Color div 2),
      (inf.Vertexes[1].Specular div 2 + inf.Vertexes[3].Specular div 2),
      (inf.Vertexes[1].tu + inf.Vertexes[3].tu) / 2,
      (inf.Vertexes[1].tv + inf.Vertexes[3].tv) / 2);

    vCenter23 := MakeD3DLVertex(
      (inf.Vertexes[2].x + inf.Vertexes[3].x) / 2,
      (inf.Vertexes[2].y + inf.Vertexes[3].y) / 2,
      (inf.Vertexes[2].z + inf.Vertexes[3].z) / 2,
      (inf.Vertexes[2].Color div 2 + inf.Vertexes[3].Color div 2),
      (inf.Vertexes[2].Specular div 2 + inf.Vertexes[3].Specular div 2),
      (inf.Vertexes[2].tu + inf.Vertexes[3].tu) / 2,
      (inf.Vertexes[2].tv + inf.Vertexes[3].tv) / 2);

    inf1.TextureName := inf.TextureName;
    inf1.Vertexes[0] := inf.Vertexes[0];
    inf1.Vertexes[1] := vCenter01;
    inf1.Vertexes[2] := vCenter02;
    inf1.Vertexes[3] := vCenter;
    MergeQuadTessalation4(inf1, level - 1);

    inf1.Vertexes[0] := vCenter01;
    inf1.Vertexes[1] := inf.Vertexes[1];
    inf1.Vertexes[2] := vCenter;
    inf1.Vertexes[3] := vCenter13;
    MergeQuadTessalation4(inf1, level - 1);

    inf1.Vertexes[0] := vCenter02;
    inf1.Vertexes[1] := vCenter;
    inf1.Vertexes[2] := inf.Vertexes[2];
    inf1.Vertexes[3] := vCenter23;
    MergeQuadTessalation4(inf1, level - 1);

    inf1.Vertexes[0] := vCenter;
    inf1.Vertexes[1] := vCenter13;
    inf1.Vertexes[2] := vCenter23;
    inf1.Vertexes[3] := inf.Vertexes[3];
    MergeQuadTessalation4(inf1, level - 1);

    Result := True;
  end;
{$IFDEF DESIGNER}
  CanSaveUndo := oldCanSaveUndo;
{$ENDIF}
end;

function TD3DScene.MergeQuadTessalation4(const inf: TD3DGenericTriangleInfo;
  const v: TD3DLVertex; const idx: integer;
  const level: integer = 2): boolean;
var
  inf1: TD3DGenericQuadrangleInfo;
begin
  case idx of
     0: begin
          inf1.Vertexes[0] := v;
          inf1.Vertexes[1] := inf.Vertexes[0];
          inf1.Vertexes[2] := inf.Vertexes[1];
          inf1.Vertexes[3] := inf.Vertexes[2];
        end;
     1: begin
          inf1.Vertexes[0] := inf.Vertexes[0];
          inf1.Vertexes[1] := v;
          inf1.Vertexes[2] := inf.Vertexes[1];
          inf1.Vertexes[3] := inf.Vertexes[2];
        end;
     2: begin
          inf1.Vertexes[0] := inf.Vertexes[0];
          inf1.Vertexes[1] := inf.Vertexes[1];
          inf1.Vertexes[2] := v;
          inf1.Vertexes[3] := inf.Vertexes[2];
        end;
     3: begin
          inf1.Vertexes[0] := inf.Vertexes[0];
          inf1.Vertexes[1] := inf.Vertexes[1];
          inf1.Vertexes[2] := inf.Vertexes[2];
          inf1.Vertexes[3] := v;
        end;
  else
    begin
      Result := False;
      Exit;
    end;
  end;

  inf1.TextureName := inf.TextureName;

  Result := MergeQuadTessalation4(inf1, level);
end;

function TD3DScene.MergeQuadTessalationH(const inf: TD3DGenericTriangleInfo;
  const v: TD3DLVertex; const idx: integer;
  const level: integer = 2): boolean;
var
  inf1: TD3DGenericQuadrangleInfo;
begin
  case idx of
     0: begin
          inf1.Vertexes[0] := v;
          inf1.Vertexes[1] := inf.Vertexes[0];
          inf1.Vertexes[2] := inf.Vertexes[1];
          inf1.Vertexes[3] := inf.Vertexes[2];
        end;
     1: begin
          inf1.Vertexes[0] := inf.Vertexes[0];
          inf1.Vertexes[1] := v;
          inf1.Vertexes[2] := inf.Vertexes[1];
          inf1.Vertexes[3] := inf.Vertexes[2];
        end;
     2: begin
          inf1.Vertexes[0] := inf.Vertexes[0];
          inf1.Vertexes[1] := inf.Vertexes[1];
          inf1.Vertexes[2] := v;
          inf1.Vertexes[3] := inf.Vertexes[2];
        end;
     3: begin
          inf1.Vertexes[0] := inf.Vertexes[0];
          inf1.Vertexes[1] := inf.Vertexes[1];
          inf1.Vertexes[2] := inf.Vertexes[2];
          inf1.Vertexes[3] := v;
        end;
  else
    begin
      Result := False;
      Exit;
    end;
  end;

  inf1.TextureName := inf.TextureName;

  Result := MergeQuadTessalationH(inf1, level);
end;

function TD3DScene.MergeQuadTessalationH(const inf: TD3DGenericQuadrangleInfo;
  const level: integer = 2): boolean;
var
  ptess: PD3DTessalationInfo;
  i, j: integer;
  w1, w2: TD3DValue;
{$IFDEF DESIGNER}
    oldCanSaveUndo: boolean;
{$ENDIF}
begin
{$IFDEF DESIGNER}
  SaveUndo;
  oldCanSaveUndo := CanSaveUndo;
  CanSaveUndo := False;
{$ENDIF}
  if level < 2 then
  begin
    MergePolygonData(ID3D_GenericQuadrangle, @inf);
    Result := False;
  end
  else
  begin
    System.new(ptess);
    try
      ptess.TextureName := inf.TextureName;
      ptess.PrimitiveType := D3DPT_TRIANGLESTRIP;
      ptess.Cull := D3DCULL_NONE;
      ptess.NumVertexes := 4 + (level - 1) * 2;
      ptess.Vertexes[0] := inf.Vertexes[0];
      ptess.Vertexes[1] := inf.Vertexes[1];
      j := 2;
      for i := 1 to level - 1 do
      begin
        w1 := (level - i) / level;
        w2 := i / level;
        ptess.Vertexes[j] := MakeD3DLVertex(
          inf.Vertexes[0].x * w1 + inf.Vertexes[2].x * w2,
          inf.Vertexes[0].y * w1 + inf.Vertexes[2].y * w2,
          inf.Vertexes[0].z * w1 + inf.Vertexes[2].z * w2,
          inf.Vertexes[0].Color div 2 + inf.Vertexes[2].Color div 2,
          inf.Vertexes[0].Specular div 2 + inf.Vertexes[2].Specular div 2,
          inf.Vertexes[0].tu * w1 + inf.Vertexes[2].tu * w2,
          inf.Vertexes[0].tv * w1 + inf.Vertexes[2].tv * w2);
        inc(j);

        ptess.Vertexes[j] := MakeD3DLVertex(
          inf.Vertexes[1].x * w1 + inf.Vertexes[3].x * w2,
          inf.Vertexes[1].y * w1 + inf.Vertexes[3].y * w2,
          inf.Vertexes[1].z * w1 + inf.Vertexes[3].z * w2,
          inf.Vertexes[1].Color div 2 + inf.Vertexes[3].Color div 2,
          inf.Vertexes[1].Specular div 2 + inf.Vertexes[3].Specular div 2,
          inf.Vertexes[1].tu * w1 + inf.Vertexes[3].tu * w2,
          inf.Vertexes[1].tv * w1 + inf.Vertexes[3].tv * w2);
        inc(j);

      end;
      ptess.Vertexes[j] := inf.Vertexes[2];
      ptess.Vertexes[j + 1] := inf.Vertexes[3];

      Result := AddTessalatedPolygon(ptess) <> nil;
    finally
      dispose(ptess);
    end;
  end;

{$IFDEF DESIGNER}
  CanSaveUndo := oldCanSaveUndo;
{$ENDIF}
end;

function TD3DScene.MergePolygonTessalation(pInfo: PD3DPolygonInfo): boolean;
var
  ptess: PD3DTessalationInfo;
  p: TD3DPolygon;
  i: integer;
{$IFDEF DESIGNER}
  oldCanSaveUndo: boolean;
{$ENDIF}
begin
{$IFDEF DESIGNER}
  SaveUndo;
  oldCanSaveUndo := CanSaveUndo;
  CanSaveUndo := False;
{$ENDIF}
  system.new(ptess);
  try
    FillChar(ptess^, SizeOf(ptess^), Chr(0));
    p := TD3DPolygon.Create(DXDraw, AddTexturesToCollection(pInfo.TextureNames), pInfo^);
    try
      ptess.NumVertexes := pInfo.NumVertexes;
      ptess.TextureName := pInfo.TextureNames[0, 0];
      ptess.Cull := pInfo.Cull;
      for i := 0 to pInfo.NumVertexes - 1 do
        ptess.Vertexes[i] := p.TheVertexes[i];
    finally
      p.Free;
    end;
    Result := MergeTessalation(ptess);
  finally
    dispose(ptess);
  end;
{$IFDEF DESIGNER}
  CanSaveUndo := oldCanSaveUndo;
{$ENDIF}
end;

function TD3DScene.AddPolygonData(const aVertexes: PD3DLVertexArray; const aNumVertexes: integer;
  const prtype: TD3DPrimitiveType; const aTexturename: string;
  const aTexture: TDirect3DTexture2 = nil): TD3DObject;
begin
  if aTexture = nil then
    Result := TD3DPolygon.Create(DXDraw, aVertexes, aNumVertexes, prtype,
       AddTextureToCollectionConst(aTextureName), aTextureName)
  else
    Result := TD3DPolygon.Create(DXDraw, aVertexes, aNumVertexes, prtype,
       aTexture, aTextureName);
  if Result <> nil then
  begin
    Surfaces.Objects[Surfaces.Add(texturename)] := Result;
    (Result as TD3DPolygon).MaxPolygonVertexes := fMaxPolygonVertexes;
  end;
end;

function TD3DScene.MergePolygonData(const aVertexes: PD3DLVertexArray;
  const aNumVertexes: integer; const prtype: TD3DPrimitiveType;
  const aTexturename: string; const aTexture: TDirect3DTexture2 = nil): boolean;
var
  p: TD3DObject;
begin
  if aTexture = nil then
    p := TD3DPolygon.Create(DXDraw, aVertexes, aNumVertexes, prtype,
        AddTextureToCollectionConst(aTextureName), aTextureName)
  else
    p := TD3DPolygon.Create(DXDraw, aVertexes, aNumVertexes, prtype,
        aTexture, aTextureName);
  if p <> nil then
  begin
    Result := MergePolygonData(p);
    if Result then
      p.Free;
  end
  else
    Result := False;
end;

function TD3DScene.MergePolygonData(var d3dobj: TD3DObject): boolean;
var
  i: integer;
  obj: TObject;
  TextureName: string;
  SurfaceCount: integer;
begin
  if d3dobj = nil then
  begin
    Result := False;
    Exit;
  end;

  if d3dobj.GetTypeID = ID3D_Polygon then
  begin
    SurfaceCount := Surfaces.Count;
    if (fLastMergeIndex > -1) and (fLastMergeIndex < SurfaceCount) then
    begin
      obj := Surfaces.Objects[fLastMergeIndex];
      if (obj as TD3DObject).GetTypeID = ID3D_Polygon then
        if (obj as TD3DPolygon).CanMergeWithPolygon(d3dobj as TD3DPolygon) then
          if (obj as TD3DPolygon).MergeWithPolygon(d3dobj as TD3DPolygon) then
          begin
            fNeedsRadiusAndCenterRecalc := True;
            Result := True;
            Exit;
          end;
    end;

    TextureName := d3dobj.TextureName;

    if Surfaces.Sorted then
    begin
      i := Surfaces.IndexOf(TextureName);

      if i > -1 then
      begin

        obj := Surfaces.Objects[i];
        if (obj as TD3DObject).GetTypeID = ID3D_Polygon then
          if (obj as TD3DPolygon).CanMergeWithPolygon(d3dobj as TD3DPolygon) then
            if (obj as TD3DPolygon).MergeWithPolygon(d3dobj as TD3DPolygon) then
            begin
              fLastMergeIndex := i;
              FreeAndNilSafe(d3dobj);
              fNeedsRadiusAndCenterRecalc := True;
              Result := True;
              Exit;
            end;

        if i > 1 then
        begin
          obj := Surfaces.Objects[i - 1];
          if (obj as TD3DObject).GetTypeID = ID3D_Polygon then
            if (obj as TD3DPolygon).CanMergeWithPolygon(d3dobj as TD3DPolygon) then
              if (obj as TD3DPolygon).MergeWithPolygon(d3dobj as TD3DPolygon) then
              begin
                fLastMergeIndex := i - 1;
                FreeAndNilSafe(d3dobj);
                fNeedsRadiusAndCenterRecalc := True;
                Result := True;
                Exit;
              end;
        end;

        if i < Surfaces.Count - 1 then
        begin
          obj := Surfaces.Objects[i + 1];
          if (obj as TD3DObject).GetTypeID = ID3D_Polygon then
            if (obj as TD3DPolygon).CanMergeWithPolygon(d3dobj as TD3DPolygon) then
              if (obj as TD3DPolygon).MergeWithPolygon(d3dobj as TD3DPolygon) then
              begin
                fLastMergeIndex := i + 1;
                FreeAndNilSafe(d3dobj);
                fNeedsRadiusAndCenterRecalc := True;
                Result := True;
                Exit;
              end;
        end;

      end;

    end;

    for i := SurfaceCount - 1 downto 0 do
    begin
      obj := Surfaces.Objects[i];
      if (obj as TD3DObject).GetTypeID = ID3D_Polygon then
        if (obj as TD3DPolygon).CanMergeWithPolygon(d3dobj as TD3DPolygon) then
          if (obj as TD3DPolygon).MergeWithPolygon(d3dobj as TD3DPolygon) then
          begin
            fLastMergeIndex := i;
            FreeAndNilSafe(d3dobj);
            fNeedsRadiusAndCenterRecalc := True;
            Result := True;
            Exit;
          end;
    end;
  end;
  AddSurface(d3dobj);
  Result := False;
end;

function TD3DScene.MergePolygonData(SurfaceType: byte; pInfo: Pointer): boolean;
var
  i: integer;
  obj: TObject;
  TextureName: string;
  SurfaceCount: integer;
begin
  SurfaceCount := Surfaces.Count;
  if (fLastMergeIndex > -1) and (fLastMergeIndex < SurfaceCount) then
  begin
    obj := Surfaces.Objects[fLastMergeIndex];
    if (obj as TD3DObject).CanMergeWith(SurfaceType, pInfo) then
      if (obj as TD3DObject).MergeWith(SurfaceType, pInfo) then
      begin
        fNeedsRadiusAndCenterRecalc := True;
        Result := True;
        Exit;
      end;
  end;

  if Surfaces.Sorted then
  begin
    case SurfaceType of
      ID3D_GenericTriangle: TextureName := PD3DGenericTriangleInfo(pInfo).TextureName;
      ID3D_GenericQuadrangle: TextureName := PD3DGenericQuadrangleInfo(pInfo).TextureName;
      ID3D_Quadrangle: TextureName := PD3DQuadrangleInfo(pInfo)^.TextureName;
      ID3D_Polygon: TextureName := PD3DPolygonInfo(pInfo)^.TextureNames[0, 0];
    else
      TextureName := '';
    end;
    i := Surfaces.IndexOf(TextureName);
    if i > -1 then
    begin
      obj := Surfaces.Objects[i];
      if (obj as TD3DObject).CanMergeWith(SurfaceType, pInfo) then
        if (obj as TD3DObject).MergeWith(SurfaceType, pInfo) then
        begin
          fLastMergeIndex := i;
          fNeedsRadiusAndCenterRecalc := True;
          Result := True;
          Exit;
        end;

      if i > 1 then
      begin
        obj := Surfaces.Objects[i - 1];
        if (obj as TD3DObject).CanMergeWith(SurfaceType, pInfo) then
          if (obj as TD3DObject).MergeWith(SurfaceType, pInfo) then
          begin
            fLastMergeIndex := i - 1;
            fNeedsRadiusAndCenterRecalc := True;
            Result := True;
            Exit;
          end;
      end;

      if i < SurfaceCount - 1 then
      begin
        obj := Surfaces.Objects[i + 1];
        if (obj as TD3DObject).CanMergeWith(SurfaceType, pInfo) then
          if (obj as TD3DObject).MergeWith(SurfaceType, pInfo) then
          begin
            fLastMergeIndex := i + 1;
            fNeedsRadiusAndCenterRecalc := True;
            Result := True;
            Exit;
          end;
      end;

    end;
  end;

  for i := SurfaceCount - 1 downto 0 do
  begin
    obj := Surfaces.Objects[i];
    if (obj as TD3DObject).CanMergeWith(SurfaceType, pInfo) then
      if (obj as TD3DObject).MergeWith(SurfaceType, pInfo) then
      begin
        fLastMergeIndex := i;
        fNeedsRadiusAndCenterRecalc := True;
        Result := True;
        Exit;
      end;
  end;
  Result := False;
  AddSurface(SurfaceType, pInfo);
end;

function TD3DScene.AddSurface(obj: TD3DObject): TD3DObject;
// ׀סןףןק, פן obj הום נסנוי םב בנוכוץטוסשטו!!
var
  idx: integer;
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  Result := obj;
  if Result <> nil then
  begin
    fModified := True;
    idx := Surfaces.AddObject(obj.TextureName, obj);
    AddToCache(Surfaces.Strings[idx], Surfaces.Objects[idx]);
    Result.SafeMode := fSafeMode;
    if obj.GetTypeID = ID3D_Polygon then
      (obj as TD3DPolygon).MaxPolygonVertexes := fMaxPolygonVertexes;
{$IFNDEF NO_D3DBILLBOARDS}
    if obj.GetTypeID = ID3D_BillBoard then
      OptimizeBillBoards;
{$ENDIF}
{$IFNDEF NO_GLOBALID}
    AdjustGlobalID;
{$ENDIF}
    fNeedsRadiusAndCenterRecalc := True;
  end;
end;

function TD3DScene.AddSurface(SurfaceType: byte; pInfo: Pointer): TD3DObject;
var
  D3DSurface: TD3DObject;
  TextureName: string;
  TextureNames: PTextureNames;
  merger: TD3DObject;
  idx: integer;
{$IFNDEF NO_D3DSTUBOBJECTS}
  {$IFNDEF NO_D3DEXOBJECTS}
  pSOinf: TD3DStubObjectInfo;
  i: integer;
  {$ENDIF}
{$ENDIF}
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  case SurfaceType of
    ID3D_GenericTriangle:
      begin
        merger := PrepareRTLOptimizer(
          PD3DGenericTriangleInfo(pInfo)^.TextureName,
            False, True, D3DCULL_NONE);
        if merger <> nil then
          (merger as TD3DPolygon).MergeWith(ID3D_GenericTriangle, pInfo);
        Result := merger;
        Exit;
      end;
    ID3D_GenericQuadrangle:
      begin
        merger := PrepareRTLOptimizer(
          PD3DGenericQuadrangleInfo(pInfo)^.TextureName,
            False, True, D3DCULL_NONE);
        if merger <> nil then
          (merger as TD3DPolygon).MergeWith(ID3D_GenericQuadrangle, pInfo);
        Result := merger;
        Exit;
      end;
{$IFNDEF NO_D3DTRIANGLES}
    ID3D_Triangle:
      begin
        TextureName := PD3DTriangleInfo(pInfo)^.TextureName;
        D3DSurface :=
          TD3DSTriangle.Create(DXDraw, AddTextureToCollection(TextureName),
            PD3DTriangleInfo(pInfo)^);
      end;
{$ENDIF}
    ID3D_Quadrangle:
      begin
        TextureName := PD3DQuadrangleInfo(pInfo)^.TextureName;
        D3DSurface :=
          TD3DQuadrAngle.Create(DXDraw, AddTextureToCollection(TextureName),
            PD3DQuadrangleInfo(pInfo)^);
      end;
{$IFNDEF NO_D3DSTUBOBJECTS}
    ID3D_StubObject:
      begin
        TextureNames := @PD3DStubObjectInfo(pInfo)^.TextureNames;
        TextureName := TextureNames[0, 0];
        D3DSurface :=
          TD3DStubObject.Create(DXDraw, AddTexturesToCollection(TextureNames^),
            PD3DStubObjectInfo(pInfo)^);
      end;
{$ENDIF}
{$IFNDEF NO_D3DEXOBJECTS}
    ID3D_ExObject:
      begin
        TextureNames := @PD3DExObjectInfo(pInfo)^.TextureNames;
        TextureName := TextureNames[0, 0];
        D3DSurface :=
          TD3DExObject.Create(DXDraw, AddTexturesToCollection(TextureNames^),
            PD3DExObjectInfo(pInfo)^);
      end;
{$ENDIF}
{$IFNDEF NO_D3DSTUBOBJECTS}
  {$IFNDEF NO_D3DEXOBJECTS}
    ID3D_ExObjectToStubObject:
      begin
//        GetMem(pSOinf, SizeOf(TD3DStubObjectInfo));

        pSOinf.SimpleRotation := True;
        pSOinf.Key := PD3DExObjectInfo(pInfo).Key;
        pSOinf.x := PD3DExObjectInfo(pInfo).x;
        pSOinf.y := PD3DExObjectInfo(pInfo).y;
        pSOinf.z := PD3DExObjectInfo(pInfo).z;
        pSOinf.Width := PD3DExObjectInfo(pInfo).Width;
        pSOinf.Height := PD3DExObjectInfo(pInfo).Height;
        pSOinf.zOrder := PD3DExObjectInfo(pInfo).zOrder;
        pSOinf.C := PD3DExObjectInfo(pInfo).C;
        pSOinf.Transparency := PD3DExObjectInfo(pInfo).Transparency;
        pSOinf.NumTextures := PD3DExObjectInfo(pInfo).NumTextures;
        pSOinf.Interval := PD3DExObjectInfo(pInfo).Interval;
        pSOinf.u := PD3DExObjectInfo(pInfo).u;
        pSOinf.v := PD3DExObjectInfo(pInfo).v;
        pSOinf.du := PD3DExObjectInfo(pInfo).du;
        pSOinf.dv := PD3DExObjectInfo(pInfo).dv;

        for i := 0 to pSOinf.NumTextures - 1 do
        begin
          pSOinf.TextureNames[i, 0] := TD3DExObjectInfo(pInfo^).TextureNames[i, 0];
          pSOinf.TextureNames[i, 1] := TD3DExObjectInfo(pInfo^).TextureNames[i, 1];
        end;
        for i := pSOinf.NumTextures to MAXTEXTURES - 1 do
        begin
          pSOinf.TextureNames[i, 0] := '';
          pSOinf.TextureNames[i, 1] := '';
        end;

        TextureNames := @PD3DExObjectInfo(pInfo)^.TextureNames;
        TextureName := TextureNames[0, 0];
        D3DSurface :=
          TD3DStubObject.Create(DXDraw, AddTexturesToCollection(TextureNames^),
            pSOinf);

//        FreeMem(pSOinf, SizeOf(TD3DStubObjectInfo));

      end;
  {$ENDIF}
{$ENDIF}

    ID3D_Polygon:
      begin
        TextureNames := @PD3DPolygonInfo(pInfo)^.TextureNames;
        TextureName := TextureNames[0, 0];
        D3DSurface :=
          TD3DPolygon.Create(DXDraw, AddTexturesToCollection(TextureNames^),
            PD3DPolygonInfo(pInfo)^);
      if D3DSurface <> nil then
        (D3DSurface as TD3DPolygon).MaxPolygonVertexes := fMaxPolygonVertexes;
      end;
{$IFNDEF NO_D3DPROCEDURALOBJECTS}
    ID3D_ProceduralObject:
      begin
        TextureNames := @PD3DProceduralObjectInfo(pInfo)^.TextureNames;
        TextureName := TextureNames[0, 0];
        D3DSurface :=
          TD3DProceduralObject.Create(self, AddTexturesToCollection(TextureNames^),
            PD3DProceduralObjectInfo(pInfo)^);
        (D3DSurface as TD3DProceduralObject).Execute;
      end;
{$ENDIF}
{$IFNDEF NO_D3DACTORS}
    ID3D_Actor:
      begin
        TextureNames := @PD3DActorInfo(pInfo)^.TextureNames;
        TextureName := TextureNames[0, 0];
        D3DSurface :=
          TD3DActor.Create(self, AddTexturesToCollection(TextureNames^),
            PD3DActorInfo(pInfo)^);
      end;
{$ENDIF}
{$IFNDEF NO_D3DBILLBOARDS}
    ID3D_BillBoard:
      begin
        TextureNames := @PD3DBillBoardInfo(pInfo)^.TextureNames;
        TextureName := TextureNames[0, 0];
        D3DSurface :=
          TD3DBillBoard.Create(DXDraw, AddPicturesToCollection(TextureNames^),
            PD3DBillBoardInfo(pInfo)^);
      end;
{$ENDIF}
{$IFNDEF NO_D3DCUBES}
    ID3D_Cube:
      begin
        TextureNames := @PD3DCubeInfo(pInfo)^.TextureNames;
        TextureName := TextureNames[0, 0];
        D3DSurface :=
          TD3DCube.Create(DXDraw, AddTexturesToCollection(TextureNames^),
            PD3DCubeInfo(pInfo)^);
      end;
{$ENDIF}
{$IFNDEF NO_D3DSPHERES}
    ID3D_Sphere:
      begin
        TextureNames := @PD3DSphereInfo(pInfo)^.TextureNames;
        TextureName := TextureNames[0, 0];
        D3DSurface :=
          TD3DSphere.Create(DXDraw, AddTexturesToCollection(TextureNames^),
            PD3DSphereInfo(pInfo)^);
      end;
{$ENDIF}
{$IFNDEF NO_D3DCONES}
    ID3D_Cone:
      begin
        TextureNames := @PD3DConeInfo(pInfo)^.TextureNames;
        TextureName := TextureNames[0, 0];
        D3DSurface :=
          TD3DCone.Create(DXDraw, AddTexturesToCollection(TextureNames^),
            PD3DConeInfo(pInfo)^);
      end;
{$ENDIF}
{$IFNDEF NO_D3DCYLINDERS}
    ID3D_Cylinder:
      begin
        TextureNames := @PD3DCylinderInfo(pInfo)^.TextureNames;
        TextureName := TextureNames[0, 0];
        D3DSurface :=
          TD3DCylinder.Create(DXDraw, AddTexturesToCollection(TextureNames^),
            PD3DCylinderInfo(pInfo)^);
      end;
{$ENDIF}
    ID3D_Scene:
      begin
        TextureName := PD3DSceneInfo(pInfo)^.PathToScene;
        D3DSurface := TD3DScene.CreateAttached(PD3DSceneInfo(pInfo)^, self);
      end;
{$IFNDEF NO_D3DPLUGINS}
    ID3D_PlugIn:
      begin
        TextureName := PD3DPlugInInfo(pInfo)^.TextureName;
        D3DSurface := TD3DPlugIn.Create(self, AddTextureToCollection(TextureName),
          PD3DPlugInInfo(pInfo)^);
        (D3DSurface as TD3DPlugIn).AcceptPosition(fPosition);
        (D3DSurface as TD3DPlugIn).AcceptRotation(fRotation);
      end;
{$ENDIF}
{$IFNDEF NO_D3DRINGS}
    ID3D_Ring:
      begin
        TextureNames := @PD3DRingInfo(pInfo)^.TextureNames;
        TextureName := TextureNames[0, 0];
        D3DSurface :=
          TD3DRing.Create(DXDraw, AddTexturesToCollection(TextureNames^),
            PD3DRingInfo(pInfo)^);
      end;
{$ENDIF}
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
    ID3D_SectorCollection:
      begin
        D3DSurface := TD3DSectorCollection.Create(PD3DSectorCollectionInfo2(pInfo)^, self);
        TextureName := D3DSurface.TextureName;
        (D3DSurface as TD3DSectorCollection).AcceptPosition(fOldPosition, fPosition);
        (D3DSurface as TD3DSectorCollection).AcceptRotation(fRotation);
      end;
{$ENDIF}
{$IFNDEF NO_D3DTEXTS}
    ID3D_Text:
      begin
        TextureNames := @PD3DTextInfo(pInfo)^.TextureNames;
        TextureName := TextureNames[0, 0];
        D3DSurface :=
          TD3DText.Create(DXDraw, AddTexturesToCollection(TextureNames^),
            PD3DTextInfo(pInfo)^);
      end;
{$ENDIF}
  else
    begin
      Result := nil;
      Exit;
    end;
  end;
  Result := D3DSurface;
  if Result <> nil then
  begin
    fModified := True;
    idx := Surfaces.Add(TextureName);
    Surfaces.Objects[idx] := D3DSurface;
    AddToCache(Surfaces.Strings[idx], Surfaces.Objects[idx]);
    Result.SafeMode := fSafeMode;
{$IFNDEF NO_D3DBILLBOARDS}
    if SurfaceType = ID3D_BillBoard then
      OptimizeBillBoards;
{$ENDIF}
{$IFNDEF NO_GLOBALID}
    AdjustGlobalID;
{$ENDIF}
    fNeedsRadiusAndCenterRecalc := True;
  end;
end;

function TD3DScene.ReplaceSurface(index: integer; SurfaceType: byte;
  pInfo: Pointer): TD3DObject;
var
  D3DSurface: TD3DObject;
  TextureName: string;
  TextureNames: PTextureNames;
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  if (index >= 0) and (index < Surfaces.Count) then
  begin
    case SurfaceType of
{$IFNDEF NO_D3DTRIANGLES}
      ID3D_Triangle:
        begin
          TextureName := PD3DTriangleInfo(pInfo)^.TextureName;
          D3DSurface :=
            TD3DSTriangle.Create(DXDraw, AddTextureToCollection(TextureName),
              PD3DTriangleInfo(pInfo)^);
        end;
{$ENDIF}
      ID3D_Quadrangle:
        begin
          TextureName := PD3DQuadrangleInfo(pInfo)^.TextureName;
          D3DSurface :=
            TD3DQuadrAngle.Create(DXDraw, AddTextureToCollection(TextureName),
              PD3DQuadrangleInfo(pInfo)^);
        end;
{$IFNDEF NO_D3DSTUBOBJECTS}
      ID3D_StubObject:
        begin
        // סבפלו פן נס‏פן Texture דיב וםחלסשףח פןץ Surfaces.Strings[index]!
          TextureNames := @PD3DStubObjectInfo(pInfo)^.TextureNames;
          TextureName := TextureNames[0, 0];
          D3DSurface :=
            TD3DStubObject.Create(DXDraw, AddTexturesToCollection(TextureNames^),
              PD3DStubObjectInfo(pInfo)^);
         (D3DSurface as TD3DStubObject).PerspectiveRotate(Position, Rotation);
        end;
{$ENDIF}
{$IFNDEF NO_D3DEXOBJECTS}
      ID3D_ExObject:
        begin
        // סבפלו פן נס‏פן Texture דיב וםחלסשףח פןץ Surfaces.Strings[index]!
          TextureNames := @PD3DExObjectInfo(pInfo)^.TextureNames;
          TextureName := TextureNames[0, 0];
          D3DSurface :=
            TD3DExObject.Create(DXDraw, AddTexturesToCollection(TextureNames^),
              PD3DExObjectInfo(pInfo)^);
         (D3DSurface as TD3DExObject).SimpleRotate(Position, Rotation.y);
//         (D3DSurface as TD3DExObject).SimpleRotate(fPosition);
        end;
{$ENDIF}
      ID3D_Polygon:
        begin
        // סבפלו פן נס‏פן Texture דיב וםחלסשףח פןץ Surfaces.Strings[index]!
          TextureNames := @PD3DPolygonInfo(pInfo)^.TextureNames;
          TextureName := TextureNames[0, 0];
          D3DSurface :=
            TD3DPolygon.Create(DXDraw, AddTexturesToCollection(TextureNames^),
              PD3DPolygonInfo(pInfo)^);
          if D3DSurface <> nil then
            (D3DSurface as TD3DPolygon).MaxPolygonVertexes := fMaxPolygonVertexes;
        end;
{$IFNDEF NO_D3DPROCEDURALOBJECTS}
      ID3D_ProceduralObject:
        begin
        // סבפלו פן נס‏פן Texture דיב וםחלסשףח פןץ Surfaces.Strings[index]!
          TextureNames := @PD3DProceduralObjectInfo(pInfo)^.TextureNames;
          TextureName := TextureNames[0, 0];
          D3DSurface :=
            TD3DProceduralObject.Create(self, AddTexturesToCollection(TextureNames^),
              PD3DProceduralObjectInfo(pInfo)^);
        (D3DSurface as TD3DProceduralObject).Execute;
        end;
{$ENDIF}
{$IFNDEF NO_D3DACTORS}
    ID3D_Actor:
      begin
        // סבפלו פן נס‏פן Texture דיב וםחלסשףח פןץ Surfaces.Strings[index]!
        TextureNames := @PD3DActorInfo(pInfo)^.TextureNames;
        TextureName := TextureNames[0, 0];
        D3DSurface :=
          TD3DActor.Create(self, AddTexturesToCollection(TextureNames^),
            PD3DActorInfo(pInfo)^);
      end;
{$ENDIF}
{$IFNDEF NO_D3DBILLBOARDS}
      ID3D_BillBoard:
        begin
        // סבפלו פן נס‏פן Texture דיב וםחלסשףח פןץ Surfaces.Strings[index]!
          TextureNames := @PD3DBillBoardInfo(pInfo)^.TextureNames;
          TextureName := TextureNames[0, 0];
          D3DSurface :=
            TD3DBillBoard.Create(DXDraw, AddPicturesToCollection(TextureNames^),
              PD3DBillBoardInfo(pInfo)^);
        end;
{$ENDIF}
{$IFNDEF NO_D3DCUBES}
      ID3D_Cube:
        begin
        // סבפלו פן נס‏פן Texture דיב וםחלסשףח פןץ Surfaces.Strings[index]!
          TextureNames := @PD3DCubeInfo(pInfo)^.TextureNames;
          TextureName := TextureNames[0, 0];
          D3DSurface :=
            TD3DCube.Create(DXDraw, AddTexturesToCollection(TextureNames^),
              PD3DCubeInfo(pInfo)^);
        end;
{$ENDIF}
{$IFNDEF NO_D3DSPHERES}
      ID3D_Sphere:
        begin
        // סבפלו פן נס‏פן Texture דיב וםחלסשףח פןץ Surfaces.Strings[index]!
          TextureNames := @PD3DSphereInfo(pInfo)^.TextureNames;
          TextureName := TextureNames[0, 0];
          D3DSurface :=
            TD3DSphere.Create(DXDraw, AddTexturesToCollection(TextureNames^),
              PD3DSphereInfo(pInfo)^);
        end;
{$ENDIF}
{$IFNDEF NO_D3DCONES}
      ID3D_Cone:
        begin
        // סבפלו פן נס‏פן Texture דיב וםחלסשףח פןץ Surfaces.Strings[index]!
          TextureNames := @PD3DConeInfo(pInfo)^.TextureNames;
          TextureName := TextureNames[0, 0];
          D3DSurface :=
            TD3DCone.Create(DXDraw, AddTexturesToCollection(TextureNames^),
              PD3DConeInfo(pInfo)^);
        end;
{$ENDIF}
{$IFNDEF NO_D3DCYLINDERS}
      ID3D_Cylinder:
        begin
        // סבפלו פן נס‏פן Texture דיב וםחלסשףח פןץ Surfaces.Strings[index]!
          TextureNames := @PD3DCylinderInfo(pInfo)^.TextureNames;
          TextureName := TextureNames[0, 0];
          D3DSurface :=
            TD3DCylinder.Create(DXDraw, AddTexturesToCollection(TextureNames^),
              PD3DCylinderInfo(pInfo)^);
        end;
{$ENDIF}        
      ID3D_Scene:
        begin
          TextureName := PD3DSceneInfo(pInfo)^.PathToScene;
          D3DSurface := TD3DScene.CreateAttached(PD3DSceneInfo(pInfo)^, self);
        end;
{$IFNDEF NO_D3DPLUGINS}
      ID3D_PlugIn:
        begin
          TextureName := PD3DPlugInInfo(pInfo)^.TextureName;
          Surfaces.Objects[index].Free; // ֵיהיך נוסנפשףח, unload to dll
          D3DSurface :=
            TD3DPlugIn.Create(self, AddTextureToCollection(TextureName),
              PD3DPlugInInfo(pInfo)^);
          (D3DSurface as TD3DPlugIn).AcceptPosition(fPosition);
          (D3DSurface as TD3DPlugIn).AcceptRotation(fRotation);
        end;
{$ENDIF}        
{$IFNDEF NO_D3DRINGS}
      ID3D_Ring:
        begin
        // סבפלו פן נס‏פן Texture דיב וםחלסשףח פןץ Surfaces.Strings[index]!
          TextureNames := @PD3DRingInfo(pInfo)^.TextureNames;
          TextureName := TextureNames[0, 0];
          D3DSurface :=
            TD3DRing.Create(DXDraw, AddTexturesToCollection(TextureNames^),
              PD3DRingInfo(pInfo)^);
        end;
{$ENDIF}        
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
      ID3D_SectorCollection:
        begin
          D3DSurface :=
            TD3DSectorCollection.Create(PD3DSectorCollectionInfo2(pInfo)^, self);
          TextureName := D3DSurface.TextureName;
        (D3DSurface as TD3DSectorCollection).AcceptPosition(fOldPosition, fPosition);
        (D3DSurface as TD3DSectorCollection).AcceptRotation(fRotation);
        end;
{$ENDIF}
{$IFNDEF NO_D3DTEXTS}
      ID3D_Text:
        begin
        // סבפלו פן נס‏פן Texture דיב וםחלסשףח פןץ Surfaces.Strings[index]!
          TextureNames := @PD3DTextInfo(pInfo)^.TextureNames;
          TextureName := TextureNames[0, 0];
          D3DSurface :=
            TD3DText.Create(DXDraw, AddTexturesToCollection(TextureNames^),
              PD3DTextInfo(pInfo)^);
        end;
{$ENDIF}
    else
      begin
        Result := nil;
        Exit;
      end;
    end;
    fModified := True;
    Surfaces.Strings[index] := TextureName;
{$IFNDEF NO_D3DPLUGINS}
    if SurfaceType <> ID3D_PlugIn then
{$ENDIF}
      Surfaces.Objects[index].Free;

    Surfaces.Objects[index] := D3DSurface;
    Result := D3DSurface;
    CreateCache;
    Recalc;
{$IFNDEF NO_D3DBILLBOARDS}
    if SurfaceType = ID3D_BillBoard then
      OptimizeBillBoards;
{$ENDIF}
{$IFNDEF NO_GLOBALID}
    AdjustGlobalID;
{$ENDIF}
    fNeedsRadiusAndCenterRecalc := True;
  end
  else
    Result := nil;
end;

// ׀סןףטפוי לב נחד צשפויףלן‎
procedure TD3DScene.AddLight(pInfo: PD3DLightInfo);
var
  l: TD3DSceneLight;
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  l := TD3DSceneLight.Create(pInfo^);
  Lights.AddObject('', l);
  ApplyLight(l);
  fNeedsRecalc := fNeedsRecalc or fNeedsLightRecalc; // ּופ פחם נסןףטךח נסנוי םב דםוי ונבםבץנןכןדיףלע
  fModified := True;
{$IFNDEF NO_GLOBALID}
  AdjustGlobalID;
{$ENDIF}
end;

// ִיבדסצוי לב נחד צשפויףלן‎
procedure TD3DScene.DeleteLight(index: integer);
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  if (index >= 0) and (index < Lights.Count) then   // ¸כודקןע ףפב סיב פחע כףפבע
  begin
    Lights.Objects[index].Free;   // ִיבדסבצ פחע נחדע צשפויףלן‎
    Lights.Delete(index);
    fNeedsRecalc := fNeedsRecalc or fNeedsLightRecalc; // ֵנבםבץנןכןדיףלע
    fModified := True;
  end;
end;

// ֱםפיךבפףפבףח נחדע צשפויףלן‎
procedure TD3DScene.ReplaceLight(index: integer; pInfo: PD3DLightInfo);
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  if (Lights.Count > 0) and (index < Lights.Count) then // ¸כודקןע ףפב סיב פחע כףפבע
  begin
    Lights.Objects[index].Free;
    Lights.Objects[index] := TD3DSceneLight.Create(pInfo^);
    fNeedsRecalc := fNeedsRecalc or fNeedsLightRecalc; // ֵנבםבץנןכןדיףלע
    fModified := True;
{$IFNDEF NO_GLOBALID}
    AdjustGlobalID;
{$ENDIF}
  end;
end;

{$IFNDEF NO_D3DSOUNDS}
procedure TD3DScene.ReplaceSound(index: integer; pInfo: PD3DSoundInfo);
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  if (index >= 0) and (index < Sounds.Count) then
  begin
    Sounds.Strings[index] := pInfo^.SoundName;
    Sounds.Objects[index].Free;
    Sounds.Objects[index] := TD3DSound.Create(DXSound, AddWaveToCollection(pInfo^.SoundName), pInfo^, fMute);
    (Sounds.Objects[index] as TD3DBaseAudio).Position := fPosition;
    (Sounds.Objects[index] as TD3DBaseAudio).Rotation := Rotation;
    fModified := True;
{$IFNDEF NO_GLOBALID}
    AdjustGlobalID;
{$ENDIF}
  end;
end;

procedure TD3DScene.ReplaceTone(index: integer; pInfo: PD3DToneInfo);
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  if (index >= 0) and (index < Sounds.Count) then
  begin
    Sounds.Strings[index] := rsTone;
    Sounds.Objects[index].Free;
    Sounds.Objects[index] := TD3DTone.Create(pInfo^, fMute);
    (Sounds.Objects[index] as TD3DBaseAudio).Position := fPosition;
    (Sounds.Objects[index] as TD3DBaseAudio).Rotation := Rotation;
    fModified := True;
{$IFNDEF NO_GLOBALID}
    AdjustGlobalID;
{$ENDIF}
  end;
end;

function TD3DScene.AddSound(pInfo: PD3DSoundInfo): TD3DSound;
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  Result := TD3DSound.Create(DXSound,
    AddWaveToCollection(pInfo^.SoundName), pInfo^, fMute);
  Sounds.Objects[Sounds.Add(pInfo^.SoundName)] := Result;
  Result.Position := Position;
  Result.Rotation := Rotation;
  fModified := True;
{$IFNDEF NO_GLOBALID}
  AdjustGlobalID;
{$ENDIF}
end;

function TD3DScene.AddTone(pInfo: PD3DToneInfo): TD3DTone;
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  Result := TD3DTone.Create(pInfo^, fMute);
  Sounds.Objects[Sounds.Add(rsTone)] := Result;
  Result.Position := Position;
  Result.Rotation := Rotation;
  fModified := True;
{$IFNDEF NO_GLOBALID}
  AdjustGlobalID;
{$ENDIF}
end;

procedure TD3DScene.DeleteSound(index: integer);
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  if (index >= 0) and (index < Sounds.Count) then
  begin
    Sounds.Objects[index].Free;
    Sounds.Delete(index);
    fModified := True;
  end;
end;
{$ENDIF}

procedure TD3DScene.AddAction(pInfo: PD3DActionInfo);
var
  D3DAction: TD3DAction;
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  D3DAction := TD3DAction.Create(pInfo^, self);
  Actions.AddObject('', D3DAction);
  fModified := fModified or not D3DAction.RunTimeOnly;
{$IFNDEF NO_GLOBALID}
  AdjustGlobalID;
{$ENDIF}
end;

procedure TD3DScene.DeleteAction(index: integer);
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  if (index >= 0) and (index < Actions.Count) then
  begin
    fModified := fModified or not (Actions.Objects[index] as TD3DAction).RunTimeOnly;
    Actions.Objects[index].Free;
    Actions.Delete(index);
  end;
end;

procedure TD3DScene.DeleteActionByKey(key: integer);
var
  i: integer;
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  for i := Actions.Count - 1 downto 0 do
    if (Actions.Objects[i] as TD3DAction).GetKeyID = key then
      DeleteAction(i);
end;

procedure TD3DScene.ReplaceAction(index: integer; pInfo: PD3DActionInfo);
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  if (index >= 0) and (index < Actions.Count) then
  begin
    fModified := fModified or not (Actions.Objects[index] as TD3DAction).RunTimeOnly;
    Actions.Objects[index].Free;
    Actions.Objects[index] := TD3DAction.Create(pInfo^, self);
    fModified := fModified or not (Actions.Objects[index] as TD3DAction).RunTimeOnly;
{$IFNDEF NO_GLOBALID}
    AdjustGlobalID;
{$ENDIF}
  end;
end;

procedure TD3DScene.DeleteNonSaveAbleObjects;
var
  i: integer;
{$IFDEF DESIGNER}
  oldCanSaveUndo: boolean;
{$ENDIF}
begin
{$IFDEF DESIGNER}
  SaveUndo;
  oldCanSaveUndo := CanSaveUndo;
  CanSaveUndo := False;
{$ENDIF}
  for i := Surfaces.Count - 1 downto 0 do
    if not (Surfaces.Objects[i] as TD3DObject).Saveable then
      DeleteSurface(i);
{$IFDEF DESIGNER}
  CanSaveUndo := oldCanSaveUndo;
{$ENDIF}
end;

// Clean up runtime actions that may be left from code
procedure TD3DScene.DeleteRunTimeActions;
var
  i: Integer;
{$IFDEF DESIGNER}
  oldCanSaveUndo: boolean;
{$ENDIF}
begin
{$IFDEF DESIGNER}
  SaveUndo;
  oldCanSaveUndo := CanSaveUndo;
  CanSaveUndo := False;
{$ENDIF}
  for i := Actions.Count - 1 downto 0 do
    if (Actions.Objects[i] as TD3DAction).RunTimeOnly then
      DeleteAction(i);
{$IFDEF DESIGNER}
  CanSaveUndo := oldCanSaveUndo;
{$ENDIF}
end;

procedure TD3DScene.AddCustomData(pInfo: PCustomDataInfo);
var
  Custom: TCustomData;
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  Custom := TCustomData.Create(pInfo^, AddStreamToCollection(pInfo.PathToStream));
  CustomData.Objects[CustomData.Add(pInfo.PathToStream)] := Custom;
  fModified := True;
{$IFNDEF NO_GLOBALID}
  AdjustGlobalID;
{$ENDIF}
end;

procedure TD3DScene.DeleteCustomData(index: integer);
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  if (index >= 0) and (index < CustomData.Count) then
  begin
    CustomData.Objects[index].Free;
    CustomData.Delete(index);
    fModified := True;
  end;
end;

function IsEqualCustomDataInfo(const i1, i2: TCustomDataInfo): boolean;
begin
  Result := (i1.PathToStream = i2.PathToStream) and (i1.Key = i2.Key);
end;

procedure TD3DScene.ReplaceCustomData(index: integer; pInfo: PCustomDataInfo);
var
  oldInfo: TCustomDataInfo;
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  if (index >= 0) and (index < CustomData.Count) then
  begin
    oldInfo := (CustomData.Objects[index] as TCustomData).Info;
    CustomData.Strings[index] := pInfo.PathToStream;
    CustomData.Objects[index].Free;
    CustomData.Objects[index] := TCustomData.Create(pInfo^, AddStreamToCollection(pInfo.PathToStream));
    fModified := fModified or not IsEqualCustomDataInfo(oldInfo, TCustomDataInfo(pInfo^));
{$IFNDEF NO_GLOBALID}
    AdjustGlobalID;
{$ENDIF}
  end;
end;

{$IFNDEF NO_SCRIPTS}
procedure TD3DScene.AddScript(pInfo: PD3DScriptInfo);
var
  S: TScript;
  strm: TStream;
begin
  strm := AddStreamToCollection(pInfo.PathToStream);
  if Scripts.IndexOf(pInfo.PathToStream) = -1 then
  begin
  {$IFDEF DESIGNER}
    SaveUndo;
  {$ENDIF}
    StopScriptEngine;
    S := TScript.Create(pInfo^, strm);
    Streams.Delete(Streams.Count - 1); // ????????????????
    Scripts.Objects[Scripts.Add(pInfo.PathToStream)] := S;
    fModified := True;
{$IFNDEF NO_GLOBALID}
    AdjustGlobalID;
{$ENDIF}
    StartScriptEngine;
  end;
end;

procedure TD3DScene.DeleteScript(index: integer);
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  if (index >= 0) and (index < Scripts.Count) then
  begin
    StopScriptEngine;
    Scripts.Objects[index].Free;
    Scripts.Delete(index);
    fModified := True;
    StartScriptEngine;
  end;
end;

function IsEqualD3DScriptInfo(const i1, i2: TD3DScriptInfo): boolean;
begin
  Result := (i1.PathToStream = i2.PathToStream) and
            (i1.AttachedEvent = i2.AttachedEvent) and
            (i1.Key = i2.Key);
end;

procedure TD3DScene.ReplaceScript(index: integer; pInfo: PD3DScriptInfo);
var
  strm: TStream;
  oldInfo: TD3DScriptInfo;
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  if (index >= 0) and (index < Scripts.Count) then
  begin
    StopScriptEngine;
    oldInfo := (Scripts.Objects[index] as TScript).Info;
    Scripts.Strings[index] := pInfo.PathToStream;
    Scripts.Objects[index].Free;
    strm := AddStreamToCollection(pInfo.PathToStream);
    Scripts.Objects[index] := TScript.Create(pInfo^, strm);
    Streams.Delete(Streams.Count - 1);
    fModified := fModified or not IsEqualD3DScriptInfo(oldInfo, TD3DScriptInfo(pInfo^));
{$IFNDEF NO_GLOBALID}
    AdjustGlobalID;
{$ENDIF}
    StartScriptEngine;
  end;
end;
{$ENDIF}

procedure TD3DScene.InitialMove(vM: TD3DVector);
var
  i: integer;
begin
  for i := 0 to Surfaces.Count - 1 do
    (Surfaces.Objects[i] as TD3DObject).Move(vM);
{$IFNDEF NO_D3DSOUNDS}
  for i := 0 to Sounds.Count - 1 do
    (Sounds.Objects[i] as TD3DBaseAudio).Move(vM);
{$ENDIF}
  fNeedsRecalc := fNeedsRecalc or fNeedsPositionRecalc or fNeedsLightRecalc;
end;

procedure TD3DScene.InitialMove(x, y, z: TD3DValue);
var
  i: integer;
begin
  for i := 0 to Surfaces.Count - 1 do
    (Surfaces.Objects[i] as TD3DObject).Move(x, y, z);
{$IFNDEF NO_D3DSOUNDS}
  for i := 0 to Sounds.Count - 1 do
    (Sounds.Objects[i] as TD3DBaseAudio).Move(x, y, z);
{$ENDIF}
  fNeedsRecalc := fNeedsRecalc or fNeedsPositionRecalc or fNeedsLightRecalc;
end;

procedure TD3DScene.InitialRotate(vM: TD3DVector);
var
  i: integer;
begin
  for i := 0 to Surfaces.Count - 1 do
    (Surfaces.Objects[i] as TD3DObject).Rotate(vM);
{$IFNDEF NO_D3DSOUNDS}
  for i := 0 to Sounds.Count - 1 do
    (Sounds.Objects[i] as TD3DBaseAudio).Rotate(vM);
{$ENDIF}
  fNeedsRecalc := fNeedsRecalc or fNeedsRotationRecalc;
end;

procedure TD3DScene.InitialRotate(x, y, z: TD3DValue);
var
  i: integer;
begin
  for i := 0 to Surfaces.Count - 1 do
    (Surfaces.Objects[i] as TD3DObject).Rotate(x, y, z);
{$IFNDEF NO_D3DSOUNDS}
  for i := 0 to Sounds.Count - 1 do
    (Sounds.Objects[i] as TD3DBaseAudio).Rotate(x, y, z);
{$ENDIF}
  fNeedsRecalc := fNeedsRecalc or fNeedsRotationRecalc;
end;

procedure TD3DScene.Move(vM: TD3DVector);
begin
  InitialMove(vM);
  if fAttached then
  begin
    Info.x := Info.x + vM.x;
    Info.y := Info.y + vM.y;
    Info.z := Info.z + vM.z;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DScene.Rotate(vM: TD3DVector);
begin
  InitialRotate(vM);
  if fAttached then
  begin
    Info.dx := Info.dx + vM.x;
    Info.dy := Info.dy + vM.y;
    Info.dz := Info.dz + vM.z;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

// ID: װ‎נןע בםפיךוילםןץ
// Key: שהיךע
procedure TD3DScene.MoveObjects(ID, key: integer; x, y, z: TD3DValue);
var
  i: integer;
  obj: TObject;
begin
  if ID = ID3D_ALL then
  begin
    for i := 0 to Surfaces.Count - 1 do
    begin
      obj := Surfaces.Objects[i];
      if (obj as TD3DObject).GetKeyID = key then
        (obj as TD3DObject).Move(x, y, z);
    end;
{$IFNDEF NO_D3DSOUNDS}
    for i := 0 to Sounds.Count - 1 do
    begin
      obj := Sounds.Objects[i];
      if (obj as TD3DBaseAudio).GetKeyID = key then
        (obj as TD3DBaseAudio).Move(x, y, z);
    end;
{$ENDIF}
  end
  else if ID < ID3D_MAXSURFACE then
  begin
    for i := 0 to Surfaces.Count - 1 do
    begin
      obj := Surfaces.Objects[i];
      if (obj as TD3DObject).GetTypeID = ID then
        if (obj as TD3DObject).GetKeyID = key then
        begin
          (obj as TD3DObject).Move(x, y, z);
          (obj as TD3DObject).ApplyLights(Lights);
        end;
    end;
  end
  else
{$IFNDEF NO_D3DSOUNDS}
    for i := 0 to Sounds.Count - 1 do
    begin
      obj := Sounds.Objects[i];
      if (obj as TD3DBaseAudio).GetTypeID = ID then
        if (obj as TD3DBaseAudio).GetKeyID = key then
          (obj as TD3DBaseAudio).Move(x, y, z);
    end;
{$ELSE}
  begin
  end;
{$ENDIF}
  fNeedsRecalc := fNeedsRecalc or fNeedsPositionRecalc;
  fNeedsRadiusAndCenterRecalc := True;
end;

// ID: װ‎נןע בםפיךוילםןץ
// Key: שהיךע
procedure TD3DScene.MoveObjectsTo(ID, key: integer; x, y, z: TD3DValue);
var
  i: integer;
  obj: TObject;
begin
  if ID = ID3D_ALL then
  begin
    for i := 0 to Surfaces.Count - 1 do
    begin
      obj := Surfaces.Objects[i];
      if (obj as TD3DObject).GetKeyID = key then
        (obj as TD3DObject).MoveTo(x, y, z);
    end;
{$IFNDEF NO_D3DSOUNDS}
    for i := 0 to Sounds.Count - 1 do
    begin
      obj := Sounds.Objects[i];
      if (obj as TD3DBaseAudio).GetKeyID = key then
        (obj as TD3DBaseAudio).MoveTo(x, y, z);
    end;
{$ENDIF}
  end
  else if ID < ID3D_MAXSURFACE then
  begin
    for i := 0 to Surfaces.Count - 1 do
    begin
      obj := Surfaces.Objects[i];
      if (obj as TD3DObject).GetTypeID = ID then
        if (obj as TD3DObject).GetKeyID = key then
        begin
          (obj as TD3DObject).MoveTo(x, y, z);
          (obj as TD3DObject).ApplyLights(Lights);
        end;
    end;
  end
  else
{$IFNDEF NO_D3DSOUNDS}
    for i := 0 to Sounds.Count - 1 do
    begin
      obj := Sounds.Objects[i];
      if (obj as TD3DBaseAudio).GetTypeID = ID then
        if (obj as TD3DBaseAudio).GetKeyID = key then
          (obj as TD3DBaseAudio).MoveTo(x, y, z);
    end;
{$ELSE}
  begin
  end;
{$ENDIF}
  fNeedsRecalc := fNeedsRecalc or fNeedsPositionRecalc;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DScene.MoveSurface(index: integer; x, y, z: TD3DValue); // ּופבךםחףח בםפיךוילםןץ
var
  obj: TObject;
begin
  if (index >= 0) and (index < Surfaces.Count) then
  begin
    obj := Surfaces.Objects[index];
    (obj as TD3DObject).Move(x, y, z);
    (obj as TD3DObject).ApplyLights(Lights);
    fNeedsRecalc := fNeedsRecalc or fNeedsPositionRecalc;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

// ׀וסיףפסצוי פב בםפיךולוםב ד‎סש בנ פןם ובץפ פןץע ( ֿי קןי הום נוסיףפסצןםפבי!)
procedure TD3DScene.RotateObjects(ID, key: integer; dx, dy, dz: TD3DValue);
var
  i: integer;
  Cache: TDXStringList;
  v: TD3DVector;
  vP, vR: TD3DVector;
  obj: TObject;
begin
  Cache := TDXStringList.Create;
  try
    if ID = ID3D_ALL then
    begin
      for i := 0 to Surfaces.Count - 1 do
      begin
        obj := Surfaces.Objects[i];
        if (obj as TD3DObject).GetKeyID = key then
          Cache.AddObject('', obj);
      end;
    end
    else
    begin
      for i := 0 to Surfaces.Count - 1 do
      begin
        obj := Surfaces.Objects[i];
        if (obj as TD3DObject).GetTypeID = ID then
          if (obj as TD3DObject).GetKeyID = key then
            Cache.AddObject('', obj );
      end;
    end;
    if Cache.Count > 0 then
    begin
      vP := VectorSub(Position, GetParentPositionVector);
      vR := VectorSub(Rotation, GetParentRotationVector);
      for i := 0 to Cache.Count - 1 do
      begin
        obj := Cache.Objects[i];
        v := (obj as TD3DObject).GetLocatePosition(0.0);
        (obj as TD3DObject).Move(NegativeVector(v));
        (obj as TD3DObject).Rotate(dx, dy, dz);
        (obj as TD3DObject).Move(v);
{$IFNDEF NO_D3DSTUBOBJECTS}
        if (obj as TD3DObject).GetTypeID = ID3D_StubObject then
          (obj as TD3DStubObject).PerspectiveRotate(vP, vR)
{$ELSE}
        if (obj as TD3DObject).GetTypeID = 3 then
        begin
        end
{$ENDIF}
{$IFNDEF NO_D3DEXOBJECTS}
        else if (obj as TD3DObject).GetTypeID = ID3D_ExObject then
          (obj as TD3DExObject).SimpleRotate(vP, vR.y)
//          (Cache.Objects[i] as TD3DExObject).SimpleRotate(fPosition)
{$ENDIF}
{$IFNDEF NO_D3DBILLBOARDS}
        else if (obj as TD3DObject).GetTypeID = ID3D_BillBoard then
          (obj as TD3DBillBoard).SimpleRotate(vR.y)
{$ENDIF}
        else if (obj as TD3DObject).GetTypeID = ID3D_Scene then
          (obj as TD3DScene).RotateObjects;
        (obj as TD3DObject).ApplyLights(Lights);
      end;
//      fNeedsRecalc := fNeedsRecalc or fNeedsRotationRecalc;
    end;
  finally
    Cache.Free;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DScene.RotateSurface(index: integer; dx, dy, dz: TD3DValue); // ׀וסיףפסןצ בםפיךוילםןץ ד‎סש בנ פןם מןם פןץע
var
  v, vP, vR: TD3DVector;
  obj: TObject;
begin
  if (index >= 0) and (index < Surfaces.Count) then
  begin
    vP := VectorSub(Position, GetParentPositionVector);
    vR := VectorSub(Rotation, GetParentRotationVector);
    obj := Surfaces.Objects[index];
    v := (obj as TD3DObject).GetLocatePosition(0.0);
    (obj as TD3DObject).Move(NegativeVector(v));
    (obj as TD3DObject).Rotate(dx, dy, dz);
    (obj as TD3DObject).Move(v);
{$IFNDEF NO_D3DSTUBOBJECTS}
    if (obj as TD3DObject).GetTypeID = ID3D_StubObject then
     (obj as TD3DStubObject).PerspectiveRotate(vP, vR)
{$ELSE}
    if (obj as TD3DObject).GetTypeID = 3 then
    begin
    end
{$ENDIF}
{$IFNDEF NO_D3DEXOBJECTS}
    else if (obj as TD3DObject).GetTypeID = ID3D_ExObject then
     (obj as TD3DExObject).SimpleRotate(vP, vR.y)
//     (Surfaces.Objects[index] as TD3DExObject).SimpleRotate(fPosition)
{$ENDIF}
{$IFNDEF NO_D3DBILLBOARDS}
    else if (obj as TD3DObject).GetTypeID = ID3D_BillBoard then
     (obj as TD3DBillBoard).SimpleRotate(vR.y)
{$ENDIF}
    else if (obj as TD3DObject).GetTypeID = ID3D_Scene then
     (obj as TD3DScene).RotateObjects;
    (obj as TD3DObject).ApplyLights(Lights);
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DScene.RotateSurfaceAround(index: integer; x, y, z: TD3DValue; dx, dy, dz: TD3DValue); // ׀וסיףפסןצ בםפיךוילםןץ ד‎סש בנ ףחלון
var
  v, vP, vR: TD3DVector;
  obj: TObject;
begin
  if (index >= 0) and (index < Surfaces.Count) then
  begin
    vP := VectorSub(Position, GetParentPositionVector);
    vR := VectorSub(Rotation, GetParentRotationVector);
    v := MakeD3DVector(x, y, z);
    obj := Surfaces.Objects[index];
    (obj as TD3DObject).Move(NegativeVector(v));
    (obj as TD3DObject).Rotate(dx, dy, dz);
    (obj as TD3DObject).Move(v);
{$IFNDEF NO_D3DSTUBOBJECTS}
    if (obj as TD3DObject).GetTypeID = ID3D_StubObject then
     (obj as TD3DStubObject).PerspectiveRotate(vP, vR)
{$ELSE}
    if (obj as TD3DObject).GetTypeID = 3 then
    begin
    end
{$ENDIF}
{$IFNDEF NO_D3DEXOBJECTS}
    else if (obj as TD3DObject).GetTypeID = ID3D_ExObject then
     (obj as TD3DExObject).SimpleRotate(vP, vR.y)
//     (Surfaces.Objects[index] as TD3DExObject).SimpleRotate(fPosition)
{$ENDIF}
{$IFNDEF NO_D3DBILLBOARDS}
    else if (obj as TD3DObject).GetTypeID = ID3D_BillBoard then
     (obj as TD3DBillBoard).SimpleRotate(vR.y)
{$ENDIF}
    else if (obj as TD3DObject).GetTypeID = ID3D_Scene then
     (obj as TD3DScene).RotateObjects;
    (obj as TD3DObject).ApplyLights(Lights);
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DScene.RotateObjectsAround(ID, key: integer; x, y, z: TD3DValue; dx, dy, dz: TD3DValue);
var
  i: integer;
  Cache: TDXStringList;
  v: TD3DVector;
  vP, vR: TD3DVector;
  obj: TObject;
begin
  Cache := TDXStringList.Create;
  try
    if ID = ID3D_ALL then
    begin
      for i := 0 to Surfaces.Count - 1 do
      begin
        obj := Surfaces.Objects[i];
        if (obj as TD3DObject).GetKeyID = key then
          Cache.AddObject('', obj);
      end
    end
    else
    begin
      for i := 0 to Surfaces.Count - 1 do
      begin
        obj := Surfaces.Objects[i];
        if (obj as TD3DObject).GetTypeID = ID then
          if (obj as TD3DObject).GetKeyID = key then
            Cache.AddObject('', obj);
      end;
    end;
    if Cache.Count > 0 then
    begin
      vP := VectorSub(Position, GetParentPositionVector);
      vR := VectorSub(Rotation, GetParentRotationVector);
      for i := 0 to Cache.Count - 1 do
      begin
//      v := (Cache.Objects[i] as TD3DObject).GetLocatePosition(0.0);
        v := MakeD3DVector(x, y, z);
        obj := Cache.Objects[i];
        (obj as TD3DObject).Move(NegativeVector(v));
        (obj as TD3DObject).Rotate(dx, dy, dz);
        (obj as TD3DObject).Move(v);
{$IFNDEF NO_D3DSTUBOBJECTS}
        if (obj as TD3DObject).GetTypeID = ID3D_StubObject then
          (obj as TD3DStubObject).PerspectiveRotate(vP, vR)
{$ELSE}
        if (obj as TD3DObject).GetTypeID = 3 then
        begin
        end
{$ENDIF}
{$IFNDEF NO_D3DEXOBJECTS}
        else if (obj as TD3DObject).GetTypeID = ID3D_ExObject then
          (obj as TD3DExObject).SimpleRotate(vP, vR.y)
//          (Cache.Objects[i] as TD3DExObject).SimpleRotate(fPosition)
{$ENDIF}
{$IFNDEF NO_D3DBILLBOARDS}
        else if (obj as TD3DObject).GetTypeID = ID3D_BillBoard then
          (obj as TD3DBillBoard).SimpleRotate(vR.y)
{$ENDIF}
        else if (obj as TD3DObject).GetTypeID = ID3D_Scene then
          (obj as TD3DScene).RotateObjects;
        (obj as TD3DObject).ApplyLights(Lights);
      end;
//      fNeedsRecalc := fNeedsRecalc or fNeedsRotationRecalc;
    end;
  finally
    Cache.Free;
  end;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DScene.SetCulled(Value: boolean);
var
  i: integer;
begin
  if Value <> fCulled then
  begin
    fCulled := Value;
    for i := 0 to Surfaces.Count - 1 do
      (Surfaces.Objects[i] as TD3DObject).Culled := Value;
  end;
end;

procedure TD3DScene.FastClear;
// ִום בנוכוץטוס‏םוי פב textures, דיב פחם FastLoadFromStream (Undo, Redo operations)
begin
  doClearStringList(Surfaces);
{$IFNDEF NO_D3DSOUNDS}
  doClearStringList(Sounds);
{$ENDIF}
  doClearStringList(CustomData);
{$IFNDEF NO_SCRIPTS}
  doClearStringList(Scripts);
{$ENDIF}
  doClearStringList(Actions);
  doClearStringList(Lights);
  ClearCache;
  fNeedsRadiusAndCenterRecalc := True;
end;

procedure TD3DScene.ClearCache;
begin
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
  _CacheSectorCollections.Clear;
{$ENDIF}
{$IFNDEF NO_D3DBILLBOARDS}
  _CacheBillBoards.Clear;
{$ENDIF}
  _CacheNestedScenes.Clear;
{$IFNDEF NO_D3DPLUGINS}
  _CachePlugIns.Clear;
{$ENDIF}
  _CacheRotatingObjects.Clear;
end;

function TD3DScene.AddToCache(const s: string; item: TObject): boolean;
begin
  Result := True;
  if (item as TD3DObject).GetTypeID = ID3D_Scene then
    _CacheNestedScenes.AddObject(s, item)
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
  else if (item as TD3DObject).GetTypeID = ID3D_SectorCollection then
    _CacheSectorCollections.AddObject(s, item)
{$ENDIF}
{$IFNDEF NO_D3DPLUGINS}
  else if (item as TD3DObject).GetTypeID = ID3D_PlugIn then
    _CachePlugIns.AddObject(s, item)
{$ENDIF}
{$IFNDEF NO_D3DSTUBOBJECTS}
  else if (item as TD3DObject).GetTypeID = ID3D_StubObject then
    _CacheRotatingObjects.AddObject(s, item)
{$ENDIF}
{$IFNDEF NO_D3DEXOBJECTS}
  else if (item as TD3DObject).GetTypeID = ID3D_ExObject then
    _CacheRotatingObjects.AddObject(s, item)
{$ENDIF}
{$IFNDEF NO_D3DBILLBOARDS}
  else if (item as TD3DObject).GetTypeID = ID3D_BillBoard then
    _CacheBillBoards.AddObject(s, item)
{$ENDIF}
  else
    Result := False;
end;

procedure TD3DScene.CreateCache;
var
  i: integer;
begin
  ClearCache;
  for i := 0 to Surfaces.Count - 1 do
    AddToCache(Surfaces.Strings[i], Surfaces.Objects[i]);
end;

procedure TD3DScene.Clear;
begin
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
  _CurrentSectorIndex := -1;
{$ENDIF}
  FastClear;
  if fParent = nil then
  begin
    doClearStringList(Textures);
{$IFNDEF NO_D3DSOUNDS}
    doClearStringList(Waves);
{$ENDIF}
    doClearStringList(Streams);
{$IFNDEF NO_D3DACTORS}
    doClearStringList(Models);
{$ENDIF}
  end;
end;

procedure TD3DScene.New;
{$IFDEF DESIGNER}
var
  flag: boolean;
{$ENDIF}
begin
{$IFDEF DESIGNER}
  ClearUndoRedo;
  flag := CanSaveUndo;
  CanSaveUndo := False;
{$ENDIF}
{$IFNDEF NO_SCRIPTS}
  StopScriptEngine;
{$ENDIF}
  fLastMergeIndex := -1;
  fFileName := '';
  GlobalID := 0;
  Clear;
  fModified := False;
{$IFNDEF NO_SCRIPTS}
  StartScriptEngine;
{$ENDIF}
{$IFDEF DESIGNER}
  CanSaveUndo := flag;
{$ENDIF}
end;

procedure TD3DScene.DeleteSurface(index: integer);
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  if (index >= 0) and (index < Surfaces.Count) then
  begin
    Surfaces.Objects[index].Free;
    Surfaces.Delete(index);
    fModified := True;
    fNeedsRadiusAndCenterRecalc := True;
    CreateCache;
  end;
end;

procedure TD3DScene.TessalatePolygon(index: integer;
  doDeleteSource: boolean = True; doRecalculate: boolean = True);
var
  p: PD3DTessalationInfo;
  i: integer;
  obj: TObject;
  {$IFDEF DESIGNER}
  oldCanSaveUndo: boolean;
  {$ENDIF}
begin
  obj := Surfaces.Objects[index];
  if obj is TD3DPolygon then
  begin
    if (obj as TD3DPolygon).Info2.PrimitiveType = D3DPT_TRIANGLEFAN then
    begin
    {$IFDEF DESIGNER}
      SaveUndo;
      oldCanSaveUndo := CanSaveUndo;
      CanSaveUndo := False;
    {$ENDIF}

      system.new(p);
      try
        if doDeleteSource then
          (obj as TD3DPolygon).Flags := (obj as TD3DPolygon).Flags and flag_GoingToDelete;
        p.NumVertexes := (obj as TD3DPolygon).Info2.NumVertexes;
        p.TextureName := (obj as TD3DPolygon).Info2.TextureNames[0, 0];
        p.Cull := (obj as TD3DPolygon).Info2.Cull;
        p.PrimitiveType := D3DPT_TRIANGLEFAN;
        for i := 0 to (obj as TD3DPolygon).Info2.NumVertexes - 1 do
          p.Vertexes[i] := (obj as TD3DPolygon).TheVertexes[i];
        if doDeleteSource then
          DeleteSurface(index);
        MergeTessalation(p);
      finally
        dispose(p);
      end;

      if doRecalculate then
        fNeedsRecalc := fNeedsRecalc or fNeedsPositionRecalc; // ִום קסויזופבי lightrecalc
      fModified := True;
    {$IFDEF DESIGNER}
      CanSaveUndo := oldCanSaveUndo;
    {$ENDIF}
    end;
  end;
end;

procedure TD3DScene.SplitPolygon(index: integer;
      doDeleteSource: boolean = True; doRecalculate: boolean = True);
var
  Count,i: integer;
  A: PD3DPolygonInfoArray;
  obj: TObject;
  {$IFDEF DESIGNER}
  oldCanSaveUndo: boolean;
  {$ENDIF}
begin
  obj := Surfaces.Objects[index];
  if obj is TD3DPolygon then
  begin
  {$IFDEF DESIGNER}
    SaveUndo;
    oldCanSaveUndo := CanSaveUndo;
    CanSaveUndo := False;
  {$ENDIF}
    System.new(A);
    try
      if doDeleteSource then
        (obj as TD3DPolygon).Flags := (obj as TD3DPolygon).Flags and flag_GoingToDelete;
      (obj as TD3DPolygon).GetSplitData(A, Count);
      for i := 0 to Count - 1 do
      begin
        AddSurface(ID3D_Polygon, A[i]);
        dispose(A[i]);
      end;
    finally
      dispose(A);
    end;

    if doDeleteSource then
      DeleteSurface(index);
    if doRecalculate then
      fNeedsRecalc := fNeedsRecalc or fNeedsPositionRecalc; // ִום קסויזופבי lightrecalc
    fModified := True;
  {$IFDEF DESIGNER}
    CanSaveUndo := oldCanSaveUndo;
  {$ENDIF}
  end;
end;

procedure TD3DScene.ReduceMemory;
var
  i: integer;
begin
  for i := 0 to Surfaces.Count - 1 do
    (Surfaces.Objects[i] as TD3DObject).ReduceMemory;
end;

procedure TD3DScene.SplitAllPolygons;
var
  i, Count: integer;
  S: TStack;
{$IFDEF DESIGNER}
  oldCanSaveUndo: boolean;
{$ENDIF}
begin
{$IFDEF DESIGNER}
  SaveUndo;
  oldCanSaveUndo := CanSaveUndo;
  CanSaveUndo := False;
{$ENDIF}
  count := Surfaces.Count;
// ֿ כודקןע דיב פן ם וםבי נןכ‎דשםן ח וניצםויב
// דםופבי ףפחם SplitPolygon, ןנפו הום קסויזופבי םב
// ךםש וה‏ פןם כודקן
  for i := 0 to Count - 1 do
    SplitPolygon(i, False, False);
  S := TStack.Create;
  try
// װ‏סב ףבס‏םןץלו דיב הו‎פוסח צןס פחם כףפב לו פיע וניצםויוע,
// בככ לקסי פן ףחלון Count, הום טב ףבס‏ףןץלו החכבהו פב םב
// נןכ‎דשםב נןץ החליןץסדטחךבם. סבפלו פב indexes ףפח ףפןגב S.
// ּופ בהובזןץלו פחם ףפןגב (בםפףפסןצח צןס = הום קםןץלו
// פן order פשם indexes
    for i := 0 to Count - 1 do
      if Surfaces.Objects[i] is TD3DPolygon then
        S.Push(i);
    while not S.Empty do DeleteSurface(S.Pop);
  finally
    S.Free;
  end;
  fNeedsRecalc := fNeedsRecalc or fNeedsPositionRecalc; // ִום קסויזופבי lightrecalc
{$IFDEF DESIGNER}
  CanSaveUndo := oldCanSaveUndo;
{$ENDIF}
end;

procedure TD3DScene.LoadFromResource(const resName: string);
var
  rs: TResourceStream;
begin
  InvokeResource := True;
  try
    if IsValidInteger(GetExistedResourceEntry(resName)) then
      rs := TResourceStream.CreateFromID(HInstance, StrToInt(GetExistedResourceEntry(resName)), PChar(rsD3D))
    else
      rs := TResourceStream.Create(HInstance, GetExistedResourceEntry(resName), PChar(rsD3D));
    try
      LoadFromStream(rs, FILEVERSION);
    finally
      rs.Free
    end;
  finally
    InvokeResource := False;
  end;
end;

{$IFNDEF NO_D3DPROCEDURALOBJECTS}
procedure TD3DScene.RunProceduralObjects;
var
  i: integer;
  obj: TObject;
begin
  for i := 0 to Surfaces.Count - 1 do
  begin
    obj := Surfaces.Objects[i];
    if (obj as TD3DObject).GetTypeID = ID3D_ProceduralObject then
      (obj as TD3DProceduralObject).Execute;
  end;
end;
{$ENDIF}

{$IFNDEF NO_D3DPROCEDURALOBJECTS}
function TD3DScene.GetCurrentProceduralObject: TD3DProceduralObject;
begin
  Result := CurrentProceduralObject;
end;
{$ENDIF}

procedure TD3DScene.LoadFromStream(s: TStream; version: integer);
begin
{$IFNDEF NO_SCRIPTS}
  StopScriptEngine;
{$ENDIF}
  Clear;
  AppendFromStream(s);
{$IFNDEF NO_SCRIPTS}
  StartScriptEngine;
{$ENDIF}
end;

procedure TD3DScene.FastLoadFromStream(s: TStream);
// ִום בנוכוץטוס‏םוי פב textures, דיב Undo/Redo operations
begin
{$IFNDEF NO_SCRIPTS}
  StopScriptEngine;
{$ENDIF}
  FastClear;
  AppendFromStream(s);
{$IFNDEF NO_SCRIPTS}
  StartScriptEngine;
{$ENDIF}
end;

procedure TD3DScene.OldAppendFromStream(s: TStream;
      x: TD3DValue=0; y:TD3DValue=0; z: TD3DValue=0;
      dx: TD3DValue=0; dy:TD3DValue=0; dz: TD3DValue=0);
var
  i, j, k, count: integer;
  c: char;
  id: byte;
  D3DSurface: TD3DObject;
{$IFNDEF NO_D3DSOUNDS}
  D3DAudio: TD3DBaseAudio;
{$ENDIF}
  D3DAction: TD3DAction;
  D3DSceneLight: TD3DSceneLight;
  Custom: TCustomData;
{$IFNDEF NO_SCRIPTS}
  Sc: TScript;
{$ENDIF}
{$IFNDEF NO_SCRIPTS}
  strm: TStream;
{$ENDIF}
  len: byte;
  num: ShortInt;
  TextureName,
{$IFNDEF NO_D3DSOUNDS}
  SoundName,
{$ENDIF}
  CustomDataName, ScriptName: string;
  TextureNames: TTextureNames;
{$IFNDEF NO_D3DSOUNDS}
  fOldMuted: boolean;
{$ENDIF}
  Inf: TD3DSceneInfo;
begin
{$IFNDEF NO_D3DSOUNDS}
  fOldMuted := Muted;
  Muted := True;
{$ENDIF}
// ִיבגזןץלו פןם בסיטל פשם Surfaces
  s.Read(count, SizeOf(Count));
  for i := 1 to Count do
  begin
{$IFNDEF NO_MESSAGESCAN}
  // Dispatch WM_PAINT && WM_SCENE_SETCURSOR MESSAGES
    MessageScan;
{$ENDIF}
  // ִיבגזןץלו פן id פןץ TD3DObject
    s.Read(id, SizeOf(id));
    if id = ID3D_Abstract then
    begin
    end
    else
    begin
      s.Read(len, SizeOf(len));
      TextureName := '';
      for j := 1 to len do
      begin
        s.Read(c, SizeOf(c));
        TextureName := TextureName + c;
      end;
      case id of
{$IFNDEF NO_D3DTRIANGLES}
        ID3D_Triangle:
          begin
            D3DSurface := TD3DSTriangle.CreateFromStream(s, DXDraw, AddTextureToCollection(TextureName), FILEVERSION_000);
            (D3DSurface as TD3DSTriangle).Info.TextureName := TextureName;
          end;
{$ENDIF}
        ID3D_Quadrangle:
          begin
            D3DSurface := TD3DQuadrAngle.CreateFromStream(s, DXDraw, AddTextureToCollection(TextureName), FILEVERSION_000);
            (D3DSurface as TD3DQuadrAngle).Info.TextureName := TextureName;
          end;
{$IFNDEF NO_D3DSTUBOBJECTS}
        ID3D_StubObject:
          begin
            FillChar(TextureNames, SizeOf(TextureNames), Chr(0));
            TextureNames[0, 0] := TextureName; // װן נס‏פן Texture פן קןץלו היבגףוי הח!
            s.Read(num, SizeOf(num)); // ִיבגזןץלו פןם בסיטל פשם Textures
           // ִיבגזןץלו פחם נס‏פח לףךב פןץ װD3DStubObject
            s.Read(len, SizeOf(len));
            TextureNames[0, 1] := '';
            for k := 1 to len do
            begin
              s.Read(c, SizeOf(c));
              TextureNames[0, 1] := TextureNames[0, 1] + c;
            end;
            for j := 1 to num - 1 do      // ¸פףי בסקזןץלו פן loop בנ פן 1 & קי בנ פן 0
            begin
              // ִיבגזןץלו פחם ויךםב פןץ װD3DStubObject
              s.Read(len, SizeOf(len));
              TextureNames[j, 0] := '';
              for k := 1 to len do
              begin
                s.Read(c, SizeOf(c));
                TextureNames[j, 0] := TextureNames[j,0] + c;
              end;
              // ִיבגזןץלו פחם לףךב פןץ װD3DStubObject
              s.Read(len, SizeOf(len));
              TextureNames[j, 1] := '';
              for k := 1 to len do
              begin
                s.Read(c, SizeOf(c));
                TextureNames[j, 1] := TextureNames[j, 1] + c;
              end;
            end;
            D3DSurface := TD3DStubObject.CreateFromStream(s, DXDraw, AddTexturesToCollection(TextureNames), FILEVERSION_000);
            (D3DSurface as TD3DStubObject).Info.TextureNames := TextureNames;
            (D3DSurface as TD3DStubObject).PerspectiveRotate(Position, Rotation);
          end;
{$ENDIF}
{$IFNDEF NO_D3DEXOBJECTS}
        ID3D_ExObject:
          begin
            FillChar(TextureNames, SizeOf(TextureNames), Chr(0));
            TextureNames[0, 0] := TextureName; // װן נס‏פן Texture פן קןץלו היבגףוי הח!
            s.Read(num, SizeOf(num)); // ִיבגזןץלו פןם בסיטל פשם Textures
           // ִיבגזןץלו פחם נס‏פח לףךב פןץ װD3DExObject
            s.Read(len, SizeOf(len));
            TextureNames[0, 1] := '';
            for k := 1 to len do
            begin
              s.Read(c, SizeOf(c));
              TextureNames[0, 1] := TextureNames[0, 1] + c;
            end;
            for j := 1 to num - 1 do      // ¸פףי בסקזןץלו פן loop בנ פן 1 & קי בנ פן 0
            begin
              // ִיבגזןץלו פחם ויךםב פןץ װD3DExObject
              s.Read(len, SizeOf(len));
              TextureNames[j, 0] := '';
              for k := 1 to len do
              begin
                s.Read(c, SizeOf(c));
                TextureNames[j, 0] := TextureNames[j,0] + c;
              end;
              // ִיבגזןץלו פחם לףךב פןץ װD3DExObject
              s.Read(len, SizeOf(len));
              TextureNames[j, 1] := '';
              for k := 1 to len do
              begin
                s.Read(c, SizeOf(c));
                TextureNames[j, 1] := TextureNames[j, 1] + c;
              end;
            end;
            D3DSurface := TD3DExObject.CreateFromStream(s, DXDraw, AddTexturesToCollection(TextureNames), FILEVERSION_000);
            (D3DSurface as TD3DExObject).Info.TextureNames := TextureNames;
            (D3DSurface as TD3DExObject).SimpleRotate(Position, Rotation.y);
//            (D3DSurface as TD3DExObject).SimpleRotate(fPosition);
          end;
{$ENDIF}
        ID3D_Polygon:
          begin
            FillChar(TextureNames, SizeOf(TextureNames), Chr(0));
            TextureNames[0, 0] := TextureName; // װן נס‏פן Texture פן קןץלו היבגףוי הח!
            s.Read(num, SizeOf(num)); // ִיבגזןץלו פןם בסיטל פשם Textures
           // ִיבגזןץלו פחם נס‏פח לףךב פןץ װD3DPolygon
            s.Read(len, SizeOf(len));
            TextureNames[0, 1] := '';
            for k := 1 to len do
            begin
              s.Read(c, SizeOf(c));
              TextureNames[0, 1] := TextureNames[0, 1] + c;
            end;
            for j := 1 to num - 1 do      // ¸פףי בסקזןץלו פן loop בנ פן 1 & קי בנ פן 0
            begin
              // ִיבגזןץלו פחם ויךםב פןץ װD3DPolygon
              s.Read(len, SizeOf(len));
              TextureNames[j, 0] := '';
              for k := 1 to len do
              begin
                s.Read(c, SizeOf(c));
                TextureNames[j, 0] := TextureNames[j, 0] + c;
              end;
              // ִיבגזןץלו פחם לףךב פןץ װD3DPolygon
              s.Read(len, SizeOf(len));
              TextureNames[j, 1] := '';
              for k := 1 to len do
              begin
                s.Read(c, SizeOf(c));
                TextureNames[j, 1] := TextureNames[j, 1] + c;
              end;
            end;
            D3DSurface := TD3DPolygon.CreateFromStream(s, DXDraw, AddTexturesToCollection(TextureNames), FILEVERSION_000);
            if D3DSurface <> nil then
            begin
              (D3DSurface as TD3DPolygon).Info2.TextureNames := TextureNames;
              (D3DSurface as TD3DPolygon).MaxPolygonVertexes := fMaxPolygonVertexes;
            end;
          end;
{$IFNDEF NO_D3DBILLBOARDS}
        ID3D_BillBoard:
          begin
            FillChar(TextureNames, SizeOf(TextureNames), Chr(0));
            TextureNames[0, 0] := TextureName; // װן נס‏פן Texture פן קןץלו היבגףוי הח!
            s.Read(num, SizeOf(num)); // ִיבגזןץלו פןם בסיטל פשם Textures
           // ִיבגזןץלו פחם נס‏פח לףךב פןץ װD3DBillBoard
            s.Read(len, SizeOf(len));
            TextureNames[0, 1] := '';
            for k := 1 to len do
            begin
              s.Read(c, SizeOf(c));
              TextureNames[0, 1] := TextureNames[0, 1] + c;
            end;
            for j := 1 to num - 1 do      // ¸פףי בסקזןץלו פן loop בנ פן 1 & קי בנ פן 0
            begin
              // ִיבגזןץלו פחם ויךםב פןץ װD3DBillBoard
              s.Read(len, SizeOf(len));
              TextureNames[j, 0] := '';
              for k := 1 to len do
              begin
                s.Read(c, SizeOf(c));
                TextureNames[j, 0] := TextureNames[j, 0] + c;
              end;
              // ִיבגזןץלו פחם לףךב פןץ װD3DBillBoard
              s.Read(len, SizeOf(len));
              TextureNames[j, 1] := '';
              for k := 1 to len do
              begin
                s.Read(c, SizeOf(c));
                TextureNames[j, 1] := TextureNames[j, 1] + c;
              end;
            end;
            D3DSurface := TD3DBillBoard.CreateFromStream(s, DXDraw, AddPicturesToCollection(TextureNames), FILEVERSION_000);
            (D3DSurface as TD3DBillBoard).Info.TextureNames := TextureNames;
          end;
{$ENDIF}
{$IFNDEF NO_D3DCUBES}
        ID3D_Cube:
          begin
            FillChar(TextureNames, SizeOf(TextureNames), Chr(0));
            TextureNames[0, 0] := TextureName; // װן נס‏פן Texture פן קןץלו היבגףוי הח!
            s.Read(num, SizeOf(num)); // ִיבגזןץלו פןם בסיטל פשם Textures
           // ִיבגזןץלו פחם נס‏פח לףךב פןץ Cube
            s.Read(len, SizeOf(len));
            TextureNames[0, 1] := '';
            for k := 1 to len do
            begin
              s.Read(c, SizeOf(c));
              TextureNames[0, 1] := TextureNames[0, 1] + c;
            end;
            for j := 1 to num - 1 do      // ¸פףי בסקזןץלו פן loop בנ פן 1 & קי בנ פן 0
            begin
              // ִיבגזןץלו פחם ויךםב פןץ Cube
              s.Read(len, SizeOf(len));
              TextureNames[j, 0] := '';
              for k := 1 to len do
              begin
                s.Read(c, SizeOf(c));
                TextureNames[j, 0] := TextureNames[j, 0] + c;
              end;
              // ִיבגזןץלו פחם לףךב פןץ Cube
              s.Read(len, SizeOf(len));
              TextureNames[j, 1] := '';
              for k := 1 to len do
              begin
                s.Read(c, SizeOf(c));
                TextureNames[j, 1] := TextureNames[j, 1] + c;
              end;
            end;
            D3DSurface := TD3DCube.CreateFromStream(s, DXDraw, AddTexturesToCollection(TextureNames), FILEVERSION_000);
            (D3DSurface as TD3DCube).Info.TextureNames := TextureNames;
          end;
{$ENDIF}
{$IFNDEF NO_D3DSPHERES}
        ID3D_Sphere:
          begin
            FillChar(TextureNames, SizeOf(TextureNames), Chr(0));
            TextureNames[0, 0] := TextureName; // װן נס‏פן Texture פן קןץלו היבגףוי הח!
            s.Read(num, SizeOf(num)); // ִיבגזןץלו פןם בסיטל פשם Textures
           // ִיבגזןץלו פחם נס‏פח לףךב פןץ Cube
            s.Read(len, SizeOf(len));
            TextureNames[0, 1] := '';
            for k := 1 to len do
            begin
              s.Read(c, SizeOf(c));
              TextureNames[0, 1] := TextureNames[0, 1] + c;
            end;
            for j := 1 to num - 1 do      // ¸פףי בסקזןץלו פן loop בנ פן 1 & קי בנ פן 0
            begin
              // ִיבגזןץלו פחם ויךםב פןץ Cube
              s.Read(len, SizeOf(len));
              TextureNames[j, 0] := '';
              for k := 1 to len do
              begin
                s.Read(c, SizeOf(c));
                TextureNames[j, 0] := TextureNames[j, 0] + c;
              end;
              // ִיבגזןץלו פחם לףךב פןץ Cube
              s.Read(len, SizeOf(len));
              TextureNames[j, 1] := '';
              for k := 1 to len do
              begin
                s.Read(c, SizeOf(c));
                TextureNames[j, 1] := TextureNames[j, 1] + c;
              end;
            end;
            D3DSurface := TD3DSphere.CreateFromStream(s, DXDraw, AddTexturesToCollection(TextureNames), FILEVERSION_000);
            (D3DSurface as TD3DSphere).Info.TextureNames := TextureNames;
          end;
{$ENDIF}
{$IFNDEF NO_D3DCONES}
        ID3D_Cone:
          begin
            FillChar(TextureNames, SizeOf(TextureNames), Chr(0));
            TextureNames[0, 0] := TextureName; // װן נס‏פן Texture פן קןץלו היבגףוי הח!
            s.Read(num, SizeOf(num)); // ִיבגזןץלו פןם בסיטל פשם Textures
           // ִיבגזןץלו פחם נס‏פח לףךב פןץ ך‏םןץ
            s.Read(len, SizeOf(len));
            TextureNames[0, 1] := '';
            for k := 1 to len do
            begin
              s.Read(c, SizeOf(c));
              TextureNames[0, 1] := TextureNames[0, 1] + c;
            end;
            for j := 1 to num - 1 do      // ¸פףי בסקזןץלו פן loop בנ פן 1 & קי בנ פן 0
            begin
              // ִיבגזןץלו פחם ויךםב פןץ ך‏םןץ
              s.Read(len, SizeOf(len));
              TextureNames[j, 0] := '';
              for k := 1 to len do
              begin
                s.Read(c, SizeOf(c));
                TextureNames[j, 0] := TextureNames[j, 0] + c;
              end;
              // ִיבגזןץלו פחם לףךב פןץ Cube
              s.Read(len, SizeOf(len));
              TextureNames[j, 1] := '';
              for k := 1 to len do
              begin
                s.Read(c, SizeOf(c));
                TextureNames[j, 1] := TextureNames[j, 1] + c;
              end;
            end;
            D3DSurface := TD3DCone.CreateFromStream(s, DXDraw, AddTexturesToCollection(TextureNames), FILEVERSION_000);
            (D3DSurface as TD3DCone).Info.TextureNames := TextureNames;
          end;
{$ENDIF}
{$IFNDEF NO_D3DCYLINDERS}
        ID3D_Cylinder:
          begin
            FillChar(TextureNames, SizeOf(TextureNames), Chr(0));
            TextureNames[0, 0] := TextureName; // װן נס‏פן Texture פן קןץלו היבגףוי הח!
            s.Read(num, SizeOf(num)); // ִיבגזןץלו פןם בסיטל פשם Textures
           // ִיבגזןץלו פחם נס‏פח לףךב פןץ ךץכםהסןץ
            s.Read(len, SizeOf(len));
            TextureNames[0, 1] := '';
            for k := 1 to len do
            begin
              s.Read(c, SizeOf(c));
              TextureNames[0, 1] := TextureNames[0, 1] + c;
            end;
            for j := 1 to num - 1 do      // ¸פףי בסקזןץלו פן loop בנ פן 1 & קי בנ פן 0
            begin
              // ִיבגזןץלו פחם ויךםב פןץ ךץכםהסןץ
              s.Read(len, SizeOf(len));
              TextureNames[j, 0] := '';
              for k := 1 to len do
              begin
                s.Read(c, SizeOf(c));
                TextureNames[j, 0] := TextureNames[j, 0] + c;
              end;
              // ִיבגזןץלו פחם לףךב
              s.Read(len, SizeOf(len));
              TextureNames[j, 1] := '';
              for k := 1 to len do
              begin
                s.Read(c, SizeOf(c));
                TextureNames[j, 1] := TextureNames[j, 1] + c;
              end;
            end;
            D3DSurface := TD3DCylinder.CreateFromStream(s, DXDraw, AddTexturesToCollection(TextureNames), FILEVERSION_000);
            (D3DSurface as TD3DCylinder).Info.TextureNames := TextureNames;
          end;
{$ENDIF}
        ID3D_Scene:
          begin
            s.Read(inf, SizeOf(Inf) - SizeOf(Inf.PathToScene)); // Hack, PathToScene must be the last field of record
            if InvokeWad then
              inf.PathToScene := GetExistedWADEntry(TextureName)
            else if InvokeResource then
              inf.PathToScene := GetExistedResourceEntry(TextureName)
            else
              inf.PathToScene := GetExistedFileName(TextureName);
            D3DSurface := TD3DScene.CreateAttached(inf, self);
          end;
      else
        D3DSurface := nil;
      end;
      if Assigned(D3DSurface) then
      begin
        D3DSurface.Rotate(dx, dy, dz);
        D3DSurface.Move(x, y, z);
        Surfaces.Objects[Surfaces.Add(TextureName)] := D3DSurface;
      end;
    end;
  end;
// ִיבגזןץלו פןם בסיטל פשם קשם
  s.Read(count, SizeOf(Count));
{$IFNDEF NO_D3DSOUNDS}
  for i := 1 to Count do
  begin
  // ִיבגזןץלו פן םןלב פןץ קןץ
    s.Read(id, SizeOf(id));
    if id = ID3D_Sound then
    begin
      s.Read(len, SizeOf(len));
      SoundName := '';
      for j := 1 to len do
      begin
        s.Read(c, SizeOf(c));
        SoundName := SoundName + c;
      end;
      D3DAudio := TD3DSound.CreateFromStream(s, DXSound, AddWaveToCollection(SoundName), FILEVERSION_000, fMute);
      (D3DAudio as TD3DSound).Info.SoundName := SoundName;
    end
    else if id = ID3D_Tone then
    begin
      SoundName := rsTone;
      D3DAudio := TD3DTone.CreateFromStream(s, FILEVERSION_000, fMute)
    end
    else
      D3DAudio := nil;
    if Assigned(D3DAudio) then
    begin
      D3DAudio.Move(x, y, z);
      Sounds.Objects[Sounds.Add(SoundName)] := D3DAudio;
    end;
  end;
{$ENDIF}
// ִיבגזןץלו פב CustomData לםן ם הום קןץלו צפףוי ףפן פכןע פןץ stream
  if s.Position < s.Size then
  begin
    s.Read(count, SizeOf(Count));
    for i := 1 to Count do
    begin
    // ִיבגזןץלו פן םןלב פןץ CustomData
      s.Read(len, SizeOf(len));
      CustomDataName := '';
      for j := 1 to len do
      begin
        s.Read(c, SizeOf(c));
        CustomDataName := CustomDataName + c;
      end;
      Custom := TCustomData.CreateFromStream(s, AddStreamToCollection(CustomDataName), CustomDataName, FILEVERSION_000);
      CustomData.Objects[CustomData.Add(CustomDataName)] := Custom;
    end;
  end;
// ִיבגזןץלו פב Scripts לםן ם הום קןץלו צפףוי ףפן פכןע פןץ stream
  if s.Position < s.Size then
  begin
    s.Read(count, SizeOf(Count));
    for i := 1 to Count do
    begin
    // ִיבגזןץלו פן םןלב פןץ Script
      s.Read(len, SizeOf(len));
      ScriptName := '';
      for j := 1 to len do
      begin
        s.Read(c, SizeOf(c));
        ScriptName := ScriptName + c;
      end;
{$IFNDEF NO_SCRIPTS}
      strm := AddStreamToCollection(ScriptName);
      Sc := TScript.CreateFromStream(s, strm, FILEVERSION_000);
      Streams.Delete(Streams.Count - 1); // ִיבדסצןץלו פן Stream בנ פחם כףפב, הום פן קסויבזלבףפו נכןם
      Scripts.Objects[Scripts.Add(ScriptName)] := Sc;
{$ENDIF}
    end;
  end;
// ִיבגזןץלו פב Actions לםן ם הום קןץלו צפףוי ףפן פכןע פןץ stream
  if s.Position < s.Size then
  begin
    s.Read(count, SizeOf(Count));
    for i := 1 to Count do
    begin
      D3DAction := TD3DAction.CreateFromStream(s, self, FILEVERSION_000);
      Actions.AddObject('', D3DAction);
    end;
  end;
// ִיבגזןץלו פב Lights לםן ם הום קןץלו צפףוי ףפן פכןע פןץ stream
  if s.Position < s.Size then
  begin
    s.Read(count, SizeOf(Count));
    for i := 1 to Count do
    begin
      D3DSceneLight := TD3DSceneLight.CreateFromStream(s, FILEVERSION_000);
      Lights.AddObject('', D3DSceneLight);
    end;
  end;
  CreateCache;
{$IFNDEF NO_D3DSOUNDS}
  Muted := fOldMuted;
{$ENDIF}
{$IFNDEF NO_D3DBILLBOARDS}
  OptimizeBillBoards;
{$ENDIF}  
{$IFNDEF NO_D3DSOUNDS}
  Update3DSounds;
{$ENDIF}  
  ForceRecalc;
end;

procedure TD3DScene.GetTextureNames(var s: TDXStringList);
var
  i: integer;
begin
  if s = nil then
    s := TDXStringList.Create;
  for i := 0 to Surfaces.Count - 1 do
    (Surfaces.Objects[i] as TD3DObject).GetTextureNames(s);
end;

function TD3DScene.GetFileVersion(fName: string): integer;
var
  f: TStream;
{$IFNDEF NO_IDSOFTGAMESSUPPORT}
  wName, wEntry: string;
  w: TWAD;
{$ENDIF}

  function GetVer: integer;
  var
    len, i: integer;
    c: char;
    sig: string;
  begin
    len := Length(rsSIGNATURE);
    if len + SizeOf(Result) < f.size then
    begin
      sig := '';
      for i := 1 to len do
      begin
        f.Read(c, SizeOf(c));
        sig := sig + c;
      end;
      if sig = rsSIGNATURE then
        f.read(Result, SizeOf(Result));
    end;
  end;

begin
  Result := FILEVERSION_000;
  if InvokeWAD and (Wad <> nil) and Wad.EntryExist(GetExistedWadEntry(fName)) then
  begin
    f := TMemoryStream.Create;
    try
      if WAD.CopyToStream(fName, f) then
        Result := GetVer;
    finally
      f.Free;
    end;
  end
  else if FileExists(fName) then
  begin
    f := TFileStream.Create(fName, fmOpenRead or fmShareDenyWrite);
    try
      Result := GetVer;
    finally
      f.Free;
    end;
  end
{$IFNDEF NO_IDSOFTGAMESSUPPORT}
  else if GetWADLinkInfo(fName, wName, wEntry) then
  begin
    if FileExists(wName) then
    begin
      w := TWad.CreateFromFile(wName);
      f := TMemoryStream.Create;
      try
        if w.CopyToStream(fName, f) then
          Result := GetVer;
      finally
        f.Free;
        w.Free;
      end;
    end
  end
{$ENDIF}
  else if InvokeResource then
  begin
    if IsValidInteger(GetExistedResourceEntry(fName)) then
      f := TResourceStream.CreateFromID(HInstance, StrToInt(GetExistedResourceEntry(fName)), PChar(rsD3D))
    else
      f := TResourceStream.Create(HInstance, GetExistedResourceEntry(fName), PChar(rsD3D));
    try
      Result := GetVer;
    finally
      f.Free
    end;
  end;
end;

procedure TD3DScene.AppendFromStream(s: TStream;
      x: TD3DValue=0; y:TD3DValue=0; z: TD3DValue=0;
      dx: TD3DValue=0; dy:TD3DValue=0; dz: TD3DValue=0);
var
  sig: string;
  ilen: integer;
  c: char;
  len: byte;
  i, j, count: integer;
  id: byte;
  D3DSurface: TD3DObject;
{$IFNDEF NO_D3DSOUNDS}
  D3DAudio: TD3DBaseAudio;
{$ENDIF}
  D3DAction: TD3DAction;
  D3DSceneLight: TD3DSceneLight;
  Custom: TCustomData;
{$IFNDEF NO_SCRIPTS}
  Sc: TScript;
  strm: TStream;
{$ENDIF}
{$IFNDEF NO_D3DSOUNDS}
  SoundName,
{$ENDIF}
  CustomDataName, ScriptName: string;
  TextureNames: TTextureNames;
{$IFNDEF NO_D3DSOUNDS}
  fOldMuted: boolean;
{$ENDIF}
  Inf: TD3DSceneInfo;
  TNames: string;
  sTNames: TDXStringList;
  ver: integer;
  cs: TCriticalSection;

  function ReadTextureNames: SmallInt;
  var
    i: integer;
    P: PSmallIntArray;
  begin
    for i := 0 to MAXTEXTURES - 1 do
    begin
      TextureNames[i, 1] := '';
      TextureNames[i, 0] := '';
    end;
    s.Read(Result, SizeOf(Result));
    if Result > 0 then
    begin
      GetMem(P, 2 * Result * SizeOf(SmallInt));
      s.Read(P^, 2 * Result * SizeOf(SmallInt));
      for i := 0 to Result - 1 do
      begin
        if (P[2 * i] > -1) and (P[2 * i] < sTNames.Count) then
          TextureNames[i, 0] := sTNames.Strings[P[2 * i]];
        if (P[2 * i + 1] > -1) and (P[2 * i + 1] < sTNames.Count) then
          TextureNames[i, 1] := sTNames.Strings[P[2 * i + 1]];
      end;
      FreeMem(P, 2 * Result * SizeOf(SmallInt));
    end;
  end;

begin
  cs := TCriticalSection.Create;
  try
    cs.Enter;

    len := Length(rsSIGNATURE);
    if s.Position + len < s.size then
    begin
      sig := '';
      for i := 1 to len do
      begin
        s.Read(c, SizeOf(c));
        sig := sig + c;
      end;
      if sig <> rsSIGNATURE then
      begin
        s.Seek(s.Position - len, soFromBeginning);
        OldAppendFromStream(s, x, y, z, dx, dy, dz);
      end
      else
      begin
        s.read(ver, SizeOf(ver));
        s.read(ilen, SizeOf(ilen));
        TNames := '';
        for i := 1 to iLen do
        begin
          s.Read(c, SizeOf(c));
          TNames := TNames + c;
        end;
        sTNames := TDXStringList.Create;
        sTNames.Text := TNames;
        TNames := '';
        AddTexturesToCollection(sTNames);
{$IFNDEF NO_D3DSOUNDS}
        fOldMuted := Muted;
        Muted := True;
{$ENDIF}
      // ִיבגזןץלו פןם בסיטל פשם Surfaces
        s.Read(count, SizeOf(Count));
        for i := 1 to Count do
        begin
{$IFNDEF NO_MESSAGESCAN}
        // Dispatch WM_PAINT && WM_SCENE_SETCURSOR MESSAGES
          MessageScan;
{$ENDIF}
        // ִיבגזןץלו פן id פןץ TD3DObject
          s.Read(id, SizeOf(id));
          if id = ID3D_Abstract then
          begin
          end
          else
          begin
            if not (id in [ID3D_Scene {$IFNDEF NO_D3DSECTORCOLLECTIONS}
, ID3D_SECTORCOLLECTION{$ENDIF}]) then ReadTextureNames;
            case id of
{$IFNDEF NO_D3DTRIANGLES}
              ID3D_Triangle:
                begin
                  D3DSurface :=
                    TD3DSTriangle.CreateFromStream(s, DXDraw,
                      AddTextureToCollection(TextureNames[0, 0]), ver);
                 (D3DSurface as TD3DSTriangle).Info.TextureName := TextureNames[0, 0];
                end;
{$ENDIF}
              ID3D_Quadrangle:
                begin
                  D3DSurface :=
                    TD3DQuadrAngle.CreateFromStream(s, DXDraw,
                      AddTextureToCollection(TextureNames[0, 0]), ver);
                  (D3DSurface as TD3DQuadrAngle).Info.TextureName := TextureNames[0, 0];
                end;
{$IFNDEF NO_D3DSTUBOBJECTS}
              ID3D_StubObject:
                begin
                  D3DSurface :=
                    TD3DStubObject.CreateFromStream(s, DXDraw,
                      AddTexturesToCollection(TextureNames), ver);
                  (D3DSurface as TD3DStubObject).Info.TextureNames := TextureNames;
                  (D3DSurface as TD3DStubObject).PerspectiveRotate(Position, Rotation);
                end;
{$ENDIF}
{$IFNDEF NO_D3DEXOBJECTS}
              ID3D_ExObject:
                begin
                  D3DSurface :=
                    TD3DExObject.CreateFromStream(s, DXDraw,
                      AddTexturesToCollection(TextureNames), ver);
                  (D3DSurface as TD3DExObject).Info.TextureNames := TextureNames;
                  (D3DSurface as TD3DExObject).SimpleRotate(Position, Rotation.y);
//                  (D3DSurface as TD3DExObject).SimpleRotate(fPosition);
                end;
{$ENDIF}
              ID3D_Polygon:
                begin
                  D3DSurface :=
                    TD3DPolygon.CreateFromStream(s, DXDraw,
                      AddTexturesToCollection(TextureNames), ver);
                  if D3DSurface <> nil then
                  begin
                    (D3DSurface as TD3DPolygon).Info2.TextureNames := TextureNames;
                    (D3DSurface as TD3DPolygon).MaxPolygonVertexes := fMaxPolygonVertexes;
                  end;
                end;
{$IFNDEF NO_D3DPROCEDURALOBJECTS}
              ID3D_ProceduralObject:
                begin
                  D3DSurface :=
                    TD3DProceduralObject.CreateFromStream(s, self,
                      AddTexturesToCollection(TextureNames), ver);
                  (D3DSurface as TD3DProceduralObject).Info.TextureNames := TextureNames;
                end;
{$ENDIF}
{$IFNDEF NO_D3DACTORS}
              ID3D_Actor:
                begin
                  D3DSurface :=
                    TD3DActor.CreateFromStream(s, self,
                      AddTexturesToCollection(TextureNames), ver);
                  (D3DSurface as TD3DActor).Info.TextureNames := TextureNames;
                  (D3DSurface as TD3DActor).AppliedInfo.TextureNames := TextureNames;
                end;
{$ENDIF}
{$IFNDEF NO_D3DBILLBOARDS}
              ID3D_BillBoard:
                begin
                  D3DSurface :=
                    TD3DBillBoard.CreateFromStream(s, DXDraw,
                      AddPicturesToCollection(TextureNames), ver);
                  (D3DSurface as TD3DBillBoard).Info.TextureNames := TextureNames;
                end;
{$ENDIF}
{$IFNDEF NO_D3DCUBES}
              ID3D_Cube:
                begin
                  D3DSurface :=
                    TD3DCube.CreateFromStream(s, DXDraw,
                      AddTexturesToCollection(TextureNames), ver);
                  (D3DSurface as TD3DCube).Info.TextureNames := TextureNames;
                end;
{$ENDIF}
{$IFNDEF NO_D3DSPHERES}
              ID3D_Sphere:
                begin
                  D3DSurface :=
                    TD3DSphere.CreateFromStream(s, DXDraw,
                      AddTexturesToCollection(TextureNames), ver);
                  (D3DSurface as TD3DSphere).Info.TextureNames := TextureNames;
                end;
{$ENDIF}
{$IFNDEF NO_D3DCONES}
              ID3D_Cone:
                begin
                  D3DSurface :=
                    TD3DCone.CreateFromStream(s, DXDraw,
                      AddTexturesToCollection(TextureNames), ver);
                  (D3DSurface as TD3DCone).Info.TextureNames := TextureNames;
                end;
{$ENDIF}
{$IFNDEF NO_D3DCYLINDERS}
              ID3D_Cylinder:
                begin
                  D3DSurface :=
                    TD3DCylinder.CreateFromStream(s, DXDraw,
                      AddTexturesToCollection(TextureNames), ver);
                  (D3DSurface as TD3DCylinder).Info.TextureNames := TextureNames;
                end;
{$ENDIF}
{$IFNDEF NO_D3DPLUGINS}
              ID3D_PlugIn:
                begin
                  D3DSurface :=
                    TD3DPlugIn.CreateFromStream(s, self,
                      AddTextureToCollection(TextureNames[0, 0]), ver);
                  (D3DSurface as TD3DPlugIn).Info.TextureName := TextureNames[0, 0];
                  (D3DSurface as TD3DPlugIn).AcceptPosition(fPosition);
                  (D3DSurface as TD3DPlugIn).AcceptRotation(fRotation);
                end;
{$ENDIF}
{$IFNDEF NO_D3DRINGS}
              ID3D_Ring:
                begin
                  D3DSurface :=
                    TD3DRing.CreateFromStream(s, DXDraw,
                      AddTexturesToCollection(TextureNames), ver);
                  (D3DSurface as TD3DRing).Info.TextureNames := TextureNames;
                end;
{$ENDIF}
{$IFNDEF NO_D3DTEXTS}
              ID3D_Text:
                begin
                  D3DSurface :=
                    TD3DText.CreateFromStream(s, DXDraw,
                      AddTexturesToCollection(TextureNames), ver);
                  (D3DSurface as TD3DText).Info.TextureNames := TextureNames;
                end;
{$ENDIF}
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
              ID3D_SectorCollection:
                begin
                  D3DSurface :=
                    TD3DSectorCollection.CreateFromStream(s, self, ver);
                  (D3DSurface as TD3DSectorCollection).AcceptPosition(fOldPosition, fPosition);
                  (D3DSurface as TD3DSectorCollection).AcceptRotation(fRotation);
                end;
{$ENDIF}
{$IFNDEF NO_D3DGENERICRTLPOLYGONS}
              ID3D_GenericRTLPolygon:
                begin
                  D3DSurface :=
                    TD3DGenericRTLPolygon.CreateFromStream(s, DXDraw,
                      AddTextureToCollection(TextureNames[0, 0]), ver);
                  (D3DSurface as TD3DGenericRTLPolygon).SetTextureName(TextureNames[0, 0]);
                  (D3DSurface as TD3DGenericRTLPolygon).SetTexture2(TextureNames[0, 1], AddTextureToCollection(TextureNames[0, 1]));
                end;
{$ENDIF}
{$IFNDEF NO_D3DEXTRARTLPOLYGONS}
              ID3D_ExtraRTLPolygon:
                begin
                  D3DSurface :=
                    TD3DExtraRTLPolygon.CreateFromStream(s, DXDraw,
                      AddTexturesToCollection(TextureNames), ver);
                  (D3DSurface as TD3DExtraRTLPolygon).TextureNames := TextureNames;
                end;
{$ENDIF}
              ID3D_Scene:
                begin
                  Inf.PathToScene := '';
                  repeat
                    s.Read(c, SizeOf(c));
                    if c <> #0 then
                      Inf.PathToScene := Inf.PathToScene + c;
                  until c = #0;
                  // Hack, PathToScene must be the last field of record ->
                  s.Read(inf, SizeOf(Inf) - SizeOf(Inf.PathToScene));
                  if InvokeWad then
                    inf.PathToScene := GetExistedWADEntry(inf.PathToScene)
                  else if InvokeResource then
                    inf.PathToScene := GetExistedResourceEntry(inf.PathToScene)
                  else
                    inf.PathToScene := GetExistedFileName(inf.PathToScene);
                  D3DSurface := TD3DScene.CreateAttached(inf, self);
                  TextureNames[0, 0] := inf.PathToScene;
                end;
            else
              D3DSurface := nil;
            end;
            if Assigned(D3DSurface) then
            begin
              D3DSurface.Rotate(dx, dy, dz);
              D3DSurface.Move(x, y, z);
              Surfaces.Objects[Surfaces.Add(TextureNames[0, 0])] := D3DSurface;
            end;
          end;
        end;
        sTNames.Free;

      // ִיבגזןץלו פןם בסיטל פשם קשם
        s.Read(Count, SizeOf(Count));
{$IFNDEF NO_D3DSOUNDS}
        for i := 1 to Count do
        begin
        // ִיבגזןץלו פן םןלב פןץ קןץ
          s.Read(id, SizeOf(id));
          if id = ID3D_Sound then
          begin
            s.Read(len, SizeOf(len));
            SoundName := '';
            for j := 1 to len do
            begin
              s.Read(c, SizeOf(c));
              SoundName := SoundName + c;
            end;
            D3DAudio :=
              TD3DSound.CreateFromStream(s, DXSound,
                AddWaveToCollection(SoundName), ver, fMute);
            (D3DAudio as TD3DSound).Info.SoundName := SoundName;
          end
          else if id = ID3D_Tone then
          begin
            SoundName := rsTone;
            D3DAudio := TD3DTone.CreateFromStream(s, ver, fMute)
          end
          else
            D3DAudio := nil;
          if Assigned(D3DAudio) then
          begin
            D3DAudio.Move(x, y, z);
            Sounds.Objects[Sounds.Add(SoundName)] := D3DAudio;
          end;
        end;
{$ENDIF}
      // ִיבגזןץלו פב CustomData לםן ם הום קןץלו צפףוי ףפן פכןע פןץ stream
        if s.Position < s.Size then
        begin
          s.Read(Count, SizeOf(Count));
          for i := 1 to Count do
          begin
          // ִיבגזןץלו פן םןלב פןץ CustomData
            s.Read(len, SizeOf(len));
            CustomDataName := '';
            for j := 1 to len do
            begin
              s.Read(c, SizeOf(c));
              CustomDataName := CustomDataName + c;
            end;
            Custom :=
              TCustomData.CreateFromStream(s,
                AddStreamToCollection(CustomDataName), CustomDataName, ver);
            CustomData.Objects[CustomData.Add(CustomDataName)] := Custom;
          end;
        end;
      // ִיבגזןץלו פב Scripts לםן ם הום קןץלו צפףוי ףפן פכןע פןץ stream
        if s.Position < s.Size then
        begin
          s.Read(count, SizeOf(Count));
          for i := 1 to Count do
          begin
          // ִיבגזןץלו פן םןלב פןץ Script
            s.Read(len, SizeOf(len));
            ScriptName := '';
            for j := 1 to len do
            begin
              s.Read(c, SizeOf(c));
              ScriptName := ScriptName + c;
            end;
{$IFNDEF NO_SCRIPTS}
            strm := AddStreamToCollection(ScriptName);
            Sc := TScript.CreateFromStream(s, strm, ver);
            Streams.Delete(Streams.Count - 1); // ִיבדסצןץלו פן Stream בנ פחם כףפב, הום פן קסויבזלבףפו נכןם
            Scripts.Objects[Scripts.Add(ScriptName)] := Sc;
{$ENDIF}
          end;
        end;
      // ִיבגזןץלו פב Actions לםן ם הום קןץלו צפףוי ףפן פכןע פןץ stream
        if s.Position < s.Size then
        begin
          s.Read(count, SizeOf(Count));
          for i := 1 to Count do
          begin
            D3DAction := TD3DAction.CreateFromStream(s, self, ver);
            Actions.AddObject('', D3DAction);
          end;
        end;
      // ִיבגזןץלו פב Lights לםן ם הום קןץלו צפףוי ףפן פכןע פןץ stream
        if s.Position < s.Size then
        begin
          s.Read(count, SizeOf(Count));
          for i := 1 to Count do
          begin
            D3DSceneLight := TD3DSceneLight.CreateFromStream(s, ver);
            Lights.AddObject('', D3DSceneLight);
          end;
        end;
        CreateCache;
{$IFNDEF NO_D3DSOUNDS}
        Muted := fOldMuted;
{$ENDIF}
{$IFNDEF NO_D3DBILLBOARDS}
        OptimizeBillBoards;
{$ENDIF}        
{$IFNDEF NO_D3DSOUNDS}
        Update3DSounds;
{$ENDIF}        
        Textures.Sorted := True;
        ForceRecalc;
      end;
    end;
  finally
    cs.Leave;
    cs.Free;
  end;
end;

procedure TD3DScene.SaveSignatureToStream(s: TStream);
var
  i: integer;
  ver: integer;
begin
  for i := 1 to Length(rsSignature) do
    s.Write(rsSignature[i], 1);
  ver := Version;
  s.Write(ver, SizeOf(ver));
end;

{$IFDEF DESIGNER}
procedure TD3DScene.SaveTextureNamesToDirectory(s: TStream; path: string; defExt: string = ''; doBackup: boolean = True);
var
  stNames: TDXStringList;
  TNames: string;
  newEntry: string;
  i, j, iLen: integer;
  Graphic: TGraphic;
  ext: string;

  function GetTheFileName(const s: string): string;
  var
    foo, Entry: string;
  begin
    SafeAddSlash(path);
    if FileExists(s) then
    begin
      if defExt = '' then
        Result := path + ExtractFileName(s)
      else
        Result := ChangeFileExt(path + ExtractFileName(s), defExt)
    end
{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_DOOMSUPPORT}
    else if IsWadLinkInfo(s) then
    begin
      GetWadLinkInfo(s, foo, Entry);
      if defExt = '' then
        Result := path + Entry + rsExtBMP
      else
        Result := path + Entry + defExt;
    end
{$ENDIF}
{$IFNDEF NO_DOOMSUPPORT}
    else if IsPAKLinkInfo(s) then
    begin
      GetPAKLinkInfo(s, foo, Entry);
      if defExt = '' then
        Result := path + Entry + rsExtBMP
      else
        Result := path + Entry + defExt;
    end
{$ENDIF}
{$ENDIF}
    else if IsDllLinkInfo(s) then
    begin
      GetDllLinkInfo(s, foo, Entry);
      if defExt = '' then
        Result := path + Entry + rsExtBMP
      else
        Result := path + Entry + defExt;
    end
    else
      Result := s;
  end;

begin
  stNames := TDXStringList.Create;
  try
    if Textures.Count > 0 then
    begin
      GetTextureNames(stNames);
      if defExt <> '' then
        if defExt[1] <> '.' then
          defExt := '.' + defExt;
      for i := 0 to stNames.Count - 1 do
      begin
        newEntry := GetTheFileName(stNames.Strings[i]);
        ext := UpperCase(ExtractFileExt(stNames.Strings[i]));
        if ext = UpperCase(ExtractFileExt(newEntry)) then
        begin
          CopyFile(stNames.Strings[i], newEntry, doBackup);
          for j := 0 to _CacheSectorCollections.Count - 1 do
            (_CacheSectorCollections.Objects[j] as TD3DSectorCollection).ReplaceImageEntry(
              stNames.Strings[i], newEntry);
          stNames.Strings[i] := newEntry;
        end
        else
        begin
            for j := 0 to _CacheSectorCollections.Count - 1 do
              (_CacheSectorCollections.Objects[j] as TD3DSectorCollection).ReplaceImageEntry(
                stNames.Strings[i], newEntry);
          Graphic := DXImageLoad(stNames.Strings[i]);
          try
            stNames.Strings[i] := newEntry;
            if ext = UpperCase(rsExtBMZ) then
              SaveImageAs(Graphic, tiBMZ, stNames.Strings[i])
            else if ext = UpperCase(rsExtWZ1) then
              SaveImageAs(Graphic, tiWZ1, stNames.Strings[i])
            else if ext = UpperCase(rsExtWZ2) then
              SaveImageAs(Graphic, tiWZ2, stNames.Strings[i])
            else if ext = UpperCase(rsExtBMP) then
              SaveImageAs(Graphic, tiBMP, stNames.Strings[i])
            else if ext = UpperCase(rsExtPPM) then
              SaveImageAs(Graphic, tiPPM, stNames.Strings[i])
            else if ext = UpperCase(rsExtJPG) then
              SaveImageAs(Graphic, tiJPG, stNames.Strings[i])
            else if ext = UpperCase(rsExtTIF) then
              SaveImageAs(Graphic, tiTIF, stNames.Strings[i])
            else if ext = UpperCase(rsExtPCX) then
              SaveImageAs(Graphic, tiPCX, stNames.Strings[i])
            else if ext = UpperCase(rsExtM8) then
              SaveImageAs(Graphic, tiM8, stNames.Strings[i])
            else if ext = UpperCase(rsExtTGA) then
              SaveImageAs(Graphic, tiTGA, stNames.Strings[i]);
          finally
            Graphic.Free;
          end;
        end;
      end;
    end;
    TNames := stNames.Text;
    iLen := Length(TNames);
    s.Write(iLen, SizeOf(iLen));
    for i := 1 to iLen do s.Write(TNames[i], 1);
  finally
    stNames.Free;
  end;
end;
{$ENDIF}

procedure TD3DScene.SaveTextureNamesToStream(s: TStream);
var
  stNames: TDXStringList;
  TNames: string;
  i, iLen: integer;
begin
  stNames := TDXStringList.Create;
  try
    if Textures.Count > 0 then
    begin
      GetTextureNames(stNames);
      TNames := stNames.Text;
    end
    else
      TNames := '';
  finally
    stNames.Free;
  end;
  iLen := Length(TNames);
  s.Write(iLen, SizeOf(iLen));
  for i := 1 to iLen do s.Write(TNames[i], 1);
end;

{$IFDEF DESIGNER}
procedure TD3DScene.TransferToDirectory(FileName: string; picExt: string);
{ ּופבצןס ףו ךבפכןדן.
  ֱנןטחךו‎וי פחם ףךחם ףפן בסקון FileName ךבי לופבצסוי כב פב בנבססבפחפב
  בסקוב ףפןם ךבפכןדן פןץ FileName }
var
  fOldMuted: boolean;
  f: TFileStream;
  i: integer;
  oldPos: integer;
  s: TDXStringList;
  obj: TObject;
begin
  fOldMuted := Muted;
  Muted := True;
  ForceDirectories(ExtractFilePath(FileName));
  CreateBackUpFile(FileName);
  f := TFileStream.Create(FileName, fmCreate or fmShareDenyWrite);
  try
    SaveSignatureToStream(f);
    SaveTextureNamesToDirectory(f, ExtractFilePath(FileName), picExt);
    SaveDataToStream(f);
  finally
    f.Free;
  end;
  for i := 0 to _CacheNestedScenes.Count - 1 do
{    (_CacheNestedScenes.Objects[i] as TD3DScene).SaveToFile(
      ExtractFilePath(FileName) + ExtractFileName((_CacheNestedScenes.Objects[i] as TD3DScene).Info.PathToScene));}
    (_CacheNestedScenes.Objects[i] as TD3DScene).TransferToDirectory(
      ExtractFilePath(FileName) + ExtractFileName((_CacheNestedScenes.Objects[i] as TD3DScene).Info.PathToScene),
        picExt);
  for i := 0 to Streams.Count - 1 do
  begin
    f := TFileStream.Create(
      ExtractFilePath(FileName) + ExtractFileName(Streams.Strings[i]), fmCreate or fmShareDenyWrite);
    try
      obj := Streams.Objects[i];
      oldPos := (obj as TStream).Position;
      f.CopyFrom(obj as TStream, 0);
      (obj as TStream).Position := oldPos;
    finally
      f.Free;
    end;
  end;
  for i := 0 to _CachePlugIns.Count - 1 do
  begin
    obj := _CachePlugIns.Objects[i];
    CopyFile(
      GetExistedFileName((obj as TD3DPlugIn).Info.dll),
      ExtractFilePath(FileName) + ExtractFileName((obj as TD3DPlugIn).Info.dll),
      False);
  end;

  s := TDXStringList.Create;
  try
    for i := 0 to Scripts.Count - 1 do
    begin
      s.Text := (Scripts.Objects[i] as TScript).Text;
      s.SaveToFile(ExtractFilePath(FileName) + ExtractFileName(Scripts.Strings[i]));
    end;
  finally
    s.Free;
  end;

  Muted := fOldMuted;
end;
{$ENDIF}

procedure TD3DScene.SaveToStream(s: TStream);
{$IFNDEF NO_D3DSOUNDS}
var
  fOldMuted: boolean;
{$ENDIF}
begin
{$IFNDEF NO_D3DSOUNDS}
  fOldMuted := Muted;
  Muted := True;
{$ENDIF}
  SaveSignatureToStream(s);
  SaveTextureNamesToStream(s);
  SaveDataToStream(s);
{$IFNDEF NO_D3DSOUNDS}
  Muted := fOldMuted;
{$ENDIF}
end;

{$IFDEF NO_D3DEXTRARTLPOLYGONS}
{$IFDEF NO_D3DGENERICRTLPOLYGONS}
{$DEFINE NO_RTLPOLYGONS}
{$ENDIF}
{$ENDIF}

procedure TD3DScene.SaveDataToStream(s: TStream);
var
  id: byte;
  count, i, j: integer;
  str: string;
  stNames: TDXStringList;
  len: byte;
  c: char;
  cs: TCriticalSection;
{$IFNDEF NO_D3DEXTRARTLPOLYGONS}
  ntx: smallint;
{$ENDIF}
{$IFNDEF NO_RTLPOLYGONS}
  TexRTLNames: TTextureNames;
{$ENDIF}

  procedure WriteTextureName(TexName: string);
  var
    indx: smallInt;
  begin
    if TexName = '' then
    begin
      indx := 0;
      s.Write(indx, SizeOf(indx));
    end
    else
    begin
      indx := 1;
      s.Write(indx, SizeOf(indx));
      indx := stNames.IndexOf(TexName);
      s.Write(indx, SizeOf(indx));
      indx := -1;
      s.Write(indx, SizeOf(indx));
    end;
  end;

  procedure WriteTextureNames(TexNames: PTextureNames; var numTextures: SmallInt);
  var
    local_i: integer;
    indx: smallInt;
  begin
    numTextures := GetNumTextures(TexNames);
    s.Write(numTextures, SizeOf(numTextures));
    if numTextures > 0 then
      for local_i := 0 to numTextures - 1 do
      begin
        indx := stNames.IndexOf(TexNames[local_i, 0]);
        s.Write(indx, SizeOf(indx));
        indx := stNames.IndexOf(TexNames[local_i, 1]);
        s.Write(indx, SizeOf(indx));
      end;
  end;

  procedure WriteRTLTextureNames(TexNames: PTextureNames; numTextures: SmallInt);
  var
    local_i: integer;
    indx: smallInt;
  begin
    s.Write(numTextures, SizeOf(numTextures));
    if numTextures > 0 then
      for local_i := 0 to numTextures - 1 do
      begin
        indx := stNames.IndexOf(TexNames[local_i, 0]);
        s.Write(indx, SizeOf(indx));
        indx := stNames.IndexOf(TexNames[local_i, 1]);
        s.Write(indx, SizeOf(indx));
      end;
    end;

begin
  cs := TCriticalSection.Create;
  try
    cs.Enter;
    stNames := TDXStringList.Create;
    if Textures.Count > 0 then
      GetTextureNames(stNames);
    count := 0;
    for i := 0 to Surfaces.Count - 1 do
      if (Surfaces.Objects[i] as TD3DObject).Saveable then
        inc(count);
    s.Write(count, SizeOf(count));
    for i := 0 to count - 1 do if (Surfaces.Objects[i] as TD3DObject).Saveable then
    begin
{$IFNDEF NO_MESSAGESCAN}
      MessageScan;
{$ENDIF}
      id := (Surfaces.Objects[i] as TD3DObject).GetTypeID;
      s.Write(id, SizeOf(id));
      if id = ID3D_Quadrangle then
        WriteTextureName((Surfaces.Objects[i] as TD3DObject).TextureName)
{$IFNDEF NO_D3DTRIANGLES}
      else if id = ID3D_Triangle then
        WriteTextureName((Surfaces.Objects[i] as TD3DObject).TextureName)
{$ENDIF}
{$IFNDEF NO_D3DSTUBOBJECTS}
      else if id = ID3D_StubObject then
        with (Surfaces.Objects[i] as TD3DStubObject).Info do
          WriteTextureNames(@TextureNames, numTextures)
{$ENDIF}
{$IFNDEF NO_D3DEXOBJECTS}
      else if id = ID3D_ExObject then
        with (Surfaces.Objects[i] as TD3DExObject).Info do
          WriteTextureNames(@TextureNames, numTextures)
{$ENDIF}
      else if id = ID3D_Polygon then
        with (Surfaces.Objects[i] as TD3DPolygon).Info2 do
          WriteTextureNames(@TextureNames, numTextures)
{$IFNDEF NO_D3DPROCEDURALOBJECTS}
      else if id = ID3D_ProceduralObject then
        with (Surfaces.Objects[i] as TD3DProceduralObject).Info do
          WriteTextureNames(@TextureNames, numTextures)
{$ENDIF}
{$IFNDEF NO_D3DACTORS}
      else if id = ID3D_Actor then
        with (Surfaces.Objects[i] as TD3DActor).Info do
          WriteTextureNames(@TextureNames, numTextures)
{$ENDIF}
{$IFNDEF NO_D3DBILLBOARDS}
      else if id = ID3D_BillBoard then
        with (Surfaces.Objects[i] as TD3DBillBoard).Info do
          WriteTextureNames(@TextureNames, numTextures)
{$ENDIF}
{$IFNDEF NO_D3DCUBES}
      else if id = ID3D_Cube then
        with (Surfaces.Objects[i] as TD3DCube).Info do
          WriteTextureNames(@TextureNames, numTextures)
{$ENDIF}
{$IFNDEF NO_D3DSPHERES}
      else if id = ID3D_Sphere then
        with (Surfaces.Objects[i] as TD3DSphere).Info do
          WriteTextureNames(@TextureNames, numTextures)
{$ENDIF}
{$IFNDEF NO_D3DCONES}
      else if id = ID3D_Cone then
        with (Surfaces.Objects[i] as TD3DCone).Info do
          WriteTextureNames(@TextureNames, numTextures)
{$ENDIF}
{$IFNDEF NO_D3DCYLINDERS}
      else if id = ID3D_Cylinder then
        with (Surfaces.Objects[i] as TD3DCylinder).Info do
          WriteTextureNames(@TextureNames, numTextures)
{$ENDIF}
{$IFNDEF NO_D3DTEXTS}
      else if id = ID3D_Text then
        with (Surfaces.Objects[i] as TD3DText).Info do
          WriteTextureNames(@TextureNames, numTextures)
{$ENDIF}
{$IFNDEF NO_D3DPLUGINS}
      else if id = ID3D_PlugIn then
        WriteTextureName((Surfaces.Objects[i] as TD3DPlugIn).Info.TextureName)
{$ENDIF}
{$IFNDEF NO_D3DRINGS}
      else if id = ID3D_Ring then
        with (Surfaces.Objects[i] as TD3DRing).Info do
          WriteTextureNames(@TextureNames, numTextures)
{$ENDIF}
{$IFNDEF NO_D3DGENERICRTLPOLYGONS}
      else if id = ID3D_GenericRTLPolygon then
      begin
        TexRTLNames[0, 0] := (Surfaces.Objects[i] as TD3DGenericRTLPolygon).TextureName;
        TexRTLNames[0, 1] := (Surfaces.Objects[i] as TD3DGenericRTLPolygon).TextureName2;
        WriteRTLTextureNames(@TexRTLNames, 1);
      end
{$ENDIF}
{$IFNDEF NO_D3DEXTRARTLPOLYGONS}
      else if id = ID3D_ExtraRTLPolygon then
      begin
        with (Surfaces.Objects[i] as TD3DExtraRTLPolygon) do
        begin
          ntx := NumTextures;
          TexRTLNames := TextureNames;
          WriteTextureNames(@TexRTLNames, ntx);
        end;
      end
{$ENDIF}
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
      else if id = ID3D_SectorCollection then
      begin
      end
{$ENDIF}
      else if id = ID3D_Scene then
      begin
        for j := 1 to Length((Surfaces.Objects[i] as TD3DScene).Info.PathToScene) do
          s.Write((Surfaces.Objects[i] as TD3DScene).Info.PathToScene[j], 1);
        c := #0;
        s.Write(c, 1);
        // Hack: PathToScene must be the last field of record Info ->
        s.Write((Surfaces.Objects[i] as TD3DScene).Info,
          SizeOf((Surfaces.Objects[i] as TD3DScene).Info) -
          SizeOf((Surfaces.Objects[i] as TD3DScene).Info.PathToScene));
      end;
      if (id <> ID3D_Scene) then
        (Surfaces.Objects[i] as TD3DObject).SaveToStream(s);
    end;

    stNames.Free;
  // ֳסצןץלו פןם בסיטל פשם קשם

{$IFNDEF NO_D3DSOUNDS}
    count := Sounds.Count;
    s.Write(count, SizeOf(count));
    for i := 0 to Count - 1 do
    begin
      id := (Sounds.Objects[i] as TD3DBaseAudio).GetTypeID;
      s.Write(id, SizeOf(id));
      if id = ID3D_Sound then
      begin
      // ֳסצןץלו פן םןלב פןץ קןץ
        str := Sounds.Strings[i];
        len := Length(str);
        s.Write(len, SizeOf(len));
        for j := 1 to len do s.Write(str[j], SizeOf(Char));
        (Sounds.Objects[i] as TD3DBaseAudio).SaveToStream(s);
      end
      else if id = ID3D_Tone then
        (Sounds.Objects[i] as TD3DBaseAudio).SaveToStream(s);
    end;
{$ELSE}
    count := 0;
    s.Write(count, SizeOf(count));
{$ENDIF}

    Count := CustomData.Count;
    s.Write(Count, SizeOf(Count));
    for i := 0 to Count - 1 do
    begin
    // ֳסצןץלו פן םןלב פןץ CustomData
      str := CustomData.Strings[i];
      len := Length(str);
      s.Write(len, SizeOf(len));
      for j := 1 to len do s.Write(str[j], SizeOf(Char));
      (CustomData.Objects[i] as TCustomData).SaveToStream(s);
    end;

{$IFNDEF NO_SCRIPTS}
    count := Scripts.Count;
    s.Write(count, SizeOf(count));
    for i := 0 to Count - 1 do
    begin
    // ֳסצןץלו פן םןלב פןץ Script
      str := Scripts.Strings[i];
      len := Length(str);
      s.Write(len, SizeOf(len));
      for j := 1 to len do s.Write(str[j], SizeOf(Char));
      (Scripts.Objects[i] as TScript).SaveToStream(s);
    end;
    count := 0;
{$ELSE}
    count := 0;
    s.Write(count, SizeOf(count));
{$ENDIF}

    for i := 0 to Actions.Count - 1 do
      if not (Actions.Objects[i] as TD3DAction).RunTimeOnly then
        inc(count);

    s.Write(count, SizeOf(count));
    for i := 0 to Actions.Count - 1 do
      if not (Actions.Objects[i] as TD3DAction).RunTimeOnly then
        (Actions.Objects[i] as TD3DAction).SaveToStream(s);

    count := Lights.Count;
    s.Write(count, SizeOf(count));
    for i := 0 to Count - 1 do
      (Lights.Objects[i] as TD3DSceneLight).SaveToStream(s);
  finally
    cs.Leave;
    cs.Free;
  end;
end;

function TD3DScene.GetExistedResourceEntry(s: TFileName): TFileName;
begin
  Result := RTLGetExistedResourceEntry(s);
end;

// ׀סןףנבטו םב וםפןנףוי פן s ףפן הףךן
function TD3DScene.GetExistedFileName(s: TFileName): TFileName;
var
  i: integer;
  strim: string;
  stmp: string;
  i_pos: integer;
begin
  Result := s;
  if Result = EmptyStr then
    Exit;
  if IsSpecialTextureName(s) then
    Exit;
  if FileExists(Result) then
    Exit;

  i_pos := Pos('::', Result);
  if i_pos > 0 then
    s := Copy(Result, i_pos + 2, Length(Result) - i_pos - 1);

  strim := TrimStr(s);
  Result := ExpandFileName(strim);
// OK, פן בסקון ץנסקוי
  if FileExists(Result) then
    Exit;
// ״קםןץלו ףפןם ךבפכןדן נןץ ךםבלו פן פוכוץפבן Open Operation
  if fFileName <> '' then
  begin
    Result :=
      SafeAddSlash(ExtractFilePath(fFileName)) +
        ExtractFileName(strim);
    if FileExists(Result) then
      Exit;

    Result :=
      SafeAddSlash(ExtractFilePath(fFileName)) + strim;
    if FileExists(Result) then
      Exit;
  end;
// ״קםןץלו ףפן פסקןם directory
  Result := ExtractFileName(strim);
  if FileExists(Result) then
    Exit;
// ״קםןץלו ףפן directory פחע וצבסלןדע
  Result :=
    SafeAddSlash(ExtractFilePath(ParamStr(0))) +
      ExtractFileName(s);
  if FileExists(Result) then
    Exit;
  for i := 0 to SearchPaths.Count - 1 do
  begin
    stmp := SearchPaths.Strings[i];

    Result := stmp + ExtractFileName(strim);
    if FileExists(Result) then
      Exit;

    Result := stmp + strim;
    if FileExists(Result) then
      Exit;

  end;
  for i := 0 to _CacheNestedScenes.Count - 1 do
  begin
    Result :=
      SafeAddSlash(ExtractFilePath((_CacheNestedScenes.Objects[i] as TD3DScene).Info.PathToScene)) +
        ExtractFileName(strim);
    if FileExists(Result) then
      Exit;

    Result :=
      SafeAddSlash(ExtractFilePath((_CacheNestedScenes.Objects[i] as TD3DScene).Info.PathToScene)) +
        strim;
    if FileExists(Result) then
      Exit;

  end;
{$IFNDEF NO_D3DPLUGINS}
  for i := 0 to _CachePlugIns.Count - 1 do
  begin
    Result :=
      SafeAddSlash(ExtractFilePath((_CachePlugIns.Objects[i] as TD3DPlugIn).Info.DLL)) +
        ExtractFileName(strim);
    if FileExists(Result) then
      Exit;

    Result :=
      SafeAddSlash(ExtractFilePath((_CachePlugIns.Objects[i] as TD3DPlugIn).Info.DLL)) +
        strim;
    if FileExists(Result) then
      Exit;

  end;
{$ENDIF}
// ״קםןץלו ףפב 4 Parent directories
  for i := 1 to 4 do
  begin
    Result := rsParentDir + strim;
    if FileExists(Result) then
      Exit;

    Result := rsParentDir + ExtractFileName(strim);
    if FileExists(Result) then
      Exit;
  end;
// װכןע, הום גסטחךו פוכיך, Result = בסקיך filename
  if Pos(':', s) = 0 then
    Result := s
  else
  begin
    Result := GetExistedFileName(Copy(s, Pos(':', s), Length(s) - Pos(':', s)));
    if (Result = EmptyStr) or (not FileExists(Result)) then
      Result := s;
  end;
end;

// ׀סןףנבטו םב וםפןנףוי פן s ףפן WAD
function TD3DScene.GetExistedWadEntry(s: TFileName): TFileName;
var
  Entries: TDXStringList;
  i: integer;
  sName: string;
begin
  Result := Trim(s);
  if Result = EmptyStr then
    Exit;
  if InvokeWAD and (Wad <> nil) then
  begin
    Entries := TDXStringList.Create;
    try
      Wad.GetEntries(Entries);
      if Entries.IndexOf(s) = - 1 then
      begin
        sName := UpperCase(ExtractFileName(s));
        for i := 0 to Entries.Count - 1 do
          if UpperCase(ExtractFileName(Entries.Strings[i])) = sName then
          begin
            Result := Entries.Strings[i];
            break;
          end;
      end;
    finally
      Entries.Free;
    end;
  end;
end;

procedure TD3DScene.AddSearchPath(const PathName: string; const doPrime: boolean = False);
begin
  if SearchPaths.IndexOf(PathName) < 0 then
  begin
    if doPrime then
      SearchPaths.Insert(0, SafeAddSlash(PathName))
    else
      SearchPaths.Add(SafeAddSlash(PathName));
  end;
end;

{$IFNDEF NO_GLOBALID}
procedure TD3DScene.AdjustGlobalID;
var
  i, id: integer;
begin
  if not fAttached and (fParent = nil) then
    GlobalID := 0;
  for i := 0 to Surfaces.Count - 1 do
  begin
    id := (Surfaces.Objects[i] as TD3DObject).GetKeyID;
    if id > GlobalID then
      GlobalID := id;
  end;
{$IFNDEF NO_D3DSOUNDS}
  for i := 0 to Sounds.Count - 1 do
  begin
    id := (Sounds.Objects[i] as TD3DBaseAudio).GetKeyID;
    if id > GlobalID then
      GlobalID := id;
  end;
{$ENDIF}
  for i := 0 to CustomData.Count - 1 do
  begin
    id := (CustomData.Objects[i] as TCustomData).GetKeyID;
    if id > GlobalID then
      GlobalID := id;
  end;
  for i := 0 to Lights.Count - 1 do
  begin
    id := (Lights.Objects[i] as TD3DSceneLight).GetKeyID;
    if id > GlobalID then
      GlobalID := id;
  end;
{$IFNDEF NO_SCRIPTS}
  for i := 0 to Scripts.Count - 1 do
  begin
    id := (Scripts.Objects[i] as TScript).GetKeyID;
    if id > GlobalID then
      GlobalID := id;
  end;
{$ENDIF}
end;
{$ENDIF}

procedure TD3DScene.LoadFromFile(s: string);
var
  f: TFileStream;
{$IFDEF DESIGNER}
  oldCanSaveUndo: boolean;
{$ENDIF}
begin
{$IFDEF DESIGNER}
  ClearUndoRedo;
  oldCanSaveUndo := CanSaveUndo;
  CanSaveUndo := False;
{$ENDIF}
  fFileName := GetExistedFileName(s);
//  f := TFileStream.Create(fFileName, fmOpenRead);
  f := TCachedFileStream.Create(fFileName, fmOpenRead);
  try
    LoadFromStream(f, FILEVERSION);
    fModified := False;
  finally
    f.free;
  end;
  fStartTime := GetTickCount/1000;
  fLastTime := - 2 * fUpdateTolerance; // ¿ףפו םב דםוי recalc ךבפ פחם נס‏פח צןס
{$IFNDEF NO_GLOBALID}
  AdjustGlobalID;
{$ENDIF}
{$IFDEF DESIGNER}
  CanSaveUndo := oldCanSaveUndo;
{$ENDIF}
end;

procedure TD3DScene.AppendFromFile(s: string;
      x: TD3DValue=0; y:TD3DValue=0; z: TD3DValue=0;
      dx: TD3DValue=0; dy:TD3DValue=0; dz: TD3DValue=0);
var
  f: TFileStream;
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  fFileName := GetExistedFileName(s);
  f := TCachedFileStream.Create(fFileName, fmOpenRead);
  try
    AppendFromStream(f, x, y, z, dx, dy, dz);
    fModified := True;
  finally                        
    f.free;
  end;
end;

procedure TD3DScene.SaveToFile(s: string);
var
  f: TFileStream;
begin
  CreateBackupFile(s, rsD3DBackupExtention);
  fFileName := s;
  f := TFileStream.Create(fFileName, fmCreate);
  try
    SaveToStream(f);
    fModified := False;
  finally
    f.free;
  end;
end;

procedure TD3DScene.LoadFromWADStream(strm: TStream; const pos, size: integer; map: string = TmpFileName);
var
  Stream, Stream1: TStream;
begin
  fFileName := '';
  FreeAndNilSafe(Wad);
  strm.Seek(pos, soFromBeginning);
{  Stream1 := TMemoryStream.Create;
  try
    Stream1.CopyFrom(strm, size);  }
  Stream1 := TSubStream.Create(strm, pos, size);
  try
    Stream1.Position := 0;
    WAD := TWad.CreateFromStream(Stream1);
    InvokeWAD := True;
    Stream := TMemoryStream.Create;
    try
      WAD.CopyToStream(GetExistedWadEntry(map), Stream);
      LoadFromStream(Stream, FILEVERSION);
      fModified := False;
    finally
      Stream.Free;
    end;
    InvokeWAD := False;
    FreeAndNilSafe(Wad);
  finally
    Stream1.Free;
  end;
  fStartTime := GetTickCount/1000;
  fLastTime := - 2 * fUpdateTolerance; // ¿ףפו םב דםוי recalc ךבפ פחם נס‏פח צןס
{$IFNDEF NO_GLOBALID}
  AdjustGlobalID;
{$ENDIF}
end;

function TD3DScene.LoadFrom(s: string): boolean;
var
  WADFileName,
  Entry: string;
{$IFDEF DESIGNER}
  oldCanSaveUndo: boolean;
  doit: boolean;
{$ENDIF}
begin
{$IFDEF DESIGNER}
  if Assigned(fOnSceneLoadFrom) then
  begin
    fOnSceneLoadFrom(self, s, doit);
    if not doit then
    begin
      Result := False;
      Exit;
    end;
  end;
  ClearUndoRedo;
  oldCanSaveUndo := CanSaveUndo;
  CanSaveUndo := False;
{$ENDIF}
  Result := True;
  if GetWADLinkInfo(s, WADFileName, Entry) then
  begin
    if FileExists(WADFileName) then
      LoadFromWADFile(WADFileName, Entry)
    else
      Result := False;
  end
  else if UpperCase(ExtractFileExt(fFileName)) = UpperCase(rsDefaultWADExtention) then
  begin
    if FileExists(GetExistedFileName(fFileName)) then
      LoadFromWADFile(GetExistedFileName(fFileName), s)
    else
      Result := False;
  end
  else if FileExists(GetExistedFileName(s)) then
    LoadFromFile(GetExistedFileName(s))
  else
    Result := False;
{$IFDEF DESIGNER}
  if Result then
    if Assigned(fOnSceneNotifyLoad) then
      fOnSceneNotifyLoad(self);
  CanSaveUndo := oldCanSaveUndo;
{$ENDIF}
end;

procedure TD3DScene.LoadFromWADFile(s: string; map: string = TmpFileName);
var
  Stream: TStream;
{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_DOOMSUPPORT}
  WADType: TIDSoftWADType;
{$ENDIF}
{$ENDIF}
{$IFDEF DESIGNER}
  oldCanSaveUndo: boolean;
{$ENDIF}
begin
{$IFDEF DESIGNER}
  ClearUndoRedo;
  oldCanSaveUndo := CanSaveUndo;
  CanSaveUndo := False;
{$ENDIF}
  fFileName := GetExistedFileName(s);
{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_DOOMSUPPORT}
  WADType := GetWadType(fFileName);
  if WADType = idVJ then
  begin
{$ENDIF}
{$ENDIF}
    FreeAndNilSafe(Wad);
    WAD := TWad.CreateFromFile(fFileName);
    InvokeWAD := True;
    Stream := TMemoryStream.Create;
    try
      WAD.CopyToStream(GetExistedWadEntry(map), Stream);
      LoadFromStream(Stream, FILEVERSION);
      fModified := False;
    finally
      Stream.Free;
    end;
    InvokeWAD := False;
    FreeAndNilSafe(Wad);
{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_DOOMSUPPORT}
  end
  else if WADType in [idDoom,    { Doom }
                      idHeretic, { Heretic }
                      idHexen,   { Hexen }
                      idStrife,  { Strife }
                      idNew,     { MSADoom }
                      idUnknown] { ֱדם‏ףפןץ פ‎נןץ WAD פחע ID Soft } then
  begin
{$IFNDEF NO_SCRIPTS}
    StopScriptEngine;
{$ENDIF}
    Clear;
    GetMapData(Self, s, s, map, DEFDOOMIMPORTFACTOR, DEFDOOMIMPORTLFACTOR, True);
{$IFNDEF NO_SCRIPTS}
    StartScriptEngine;
{$ENDIF}
    fFileName := '';
  end
  else // Invalid WAD
  begin
    MessageBox(GetFocus, PChar(Format(rsFmtInvalidWAD,[s])), PChar(Application.Title), mb_OK or mb_IconStop);
    Exit;
  end;
{$ENDIF}
{$ENDIF}
  fStartTime := GetTickCount/1000;
  fLastTime := -2 * fUpdateTolerance; // ¿ףפו םב דםוי recalc ךבפ פחם נס‏פח צןס
{$IFNDEF NO_GLOBALID}
  AdjustGlobalID;
{$ENDIF}
{$IFDEF DESIGNER}
  CanSaveUndo := oldCanSaveUndo;
{$ENDIF}
end;

procedure TD3DScene.AppendFromWADFile(s: string;
      x: TD3DValue=0; y:TD3DValue=0; z: TD3DValue=0;
      dx: TD3DValue=0; dy:TD3DValue=0; dz: TD3DValue=0;
      map: string = TmpFileName);
var
  Stream: TStream;
{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_DOOMSUPPORT}
  WADType: TIDSoftWADType;
{$ENDIF}
{$ENDIF}
begin
{$IFDEF DESIGNER}
  SaveUndo;
{$ENDIF}
  s := GetExistedFileName(s);
{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_DOOMSUPPORT}
  WADType := GetWadType(s);
  if WADType = idVJ then
  begin
{$ENDIF}
{$ENDIF}
    FreeAndNilSafe(Wad);
    WAD := TWad.CreateFromFile(s);
    InvokeWAD := True;
    Stream := TMemoryStream.Create;
    try
      WAD.CopyToStream(GetExistedWADEntry(map), Stream);
      AppendFromStream(Stream, x, y, z, dx, dy, dz);
      fModified := True;
    finally
      Stream.Free;
    end;
    InvokeWAD := False;
    FreeAndNilSafe(Wad);
{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_DOOMSUPPORT}
  end
  else if WADType in [idDoom,    { Doom }
                      idHeretic, { Heretic }
                      idHexen,   { Hexen }
                      idStrife,  { Strife }
                      idNew,     { MSADoom }
                      idUnknown] { ֱדם‏ףפןץ פ‎נןץ WAD פחע ID Soft } then
    GetMapData(Self, s, s, map, DEFDOOMIMPORTFACTOR, DEFDOOMIMPORTLFACTOR, True)
  else // Invalid WAD
    MessageBox(GetFocus, PChar(Format(rsFmtInvalidWAD,[s])), PChar(Application.Title), mb_OK or mb_IconStop);
{$ENDIF}
{$ENDIF}
{$IFNDEF NO_GLOBALID}
  AdjustGlobalID;
{$ENDIF}
end;

procedure TD3DScene.GetNested3DEntries(s: TDXStringList);
var
  i: integer;
  obj: TObject;
begin
  for i := 0 to Surfaces.Count - 1 do
  begin
    obj := Surfaces.Objects[i];
    if (obj as TD3DObject).GetTypeID = ID3D_Scene then
    begin
(*
      for j := 0 to CustomData.Count - 1 do
        if s.IndexOf(GetExistedFileName(CustomData.Strings[j])) = -1 then
          s.Add(GetExistedFileName(CustomData.Strings[j]));
{$IFNDEF NO_SCRIPTS}
      for j := 0 to Scripts.Count - 1 do
        if s.IndexOf(GetExistedFileName(Scripts.Strings[j])) = -1 then
          s.Add(GetExistedFileName(Scripts.Strings[j]));
{$ENDIF}
*)
       if s.IndexOf(UpperCase(GetExistedFileName((obj as TD3DScene).Info.PathToScene))) = -1 then
         s.Add(UpperCase(GetExistedFileName((obj as TD3DScene).Info.PathToScene)));
       (obj as TD3DScene).GetDefaultWADEntries(s);
       (obj as TD3DScene).GetNested3DEntries(s);
    end;
  end;
{    begin
      if s.IndexOf(GetExistedFileName(SC.Surfaces.Strings[i])) = -1 then
      begin
        s.Add(GetExistedFileName(SC.Surfaces.Strings[i]));
        GetNested3DEntries(s, SC.Surfaces.Objects[i] as TD3DScene)
      end;
    end;}
end;

procedure TD3DScene.GetDefaultWADEntries(s: TDXStringList);
var
  i: integer;
begin
  for i := 0 to Textures.Count - 1 do
    if s.IndexOf(Textures.Strings[i]) = -1 then
      if s.IndexOf(GetExistedFileName(Textures.Strings[i])) = -1 then
        // ּנןסו םב וםבי WAD link  DLL link
        if pos('::', Textures.Strings[i]) = 0 then
          if FileExists(GetExistedFileName(Textures.Strings[i])) then
            s.Add(Textures.Strings[i]);
{$IFNDEF NO_D3DACTORS}
  for i := 0 to Models.Count - 1 do
    if s.IndexOf(Models.Strings[i]) = -1 then
      if s.IndexOf(GetExistedFileName(Models.Strings[i])) = -1 then
        s.Add(Models.Strings[i]);
{$ENDIF}
{$IFNDEF NO_D3DSOUNDS}
  for i := 0 to Waves.Count - 1 do
    if s.IndexOf(Waves.Strings[i]) = -1 then
      if s.IndexOf(GetExistedFileName(Waves.Strings[i])) = -1 then
        s.Add(Waves.Strings[i]);
{$ENDIF}
  for i := 0 to CustomData.Count - 1 do
    if s.IndexOf(CustomData.Strings[i]) = -1 then
      if s.IndexOf(GetExistedFileName(CustomData.Strings[i])) = -1 then
        s.Add(CustomData.Strings[i]);
{$IFNDEF NO_SCRIPTS}
  for i := 0 to Scripts.Count - 1 do
    if s.IndexOf(Scripts.Strings[i]) = -1 then
      if s.IndexOf(GetExistedFileName(Scripts.Strings[i])) = -1 then
        s.Add(Scripts.Strings[i]);
{$ENDIF}
end;

procedure TD3DScene.SaveToWADFile(s: string; map: string = TmpFileName;
  cmp: TCompressionLevel = clDefault; EntriesToSave: TDXStringList = nil);
var
  nodes: TDXStringList;
  m: TMemoryStream;
begin
  CreateBackupFile(s, rsWADBackupExtention);
  if FileExists(s) then
    DeleteFile(s);
  fFileName := s;
  nodes := TDXStringList.Create;
  try
    if Assigned(EntriesToSave) then
      nodes.AddStrings(EntriesToSave)
    else
    begin
  // ֱם פן EntriesToSave = nil פפו ף‏זןץלו ףפן WAD כב פב בסקוב
      GetDefaultWADEntries(nodes);
      GetNested3DEntries(nodes);
    end;
    if map[2] + map[3] <> ':\' then
      map := 'C:\' + map;
    if not IsMap(map) then
      map := map + rsDefaultD3DExtention;
    m := TMemoryStream.Create;
    try
      SaveToStream(m);
      UpdateWadFile(fFileName, map, m, 0, cmp, OnWadProgress);
    finally
      m.Free;
    end;
    AppendWadFile(fFileName, nodes, 0, cmp, OnWadProgress);
    fModified := False;
  finally
    nodes.Free;
  end;
end;

procedure TD3DScene.AppendToWADFile(s: string; map: string = TmpFileName;
  cmp: TCompressionLevel = clDefault; EntriesToSave: TDXStringList = nil);
var
  nodes: TDXStringList;
  m: TMemoryStream;
begin
  CreateBackupFile(s, rsWADBackupExtention);
  fFileName := GetExistedFileName(s);
  nodes := TDXStringList.Create;
  try
    if Assigned(EntriesToSave) then
      nodes.AddStrings(EntriesToSave)
    else
    begin
  // ֱם פן EntriesToSave = nil פפו ף‏זןץלו ףפן WAD כב פב בסקוב
      GetDefaultWADEntries(nodes);
      GetNested3DEntries(nodes);
//      GetWADEntries(nodes);
    end;
  // םןץלו Append פןץע קןץע & פב textures & פב CustomData & פב Scripts
  // ֱם ץנסקןץם הח ףפן WAD הום פב וםחלוס‏םןץלו
    AppendWadFile(fFileName, nodes, 0, cmp, OnWadProgress);

    if map[2] + map[3] <> ':\' then
      map := 'C:\' + map;
    if not IsMap(map) then
      map := map + rsDefaultD3DExtention;
    m := TMemoryStream.Create;
    try
      SaveToStream(m);
      UpdateWadFile(fFileName, map, m, 0, cmp, OnWadProgress);
    finally
      m.Free;
    end;
    fModified := False;
  finally
    nodes.Free;
  end;
end;

// Custom װבמיםלחףח וניצבםי‏ם בםכןדב לו פן zOrder (ײטםןץףב פבמיםלחףח)
function SortZOrder(s: TStringList; Index1, Index2: Integer): Integer; register;
var
  zDiff: single;
begin
  zDiff := (s.Objects[Index1] as TD3DObject).Distance -
           (s.Objects[Index2] as TD3DObject).Distance;
  if zDiff > 0 then
      Result := -1
  else if zDiff < 0 then
    Result := 1
  else Result := 0;
end;

{$IFNDEF NO_D3DBILLBOARDS}
// Custom װבמיםלחףח וניצבםי‏ם בםכןדב לו פן בם וםבי ןסזןםפבע  קי
function SortBillBoard(s: TStringList; Index1, Index2: Integer): Integer; register;
var
  zDiff: integer;
begin
  if (s.Objects[Index1] is TD3DBillBoard) then
  begin
    if (s.Objects[Index2] is TD3DBillBoard) then
      zDiff := (s.Objects[Index1] as TD3DBillBoard).Info.zOrder -
               (s.Objects[Index2] as TD3DBillBoard).Info.zOrder
    else
      zDiff := 1
  end
  else
  begin
    if (s.Objects[Index2] is TD3DBillBoard) then
      zDiff := -1
    else
      zDiff := 0;
  end;
  if zDiff > 0 then
      Result := -1
  else if zDiff < 0 then
    Result := 1
  else Result := 0;
end;
{$ENDIF}

{$IFNDEF NO_SCRIPTS}
// Custom װבמיםלחףח פשם scripts בםכןדב לו פן Key (ֱ‎מןץףב פבמיםלחףח)
function SortScriptKeyProc(s: TStringList; Index1, Index2: Integer): Integer; register;
var
  zDiff: single;
begin
  zDiff := (s.Objects[Index1] as TScript).GetKeyID -
           (s.Objects[Index2] as TScript).GetKeyID;
  if zDiff > 0 then
      Result := 1
  else if zDiff < 0 then
    Result := -1
  else Result := 0;
end;
{$ENDIF}

// Custom װבמיםלחףח פשם objects בםכןדב לו פן לדוטע פןץע
function SortObjectSizeProc(s: TStringList; Index1, Index2: Integer): Integer; register;
var
  zDiff: single;
begin
  zDiff := (s.Objects[Index1] as TD3DObject).Radius -
           (s.Objects[Index2] as TD3DObject).Radius;
  if zDiff > 0 then
      Result := -1
  else if zDiff < 0 then
    Result := 1
  else Result := 0;
end;

// Custom װבמיםלחףח פשם objects בםכןדב לו פן Key (ֱ‎מןץףב פבמיםלחףח)
function SortObjectKeyProc(s: TStringList; Index1, Index2: Integer): Integer; register;
var
  zDiff: single;
begin
{$IFNDEF NO_D3DBILLBOARDS}
  if (s.Objects[Index1] is TD3DBillBoard) then
  begin
    if (s.Objects[Index2] is TD3DBillBoard) then
      zDiff := (s.Objects[Index1] as TD3DBillBoard).Info.zOrder -
               (s.Objects[Index2] as TD3DBillBoard).Info.zOrder
    else
      zDiff := 1
  end
  else
  begin
    if (s.Objects[Index2] is TD3DBillBoard) then
      zDiff := -1
    else
      zDiff := 0;
  end;
{$ELSE}
  zDiff := 0;
{$ENDIF}
  if zDiff = 0 then
    zDiff := (s.Objects[Index1] as TD3DObject).GetKeyID -
             (s.Objects[Index2] as TD3DObject).GetKeyID;
  if zDiff > 0 then
      Result := 1
  else if zDiff < 0 then
    Result := -1
  else Result := 0;
end;

// Custom װבמיםלחףח פשם objects בםכןדב לו פן םןלב (ֱ‎מןץףב פבמיםלחףח)
function SortObjectNameProc(s: TStringList; Index1, Index2: Integer): Integer; register;
var
  zDiff: single;
begin
{$IFNDEF NO_D3DBILLBOARDS}
  if (s.Objects[Index1] is TD3DBillBoard) then
  begin
    if (s.Objects[Index2] is TD3DBillBoard) then
      zDiff := (s.Objects[Index1] as TD3DBillBoard).Info.zOrder -
               (s.Objects[Index2] as TD3DBillBoard).Info.zOrder
    else
      zDiff := 1
  end
  else
  begin
    if (s.Objects[Index2] is TD3DBillBoard) then
      zDiff := -1
    else
      zDiff := 0;
  end;
{$ELSE}
  zDiff := 0;
{$ENDIF}
  if zDiff = 0 then
    zDiff := AnsiCompareStr((s.Objects[Index1] as TD3DObject).TextureName,
                            (s.Objects[Index2] as TD3DObject).TextureName);
  if zDiff > 0 then
      Result := 1
  else if zDiff < 0 then
    Result := -1
  else Result := 0;
end;

{$IFNDEF NO_D3DSOUNDS}
// Custom װבמיםלחףח פשם קשם בםכןדב לו פן Key (ֱ‎מןץףב פבמיםלחףח)
function SortSoundsKeyProc(s: TStringList; Index1, Index2: Integer): Integer; register;
var
  zDiff: single;
begin
  zDiff := (s.Objects[Index1] as TD3DBaseAudio).GetKeyID -
           (s.Objects[Index2] as TD3DBaseAudio).GetKeyID;
  if zDiff > 0 then
      Result := 1
  else if zDiff < 0 then
    Result := -1
  else Result := 0;
end;
{$ENDIF}

{$IFNDEF NO_D3DSOUNDS}
// Custom װבמיםלחףח וניצבםי‏ם בםכןדב לו פן zOrder (ײטםןץףב פבמיםלחףח)
function SortSoundsDistanceProc(s: TStringList; Index1, Index2: Integer): Integer; register;
var
  zDiff: single;
begin
  zDiff := (s.Objects[Index1] as TD3DBaseAudio).GetDistance(ActiveScene.Position) -
           (s.Objects[Index2] as TD3DBaseAudio).GetDistance(ActiveScene.Position);
  if zDiff > 0 then
      Result := -1
  else if zDiff < 0 then
    Result := 1
  else Result := 0;
end;
{$ENDIF}

{$IFNDEF NO_D3DSECTORCOLLECTIONS}
procedure TD3DScene.AdjustSectorsPositioning(const oldpos: TD3DVector; var newPos: TD3DVector);
var
  i: integer;
  j: integer;
  acc_ret: integer;
begin
  _NeedsPositionRecalcFromSectorCollection := False;
  j := -1;
  acc_ret := 0;
  if IsIntegerInRange(_CurrentSectorIndex, 0, _CacheSectorCollections.Count - 1) then
    acc_ret := (_CacheSectorCollections.Objects[_CurrentSectorIndex] as TD3DSectorCollection).AcceptPosition(oldpos, newPos);
  if acc_ret > 0 then
    j := _CurrentSectorIndex;
  if j = -1 then
  begin
    for i := 0 to _CacheSectorCollections.Count - 1 do
    begin
      acc_ret := (_CacheSectorCollections.Objects[i] as TD3DSectorCollection).AcceptPosition(oldpos, newpos);
      if acc_ret > 0 then
      begin
        j := i;
        break;
      end;
    end;
  end;
  _NeedsPositionRecalcFromSectorCollection := acc_ret = 2;
  if _NeedsPositionRecalcFromSectorCollection then
    fNeedsRecalc := fNeedsRecalc or fNeedsPositionRecalc;
  if j <> _CurrentSectorIndex then
  begin
    for i := 0 to _CacheSectorCollections.Count - 1 do
      (_CacheSectorCollections.Objects[i] as TD3DSectorCollection).SetIsInsideSector(i = j);
    if j > - 1 then
    begin
      if (_CacheSectorCollections.Objects[j] as TD3DSectorCollection).IsInsideClosedSector then
      begin
        for i := 0 to _CacheSectorCollections.Count - 1 do
          (_CacheSectorCollections.Objects[i] as TD3DSectorCollection).Culled := i <> j;
      end
      else
        for i := 0 to _CacheSectorCollections.Count - 1 do
          (_CacheSectorCollections.Objects[i] as TD3DSectorCollection).Culled := False;
    end
    else
      for i := 0 to _CacheSectorCollections.Count - 1 do
        (_CacheSectorCollections.Objects[i] as TD3DSectorCollection).Culled := False;
    _CurrentSectorIndex := j;
  end;
end;
{$ENDIF}

procedure TD3DScene.SetPosition(Value: TD3DVector);
{$IFNDEF NO_D3DPLUGINS}
var
  i: integer;
{$ENDIF}
begin
{$IFNDEF NO_D3DPLUGINS}
  for i := 0 to _CachePlugIns.Count - 1 do
    (_CachePlugIns.Objects[i] as TD3DPlugIn).AcceptPosition(Value);
{$ENDIF}
  if not VectorEquel(Value, fPosition)
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
     or _NeedsPositionRecalcFromSectorCollection {$ENDIF} then
  begin
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
    AdjustSectorsPositioning(fOldPosition, Value);
{$ENDIF}

    if not VectorEquel(Value, fOldPosition) then
    begin
      fOlderPosition := fOldPosition;
      fOldPosition := fPosition;
      fPosition := Value;
      fNeedsRecalc := fNeedsRecalc or fNeedsPositionRecalc or fNeedsLightRecalc;
{$IFNDEF NO_D3DPLUGINS}
      for i := 0 to _CachePlugIns.Count - 1 do
        (_CachePlugIns.Objects[i] as TD3DPlugIn).NotifyPosition(Value);
{$ENDIF}
{$IFNDEF NO_SCRIPTS}
      RunChildsEvent(ID3D_EVENTONPOSITIONCHANGE, True);
{$ENDIF}
    end;
{ ָפןםפבע ףפן fNeedsRecalc פחם נבסבנםש פיל דםופבי request דיב:
    OptimizeZOrder;
    RotateObjects;
    Update3DSounds;
    CalculatePosition;}
  end;
end;

procedure TD3DScene.ForcePosition(Value: TD3DVector);
{$IFNDEF NO_D3DPLUGINS}
var
  i: integer;
{$ENDIF}
begin
  if not VectorEquel(Value, fOldPosition) then
  begin
    fOlderPosition := fOldPosition;
    fOldPosition := Value; // טפןץלו fOldPosition
    fPosition := Value;
    fNeedsRecalc := fNeedsRecalc or fNeedsPositionRecalc or fNeedsLightRecalc;
{$IFNDEF NO_D3DPLUGINS}
    for i := 0 to _CachePlugIns.Count - 1 do
      (_CachePlugIns.Objects[i] as TD3DPlugIn).NotifyPosition(Value);
{$ENDIF}
{$IFNDEF NO_SCRIPTS}
    RunChildsEvent(ID3D_EVENTONPOSITIONCHANGE, True);
{$ENDIF}
  end;
end;

procedure TD3DScene.SetRotation(Value: TD3DVector);
{$IFNDEF NO_D3DPLUGINS}
var
  i: integer;
{$ENDIF}
begin
{$IFNDEF NO_D3DPLUGINS}
  for i := 0 to _CachePlugIns.Count - 1 do
    (_CachePlugIns.Objects[i] as TD3DPlugIn).AcceptRotation(Value);
  for i := 0 to _CacheSectorCollections.Count - 1 do
    if (_CacheSectorCollections.Objects[i] as TD3DSectorCollection).AcceptRotation(Value) then
      break;
{$ENDIF}
  if not VectorEquel(Value, fRotation) then
  begin
    fOldRotation := fRotation;
    fRotation := MakeD3DVector(
                  GetNormalizeAngle(Value.x),
                  GetNormalizeAngle(Value.y),
                  GetNormalizeAngle(Value.z));
    fNeedsRecalc := fNeedsRecalc or fNeedsRotationRecalc;
{$IFNDEF NO_D3DPLUGINS}
    for i := 0 to _CachePlugIns.Count - 1 do
      (_CachePlugIns.Objects[i] as TD3DPlugIn).NotifyRotation(Value);
{$ENDIF}
{$IFNDEF NO_SCRIPTS}
    RunChildsEvent(ID3D_EVENTONROTATIONCHANGE, True);
{$ENDIF}
{ ָפןםפבע ףפן fNeedsRecalc פחם נבסבנםש פיל דםופבי request דיב:
    RotateObjects;
    Update3DSounds;
    CalculateView;}
  end;
end;

procedure TD3DScene.ForceRotation(Value: TD3DVector);
{$IFNDEF NO_D3DPLUGINS}
var
  i: integer;
{$ENDIF}
begin
  if not VectorEquel(Value, fRotation) then
  begin
    fOldRotation := Value;
    fRotation := MakeD3DVector(
                  GetNormalizeAngle(Value.x),
                  GetNormalizeAngle(Value.y),
                  GetNormalizeAngle(Value.z));
    fNeedsRecalc := fNeedsRecalc or fNeedsRotationRecalc;
{$IFNDEF NO_D3DPLUGINS}
    for i := 0 to _CachePlugIns.Count - 1 do
      (_CachePlugIns.Objects[i] as TD3DPlugIn).NotifyRotation(Value);
{$ENDIF}
{$IFNDEF NO_SCRIPTS}
    RunChildsEvent(ID3D_EVENTONROTATIONCHANGE, True);
{$ENDIF}
  end;
end;

function TD3DScene.GetPosition: TD3DVector;
begin
  Result := VectorAdd(fPosition, MakeD3DVector(Info.x, Info.y, Info.z));
  if fParent <> nil then
    Result := VectorAdd(Result, fParent.Position);
end;

function TD3DScene.GetRotation: TD3DVector;
begin
  Result := VectorAdd(fRotation, MakeD3DVector(Info.dx, Info.dy, Info.dz));
  if fParent <> nil then
    Result := VectorAdd(Result, fParent.Rotation);
end;

procedure TD3DScene.CalculateView;
// ױנןכןדיףלע פןץ ׀םבךב D3DTRANSFORMSTATE_VIEW, לםן פבם <> fAttached
var
  mat: TD3DMatrix;
  dev: IDirect3DDevice7;
begin
  if fAttached then
    Exit;

  dev := DXDraw.D3DDevice7;
  if Assigned(dev) then
  begin
    GetRotationMatrix(mat, Rotation.X, Rotation.Y, Rotation.Z, 0.75);
    mat._44 := fNearClippingPlane; // Near clipping plane
// ¼פבם פן fNearClippingPlane = 0.0 פן z-Buffering הום הןץכו‎וי,
// נסנוי םב דםוי קסףח פחע member function OptimizeZOrder
// דיב פחם בנויךםחףח פשם וניצבםי‏ם ףפחם ףשףפ ףויס
    dev.SetTransform(D3DTRANSFORMSTATE_VIEW, mat);
  end;
end;

procedure TD3DScene.CalculatePosition;
// ױנןכןדיףלע פןץ ׀םבךב D3DTRANSFORMSTATE_WORLD, לםן פבם <> fAttached
var
  matPosition: TD3DMatrix;
  dev: IDirect3DDevice7;
begin
  if fAttached then
    Exit;
  dev := DXDraw.D3DDevice7;
  if Assigned(dev) then
  begin
  // Setup the position Matrix
    FillChar(matPosition, SizeOf(matPosition), 0);
    matPosition._11 :=  1.0;
    matPosition._22 :=  1.0;
    matPosition._33 :=  1.0;
    matPosition._44 :=  1.0;
    matPosition._41 :=  -Position.X;
    matPosition._42 :=  -Position.Y;
    matPosition._43 :=  -Position.Z;
    dev.SetTransform(D3DTRANSFORMSTATE_WORLD, matPosition);
  end;
end;

procedure TD3DScene.ApplyLights;
var
  i, j: integer;
begin
  for i := 0 to Lights.Count - 1 do
    for j := 0 to Surfaces.Count - 1 do
      (Surfaces.Objects[j] as TD3DObject).ApplyLight((Lights.Objects[i] as TD3DSceneLight));
  fNeedsRecalc := fNeedsRecalc and (not fNeedsLightRecalc);
end;

procedure TD3DScene.ApplyLight(l: TD3DSceneLight);
var
  i: integer;
begin
  for i := 0 to Surfaces.Count - 1 do
    (Surfaces.Objects[i] as TD3DObject).ApplyLight(l);
end;

{$IFNDEF NO_D3DSOUNDS}
procedure TD3DScene.PlaySounds(fKey: integer);
var
  i: integer;
  b: boolean;
  obj: TObject;
begin
  for i := 0 to Sounds.Count - 1 do
  begin
    obj := Sounds.Objects[i];
    if (obj as TD3DBaseAudio).GetTypeID = ID3D_Sound then
      if (obj as TD3DBaseAudio).GetKeyID = fKey then
      begin
        b := (obj as TD3DSound).Info.Enabled;
        (obj as TD3DSound).Info.Enabled := True;
        (obj as TD3DSound).Play;
        (obj as TD3DSound).Info.Enabled := b;
      end;
  end;
  for i := 0 to _CacheNestedScenes.Count - 1 do
    (_CacheNestedScenes.Objects[i] as TD3DScene).PlaySounds(fKey);
end;

procedure TD3DScene.PlaySounds(fKey: integer; aPosition: TD3DVector);
var
  i: integer;
  b: boolean;
  obj: TObject;
begin
  for i := 0 to Sounds.Count - 1 do
  begin
    obj := Sounds.Objects[i];
    if (obj as TD3DBaseAudio).GetTypeID = ID3D_Sound then
      if (obj as TD3DSound).GetKeyID = fKey then
      begin
        (obj as TD3DSound).Info.x := aPosition.x;
        (obj as TD3DSound).Info.y := aPosition.y;
        (obj as TD3DSound).Info.z := aPosition.z;
        (obj as TD3DSound).DoRecalc;
        b := (obj as TD3DSound).Info.Enabled;
        (obj as TD3DSound).Info.Enabled := True;
        (obj as TD3DSound).Play;
        (obj as TD3DSound).Info.Enabled := b;
      end;
  end;
  for i := 0 to _CacheNestedScenes.Count - 1 do
    (_CacheNestedScenes.Objects[i] as TD3DScene).PlaySounds(fKey, aPosition);
end;

procedure TD3DScene.PauseSounds(fKey: integer);
var
  i: integer;
  obj: TObject;
begin
  for i := 0 to Sounds.Count - 1 do
  begin
    obj := Sounds.Objects[i];
    if (obj as TD3DBaseAudio).GetTypeID = ID3D_Sound then
      if (obj as TD3DBaseAudio).GetKeyID = fKey then
        (obj as TD3DBaseAudio).Pause;
  end;
  for i := 0 to _CacheNestedScenes.Count - 1 do
    (_CacheNestedScenes.Objects[i] as TD3DScene).PauseSounds(fKey);
end;

procedure TD3DScene.StopSounds(fKey: integer);
var
  i: integer;
  obj: TObject;
begin
  for i := 0 to Sounds.Count - 1 do
  begin
    obj := Sounds.Objects[i];
    if (obj as TD3DBaseAudio).GetTypeID = ID3D_Sound then
      if (obj as TD3DBaseAudio).GetKeyID = fKey then
        (obj as TD3DBaseAudio).Stop;
  end;
  for i := 0 to _CacheNestedScenes.Count - 1 do
    (_CacheNestedScenes.Objects[i] as TD3DScene).StopSounds(fKey);
end;

procedure TD3DScene.RewindSounds(fKey: integer);
var
  i: integer;
  obj: TObject;
begin
  for i := 0 to Sounds.Count - 1 do
  begin
    obj := Sounds.Objects[i];
    if (obj as TD3DBaseAudio).GetTypeID = ID3D_Sound then
      if (obj as TD3DBaseAudio).GetKeyID = fKey then
        (obj as TD3DBaseAudio).Rewind;
  end;
  for i := 0 to _CacheNestedScenes.Count - 1 do
    (_CacheNestedScenes.Objects[i] as TD3DScene).RewindSounds(fKey);
end;

procedure TD3DScene.PlaySounds(SoundName: string);
var
  i: integer;
  b: boolean;
  obj: TObject;
  uName: string;
begin
  uName := UpperCase(ExtractFileName(SoundName));
  for i := 0 to Sounds.Count - 1 do
  begin
    obj := Sounds.Objects[i];
    if (obj as TD3DBaseAudio).GetTypeID = ID3D_Sound then
      if UpperCase(ExtractFileName((obj as TD3DSound).Info.SoundName)) = uName then
      begin
        b := (obj as TD3DSound).Info.Enabled;
        (obj as TD3DSound).Info.Enabled := True;
        (obj as TD3DSound).Play;
        (obj as TD3DSound).Info.Enabled := b;
      end;
  end;
  for i := 0 to _CacheNestedScenes.Count - 1 do
    (_CacheNestedScenes.Objects[i] as TD3DScene).PlaySounds(SoundName);
end;

procedure TD3DScene.PlaySounds(SoundName: string; aPosition: TD3DVector);
var
  i: integer;
  b: boolean;
  obj: TObject;
  uName: string;
begin
  uName := UpperCase(ExtractFileName(SoundName));
  for i := 0 to Sounds.Count - 1 do
  begin
    obj := Sounds.Objects[i];
    if (obj as TD3DBaseAudio).GetTypeID = ID3D_Sound then
      if UpperCase(ExtractFileName((obj as TD3DSound).Info.SoundName)) = uName then
      begin
        (obj as TD3DSound).Info.x := aPosition.x;
        (obj as TD3DSound).Info.y := aPosition.y;
        (obj as TD3DSound).Info.z := aPosition.z;
        (obj as TD3DSound).DoRecalc;
        b := (obj as TD3DSound).Info.Enabled;
        (obj as TD3DSound).Info.Enabled := True;
        (obj as TD3DSound).Play;
        (obj as TD3DSound).Info.Enabled := b;
      end;
  end;
  for i := 0 to _CacheNestedScenes.Count - 1 do
    (_CacheNestedScenes.Objects[i] as TD3DScene).PlaySounds(SoundName, aPosition);
end;

procedure TD3DScene.PauseSounds(SoundName: string);
var
  i: integer;
  obj: TObject;
  uName: string;
begin
  uName := UpperCase(ExtractFileName(SoundName));
  for i := 0 to Sounds.Count - 1 do
  begin
    obj := Sounds.Objects[i];
    if (obj as TD3DBaseAudio).GetTypeID = ID3D_Sound then
      if UpperCase(ExtractFileName((obj as TD3DSound).Info.SoundName)) = uName then
        (obj as TD3DSound).Pause;
  end;
  for i := 0 to _CacheNestedScenes.Count - 1 do
    (_CacheNestedScenes.Objects[i] as TD3DScene).PauseSounds(SoundName);
end;

procedure TD3DScene.StopSounds(SoundName: string);
var
  i: integer;
  obj: TObject;
  uName: string;
begin
  uName := UpperCase(ExtractFileName(SoundName));
  for i := 0 to Sounds.Count - 1 do
  begin
    obj := Sounds.Objects[i];
    if (obj as TD3DBaseAudio).GetTypeID = ID3D_Sound then
      if UpperCase(ExtractFileName((obj as TD3DSound).Info.SoundName)) = uName then
        (obj as TD3DSound).Stop;
  end;
  for i := 0 to _CacheNestedScenes.Count - 1 do
    (_CacheNestedScenes.Objects[i] as TD3DScene).StopSounds(SoundName);
end;

procedure TD3DScene.RewindSounds(SoundName: string);
var
  i: integer;
  obj: TObject;
  uName: string;
begin
  uName := UpperCase(ExtractFileName(SoundName));
  for i := 0 to Sounds.Count - 1 do
  begin
    obj := Sounds.Objects[i];
    if (obj as TD3DBaseAudio).GetTypeID = ID3D_Sound then
      if UpperCase(ExtractFileName((obj as TD3DSound).Info.SoundName)) = uName then
        (obj as TD3DSound).Rewind;
  end;
  for i := 0 to _CacheNestedScenes.Count - 1 do
    (_CacheNestedScenes.Objects[i] as TD3DScene).RewindSounds(SoundName);
end;

procedure TD3DScene.PlaySound(ASound: TD3DSound);
var
  b: boolean;
begin
  if ASound <> nil then
  begin
    b := ASound.Info.Enabled;
    ASound.Info.Enabled := True;
    ASound.Play;
    ASound.Info.Enabled := b;
  end;
end;

procedure TD3DScene.PlaySound(ASound: TD3DSound; aPosition: TD3DVector);
var
  b: boolean;
begin
  if ASound <> nil then
  begin
    ASound.Info.x := aPosition.x;
    ASound.Info.y := aPosition.y;
    ASound.Info.z := aPosition.z;
    ASound.DoRecalc;
    b := ASound.Info.Enabled;
    ASound.Info.Enabled := True;
    ASound.Play;
    ASound.Info.Enabled := b;
  end;
end;

procedure TD3DScene.PauseSound(ASound: TD3DSound);
begin
  if ASound <> nil then
    ASound.Pause;
end;

procedure TD3DScene.StopSound(ASound: TD3DSound);
begin
  if ASound <> nil then
    ASound.Stop;
end;

procedure TD3DScene.RewindSound(ASound: TD3DSound);
begin
  if ASound <> nil then
    ASound.Rewind;
end;

procedure TD3DScene.PlayTones(fKey: integer);
var
  i: integer;
begin
  for i := 0 to Sounds.Count - 1 do
    if (Sounds.Objects[i] as TD3DBaseAudio).GetTypeID = ID3D_Tone then
      if (Sounds.Objects[i] as TD3DBaseAudio).GetKeyID = fKey then
        (Sounds.Objects[i] as TD3DBaseAudio).Play;
  for i := 0 to _CacheNestedScenes.Count - 1 do
    (_CacheNestedScenes.Objects[i] as TD3DScene).PlayTones(fKey);
end;

procedure TD3DScene.PauseTones(fKey: integer);
var
  i: integer;
begin
  for i := 0 to Sounds.Count - 1 do
    if (Sounds.Objects[i] as TD3DBaseAudio).GetTypeID = ID3D_Tone then
      if (Sounds.Objects[i] as TD3DBaseAudio).GetKeyID = fKey then
        (Sounds.Objects[i] as TD3DBaseAudio).Pause;
  for i := 0 to _CacheNestedScenes.Count - 1 do
    (_CacheNestedScenes.Objects[i] as TD3DScene).PauseTones(fKey);
end;

procedure TD3DScene.StopTones(fKey: integer);
var
  i: integer;
begin
  for i := 0 to Sounds.Count - 1 do
    if (Sounds.Objects[i] as TD3DBaseAudio).GetTypeID = ID3D_Tone then
      if (Sounds.Objects[i] as TD3DBaseAudio).GetKeyID = fKey then
        (Sounds.Objects[i] as TD3DBaseAudio).Stop;
  for i := 0 to _CacheNestedScenes.Count - 1 do
    (_CacheNestedScenes.Objects[i] as TD3DScene).StopTones(fKey);
end;

procedure TD3DScene.RewindTones(fKey: integer);
var
  i: integer;
begin
  for i := 0 to Sounds.Count - 1 do
    if (Sounds.Objects[i] as TD3DBaseAudio).GetTypeID = ID3D_Tone then
      if (Sounds.Objects[i] as TD3DBaseAudio).GetKeyID = fKey then
        (Sounds.Objects[i] as TD3DBaseAudio).Rewind;
  for i := 0 to _CacheNestedScenes.Count - 1 do
    (_CacheNestedScenes.Objects[i] as TD3DScene).RewindTones(fKey);
end;

{$ENDIF}

procedure TD3DScene.PlayOldStyleSound(SoundName: string; doLoop: boolean = False);
var
  s: TStream;
  lFlag: integer;
begin
  if SoundName = '' then
    sndPlaySound(nil, SND_ASYNC)
  else
  begin
    s := AddStreamToCollection(SoundName);
    if s <> nil then
    begin
      if doLoop then
        lFlag := SND_LOOP
      else
        lFlag := 0;
      if s.InheritsFrom(TMemoryStream) then
        sndPlaySound(PChar((s as TMemoryStream).Memory), SND_MEMORY or SND_ASYNC or SND_NODEFAULT or lFlag)
      else if s.InheritsFrom(TFileStream) then
        sndPlaySound(PChar(SoundName), SND_FILENAME or SND_ASYNC or SND_NODEFAULT or lFlag)
    //else error!
      else
        StopOldStyleSound
    end;
  end;
end;

procedure TD3DScene.StopOldStyleSound;
begin
  PlayOldStyleSound(EmptyStr);
end;

// Make a request to recalc
procedure TD3DScene.ReCalc;
begin
  fNeedsRecalc := fNeedsRotationRecalc or fNeedsPositionRecalc or fNeedsLightRecalc;
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
  _NeedsPositionRecalcFromSectorCollection := True;
{$ENDIF}
end;

function TD3DScene.NeedsRecalc: boolean;
begin
  Result := fNeedsRecalc <> 0;
end;

// Execute the recalc request
procedure TD3DScene.DoReCalc;
var
  aTime: double;
begin
{$IFNDEF NO_DE3DSECTORCOLLECTIONS}
  SetPosition(fPosition);
{$ENDIF}
  if fNeedsRecalc <> 0 then
  begin
    aTime := Time;
    if (fNeedsRecalc and not fNeedsLightRecalc) = fNeedsRotationRecalc then
    begin
      RotateObjects;
      if (aTime - fLastTime) > fUpdateTolerance then
      begin
{$IFNDEF NO_D3DSOUNDS}
        Update3DSounds;
{$ENDIF}
        fLastTime := aTime;
      end;
      if not fAttached then
        CalculateView;
    end
    else if (fNeedsRecalc and not fNeedsLightRecalc) = fNeedsPositionRecalc then
    begin
      RotateObjects;
      if (aTime - fLastTime) > fUpdateTolerance then
      begin
        if fNearClippingPlane = 0.0 then
          OptimizeZOrder;
{$IFNDEF NO_D3DSOUNDS}
        Update3DSounds;
{$ENDIF}
        fLastTime := aTime;
      end;
      if not fAttached then
        CalculatePosition;
    end
    else
    begin
      RotateObjects;
      if (aTime - fLastTime) > fUpdateTolerance then
      begin
        if fNearClippingPlane = 0.0 then
          OptimizeZOrder;
{$IFNDEF NO_D3DSOUNDS}
        Update3DSounds;
{$ENDIF}
        fLastTime := aTime;
      end;
      if not fAttached then
      begin
        CalculateView;
        CalculatePosition;
      end;
    end;
    if (fNeedsRecalc and fNeedsLightRecalc) <> 0 then
      ApplyLights;
    fNeedsRecalc := 0;

// RotationRecalc requires:
{   RotateObjects;
    Update3DSounds;
    CalculateView;}

// PositionRecalc requires:
{   OptimizeZOrder;
    RotateObjects;
    Update3DSounds;
    CalculatePosition;}

// LightRecalc requires:
{   ApplyLights; }
  end;
end;

procedure TD3DScene.ForceRecalc;
begin
  Recalc;
  DoRecalc;
end;

procedure TD3DScene.Reload;
var
  m: TMemoryStream;
begin
  m := TMemoryStream.Create;
  try
    SaveToStream(m);
    m.Seek(0, soFromBeginning);
    LoadFromStream(m, FILEVERSION);
    Recalc;
  finally
    m.Free;
  end;
end;

procedure TD3DScene.SetTextureQuality(Value: TD3DTextureQuality);
begin
  if fTextureQuality <> Value then
  begin
    fTextureQuality := Value;
    Reload;
  end;
end;

function TD3DScene.GetParentPositionVector: TD3DVector;
var
  s: TD3DScene;
begin
  s := self;
  Result := MakeD3DVector(Info.x, Info.y, Info.z);
  while s.fParent <> nil do
  begin
    s := s.fParent;
    Result := VectorAdd(Result, MakeD3DVector(s.Info.x, s.Info.y, s.Info.z));
  end;
end;

function TD3DScene.GetParentRotationVector: TD3DVector;
var
  s: TD3DScene;
begin
  s := self;
  Result := MakeD3DVector(Info.dx, Info.dy, Info.dz);
  while s.fParent <> nil do
  begin
    s := s.fParent;
    Result := VectorAdd(Result, MakeD3DVector(s.Info.dx, s.Info.dy, s.Info.dz));
  end;
end;

{ װבמיםלחףח פחע כףפבע לו פיע ונצםויוע ףו ףקףח לו פן z-Order}
// ֱם fNearClippingPlane = 0.0 פפו פן zBuffering הום הןץכו‎וי ףפב DirectX 7.0!,
// ¸פףי קסחףילןנןין‎לו פחם וףשפוסיך לחקבם פבמיםלחףחע
procedure TD3DScene.OptimizeZOrder;
var
  i: integer;
  pos: TD3DVector;
  tmp: TD3DScene;
begin
  tmp := ActiveScene;
  ActiveScene := self;
  try
    pos := VectorSub(Position, GetParentPositionVector);
    for i := 0 to Surfaces.Count - 1 do
      (Surfaces.Objects[i] as TD3DObject).CalcDistance(Pos);
    Surfaces.CustomSort(SortZOrder);
  finally
    ActiveScene := tmp;
  end;
end;

{$IFNDEF NO_D3DBILLBOARDS}
procedure TD3DScene.OptimizeBillBoards;
begin
  Surfaces.CustomSort(SortBillBoard);
end;
{$ENDIF}

procedure TD3DScene.SortSurfacesAtSize;
begin
  if fNearClippingPlane <> 0.0 then
    Surfaces.CustomSort(SortObjectSizeProc);
end;

procedure TD3DScene.SortSurfacesAtKey;
begin
  if fNearClippingPlane <> 0.0 then
    Surfaces.CustomSort(SortObjectKeyProc);
end;

procedure TD3DScene.SortSurfacesAtName;
begin
  if fNearClippingPlane <> 0.0 then
    Surfaces.CustomSort(SortObjectNameProc);
end;

procedure TD3DScene.SortSurfacesAtDistance;
begin
  OptimizeZOrder;
end;

{$IFNDEF NO_D3DSOUNDS}
procedure TD3DScene.SortSoundsAtKey;
begin
  Sounds.CustomSort(SortSoundsKeyProc);
end;

procedure TD3DScene.SortSoundsAtName;
begin
  Sounds.Sort;
end;

procedure TD3DScene.SortSoundsAtDistance;
var
  tmp: TD3DScene;
begin
  tmp := ActiveScene;
  ActiveScene := self;
  try
    Sounds.CustomSort(SortSoundsDistanceProc);
  finally
    ActiveScene := tmp;
  end;
end;
{$ENDIF}

function TD3DScene.CalcDistance(const aPosition: TD3DVector): TD3DValue; register;
var
  tmp: TD3DScene;
begin
  tmp := ActiveScene;
  ActiveScene := self;
  try
    if Surfaces.Count > 0 then
    begin
      OptimizeZOrder;
      if fAttached then
        Distance := VectorMagnitude(
                      VectorSub(aPosition, MakeD3DVector(Info.x, Info.y, Info.z)))
      else
        Distance := 0.0;
      Result := Distance;
    end
    else
      Result := 0;
  finally
    ActiveScene := tmp;
  end;
end;

function TD3DScene.GetIsDrawing: boolean;
var
  s: TD3DScene;
begin
  s := self;
  while s.fParent <> nil do
    s := s.fParent;
  Result := s.fIsDrawing;
end;

procedure TD3DScene.SetNearClippingPlane(Value: TD3DValue);
// ¼פבם בככזןץלו פן fNearClippingPlane קסויזופבי
// ונבםבץנןכןדיףלע פןץ View Matrix [CalculateView()]
begin
  if fNearClippingPlane <> Value then
  begin
    fNearClippingPlane := Value;
    fNeedsRecalc := fNeedsRecalc or fNeedsRotationRecalc;
  end;
end;

// ֵניףפסצוי פב ךבס/sec, בם וםבי attached, פפו וניףפסצוי פב FPS פןץ נבפסב
function TD3DScene.GetFps: TD3DValue;
begin
  if fParent <> nil then
    Result := fParent.GetFps
  else
    Result := fFps;
end;

function TD3DScene.GetFpsSmooth: TD3DValue;
begin
  if FPSReporter <> nil then
    Result := FPSReporter.FPS
  else
    Result := GetFPS;
end;

// ֵניףפסצוי פןם בסיטל פשם Vertexes
function TD3DScene.GetNumVertexes: integer;
var
  i: integer;
begin
  Result := 0;
  for i := 0 to Surfaces.Count - 1 do
    Result := Result + (Surfaces.Objects[i] as TD3DObject).GetNumVertexes;
end;

// ֵניףפסצוי פןם בסיטל פשם פסיד‏םשם
function TD3DScene.GetNumTriangles: integer;
var
  i: integer;
begin
  Result := 0;
  for i := 0 to Surfaces.Count - 1 do
    Result := Result + (Surfaces.Objects[i] as TD3DObject).GetNumTriangles;
end;

function  TD3DScene.GetNumDrawnVertexes: integer;
var
  i: integer;
  obj: TObject;
begin
  Result := 0;
  for i := 0 to Surfaces.Count - 1 do
  begin
    obj := Surfaces.Objects[i];
    if not (obj as TD3DObject).Culled then
      if (obj as TD3DObject).DidDraw then
        Result := Result + (obj as TD3DObject).GetNumVertexes;
  end;
end;

function TD3DScene.GetNumDrawnTriangles: integer;
var
  i: integer;
  obj: TObject;
begin
  Result := 0;
  for i := 0 to Surfaces.Count - 1 do
  begin
    obj := Surfaces.Objects[i];
    if not (obj as TD3DObject).Culled then
      if (obj as TD3DObject).DidDraw then
        Result := Result + (obj as TD3DObject).GetNumTriangles;
  end;
end;

{$IFDEF DESIGNER}
// Draws a point of view at distance dist!
procedure TD3DScene.DrawPointOfView(const dist: TD3DValue);
var
  verts: array[0..2] of TD3DLVertex;
  verts2: array[0..2] of TD3DLVertex;
  v1, v: TD3DVector;
  i: integer;
  sz: TD3DValue;
  mat: TD3DMatrix;
  mat2: TD3DMatrix;
  r: TD3DVector;
//    vx, vy, vz: TD3DVector;
begin
  DXDraw.D3DDevice7.SetTexture(0, AddTextureToCollectionConst(rsGray8).Surface.IDDSurface7);
{  v := MakeD3DVector(0.0, 0.0, 1.0);
  v := VectorMulS(RotateVector(v, NegativeVector(Rotation)), dist);}
{  v := MakeD3DVector(0.0, 0.0, dist);
  v := RotateVector(v, NegativeVector(Rotation));
  v := VectorAdd(Position, v);}

  r := {NegativeVector}(Rotation);
  GetRotationMatrix(mat, r.x, r.y, r.z);
  D3DMath_MatrixInvert(mat2, mat);
  v1 := MakeD3DVector(0.0, 0.0, dist);
  D3DMath_VectorMatrixMultiply(v, v1, mat2);

  v := VectorAdd(Position, v);

  for i := low(verts) to high(verts) do
  begin
    verts[i].dwReserved := 0;
    verts[i].color := $FFFFFFFF;
    verts[i].specular := 0;
    verts[i].tu := 0.0;
    verts[i].tv := 0.0;
  end;

  verts2[0].dwReserved := 0;
  verts2[0].color := $FFFFFFFF;
  verts2[0].specular := 0;
  verts2[0].tu := 0.0;
  verts2[0].tv := 0.0;

  sz := dist / 10;

  verts[0].x := v.x - sz;
  verts[0].y := v.y + sz;
  verts[0].z := v.z - sz;

  verts[1].x := v.x + sz;
  verts[1].y := v.y + sz;
  verts[1].z := v.z - sz;

  verts[2].x := v.x;
  verts[2].y := v.y + sz;
  verts[2].z := v.z + sz;

  DXDraw.D3DDevice7.DrawPrimitive(D3DPT_TRIANGLELIST, D3DFVF_LVERTEX, verts[0], 3, 0);

  verts2[0].x := v.x;
  verts2[0].y := v.y - sz;
  verts2[0].z := v.z;

  verts2[1] := verts[0];
  verts2[2] := verts[1];
  DXDraw.D3DDevice7.DrawPrimitive(D3DPT_TRIANGLELIST, D3DFVF_LVERTEX, verts2[0], 3, 0);

  verts2[1] := verts[1];
  verts2[2] := verts[2];
  DXDraw.D3DDevice7.DrawPrimitive(D3DPT_TRIANGLELIST, D3DFVF_LVERTEX, verts2[0], 3, 0);

  verts2[1] := verts[2];
  verts2[2] := verts[0];
  DXDraw.D3DDevice7.DrawPrimitive(D3DPT_TRIANGLELIST, D3DFVF_LVERTEX, verts2[0], 3, 0);

end;
{$ENDIF}

procedure TD3DScene.CullSurfaces(const culldistance: TD3DValue);
var
  i: integer;
  obj: TD3DObject;
  v, v1, r: TD3DVector;
  dist: TD3DValue;
  mat, mat2: TD3DMatrix;
begin
  if culldistance >= g_HUGE / 2 then
  begin
    for i := 0 to Surfaces.Count - 1 do
      (Surfaces.Objects[i] as TD3DObject).Culled := False;
    Exit;
  end;

  dist := culldistance / 2;
  r := Rotation;
  GetRotationMatrix(mat, r.x, r.y, r.z);
  D3DMath_MatrixInvert(mat2, mat);
  v1 := MakeD3DVector(0.0, 0.0, dist);
  D3DMath_VectorMatrixMultiply(v, v1, mat2);

  v := VectorAdd(Position, v);

  for i := 0 to Surfaces.Count - 1 do
  begin
    obj := Surfaces.Objects[i] as TD3DObject;
    obj.Culled :=
      VectorMagnitude(VectorSub(v, obj.Center)) >
        dist + obj.Radius;
  end;

{
  rm := VectorMagnitude(Rotation);
  if rm = 0 then
  begin
    ccenter := Position;
    ccenter.z := ccenter.z + culldistance / 2.0;
  end
  else
    ccenter :=
      VectorAdd(Position, VectorMulS(VectorDivS(Rotation, rm), culldistance / 2.0));
  for i := 0 to Surfaces.Count - 1 do
  begin
    obj := Surfaces.Objects[i] as TD3DObject;
    (obj as TD3DObject).Culled :=
      VectorMagnitude(VectorSub(ccenter, obj.Center)) >
        culldistance / 2.0 + obj.Radius;
  end;}
end;


{$IFNDEF NO_SCRIPTS}
procedure TD3DScene.RunChildsEvent(ID: integer; DispatchError: boolean);
var
  i: integer;
begin
  RunEvent(ID, True);
   for i := 0 to _CacheNestedScenes.Count - 1 do
    (_CacheNestedScenes.Objects[i] as TD3DScene).RunChildsEvent(ID, DispatchError);
end;
{$ENDIF}

procedure TD3DScene.DrawLoop;
var
  i: integer;
begin
  if not fCulled then
    for i := 0 to Surfaces.Count - 1 do
//      if not (Surfaces.Objects[i] as TD3DObject).Culled then
        (Surfaces.Objects[i] as TD3DObject).DoDraw;
end;

procedure TD3DScene.BeforeDraw;
var
  i: integer;
begin
{$IFNDEF NO_D3DPLUGINS}
  for i := 0 to _CachePlugIns.Count - 1 do
   (_CachePlugIns.Objects[i] as TD3DPlugIn).BeforeDraw;
{$ENDIF}
  for i := 0 to _CacheNestedScenes.Count - 1 do
   (_CacheNestedScenes.Objects[i] as TD3DScene).BeforeDraw;
end;

procedure TD3DScene.ReInitialize;
var
  i: integer;
{$IFNDEF NO_D3DPLUGINS}
  PLS: TList;
  inf: PD3DPlugInInfo;
{$ENDIF}
begin
{$IFNDEF NO_D3DPLUGINS}
  PLS := TList.Create;
  try
{$ENDIF}
    for i := Surfaces.Count - 1 downto 0 do
{$IFNDEF NO_D3DPLUGINS}
      if (Surfaces.Objects[i] is TD3DPlugIn) then
        if not (Surfaces.Objects[i] as TD3DPlugIn).ReInitialize then
        begin
          System.new(inf);
          (Surfaces.Objects[i] as TD3DPlugIn).GetInfo(inf);
          PLS.Add(inf);
          (Surfaces.Objects[i] as TD3DPlugIn).Free;
          Surfaces.Delete(i);
        end
      else
{$ENDIF}
        if (Surfaces.Objects[i] is TD3DScene) then
          (Surfaces.Objects[i] as TD3DScene).ReInitialize;
{$IFNDEF NO_D3DPLUGINS}
    for i := PLS.Count - 1 downto 0 do
    begin
      AddSurface(ID3D_PLUGIN, PLS.Items[i]);
      dispose(PLS.Items[i]);
    end;
{$ENDIF}
    CreateCache;
{$IFNDEF NO_D3DPLUGINS}
  finally
    PLS.Free;
  end;
{$ENDIF}
  ApplyLights;
  fFps := 0.0;
end;

procedure TD3DScene.AfterDraw;
var
  i: integer;
begin
{$IFNDEF NO_D3DPLUGINS}
  for i := 0 to _CachePlugIns.Count - 1 do
   (_CachePlugIns.Objects[i] as TD3DPlugIn).AfterDraw;
{$ENDIF}
  for i := 0 to _CacheNestedScenes.Count - 1 do
   (_CacheNestedScenes.Objects[i] as TD3DScene).AfterDraw;
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
  if _NeedsPositionRecalcFromSectorCollection then
    AdjustSectorsPositioning(fPosition, fPosition);
{$ENDIF}
end;

procedure TD3DScene.ThreadDraw(level: byte = 1);
begin
  fThreadLevel := level;
  Draw;
  fThreadLevel := 0;
end;

procedure TD3DScene.Draw;
begin
  DrawWithBackColor(clBlack);
end;

procedure TD3DScene.DrawWithBackColor(c: TColor);
var
  r: TD3DRect;
  i: integer;
  aTime: double;
  dev: IDirect3DDevice7;
begin
{$IFNDEF NO_AVI}
  if IsPlayingAVI then
    Exit;
{$ENDIF}
  dev := DXDraw.D3DDevice7;
  try
    aTime := Time;
    if aTime = fOldTime then
      fOldTime := fOldTime - 0.001;// Exit; // We hope we get such big frame rate!!!!
    fSpeed := VectorMagnitude(VectorSub(fPosition, fOldPosition))/(aTime-OldTime);

    UpdateObjectsTime;
    if not fAttached then
      for i := 0 to _CacheNestedScenes.Count - 1 do
        (_CacheNestedScenes.Objects[i] as TD3DScene).DoRecalc;
    DoRecalc;

    for i := 0 to Actions.Count - 1 do
      (Actions.Objects[i] as TD3DAction).Execute;

    if not fAttached then
    begin
      fFps := (fFps + 1/(aTime-fOldTime))/2;
      FPSReporter.AddFPS(fFps);
{$IFNDEF NO_SCRIPTS}
      RunChildsEvent(ID3D_EVENTONBEFOREBEGINSCENE, True);
{$ENDIF}
    end;

{$IFNDEF NO_SCRIPTS}
    RunEvent(ID3D_EVENTONBEFOREDRAW, True);
{$ENDIF}

    if not fAttached then
    begin
      dev.SetRenderState(D3DRENDERSTATE_LIGHTING, 0);
      r.x1 := 0;
      r.y1 := 0;
      r.x2 := DXDraw.SurfaceWidth;
      r.y2 := DXDraw.SurfaceHeight;
      if DXDraw.ZBuffer <> nil then
        dev.Clear(1, r, D3DCLEAR_TARGET or D3DCLEAR_ZBUFFER, CA_MAKE(ColorToRGB(c), 0), 1, 0)
      else
        dev.Clear(1, r, D3DCLEAR_TARGET, CA_MAKE(ColorToRGB(c), 0), 1, 0);

      case fTextureQuality of
        tqWireFrame:
          dev.SetRenderState(D3DRENDERSTATE_FILLMODE, ord(D3DFILL_WIREFRAME));
        tqPoint:
          dev.SetRenderState(D3DRENDERSTATE_FILLMODE, ord(D3DFILL_POINT));
      else
        dev.SetRenderState(D3DRENDERSTATE_FILLMODE, ord(D3DFILL_SOLID));
      end;

      BeforeDraw;

      fIsDrawing := True; // ֱסק ףקוהבףחע
      { Draw Screen }
      asm FINIT  end;
      dev.BeginScene;
    end;

    DrawLoop;

    if not fAttached then
    begin
      dev.EndScene;
      asm FINIT  end;
      fIsDrawing := False; // װכןע ףקוהבףחע
      AfterDraw;
    end;

{$IFNDEF NO_SCRIPTS}
    RunEvent(ID3D_EVENTONAFTERDRAW, True);

    if not fAttached then
      RunChildsEvent(ID3D_EVENTONAFTERENDSCENE, True);
{$ENDIF}

    fOldTime := aTime;
  except
  end;
end;

{$IFNDEF NO_DXMESHES}
procedure TD3DScene.DoDrawMesh;
begin
  Draw;
end;
{$ENDIF}

// Rotate Objects such as TD3DStubObject, so they appear normal
procedure TD3DScene.RotateObjects;
var
  i: integer;
  vP, vR: TD3DVector;
begin
  vP := VectorSub(Position, GetParentPositionVector);
  vR := VectorSub(Rotation, GetParentRotationVector);
  for i := 0 to _CacheRotatingObjects.Count - 1 do
  begin
{$IFNDEF NO_D3DSTUBOBJECTS}
    if (_CacheRotatingObjects.Objects[i] as TD3DObject).GetTypeID = ID3D_StubObject then
    begin
      (_CacheRotatingObjects.Objects[i] as TD3DStubObject).PerspectiveRotate(vP, vR);
      (_CacheRotatingObjects.Objects[i] as TD3DStubObject).ApplyLights(Lights);
    end
{$ELSE}
    if (_CacheRotatingObjects.Objects[i] as TD3DObject).GetTypeID = 3 then
    begin
    end
{$ENDIF}
{$IFNDEF NO_D3DEXOBJECTS}
    else if (_CacheRotatingObjects.Objects[i] as TD3DObject).GetTypeID = ID3D_ExObject then
    begin
      (_CacheRotatingObjects.Objects[i] as TD3DExObject).SimpleRotate(vP, vR.y);
//      (_CacheRotatingObjects.Objects[i] as TD3DExObject).SimpleRotate(fPosition);
      (_CacheRotatingObjects.Objects[i] as TD3DExObject).ApplyLights(Lights);
    end;
{$ENDIF}
  end;
{$IFNDEF NO_D3DBILLBOARDS}
  for i := 0 to _CacheBillBoards.Count - 1 do
  begin
    (_CacheBillBoards.Objects[i] as TD3DBillBoard).SimpleRotate(vR.y);
    (_CacheBillBoards.Objects[i] as TD3DBillBoard).ApplyLights(Lights);
  end;
{$ENDIF}
  for i := 0 to _CacheNestedScenes.Count - 1 do
  begin
    (_CacheNestedScenes.Objects[i] as TD3DScene).RotateObjects;
    (_CacheNestedScenes.Objects[i] as TD3DObject).ApplyLights(Lights);
  end;
end;

{$IFNDEF NO_D3DSOUNDS}
procedure TD3DScene.Update3DSounds;
var
  i: integer;
  vP, vR: TD3DVector;
begin
  if not fMute then
  begin
    vP := VectorSub(Position, GetParentPositionVector);
    vR := VectorSub(Rotation, GetParentRotationVector);
    for i := 0 to Sounds.Count - 1 do
    begin
      (Sounds.Objects[i] as TD3DBaseAudio).Position := vP;
      (Sounds.Objects[i] as TD3DBaseAudio).Rotation := vR;
    end;
    for i := 0 to _CacheNestedScenes.Count - 1 do
      (_CacheNestedScenes.Objects[i] as TD3DScene).Update3DSounds;
{
    for i := 0 to Surfaces.Count - 1 do
    begin
      if (Surfaces.Objects[i] as TD3DObject).GetTypeID = ID3D_Scene then
        (Surfaces.Objects[i] as TD3DScene).Update3DSounds;
    end;}
  end;
end;
{$ENDIF}

{$IFNDEF NO_D3DSOUNDS}
procedure TD3DScene.SetMute(Value: boolean);
var
  i: integer;
begin
  if Value <> fMute then
  begin
    if Value then
      PauseSounds
    else
      RestartSounds;
   {$IFNDEF NO_SCRIPTS}
    if Value then
    begin
      SpeakPause;
      PauseCDAudio;
    end
    else
    begin
      SpeakResume;
      ResumeCDAudio
    end;
   {$ENDIF}
  end;
  for i := 0 to Surfaces.Count - 1 do
    if (Surfaces.Objects[i] as TD3DObject).GetTypeID = ID3D_Scene then
      (Surfaces.Objects[i] as TD3DScene).SetMute(Value);
end;
{$ENDIF}

{$IFNDEF NO_D3DSOUNDS}
procedure TD3DScene.PauseSounds;
var
  i: integer;
begin
  fMute := True;
  for i := 0 to Sounds.Count - 1 do
    (Sounds.Objects[i] as TD3DBaseAudio).Pause;
end;

procedure TD3DScene.RestartSounds;
var
  i: integer;
begin
  fMute := False;
  Update3DSounds;
  for i := 0 to Sounds.Count - 1 do
  begin
    if Sounds.Objects[i] is TD3DTone then
      (Sounds.Objects[i] as TD3DTone).Prepare;
    (Sounds.Objects[i] as TD3DBaseAudio).Play;
  end;
end;
{$ENDIF}

procedure TD3DScene.UpdateObjectsTime;
var
  i: integer;
  t: double;
begin
  t := Time;
  for i := 0 to Surfaces.Count - 1 do
    if Surfaces.Objects[i].InheritsFrom(TD3DTimingObject) then
      (Surfaces.Objects[i] as TD3DTimingObject).Time := t;
end;

procedure TD3DScene.ReleaseUnusedObjects;
var
  i: integer;
begin
  for i := Surfaces.Count - 1 downto 0 do
    if (Surfaces.Objects[i] is TD3DPolygon) then
      if (Surfaces.Objects[i] as TD3DPolygon).Info2.numVertexes = 0 then
      begin
        Surfaces.Objects[i].Free;
        Surfaces.Delete(i);
      end;
end;

procedure TD3DScene.ReleaseUnusedTextures(const exclude: string);
var
  sexclude: TDXStringList;
begin
  sexclude := TDXStringList.Create;
  try
    ReleaseUnusedTextures(sexclude);
  finally
    sexclude.Free;
  end;
end;

procedure TD3DScene.ReleaseUnusedTextures(const exclude: TDXStringList = nil);
var
  texs: TDXStringList;
  i: integer;
begin
  texs := TDXStringList.Create;
  try
    GetTextureNames(texs);
    texs.Sorted := True;
    if exclude = nil then
    begin
      for i := Textures.Count - 1 downto 1 do
      begin
        if texs.IndexOf(Textures.Strings[i]) = -1 then
        begin
          if Textures.Objects[i] <> nil then
          try
            Textures.Objects[i].Free;
          except
            Textures.Objects[i] := nil;
          end;
          Textures.Delete(i);
        end;
      end;
    end
    else
    begin
      exclude.Sorted := True;
      for i := Textures.Count - 1 downto 1 do
      begin
        if (texs.IndexOf(Textures.Strings[i]) = -1) then
          if (exclude.IndexOf(Textures.Strings[i]) = -1) then
          begin
            if Textures.Objects[i] <> nil then
            try
              Textures.Objects[i].Free;
            except
              Textures.Objects[i] := nil;
            end;
            Textures.Delete(i);
          end;
      end;
    end
  finally
    texs.Free;
  end;
end;

function TD3DScene.PrepareRTLOptimizer(var TextureName: string;
  flatUV: boolean; Transparent: boolean; Cull: TD3DCull;
  doAddTextures: boolean = True): TD3DObject;
var
  pInf: TD3DPolygonInfo;
begin
  if doAddTextures then
    AddTextureToCollection(TextureName);
  FillChar(pInf, SizeOf(pInf), Chr(0));
  pInf.key := GenGlobalID;
  pInf.NumTextures := 1;
  pInf.C := RGB(255, 255, 255);
  if Transparent then
    pInf.Transparency := MAXTRANSPARENCYREPLICATION
  else
    pInf.Transparency := 0;
  pInf.UseFlatUV := flatUV;
  pInf.Cull := Cull;

  pInf.PrimitiveType := D3DPT_TRIANGLELIST;
  pInf.TextureNames[0, 0] := TextureName;
  Result := AddSurface(ID3D_Polygon, @pInf);
  if Result <> nil then
    Result.RunTimeOnly := True;
end;

procedure TD3DScene.PrepareRTLOptimizer(TextureNames: TDXStringList;
  flatUV: boolean; Transparent: boolean; Cull: TD3DCull;
  doAddTextures: boolean = True);
var
  pInf: TD3DPolygonInfo;
  i: integer;
  obj: TD3DObject;
begin
  if doAddTextures then
    AddTexturesToCollection(TextureNames);
  FillChar(pInf, SizeOf(pInf), Chr(0));
  pInf.key := GenGlobalID;
  pInf.NumTextures := 1;
  pInf.C := RGB(255, 255, 255);
  if Transparent then
    pInf.Transparency := MAXTRANSPARENCYREPLICATION
  else
    pInf.Transparency := 0;
  pInf.UseFlatUV := flatUV;
  pInf.Cull := Cull;

  pInf.PrimitiveType := D3DPT_TRIANGLELIST;
  for i := 0 to TextureNames.Count - 1 do
  begin
    pInf.TextureNames[0, 0] := TextureNames.Strings[i];
    obj := AddSurface(ID3D_Polygon, @pInf);
    if obj <> nil then
      obj.RunTimeOnly := True;
  end;
end;

function TD3DScene.GetObjects(key: integer; list: TList): integer;
var
  i: integer;
begin
  Result := 0;
  for i := 0 to Surfaces.Count - 1 do
    if (Surfaces.Objects[i] as TD3DObject).GetKeyID = key then
    begin
      inc(Result);
      list.Add(Surfaces.Objects[i]);
    end;
end;

{$IFNDEF NO_D3DSOUNDS}
function TD3DScene.GetSounds(key: integer; list: TList): integer;
var
  i: integer;
begin
  Result := 0;
  for i := 0 to Sounds.Count - 1 do
    if ((Sounds.Objects[i] as TD3DBaseAudio).GetKeyID = key) and
       ((Sounds.Objects[i] as TD3DBaseAudio).GetTypeID = ID3D_Sound) then
    begin
      inc(Result);
      list.Add(Sounds.Objects[i]);
    end;
end;

function TD3DScene.GetTones(key: integer; list: TList): integer;
var
  i: integer;
begin
  Result := 0;
  for i := 0 to Sounds.Count - 1 do
    if ((Sounds.Objects[i] as TD3DBaseAudio).GetKeyID = key) and
       ((Sounds.Objects[i] as TD3DBaseAudio).GetTypeID = ID3D_Tone) then
    begin
      inc(Result);
      list.Add(Sounds.Objects[i]);
    end;
end;
{$ENDIF}

function TD3DScene.GetNumObjectsByID(ID: integer): integer;
var
  i: integer;
begin
  if ID = ID3D_All then
  begin
    Result := Surfaces.Count +
{$IFNDEF NO_D3DSOUNDS}
              Sounds.Count +
{$ENDIF}
              CustomData.Count +
{$IFNDEF NO_SCRIPTS}
              Scripts.Count +
{$ENDIF}
              Actions.Count + Lights.Count;
  end
  else
  begin
    Result := 0;
    for i := 0 to Surfaces.Count - 1 do
      if ((Surfaces.Objects[i] as TD3DObject).GetTypeID = ID) then
        inc(Result);
{$IFNDEF NO_D3DSOUNDS}
    for i := 0 to Sounds.Count - 1 do
      if ((Sounds.Objects[i] as TD3DBaseAudio).GetTypeID = ID) then
        inc(Result);
{$ENDIF}
    for i := 0 to CustomData.Count - 1 do
      if ((CustomData.Objects[i] as TCustomData).GetTypeID = ID) then
        inc(Result);
{$IFNDEF NO_SCRIPTS}
    for i := 0 to Scripts.Count - 1 do
      if ((Scripts.Objects[i] as TScript).GetTypeID = ID) then
        inc(Result);
{$ENDIF}
    for i := 0 to Actions.Count - 1 do
      if ((Actions.Objects[i] as TD3DAction).GetTypeID = ID) then
        inc(Result);
    for i := 0 to Lights.Count - 1 do
      if ((Lights.Objects[i] as TD3DSceneLight).GetTypeID = ID) then
        inc(Result);
  end;
end;

procedure TD3DScene.ShowSurfaces(ID: integer; key: integer);
var
  i: integer;
begin
  if ID = ID3D_ALL then
  begin
    for i := 0 to Surfaces.Count - 1 do
      if (Surfaces.Objects[i] as TD3DObject).GetKeyID = key then
        (Surfaces.Objects[i] as TD3DObject).SetCulled(False)
  end
  else
  begin
    for i := 0 to Surfaces.Count - 1 do
      if ((Surfaces.Objects[i] as TD3DObject).GetTypeID = ID) and
         ((Surfaces.Objects[i] as TD3DObject).GetKeyID = key) then
        (Surfaces.Objects[i] as TD3DObject).SetCulled(False);
  end;
end;

procedure TD3DScene.HideSurfaces(ID: integer; key: integer);
var
  i: integer;
begin
  if ID = ID3D_ALL then
  begin
    for i := 0 to Surfaces.Count - 1 do
      if (Surfaces.Objects[i] as TD3DObject).GetKeyID = key then
        (Surfaces.Objects[i] as TD3DObject).SetCulled(True)
  end
  else
  begin
    for i := 0 to Surfaces.Count - 1 do
      if ((Surfaces.Objects[i] as TD3DObject).GetTypeID = ID) and
         ((Surfaces.Objects[i] as TD3DObject).GetKeyID = key) then
        (Surfaces.Objects[i] as TD3DObject).SetCulled(True);
  end;
end;

function TD3DScene.GetObjectsByID(ID: integer; key: integer; list: TList): integer;
var
  i: integer;
begin
  Result := 0;
  if ID = ID3D_All then
  begin
    for i := 0 to Surfaces.Count - 1 do
      if ((Surfaces.Objects[i] as TD3DObject).GetKeyID = key) then
      begin
        inc(Result);
        list.Add(Surfaces.Objects[i]);
      end;
{$IFNDEF NO_D3DSOUNDS}
    for i := 0 to Sounds.Count - 1 do
      if ((Sounds.Objects[i] as TD3DBaseAudio).GetKeyID = key) then
      begin
        inc(Result);
        list.Add(Sounds.Objects[i]);
      end;
{$ENDIF}
    for i := 0 to CustomData.Count - 1 do
      if ((CustomData.Objects[i] as TCustomData).GetKeyID = key) then
      begin
        inc(Result);
        list.Add(CustomData.Objects[i]);
      end;
{$IFNDEF NO_SCRIPTS}
    for i := 0 to Scripts.Count - 1 do
      if ((Scripts.Objects[i] as TScript).GetKeyID = key) then
      begin
        inc(Result);
        list.Add(Scripts.Objects[i]);
      end;
{$ENDIF}
    for i := 0 to Actions.Count - 1 do
      if ((Actions.Objects[i] as TD3DAction).GetKeyID = key) then
      begin
        inc(Result);
        list.Add(Actions.Objects[i]);
      end;
    for i := 0 to Lights.Count - 1 do
      if ((Lights.Objects[i] as TD3DSceneLight).GetKeyID = ID) then
      begin
        inc(Result);
        list.Add(Lights.Objects[i]);
      end;
  end
  else
  begin
    for i := 0 to Surfaces.Count - 1 do
      if ((Surfaces.Objects[i] as TD3DObject).GetTypeID = ID) and
         ((Surfaces.Objects[i] as TD3DObject).GetKeyID = key) then
      begin
        inc(Result);
        list.Add(Surfaces.Objects[i]);
      end;
{$IFNDEF NO_D3DSOUNDS}
    for i := 0 to Sounds.Count - 1 do
      if ((Sounds.Objects[i] as TD3DBaseAudio).GetTypeID = ID) and
         ((Sounds.Objects[i] as TD3DBaseAudio).GetKeyID = key) then
      begin
        inc(Result);
        list.Add(Sounds.Objects[i]);
      end;
{$ENDIF}
    for i := 0 to CustomData.Count - 1 do
      if ((CustomData.Objects[i] as TCustomData).GetTypeID = ID) and
         ((CustomData.Objects[i] as TCustomData).GetKeyID = key) then
      begin
        inc(Result);
        list.Add(CustomData.Objects[i]);
      end;
{$IFNDEF NO_SCRIPTS}
    for i := 0 to Scripts.Count - 1 do
      if ((Scripts.Objects[i] as TScript).GetTypeID = ID) and
         ((Scripts.Objects[i] as TScript).GetKeyID = key) then
      begin
        inc(Result);
        list.Add(Scripts.Objects[i]);
      end;
{$ENDIF}
    for i := 0 to Actions.Count - 1 do
      if ((Actions.Objects[i] as TD3DAction).GetTypeID = ID) and
         ((Actions.Objects[i] as TD3DAction).GetKeyID = key) then
      begin
        inc(Result);
        list.Add(Actions.Objects[i]);
      end;
    for i := 0 to Lights.Count - 1 do
      if ((Lights.Objects[i] as TD3DSceneLight).GetTypeID = ID) and
         ((Lights.Objects[i] as TD3DSceneLight).GetKeyID = key) then
      begin
        inc(Result);
        list.Add(Lights.Objects[i]);
      end;
  end;
end;

{$IFNDEF NO_D3DBILLBOARDS}
function TD3DScene.GetBillBoards(key: integer; list: TList): integer;
begin
  Result := GetObjectsByID(ID3D_BillBoard, key, list);
end;
{$ENDIF}

function TD3DScene.GetScenes(key: integer; list: TList): integer;
begin
  Result := GetObjectsByID(ID3D_Scene, key, list);
end;

function TD3DScene.GetCustomData(key: integer; list: TList): integer;
begin
  Result := GetObjectsByID(ID3D_Custom, key, list);
end;

{$IFNDEF NO_D3DSTUBOBJECTS}
function TD3DScene.GetStubObjects(key: integer; list: TList): integer;
begin
  Result := GetObjectsByID(ID3D_StubObject, key, list);
end;
{$ENDIF}

{$IFNDEF NO_D3DEXOBJECTS}
function TD3DScene.GetExObjects(key: integer; list: TList): integer;
begin
  Result := GetObjectsByID(ID3D_ExObject, key, list);
end;
{$ENDIF}

{$IFNDEF NO_D3DTRIANGLES}
function TD3DScene.GetTriangles(key: integer; list: TList): integer;
begin
  Result := GetObjectsByID(ID3D_Triangle, key, list);
end;
{$ENDIF}

function TD3DScene.GetQuadrangles(key: integer; list: TList): integer;
begin
  Result := GetObjectsByID(ID3D_Quadrangle, key, list);
end;

function TD3DScene.GetPolygons(key: integer; list: TList): integer;
begin
  Result := GetObjectsByID(ID3D_Polygon, key, list);
end;

{$IFNDEF NO_D3DPROCEDURALOBJECTS}
function TD3DScene.SetCurrentPrObject(key: integer): boolean;
var
  i: integer;
begin
  Result := True;
  if CurrentProceduralObject <> nil then
    if CurrentProceduralObject.Info.key = key then
      Exit;
  CurrentProceduralObject := nil;
  for i := 0 to Surfaces.Count - 1 do
    if (Surfaces.Objects[i] as TD3DObject).GetTypeID = ID3D_ProceduralObject then
      if (Surfaces.Objects[i] as TD3DProceduralObject).Info.key = key then
      begin
        CurrentProceduralObject := (Surfaces.Objects[i] as TD3DProceduralObject);
        Exit;
      end;
  Result := False;
end;

function TD3DScene.GetCurrentPrObject: integer;
begin
  if CurrentProceduralObject <> nil then
    Result := CurrentProceduralObject.Info.key
  else
    Result := -1;
end;

function TD3DScene.GetProceduralObjects(key: integer; list: TList): integer;
begin
  Result := GetObjectsByID(ID3D_ProceduralObject, key, list);
end;
{$ENDIF}

{$IFNDEF NO_D3DCUBES}
function TD3DScene.GetCubes(key: integer; list: TList): integer;
begin
  Result := GetObjectsByID(ID3D_Cube, key, list);
end;
{$ENDIF}

{$IFNDEF NO_D3DSPHERES}
function TD3DScene.GetSpheres(key: integer; list: TList): integer;
begin
  Result := GetObjectsByID(ID3D_Sphere, key, list);
end;
{$ENDIF}

{$IFNDEF NO_D3DCONES}
function TD3DScene.GetCones(key: integer; list: TList): integer;
begin
  Result := GetObjectsByID(ID3D_Cone, key, list);
end;
{$ENDIF}

{$IFNDEF NO_D3DCYLINDERS}
function TD3DScene.GetCylinders(key: integer; list: TList): integer;
begin
  Result := GetObjectsByID(ID3D_Cylinder, key, list);
end;
{$ENDIF}

{$IFNDEF NO_D3DPLUGINS}
function TD3DScene.GetPlugIns(key: integer; list: TList): integer;
begin
  Result := GetObjectsByID(ID3D_PlugIn, key, list);
end;
{$ENDIF}

{$IFNDEF NO_D3DRINGS}
function TD3DScene.GetRings(key: integer; list: TList): integer;
begin
  Result := GetObjectsByID(ID3D_Ring, key, list);
end;
{$ENDIF}

{$IFNDEF NO_D3DSECTORCOLLECTIONS}
function TD3DScene.GetSectorCollections(key: integer; list: TList): integer;
begin
  Result := GetObjectsByID(ID3D_SectorCollection, key, list);
end;
{$ENDIF}

{$IFNDEF NO_D3DTEXTS}
function TD3DScene.GetTexts(key: integer; list: TList): integer;
begin
  Result := GetObjectsByID(ID3D_Text, key, list);
end;
{$ENDIF}

{$IFNDEF NO_SCRIPTS}
function TD3DScene.GetScriptUnitName(ScriptName: string): string;
var
  name: string;
begin
  Result := '';
  if Scripts.IndexOf(ScriptName) <> -1 then
  begin
    name := ExtractFileName(ScriptName);
    Result := Copy(name, 0, Pos('.', name) - 1);
  end;
end;

function TD3DScene.GetScriptPData(UnitName: string): AnsiString;
var
  i: integer;
  name: string;
  s: TStream;
begin
  Result := '';
  for i := 0 to CustomData.Count - 1 do
  begin
    name := ExtractFileName(CustomData.Strings[i]);
    if UpperCase(name) = UpperCase(UnitName + rsExtPData) then
    begin
      (CustomData.Objects[i] as TCustomData).Stream.Seek(0, soFromBeginning);
      SetLength(Result, (CustomData.Objects[i] as TCustomData).Stream.Size);
      if Length(Result) > 0 then
      begin
        (CustomData.Objects[i] as TCustomData).Stream.Read(Result[1], Length(Result));
        (CustomData.Objects[i] as TCustomData).Stream.Seek(0, soFromBeginning);
        Exit;
      end;
    end;
  end;
// ֱם הום פן גסךבלו צןספשלםן פפו פן רקםןץלו  ףפן WAD  ףפן הףךן
  if InvokeWAD and Wad.EntryExist(GetExistedWadEntry(UnitName + rsExtPData)) then
  begin
    s := TMemoryStream.Create;
    try
      WAD.CopyToStream(GetExistedWadEntry(UnitName + rsExtPData), s);
      s.Seek(0, soFromBeginning);
      SetLength(Result, s.Size);
      if Length(Result) > 0 then
        s.Read(Result[1], Length(Result));
    finally
      s.Free;
    end;
  end
  else if InvokeResource then
  begin
    if IsValidInteger(GetExistedResourceEntry(UnitName)) then
      s := TResourceStream.CreateFromID(HInstance, StrToInt(GetExistedResourceEntry(UnitName)), PChar(rsRESData))
    else
      s := TResourceStream.Create(HInstance, GetExistedResourceEntry(UnitName), PChar(rsRESData));
    try
      s.Seek(0, soFromBeginning);
      SetLength(Result, s.Size);
      if Length(Result) > 0 then
        s.Read(Result[1], Length(Result));
    finally
      s.Free;
    end;
  end
  else
  begin
    if ExtractFileExt(UnitName) = '' then
      UnitName := UnitName + rsExtPData;
    if FileExists(GetExistedFileName(UnitName)) then
    begin
      s := TFileStream.Create(GetExistedFileName(UnitName), FMOpenRead or FMShareDenyWrite);
      try
        s.Seek(0, soFromBeginning);
        SetLength(Result, s.Size);
        if Length(Result) > 0 then
          s.Read(Result[1], Length(Result));
      finally
        s.Free;
      end;
    end;
  end
end;

function TD3DScene.GetScriptText(UnitName: string): AnsiString;
var
  i: integer;
  name: string;
  s: TStream;
begin
// ֱסקיך פן רקםןץלו ףפן IFSLibrary DataModule
  Result := IFSLibrary.GetScriptText(UnitName);
  if Result <> '' then
    Exit; // OK, גסטחךו ףפן IFSLibrary DataModule, בם ץנסקוי בככן‎ טב פן בדםןףןץלו
  for i := 0 to Scripts.Count - 1 do
  begin
    name := ExtractFileName(Scripts.Strings[i]);
    if UpperCase(Copy(name, 0, Pos('.', name) - 1)) = UpperCase(UnitName) then
    begin
      Result := (Scripts.Objects[i] as TScript).Text;
      Exit;
    end;
  end;
// ֱם הום פן גסךבלו צןספשלםן פפו פן רקםןץלו  ףפן WAD  ףפן הףךן
  if InvokeWAD and Wad.EntryExist(GetExistedWadEntry(UnitName + rsExtScript)) then
  begin
    s := TMemoryStream.Create;
    try
      WAD.CopyToStream(GetExistedWadEntry(UnitName + rsExtScript), s);
      s.Seek(0, soFromBeginning);
      SetLength(Result, s.Size);
      if Length(Result) > 0 then
        s.Read(Result[1], Length(Result));
    finally
      s.Free;
    end;
  end
  else if InvokeResource then
  begin
    if IsValidInteger(GetExistedResourceEntry(UnitName)) then
      s := TResourceStream.CreateFromID(HInstance, StrToInt(GetExistedResourceEntry(UnitName)), PChar(rsRESData))
    else
      s := TResourceStream.Create(HInstance, GetExistedResourceEntry(UnitName), PChar(rsRESData));
    try
      s.Seek(0, soFromBeginning);
      SetLength(Result, s.Size);
      if Length(Result) > 0 then
        s.Read(Result[1], Length(Result));
    finally
      s.Free;
    end;
  end
  else
  begin
    if ExtractFileExt(UnitName) = '' then
      UnitName := UnitName + rsExtScript;
    if FileExists(GetExistedFileName(UnitName)) then
    begin
      s := TFileStream.Create(GetExistedFileName(UnitName), FMOpenRead or FMShareDenyWrite);
      try
        s.Seek(0, soFromBeginning);
        SetLength(Result, s.Size);
        if Length(Result) > 0 then
          s.Read(Result[1], Length(Result));
      finally
        s.Free;
      end;
    end;
  end
end;

function TD3DScene.ScriptTextExists(UnitName: string): boolean;
var
  i: integer;
  name: string;
begin
// ֱסקיך פן רקםןץלו ףפן IFSLibrary DataModule
  Result := IFSLibrary.GetScriptText(UnitName) <> '';
  if Result then
    Exit; // OK, גסטחךו ףפן IFSLibrary DataModule
  for i := 0 to Scripts.Count - 1 do
  begin
    name := ExtractFileName(Scripts.Strings[i]);
    if UpperCase(Copy(name, 0, Pos('.', name) - 1)) = UpperCase(UnitName) then
    begin
      Result := True;
      Exit;
    end;
  end;
// ֱם הום פן גסךבלו צןספשלםן פפו פן רקםןץלו  ףפן WAD  ףפן הףךן
  if InvokeWAD and Wad.EntryExist(GetExistedWadEntry(UnitName)) then
  begin
    Result := True;
    Exit;
  end
  else if FileExists(GetExistedFileName(UnitName + rsExtScript)) then
  begin
    Result := True;
    Exit
  end
  else if InvokeResource then
    Result := True;
end;

function TD3DScene.GetScripts(key: integer; list: TList): integer;
begin
  Result := GetObjectsByID(ID3D_Script, key, list);
end;
{$ENDIF}

function TD3DScene.TextureName: string;
begin
  Result := Info.PathToScene;
end;

function TD3DScene.GetTypeID: byte;
begin
  Result := ID3D_Scene;
end;

function TD3DScene.GetKeyID: integer;
begin
  Result := Info.Key;
end;

{$IFNDEF NO_MESSAGESCAN}
procedure TD3DScene.MessageScan;
var
  msg: TMsg;
begin
  while PeekMessage(msg, 0, 0, 0, PM_REMOVE) do
    if (msg.message = WM_SETCURSOR) or
       (msg.message = WM_TIMER) or
       (msg.message = WM_PAINT) then
      DispatchMessage(msg)
end;
{$ENDIF}

procedure TD3DScene.OnWadProgress(Sender: TObject; Stage: TZProgressStage; PercentDone: Byte);
begin
{$IFNDEF NO_MESSAGESCAN}
  MessageScan;
{$ENDIF}
end;

{$IFNDEF NO_SCRIPTS}
procedure TD3DScene.RunUnit(name: string);
begin
  ScriptEngine.RunUnit(name);
end;

procedure TD3DScene.RunCode(code: string);
begin
  ScriptEngine.RunCode(code);
end;

procedure TD3DScene.SetEventsEnabled(Value: boolean);
var
  i: integer;
begin
  if fEventsEnabled <> Value then
  begin
    fEventsEnabled := Value;
    for i := 0 to _CacheNestedScenes.Count - 1 do
      (_CacheNestedScenes.Objects[i] as TD3DScene).EventsEnabled := value;
  end;
end;
{$ENDIF}

procedure TD3DScene.AddFutureProc(ProcName: string; EventID: byte; TimeDelta: double);
var
  Proc: TFutureProcInfo;
begin
  if (EventID in [0..AttachedEventsCount - 1]) and (FutureProcList[EventID] <> nil) then
  begin
    Proc.EventID := EventID;
    Proc.TimeToExecute := Time + TimeDelta;
    Proc.ProcName := ProcName;
    FutureProcList[EventID].Insert(Proc);
  end;
end;

procedure TD3DScene.FutureProcEnum(Proc: TFutureProcInfo);
var
  p: procedure; stdcall;
begin
  p := GetProcAddress(HInstance, PChar(Proc.ProcName));
  if Assigned(p) then
    p
{$IFNDEF NO_SCRIPTS}
  else
    RunProcedure(Proc.ProcName, True)
  {$ENDIF};
end;

{$IFNDEF NO_SCRIPTS}
procedure TD3DScene.RunEvent(ID: integer; DispatchError: boolean);
begin
  if fEventsEnabled then
    if ScriptEngine <> nil then
    begin
      if FutureProcList[ID] <> nil then
        FutureProcList[ID].Execute(Time);
      RunProcedure(AttachedEventsTable[ID].ProcName, DispatchError);
    end;
end;

procedure TD3DScene.RunProcedure(procName: string; DispatchError: boolean);
begin
  if ScriptEngine <> nil then
    ScriptEngine.RunProcedure(procName, DispatchError);
end;

procedure TD3DScene.ScriptStopRun;
begin
  iStatus := iStopped;
end;

procedure TD3DScene.SyntaxCheckUnit(name: string);
begin
  if ScriptEngine <> nil then
    ScriptEngine.SyntaxCheckUnit(name);
end;

procedure TD3DScene.SyntaxCheckCode(code: string);
begin
  if ScriptEngine <> nil then
    ScriptEngine.SyntaxCheckCode(code);
end;

procedure TD3DScene.StepOverUnit(name: string);
begin
  if ScriptEngine <> nil then
    ScriptEngine.StepOverUnit(name);
end;

procedure TD3DScene.StepOverCode(code: string);
begin
  if ScriptEngine <> nil then
    ScriptEngine.StepOverCode(code);
end;

procedure TD3DScene.StartScriptEngine;
var
  code: AnsiString;
  i: integer;
begin
// װבמיםןלן‎לו פחם כףפב לו פב Script.
// ַ פבמיםלחףח דםופבי דיבפ פןנןטופן‎לו נסןףטופיך פב scripts ףפן ScriptEngine
// ¸פףי בנןצו‎דןץלו limitations פןץ כויפןץסדיךן‎ ףץףפלבפןע דיב פן לדוטןע פןץ
// ‏היךב (נק Edit Control -> קוי limitation ףפן לדוטןע פןץ ךוילםןץ נןץ לנןסו
// םב נוסיקוי
  IsScriptStarting := True;
  Scripts.CustomSort(SortScriptKeyProc);
  code := '';
  for i := 0 to Scripts.Count - 1 do
    if (Scripts.Objects[i] as TScript).Info.AttachedEvent = ID3D_EVENTMAIN then // 1 -> ץסשע נסדסבללב
      code := code + (Scripts.Objects[i] as TScript).Text + NL; // ׀סןףטופיך פןנןטפחףח scripts
  for i := 0 to AttachedEventsCount - 1 do
    FutureProcList[i] := TFutureProcList.Create(FutureProcEnum);
  if ScriptEngine <> nil then
  begin
    ScriptEngine.OnRunLine := nil;
    ScriptEngine.SetText(code);
    if (ScriptEngine.ErrorCode <= ENoError) and EventsEnabled then
    begin
      ScriptEngine.RunScript;
      RunEvent(ID3D_EVENTMAIN, True);
{$IFNDEF NO_D3DPROCEDURALOBJECTS}
      RunProceduralObjects;
{$ENDIF}
      RunEvent(ID3D_EVENTONCREATE, True);
    end;
  end;
  IsScriptStarting := False;
end;

procedure TD3DScene.StopScriptEngine;
var
  i: integer;
begin
  IsScriptFinishing := True;
  if ScriptEngine <> nil then
  begin
//  if ScriptEngine.ErrorCode <= ENoError then
    RunEvent(ID3D_EVENTONEXIT, True);
    ScriptEngine.CleanUp;
// Stop fog
    StopFog;
// Clean up runtime actions that may be left from code
    DeleteRunTimeActions;
// Clean up runtime objects that may be left from code
    DeleteNonSaveAbleObjects;
// Stop CDAudio playback
    StopCDAudio;
// Stop Midi playback
    StopMidi;
// Kill Direct Media Server
    KillMedia;
// Kill Speech Engine
    SpeakKill;
    PlayOldStyleSound('');
  end;
  for i := 0 to AttachedEventsCount - 1 do
    FreeAndNilSafe(FutureProcList[i]);
  IsScriptFinishing := False;
end;

procedure TD3DScene.RestartScriptEngine;
begin
  StopScriptEngine;
  StartScriptEngine;
end;

procedure TD3DScene.DoScriptMessage(Sender: TObject; Message: string);
begin
  if Assigned(fOnScriptMessage) then
    fOnScriptMessage(Sender, Message);
end;

procedure TD3DScene.DoScriptError(Sender: TObject; Module: string;
  ErrorPos: integer; ErrorString: string);
begin
  if Assigned(fOnScriptError) then
    fOnScriptError(Sender, Module, ErrorPos, ErrorString);
end;

procedure TD3DScene.DoScriptWarning(Sender: TObject;
      Module: string; ErrorPos: integer; ErrorString: string);
begin
  if Assigned(fOnScriptWarning) then
    fOnScriptWarning(Sender, Module, ErrorPos, ErrorString);
end;

procedure TD3DScene.DoRunLine(Sender: TObject; Position: integer);
begin
  if Assigned(fOnRunLine) then
    fOnRunLine(Sender, Position);
end;
{$ENDIF}

function IsMap(m: string): boolean;
begin
  Result := True;
  if Length(m) < 3 then
    Result := False
  else if UpperCase(m[Length(m) - 3] + m[Length(m) - 2] + m[Length(m) - 1] + m[Length(m)]) <> rsDefaultD3DExtention then
    Result := False;
end;

// *** TD3DSectorCollection ***

{$IFNDEF NO_D3DSECTORCOLLECTIONS}
procedure DoneSectorCollectionInfo2(var inf: TD3DSectorCollectionInfo2);
begin
  ReallocMem(inf.Points, 0);
  inf.NumPoints := 0;
  ReallocMem(inf.LineDefs, 0);
  inf.NumSideDefs := 0;
  ReallocMem(inf.SideDefs, 0);
  inf.NumLineDefs := 0;
  ReallocMem(inf.Sectors, 0);
  inf.NumSectors := 0;
end;

procedure NewSectorCollectionInfo2(var inf: PD3DSectorCollectionInfo2);
begin
  new(inf);
  FillChar(inf^, SizeOf(inf^), Chr(0));
end;

procedure DisposeSectorCollectionInfo2(var inf: PD3DSectorCollectionInfo2);
begin
  ReallocMem(inf.Points, 0);
  inf.NumPoints := 0;
  ReallocMem(inf.LineDefs, 0);
  inf.NumSideDefs := 0;
  ReallocMem(inf.SideDefs, 0);
  inf.NumLineDefs := 0;
  ReallocMem(inf.Sectors, 0);
  inf.NumSectors := 0;
  dispose(inf);
end;                     

procedure CopySectorCollectionInfo(source: PD3DSectorCollectionInfo;
  dest: PD3DSectorCollectionInfo);
var
  i: integer;
begin
  dest.Key := source.Key;
  dest.x := source.x;
  dest.y := source.y;
  dest.z := source.z;
  dest.dx := source.dx;
  dest.dy := source.dy;
  dest.dz := source.dz;
  dest.TexturePixelsPerUnit := source.TexturePixelsPerUnit;

  dest.InSideDrawStart := source.InSideDrawStart;
  dest.InSideDrawEnd := source.InSideDrawEnd;
  dest.OutSideDrawStart := source.OutSideDrawStart;
  dest.OutSideDrawEnd := source.OutSideDrawEnd;

  dest.CheckNavigation := source.CheckNavigation;
  dest.DrawTheObjects := source.DrawTheObjects;

  dest.numPoints := source.numPoints;
  for i := 0 to dest.numPoints - 1 do dest.Points[i] := source.Points[i];
  dest.numSideDefs := source.numSideDefs;
  for i := 0 to dest.numSideDefs - 1 do dest.SideDefs[i] := source.SideDefs[i];
  dest.numLineDefs := source.numLineDefs;
  for i := 0 to dest.numLineDefs - 1 do dest.LineDefs[i] := source.LineDefs[i];
  dest.numSectors := source.numSectors;
  for i := 0 to dest.numSectors - 1 do dest.Sectors[i] := source.Sectors[i];
end;

procedure CopySectorCollectionInfo2(source: PD3DSectorCollectionInfo2;
  dest: PD3DSectorCollectionInfo2);
var
  i: integer;
begin
  dest.Key := source.Key;
  dest.x := source.x;
  dest.y := source.y;
  dest.z := source.z;
  dest.dx := source.dx;
  dest.dy := source.dy;
  dest.dz := source.dz;
  dest.TexturePixelsPerUnit := source.TexturePixelsPerUnit;

  dest.InSideDrawStart := source.InSideDrawStart;
  dest.InSideDrawEnd := source.InSideDrawEnd;
  dest.OutSideDrawStart := source.OutSideDrawStart;
  dest.OutSideDrawEnd := source.OutSideDrawEnd;

  dest.CheckNavigation := source.CheckNavigation;
  dest.DrawTheObjects := source.DrawTheObjects;

  dest.numPoints := source.numPoints;
  ReAllocMem(dest.Points, dest.numPoints * SizeOf(TSectorPoint));
  for i := 0 to dest.numPoints - 1 do dest.Points[i] := source.Points[i];
  dest.numSideDefs := source.numSideDefs;
  ReAllocMem(dest.SideDefs, dest.numSideDefs * SizeOf(TSectorSideDef));
  for i := 0 to dest.numSideDefs - 1 do dest.SideDefs[i] := source.SideDefs[i];
  dest.numLineDefs := source.numLineDefs;
  ReAllocMem(dest.LineDefs, dest.numLineDefs * SizeOf(TSectorLineDef));
  for i := 0 to dest.numLineDefs - 1 do dest.LineDefs[i] := source.LineDefs[i];
  dest.numSectors := source.numSectors;
  ReAllocMem(dest.Sectors, dest.numSectors * SizeOf(TSector));
  for i := 0 to dest.numSectors - 1 do dest.Sectors[i] := source.Sectors[i];
end;

procedure CopySectorCollectionInfoFromInfo2(source: PD3DSectorCollectionInfo2;
  dest: PD3DSectorCollectionInfo);
var
  i: integer;
begin
  dest.Key := source.Key;
  dest.x := source.x;
  dest.y := source.y;
  dest.z := source.z;
  dest.dx := source.dx;
  dest.dy := source.dy;
  dest.dz := source.dz;
  dest.TexturePixelsPerUnit := source.TexturePixelsPerUnit;

  dest.InSideDrawStart := source.InSideDrawStart;
  dest.InSideDrawEnd := source.InSideDrawEnd;
  dest.OutSideDrawStart := source.OutSideDrawStart;
  dest.OutSideDrawEnd := source.OutSideDrawEnd;

  dest.CheckNavigation := source.CheckNavigation;
  dest.DrawTheObjects := source.DrawTheObjects;

  dest.numPoints := source.numPoints;
  for i := 0 to dest.numPoints - 1 do dest.Points[i] := source.Points[i];
  dest.numSideDefs := source.numSideDefs;
  for i := 0 to dest.numSideDefs - 1 do dest.SideDefs[i] := source.SideDefs[i];
  dest.numLineDefs := source.numLineDefs;
  for i := 0 to dest.numLineDefs - 1 do dest.LineDefs[i] := source.LineDefs[i];
  dest.numSectors := source.numSectors;
  for i := 0 to dest.numSectors - 1 do dest.Sectors[i] := source.Sectors[i];
end;

procedure CopySectorCollectionInfo2FromInfo(source: PD3DSectorCollectionInfo;
  dest: PD3DSectorCollectionInfo2);
var
  i: integer;
begin
  dest.Key := source.Key;
  dest.x := source.x;
  dest.y := source.y;
  dest.z := source.z;
  dest.dx := source.dx;
  dest.dy := source.dy;
  dest.dz := source.dz;
  dest.TexturePixelsPerUnit := source.TexturePixelsPerUnit;

  dest.InSideDrawStart := source.InSideDrawStart;
  dest.InSideDrawEnd := source.InSideDrawEnd;
  dest.OutSideDrawStart := source.OutSideDrawStart;
  dest.OutSideDrawEnd := source.OutSideDrawEnd;

  dest.CheckNavigation := source.CheckNavigation;
  dest.DrawTheObjects := source.DrawTheObjects;

  dest.numPoints := source.numPoints;
  ReAllocMem(dest.Points, dest.numPoints * SizeOf(TSectorPoint));
  for i := 0 to dest.numPoints - 1 do dest.Points[i] := source.Points[i];
  dest.numSideDefs := source.numSideDefs;
  ReAllocMem(dest.SideDefs, dest.numSideDefs * SizeOf(TSectorSideDef));
  for i := 0 to dest.numSideDefs - 1 do dest.SideDefs[i] := source.SideDefs[i];
  dest.numLineDefs := source.numLineDefs;
  ReAllocMem(dest.LineDefs, dest.numLineDefs * SizeOf(TSectorLineDef));
  for i := 0 to dest.numLineDefs - 1 do dest.LineDefs[i] := source.LineDefs[i];
  dest.numSectors := source.numSectors;
  ReAllocMem(dest.Sectors, dest.numSectors * SizeOf(TSector));
  for i := 0 to dest.numSectors - 1 do dest.Sectors[i] := source.Sectors[i];
end;

function LineDefLength(inf: PD3DSectorCollectionInfo2; ld: word): TD3DValue;
{ ֵניףפסצוי פן לךןע פןץ LineDef לו הוךפח ld }
begin
  Result :=
    sqrt(sqr(inf.Points[inf.LineDefs[ld].start].x -
             inf.Points[inf.LineDefs[ld]._End].x) +
         sqr(inf.Points[inf.LineDefs[ld].start].y -
             inf.Points[inf.LineDefs[ld]._End].y));
end;

function SideDefHeight(inf: PD3DSectorCollectionInfo2; sd: word): TD3DValue;
{ ֵניףפסצוי פן ‎רןע פןץ SideDef לו הוךפח sd }
begin
  Result := inf.Sectors[inf.SideDefs[sd].Sector].ceilh -
            inf.Sectors[inf.SideDefs[sd].Sector].floorh;
end;

// *** TD3DSectorCollection *** //

procedure TD3DSectorCollection.PreCreate;
begin
  fNeedsAcceptRotationY := False;
  fNewRotationY := 0.0;

{  fBoundingCube.minX := g_MINHUGE;
  fBoundingCube.maxX := g_HUGE;
  fBoundingCube.minY := g_MINHUGE;
  fBoundingCube.maxY := g_HUGE;
  fBoundingCube.minZ := g_MINHUGE;
  fBoundingCube.maxZ := g_HUGE;}

  // ֱסקיךע פילע True ‏ףפו ףפח בנסירח םב דםןץם פב ףשףפ cull
  fIsInsideClosedSector := True;
  fIsInsideSector := True;

  if  fSideNavigationInfos <> nil then
    ReallocMem(fSideNavigationInfos, 0);
  fNumSides := 0;
  if fSubSectorNavigationInfos <> nil then
    ReallocMem(fSubSectorNavigationInfos, 0);
  fNumSubSectors := 0;
  if Info2.Points <> nil then
    ReAllocMem(Info2.Points, 0);
  if Info2.SideDefs <> nil then
    ReAllocMem(Info2.SideDefs, 0);
  if Info2.LineDefs <> nil then
    ReAllocMem(Info2.LineDefs, 0);
  if Info2.Sectors <> nil then
    ReAllocMem(Info2.Sectors, 0);
end;

constructor TD3DSectorCollection.Create(aInfo: TD3DSectorCollectionInfo2; aScene: TD3DScene; active: boolean = True);
begin
  fSideNavigationInfos := nil;
  fSubSectorNavigationInfos := nil;
  Info2.Points := nil;
  Info2.SideDefs := nil;
  Info2.LineDefs := nil;
  Info2.Sectors := nil;

  PreCreate;

  gravityFactor := 0.0;
  fGravityVelocity := 0.0;
  CopySectorCollectionInfo2(@aInfo, @Info2);
  Info.x := Info2.x;
  Info.y := Info2.y;
  Info.z := Info2.z;
  Info.dx := Info2.dx;
  Info.dy := Info2.dy;
  Info.dz := Info2.dz;
  Info.Key := Info2.key;
  Info.PathToScene := '';
  fParent := aScene;
  if fParent <> nil then
    Inherited Create(fParent.DXDraw, {$IFNDEF NO_D3DSOUNDS}fParent.DXSound, {$ENDIF}True)
  else
    Inherited Create(nil, {$IFNDEF NO_D3DSOUNDS}nil, {$ENDIF}True);
{$IFDEF DESIGNER}
  CanSaveUndo := False;
{$ENDIF}
  if active then
  begin
    MakeTheSurfaces;
    InitialRotate(MakeD3DVector(Info.dx, Info.dy, Info.dz));
    InitialMove(MakeD3DVector(Info.x, Info.y, Info.z));
    ForceRecalc;
  end;
end;

constructor TD3DSectorCollection.CreateFromStream(s: TStream; aScene: TD3DScene; version: integer; active: boolean = True);
begin
  fSideNavigationInfos := nil;
  fSubSectorNavigationInfos := nil;
  Info2.Points := nil;
  Info2.SideDefs := nil;
  Info2.LineDefs := nil;
  Info2.Sectors := nil;

  PreCreate;

  LoadFromStream(s, version);
  Info.x := Info2.x;
  Info.y := Info2.y;
  Info.z := Info2.z;
  Info.dx := Info2.dx;
  Info.dy := Info2.dy;
  Info.dz := Info2.dz;
  Info.Key := Info2.key;
  Info.PathToScene := '';
  fParent := aScene;
  if fParent <> nil then
    Inherited Create(fParent.DXDraw, {$IFNDEF NO_D3DSOUNDS}fParent.DXSound, {$ENDIF}True)
  else
    Inherited Create(nil, {$IFNDEF NO_D3DSOUNDS}nil, {$ENDIF}True);
{$IFDEF DESIGNER}
  CanSaveUndo := False;
{$ENDIF}
  if active then
  begin
    MakeTheSurfaces;
    InitialRotate(MakeD3DVector(Info.dx, Info.dy, Info.dz));
    InitialMove(MakeD3DVector(Info.x, Info.y, Info.z));
    ForceRecalc;
  end;
end;

destructor TD3DSectorCollection.Destroy;
var
  i: integer;
begin
  Inherited;
  DoneSectorCollectionInfo2(Info2);
  for i := 0 to fnumSubSectors - 1 do
  begin
    ReAllocMem(fSubSectorNavigationInfos[i].FloorTriangles, 0);
    ReAllocMem(fSubSectorNavigationInfos[i].CeilingTriangles, 0);
  end;
  ReAllocMem(fSubSectorNavigationInfos, 0);
  ReallocMem(fSideNavigationInfos, 0);
end;

procedure TD3DSectorCollection.fCalcCenterAndRadius;
begin
  fCenter := MakeD3DVector(Info.x, Info.y, Info.z);
//  BoundingCube.
  // fRadius := ?
end;

procedure TD3DSectorCollection.SetIsInsideSector(Value: boolean);
// ֱנןססנפוי פב Info2.InSideDrawStart שע Info2.InSideDrawEnd לםן
var
  i: integer;
begin
  if Value <> fIsInSideSector then
  begin
    fIsInsideSector := Value;
    for i := 0 to fParent.Surfaces.Count - 1 do
      if (fParent.Surfaces.Objects[i] as TD3DObject).GetTypeID <> ID3D_SECTORCOLLECTION then
        if IsIntegerInRange((fParent.Surfaces.Objects[i] as TD3DObject).GetKeyID,
          Info2.InSideDrawStart, Info2.InSideDrawEnd) then
            (fParent.Surfaces.Objects[i] as TD3DObject).SetCulled(not Value);
  end;
end;

procedure TD3DSectorCollection.SetIsInsideClosedSector(Value: boolean);
var
  i: integer;
begin
  if Value <> fIsInSideClosedSector then
  begin
    fIsInSideClosedSector := Value;

    if fParent <> nil then
    begin
      if fIsInSideClosedSector then   // ֱם ולבףפו לףב ףו ךכויףפ פןלב...
      begin
      // ֿי ץנכןינוע ףץככןדע הום ףקוהיזןםפבי
        for i := 0 to fParent._CacheSectorCollections.Count - 1 do
          if fParent._CacheSectorCollections.Objects[i] <> self then
            (fParent._CacheSectorCollections.Objects[i] as TD3DSectorCollection).SetCulled(True);
      end
      else // ִום ולבףפו לףב ףו ךכויףפ פןלב...
      begin
      // ¼כוע ןי ףץככןדע ףקוהיזןםפבי
        for i := 0 to fParent._CacheSectorCollections.Count - 1 do
          if fParent._CacheSectorCollections.Objects[i] <> self then
            (fParent._CacheSectorCollections.Objects[i] as TD3DSectorCollection).SetCulled(False);
      end;
    end;
  end;
end;

function TD3DSectorCollection.AddSurface(SurfaceType: byte; pInfo: Pointer): TD3DObject;
begin
  Result := Inherited AddSurface(SurfaceType, pInfo);
  if Result <> nil then
    Result.RunTimeOnly := True;
end;

procedure TD3DSectorCollection.GetInfo(p: Pointer);
begin
  CopySectorCollectionInfo2(@Info2, PD3DSectorCollectionInfo2(p));
end;

function TD3DSectorCollection.GetTypeID: byte;
begin
  Result := ID3D_SectorCollection;
end;

procedure TD3DSectorCollection.CopyCollectionInfoFromInfo2(source: PD3DSectorCollectionInfo2;
  var dest: PD3DSectorCollectionInfo);
begin
  CopySectorCollectionInfoFromInfo2(source, dest);
end;

procedure TD3DSectorCollection.CopyCollectionInfo2FromInfo(source: PD3DSectorCollectionInfo;
  var dest: PD3DSectorCollectionInfo2);
begin
  CopySectorCollectionInfo2FromInfo(source, dest);
end;

procedure TD3DSectorCollection.CopyCollectionInfo(source, dest: PD3DSectorCollectionInfo);
begin
  CopySectorCollectionInfo(source, dest);
end;

function TD3DSectorCollection.LineDefLength(ld: word): TD3DValue;
{ ֵניףפסצוי פן לךןע פןץ LineDef לו הוךפח ld }
begin
  Result :=
    sqrt(sqr(Info2.Points[Info2.LineDefs[ld].start].x -
             Info2.Points[Info2.LineDefs[ld]._End].x) +
         sqr(Info2.Points[Info2.LineDefs[ld].start].y -
             Info2.Points[Info2.LineDefs[ld]._End].y));
end;

function TD3DSectorCollection.SideDefHeight(sd: word): TD3DValue;
{ ֵניףפסצוי פן ‎רןע פןץ SideDef לו הוךפח sd }
begin
  Result := Info2.Sectors[Info2.SideDefs[sd].Sector].ceilh -
            Info2.Sectors[Info2.SideDefs[sd].Sector].floorh;
end;

procedure TD3DSectorCollection.DrawLoop;
begin
  if Info2.DrawTheObjects then
    Inherited;
end;

function TD3DSectorCollection.GetNumVertexes: integer;
begin
  if Info2.DrawTheObjects then
    Result := Inherited GetNumVertexes
  else
    Result := 0;
end;

function TD3DSectorCollection.GetNumTriangles: integer;
begin
  if Info2.DrawTheObjects then
    Result := Inherited GetNumTriangles
  else
    Result := 0;
end;

// םוי בככבדע ףפב bounding boxes ךבי ףפב פסדשםב ףו נוסנפשףח לופבךםחףחע
procedure TD3DSectorCollection.AdjustMovementNavigationInfo(x, y, z: TD3DValue);
var
  i, j, k: integer;

  procedure AdjustBoundingCube(var cb: TBoundingCube);
  begin
    cb.minX := cb.minX + x;
    cb.maxX := cb.maxX + x;
    cb.minY := cb.minY + y;
    cb.maxY := cb.maxY + y;
    cb.minZ := cb.minZ + z;
    cb.maxZ := cb.maxZ + z;
  end;

begin
  if (x <> 0) or (y <> 0) or (z <> 0) then
  begin
    AdjustBoundingCube(fBoundingCube);
    for i := 0 to Info2.numSectors - 1 do
      AdjustBoundingCube(Info2.Sectors[i].BoundingCube);
    for i := 0 to fnumSubSectors - 1 do
    begin
      AdjustBoundingCube(fSubSectorNavigationInfos[i].BoundingCube);
      for j := 0 to fSubSectorNavigationInfos[i].NumFloorTriangles - 1 do
        for k := 0 to 2 do
        begin
          fSubSectorNavigationInfos[i].FloorTriangles[j][k].x :=
            fSubSectorNavigationInfos[i].FloorTriangles[j][k].x + x;
          fSubSectorNavigationInfos[i].FloorTriangles[j][k].y :=
            fSubSectorNavigationInfos[i].FloorTriangles[j][k].y + y;
          fSubSectorNavigationInfos[i].FloorTriangles[j][k].z :=
            fSubSectorNavigationInfos[i].FloorTriangles[j][k].z + z;
        end;
      for j := 0 to fSubSectorNavigationInfos[i].NumCeilingTriangles - 1 do
        for k := 0 to 2 do
        begin
          fSubSectorNavigationInfos[i].CeilingTriangles[j][k].x :=
            fSubSectorNavigationInfos[i].CeilingTriangles[j][k].x + x;
          fSubSectorNavigationInfos[i].CeilingTriangles[j][k].y :=
            fSubSectorNavigationInfos[i].CeilingTriangles[j][k].y + y;
          fSubSectorNavigationInfos[i].CeilingTriangles[j][k].z :=
            fSubSectorNavigationInfos[i].CeilingTriangles[j][k].z + z;
        end;
    end;
  end;
end;

procedure TD3DSectorCollection.InitialMove(vM: TD3DVector);
begin
  Inherited;
  AdjustMovementNavigationInfo(vM.x, vM.y, vM.z);
end;

procedure TD3DSectorCollection.InitialRotate(vM: TD3DVector);
begin
  Inherited;
end;

procedure TD3DSectorCollection.InitialMove(x, y, z: TD3DValue);
begin
  Inherited;
  AdjustMovementNavigationInfo(x, y, z);
end;

procedure TD3DSectorCollection.InitialRotate(x, y, z: TD3DValue);
begin
  Inherited;
end;

procedure TD3DSectorCollection.SetCulled(Value: boolean);
var
  i: integer;
begin
  if Value <> fCulled then
  begin
    fCulled := Value;
    for i := 0 to Surfaces.Count - 1 do
      (Surfaces.Objects[i] as TD3DObject).Culled := Value;
    if fParent <> nil then
      for i := 0 to fParent.Surfaces.Count - 1 do
        if (fParent.Surfaces.Objects[i] as TD3DObject).GetTypeID <> ID3D_SECTORCOLLECTION then
        begin
          if IsIntegerInRange((fParent.Surfaces.Objects[i] as TD3DObject).GetKeyID,
               Info2.OutSideDrawStart, Info2.OutSideDrawEnd) then
            (fParent.Surfaces.Objects[i] as TD3DObject).Culled := Value;
          if IsIntegerInRange((fParent.Surfaces.Objects[i] as TD3DObject).GetKeyID,
               Info2.InSideDrawStart, Info2.InSideDrawEnd) then
            (fParent.Surfaces.Objects[i] as TD3DObject).Culled := not fIsInSideClosedSector;
        end;
  end;
end;

function TD3DSectorCollection.AcceptRotation(var rot: TD3DVector): boolean;
begin
  if fNeedsAcceptRotationY then
  begin
    fNeedsAcceptRotationY := False;
    rot.y := fNewRotationY;
    Result := True;
  end
  else
    Result := False;
end;

function TD3DSectorCollection.BoundingCube: TBoundingCube;
begin
  Result := fBoundingCube;
end;

function TD3DSectorCollection.AcceptCeilingProjection(var pos: TD3DVector): boolean;
// ֵניףפסצוי פן פבגםי ם ץנסקוי sector ףפן 3D ףחלון pos
var
  i, j, k: integer;
begin
  Result := False;
  for i := 0 to Info2.numSectors - 1 do
    if VectorInCube(pos, Info2.Sectors[i].BoundingCube) and
      (Info2.Sectors[i].CheckFloorNavigation or
       Info2.Sectors[i].CheckCeilingNavigation) then
// **************************************************
// **** ֱסק וכדקןץ פשם SubSectors פןץ Sector i ****
// **************************************************
// ׃בס‏םןץלו כב פב SubSectors פןץ Sector i
        for j := Info2.Sectors[i].SubSectorStart to Info2.Sectors[i].SubSectorEnd do
// ֵכדקןץלו בם ח נסןגןכ פחע טףחע וםבי ףפן BoundingCube פןץ ךטו subsector פןץ sector i
          if ProjectionInCube(pos, fSubSectorNavigationInfos[j].BoundingCube) then
          // ֳיב ךטו פסדשםן פןץ subsector
            for k := 0 to fSubSectorNavigationInfos[j].NumCeilingTriangles - 1 do
              if F_PtInTriangle(fSubSectorNavigationInfos[j].CeilingTriangles[k], pos) then
              begin
              // ֱם וםבי בנכץפב וננוהןע פןלבע פפו פן ‎רןע minX ץנןכןדזופבי ו‎ךןכב
                if Info2.Sectors[i].AbsoluteFlat then
                  pos.Y := fSubSectorNavigationInfos[j].CeilingTriangles[k][0].y
                else
                  pos.Y :=
                    GetTriangleProjection(fSubSectorNavigationInfos[j].CeilingTriangles[k], pos);
                Result := True;
                Exit;
              end;
end;

function TD3DSectorCollection.AcceptCeilingProjection(const pos: TFloatPoint; var y: TD3DValue): boolean;
// ֵניףפסצוי פן פבגםי ם ץנסקוי sector ףפן 2D ףחלון pos
// ׀סןףןק, הום וכדקוי בם ולבףפו לףב ףפן sector collection
var
  i, j, k: integer;
begin
  Result := False;
  for i := 0 to Info2.numSectors - 1 do
    if ProjectionInCube(pos, Info2.Sectors[i].BoundingCube) and
      (Info2.Sectors[i].CheckFloorNavigation or
       Info2.Sectors[i].CheckCeilingNavigation) then
// **************************************************
// **** ֱסק וכדקןץ פשם SubSectors פןץ Sector i ****
// **************************************************
// ׃בס‏םןץלו כב פב SubSectors פןץ Sector i
        for j := Info2.Sectors[i].SubSectorStart to Info2.Sectors[i].SubSectorEnd do
// ֵכדקןץלו בם ח נסןגןכ פחע טףחע וםבי ףפן BoundingCube פןץ ךטו subsector פןץ sector i
          if ProjectionInCube(pos, fSubSectorNavigationInfos[j].BoundingCube) then
          // ֳיב ךטו פסדשםן פןץ subsector
            for k := 0 to fSubSectorNavigationInfos[j].NumCeilingTriangles - 1 do
              if F_PtInTriangle(fSubSectorNavigationInfos[j].CeilingTriangles[k], pos) then
              begin
              // ֱם וםבי בנכץפב וננוהןע פןלבע פפו פן ‎רןע minX ץנןכןדזופבי ו‎ךןכב
                if Info2.Sectors[i].AbsoluteFlat then
                  y := fSubSectorNavigationInfos[j].CeilingTriangles[k][0].y
                else
                  y := GetTriangleProjection(fSubSectorNavigationInfos[j].CeilingTriangles[k], pos);
                Result := True;
                Exit;
              end;
end;

function TD3DSectorCollection.AcceptCeilingProjection(const pos: TFloatPoint; var y: TD3DValue; var aSubSector: integer; var aTriangle: integer): boolean;
// ֵניףפסצוי פן פבגםי ם ץנסקוי sector ףפן 2D ףחלון pos
// ׀סןףןק, הום וכדקוי בם ולבףפו לףב ףפן sector collection
// aSubSector, aTriangle: ¾נןנפo Triangle פןץ SubSector ףפן ןנןן לנןסו םב קןץלו hit
var
  i, j, k: integer;
begin
  if (aSubSector >= 0) and (aTriangle >= 0) then
    if F_PtInTriangle(fSubSectorNavigationInfos[aSubSector].FloorTriangles[aTriangle], pos) then
    begin
      y := GetTriangleProjection(fSubSectorNavigationInfos[aSubSector].FloorTriangles[aTriangle], pos);
      Result := True;
      Exit;
    end;

  Result := False;
  for i := 0 to Info2.numSectors - 1 do
    if ProjectionInCube(pos, Info2.Sectors[i].BoundingCube) and
      (Info2.Sectors[i].CheckFloorNavigation or
       Info2.Sectors[i].CheckCeilingNavigation) then
// **************************************************
// **** ֱסק וכדקןץ פשם SubSectors פןץ Sector i ****
// **************************************************
// ׃בס‏םןץלו כב פב SubSectors פןץ Sector i
        for j := Info2.Sectors[i].SubSectorStart to Info2.Sectors[i].SubSectorEnd do
// ֵכדקןץלו בם ח נסןגןכ פחע טףחע וםבי ףפן BoundingCube פןץ ךטו subsector פןץ sector i
          if ProjectionInCube(pos, fSubSectorNavigationInfos[j].BoundingCube) then
          // ֳיב ךטו פסדשםן פןץ subsector
            for k := 0 to fSubSectorNavigationInfos[j].NumCeilingTriangles - 1 do
              if F_PtInTriangle(fSubSectorNavigationInfos[j].CeilingTriangles[k], pos) then
              begin
              // ֱם וםבי בנכץפב וננוהןע פןלבע פפו פן ‎רןע minX ץנןכןדזופבי ו‎ךןכב
                if Info2.Sectors[i].AbsoluteFlat then
                  y := fSubSectorNavigationInfos[j].CeilingTriangles[k][0].y
                else
                  y := GetTriangleProjection(fSubSectorNavigationInfos[j].CeilingTriangles[k], pos);
                Result := True;
                Exit;
              end;
end;

function TD3DSectorCollection.AcceptFloorProjection(var pos: TD3DVector): boolean;
// ֵניףפסצוי פן נפשלב ם ץנסקוי sector ףפן 3D ףחלון pos
var
  i, j, k: integer;
begin
  Result := False;
  for i := 0 to Info2.numSectors - 1 do
    if VectorInCube(pos, Info2.Sectors[i].BoundingCube) and
      (Info2.Sectors[i].CheckFloorNavigation or
       Info2.Sectors[i].CheckCeilingNavigation) then
// **************************************************
// **** ֱסק וכדקןץ פשם SubSectors פןץ Sector i ****
// **************************************************
// ׃בס‏םןץלו כב פב SubSectors פןץ Sector i
        for j := Info2.Sectors[i].SubSectorStart to Info2.Sectors[i].SubSectorEnd do
// ֵכדקןץלו בם ח נסןגןכ פחע טףחע וםבי ףפן BoundingCube פןץ ךטו subsector פןץ sector i
          if ProjectionInCube(pos, fSubSectorNavigationInfos[j].BoundingCube) then
          // ֳיב ךטו פסדשםן פןץ subsector
            for k := 0 to fSubSectorNavigationInfos[j].NumFloorTriangles - 1 do
              if F_PtInTriangle(fSubSectorNavigationInfos[j].FloorTriangles[k], pos) then
              begin
              // ֱם וםבי בנכץפב וננוהןע פןלבע פפו פן ‎רןע minX ץנןכןדזופבי ו‎ךןכב
                if Info2.Sectors[i].AbsoluteFlat then
                  pos.Y := fSubSectorNavigationInfos[j].FloorTriangles[k][0].y
                else
                  pos.Y :=
                    GetTriangleProjection(fSubSectorNavigationInfos[j].FloorTriangles[k], pos);
                Result := True;
                Exit;
              end;
end;

function TD3DSectorCollection.AcceptFloorProjection(const pos: TFloatPoint; var y: TD3DValue): boolean;
// ֵניףפסצוי פן נפשלב ם ץנסקוי sector ףפן 2D ףחלון pos
// ׀סןףןק, הום וכדקוי בם ולבףפו לףב ףפן sector collection
var
  i, j, k: integer;
begin
  Result := False;
  for i := 0 to Info2.numSectors - 1 do
    if ProjectionInCube(pos, Info2.Sectors[i].BoundingCube) and
      (Info2.Sectors[i].CheckFloorNavigation or
       Info2.Sectors[i].CheckCeilingNavigation) then
// **************************************************
// **** ֱסק וכדקןץ פשם SubSectors פןץ Sector i ****
// **************************************************
// ׃בס‏םןץלו כב פב SubSectors פןץ Sector i
        for j := Info2.Sectors[i].SubSectorStart to Info2.Sectors[i].SubSectorEnd do
// ֵכדקןץלו בם ח נסןגןכ פחע טףחע וםבי ףפן BoundingCube פןץ ךטו subsector פןץ sector i
          if ProjectionInCube(pos, fSubSectorNavigationInfos[j].BoundingCube) then
          // ֳיב ךטו פסדשםן פןץ subsector
            for k := 0 to fSubSectorNavigationInfos[j].NumFloorTriangles - 1 do
              if F_PtInTriangle(fSubSectorNavigationInfos[j].FloorTriangles[k], pos) then
              begin
              // ֱם וםבי בנכץפב וננוהןע פןלבע פפו פן ‎רןע minX ץנןכןדזופבי ו‎ךןכב
                if Info2.Sectors[i].AbsoluteFlat then
                  y := fSubSectorNavigationInfos[j].FloorTriangles[k][0].y
                else
                  y := GetTriangleProjection(fSubSectorNavigationInfos[j].FloorTriangles[k], pos);
                Result := True;
                Exit;
              end;
end;

function TD3DSectorCollection.AcceptFloorProjection(const pos: TFloatPoint; var y: TD3DValue; var aSubSector: integer; var aTriangle: integer): boolean;
// ֵניףפסצוי פן נפשלב ם ץנסקוי sector ףפן 2D ףחלון pos
// ׀סןףןק, הום וכדקוי בם ולבףפו לףב ףפן sector collection
// aSubSector, aTriangle: ¾נןנפo Triangle פןץ SubSector ףפן ןנןן לנןסו םב קןץלו hit
var
  i, j, k: integer;
begin
  if (aSubSector >= 0) and (aTriangle >= 0) then
    if F_PtInTriangle(fSubSectorNavigationInfos[aSubSector].FloorTriangles[aTriangle], pos) then
    begin
      y := GetTriangleProjection(fSubSectorNavigationInfos[aSubSector].FloorTriangles[aTriangle], pos);
      Result := True;
      Exit;
    end;

  Result := False;
  for i := 0 to Info2.numSectors - 1 do
    if ProjectionInCube(pos, Info2.Sectors[i].BoundingCube) and
      (Info2.Sectors[i].CheckFloorNavigation or
       Info2.Sectors[i].CheckCeilingNavigation) then
// **************************************************
// **** ֱסק וכדקןץ פשם SubSectors פןץ Sector i ****
// **************************************************
// ׃בס‏םןץלו כב פב SubSectors פןץ Sector i
        for j := Info2.Sectors[i].SubSectorStart to Info2.Sectors[i].SubSectorEnd do
// ֵכדקןץלו בם ח נסןגןכ פחע טףחע וםבי ףפן BoundingCube פןץ ךטו subsector פןץ sector i
          if ProjectionInCube(pos, fSubSectorNavigationInfos[j].BoundingCube) then
          // ֳיב ךטו פסדשםן פןץ subsector
            for k := 0 to fSubSectorNavigationInfos[j].NumFloorTriangles - 1 do
              if F_PtInTriangle(fSubSectorNavigationInfos[j].FloorTriangles[k], pos) then
              begin
              // ֱם וםבי בנכץפב וננוהןע פןלבע פפו פן ‎רןע minX ץנןכןדזופבי ו‎ךןכב
                if Info2.Sectors[i].AbsoluteFlat then
                  y := fSubSectorNavigationInfos[j].FloorTriangles[k][0].y
                else
                  y := GetTriangleProjection(fSubSectorNavigationInfos[j].FloorTriangles[k], pos);
                aTriangle := k;
                aSubSector := j;
                Result := True;
                Exit;
              end;
end;

function TD3DSectorCollection.AcceptPosition(const oldPos: TD3DVector;
  var pos: TD3DVector): integer;
// ֵניפסצוי True בם הום קסויזופבי םב ףץםוקיףפו ן כודקןע
var
  i, j, k, l: integer;
  minY, maxY: TD3DValue;
  r, r2: TFloatRect;
  flag: boolean;
  pS: PSector;
  fOldGravityVelocity: TD3DValue;

  function MakeIntersection(var newPos: TD3DVector; const oldPos: TD3DVector;
    const step1, step2: TFloatPoint; const distance: TD3DValue; const nvType: TNavigationType): boolean;
  begin
    case nvType of
      ntStop:
        Result := MakeStopIntersection(newPos, oldPos, step1, step2, distance);
      ntSlide:
        Result := MakeSlideIntersection(newPos, oldPos, step1, step2, distance);
      ntReflect:
        begin
          fNewRotationY := fParent.Rotation.y;
          Result := MakeReflectIntersection(newPos, oldPos, step1, step2, distance, fNewRotationY);
          fNeedsAcceptRotationY := fNeedsAcceptRotationY or Result;
        end;
    else
      Result := False;
    end;
  end;

begin
  fOldGravityVelocity := fGravityVelocity;
  fGravityVelocity := 0.0;
  Result := 0;
  if not Info2.CheckNavigation then
    Exit;
// ֱם ח טףח pos הום וםבי לףב ףפן BoundingCube פפו הום קסויזופבי םב ךםןץלו פנןפו!
  CurrentSector := -1;
  if VectorInCube(pos, fBoundingCube) or VectorInCube(oldPos, fBoundingCube) then
  begin
    minY := g_MINHUGE;
    maxY := g_HUGE;

    MakeFloatRect(r2, oldPos, pos);

    pS := @Info2.Sectors[0];
    for i := 0 to Info2.numSectors - 1 do
    begin
      if (pS.CheckWallsNavigation and
          pS.AllowWalkThru and
          pS.CheckFloorNavigation and
          VectorInCube(oldPos, pS.BoundingCube)) {or
(*2/6/04*) not Info2.Sectors[i].AllowWalkThru} then
      begin
        r.left := r2.Left - pS.MinDistanceFromWalls / 2;
        r.right := r2.right + pS.MinDistanceFromWalls / 2;
        r.Top := r2.top - pS.MinDistanceFromWalls / 2;
        r.Bottom := r2.Bottom + pS.MinDistanceFromWalls / 2;

// ֱם ח טףח וםבי לףב ףפן BoundingCube פןץ sector
// ׃בס‏םןץלו כב פב SubSectors פןץ Sector i
        for j := pS.SubSectorStart to pS.SubSectorEnd do
// ֵכדקןץלו בם ח נסןגןכ פחע טףחע וםבי ףפן BoundingCube פןץ ךטו subsector פןץ sector i
          if ProjectionInCube(oldPos, fSubSectorNavigationInfos[j].BoundingCube) then
          // ֳיב ךטו פסדשםן פןץ subsector
            for k := 0 to fSubSectorNavigationInfos[j].NumFloorTriangles - 1 do
              if F_PtInTriangle(fSubSectorNavigationInfos[j].FloorTriangles[k], oldPos) then
              begin
                flag := False;
//                tmpPos := pos;
                for l := pS.SideStart to pS.SideEnd do
                  if IntersectFloatRect(fSideNavigationInfos[l].BoundingRect, r) then
                      flag := flag or MakeIntersection(pos, oldPos,
                        fSideNavigationInfos[l].start, fSideNavigationInfos[l]._End,
                        pS.MinDistanceFromWalls, fSideNavigationInfos[l].NavigationType);
                if flag then
                  for l := pS.SideEnd downto pS.SideStart do
                    if IntersectFloatRect(fSideNavigationInfos[l].BoundingRect, r) then
                      MakeIntersection(pos, oldPos,
                        fSideNavigationInfos[l].start, fSideNavigationInfos[l]._End,
                        pS.MinDistanceFromWalls, fSideNavigationInfos[l].NavigationType);
              end;
      end;
      inc(pS);
    end;

// ׃בס‏םןץלו כב פב Sectors
    pS := @Info2.Sectors[0];
    for i := 0 to Info2.numSectors - 1 do
    begin
      if VectorInCube(pos, pS.BoundingCube) and
        (pS.CheckFloorNavigation or
         pS.CheckCeilingNavigation or
         not pS.AllowWalkThru) then
// **************************************************
// **** ֱסק וכדקןץ פשם SubSectors פןץ Sector i ****
// **************************************************
// ׃בס‏םןץלו כב פב SubSectors פןץ Sector i
        for j := pS.SubSectorStart to pS.SubSectorEnd do
// ֵכדקןץלו בם ח נסןגןכ פחע טףחע וםבי ףפן BoundingCube פןץ ךטו subsector פןץ sector i
          if ProjectionInCube(pos, fSubSectorNavigationInfos[j].BoundingCube) then
          begin
            if pS.AllowWalkThru then
            begin
            // ֱם ן פןלבע וכדקוי פן נפשלב
              if pS.CheckFloorNavigation then
              // ֳיב ךטו פסדשםן פןץ subsector
                for k := 0 to fSubSectorNavigationInfos[j].NumFloorTriangles - 1 do
                  if F_PtInTriangle(fSubSectorNavigationInfos[j].FloorTriangles[k], pos) then
                  begin
                  // ֱם וםבי בנכץפב וננוהןע פןלבע פפו פן ‎רןע minX ץנןכןדזופבי ו‎ךןכב
                    if pS.AbsoluteFlat then
                      minY := fSubSectorNavigationInfos[j].FloorTriangles[k][0].y +
                        pS.MinDistanceFromFloor
                    else
                      minY :=
                        GetTriangleProjection(fSubSectorNavigationInfos[j].FloorTriangles[k], pos) +
                          pS.MinDistanceFromFloor;
                    Result := 1;
                    break;
                  end;
              if pS.CheckCeilingNavigation and not pS.GravityBehaviour then
              // ֱם Info2.Sectors[i].GravityBehaviour = True, פפו הום וכדקןץלו פן פבגםי,
              // נלו ךבפוץטובם ףפןם נפן!
                for k := 0 to fSubSectorNavigationInfos[j].NumCeilingTriangles - 1 do
                  if F_PtInTriangle(fSubSectorNavigationInfos[j].CeilingTriangles[k], pos) then
                  begin
                    if pS.AbsoluteFlat then
                      maxY := fSubSectorNavigationInfos[j].CeilingTriangles[k][0].y -
                        pS.MinDistanceFromCeiling
                    else
                      maxY :=
                        GetTriangleProjection(fSubSectorNavigationInfos[j].CeilingTriangles[k], pos) -
                          pS.MinDistanceFromCeiling;
                    Result := 1;
                    break;
                  end;
              if Result > 0 then
              begin
{killed 25/9/05
                if pS.GravityBehaviour then
                  pos.y := minY
                else
                  pos.y := GetValueInRange(pos.y, minY, maxY);
                SetIsInSideSector(True);
                CurrentSector := i;
                SetIsInSideClosedSector(pS.ifInsideCullOtherCollections);
                Exit;}
                if pS.GravityBehaviour then
                begin
                  if (gravityFactor = 0) or
                     (fParent = nil) or
                     (pos.y <= minY) or
                     (fParent.FPS < 1.1) then
                    pos.y := minY
                  else
                  begin
                  // Added 25/9/05 -> Simulation of gravity
//                    pos.y := pos.y - (pos.y - minY) / (fParent.FPS * gravityFactor);
//                      pos.y := oldpos.y - gravityFactor / fParent.FPS;
//                      pos.y := pos.y - Max(0, oldPos.y - pos.y);
                    fGravityVelocity := fOldGravityVelocity + gravityFactor / fParent.FPS;
                    pos.y := oldpos.y - fGravityVelocity;


//                    pos.y := oldpos.y - (oldpos.y - minY) / (fParent.FPS * gravityFactor);
//                    pos.y := pos.y - Max(0, oldPos.y - pos.y);// / (fParent.FPS * gravityFactor);
                    Result := 2;
                    if pos.y < minY then
                      pos.y := minY;
                  end;
                end
                else
                  pos.y := GetValueInRange(pos.y, minY, maxY);
                SetIsInSideSector(True);
                CurrentSector := i;
                SetIsInSideClosedSector(pS.ifInsideCullOtherCollections);
                Exit;
              end;
            end
            else // ֿ פןלבע הום וניפסנוי פחם ךםחףח לףב פןץ
            begin
(* 31/5/2004

                  for k := Info2.Sectors[i].SideEnd downto Info2.Sectors[i].SideStart do
                      MakeIntersection(pos, oldPos,
                        fSideNavigationInfos[k].start, fSideNavigationInfos[k]._End,
                          Info2.Sectors[i].MinDistanceFromWalls, fSideNavigationInfos[l].NavigationType);

 31/5/2004*)

              for k := 0 to fSubSectorNavigationInfos[j].NumFloorTriangles - 1 do
                if F_PtInTriangle(fSubSectorNavigationInfos[j].FloorTriangles[k], pos) then
                begin
                  pos := oldPos;
                  Result := 1;
                  Exit;
                end;
            end;

{              if not VectorEquel(oldPos, pos) then
              begin
                tmpPos := oldPos;
            // ֱם וניפסנןפבם ח ךםחףח ףפן נבכבי ףחלון פפו לופבךיםן‎לבףפו ףו בץפ
                if AcceptPosition(oldPos, tmpPos) then
                begin

                  pos := MakeD3DVector(
                          (2*oldPos.x + Pos.x) / 3,
                          (2*oldPos.y + Pos.y) / 3,
                          (2*oldPos.z + Pos.z) / 3);
//                  AcceptPosition(oldPos, pos);
                  Result := True;
                  Exit;
                end;
              end;
            end;  }
          end;
       inc(pS);
     end;
// **************************************************
// **** װכןע וכדקןץ פשם SubSectors פןץ Sector i ***
// **************************************************
  end;
//  SetIsInsideSector(False);
  SetIsInSideClosedSector(False);
end;

{
// ׀בכביע כודקןע, וכדקוי פב נןכ‎דשםב
function TD3DSectorCollection.AcceptPosition(var pos: TD3DVector): boolean;
// ֵניפסצוי True בם ךבםו בככבדע ףפחם טףח pos
var
  i, j: integer;
  tr: TFloatTriangle;
  ptTest: TFloatPoint;
begin
  Result := False;
// ֱם ח טףח pos הום וםבי לףב ףפן BoundingCube פפו הום קסויזופבי םב ךםןץלו פנןפו!
  if VectorInCube(pos, BoundingCube) then
  begin
    ptTest.x := pos.x;
    ptTest.y := pos.z;
    for i := 0 to Surfaces.Count - 1 do
      if (Surfaces.Objects[i] is TD3DPolygon) then
      begin
      // ֿ כודקןע םב דםוי לםן ףו נבפ‏לבפב, קי ףו כב פב פסדשםב נשע ךםןץלו נבסבךפש
        for j := 0 to (Surfaces.Objects[i] as TD3DPolygon).Info2.NumVertexes div 3 - 1 do
        begin
          tr[0].x := (Surfaces.Objects[i] as TD3DPolygon).TheVertexes[j * 3].x;
          tr[0].y := (Surfaces.Objects[i] as TD3DPolygon).TheVertexes[j * 3].z;
          tr[1].x := (Surfaces.Objects[i] as TD3DPolygon).TheVertexes[j * 3 + 1].x;
          tr[1].y := (Surfaces.Objects[i] as TD3DPolygon).TheVertexes[j * 3 + 1].z;
          tr[2].x := (Surfaces.Objects[i] as TD3DPolygon).TheVertexes[j * 3 + 2].x;
          tr[2].y := (Surfaces.Objects[i] as TD3DPolygon).TheVertexes[j * 3 + 2].z;
          if F_PtInTriangle(tr, ptTest) then
          begin
          // ֵיךןםיך בככבד view
            pos.y := GetValueInRange(
              pos.y,
              (Surfaces.Objects[i] as TD3DPolygon).TheVertexes[j * 3].y + 0.8,
              (Surfaces.Objects[i] as TD3DPolygon).TheVertexes[j * 3].y + 1.2);
            Result := True;
            Exit;
          end;
        end;
      end;
  end;
end;
}

////////////////////////////////////////////////////////////////////////////////
// װן נבסבךפש פללב ך‏היךב ףפחסזופבי ףפןם בכדסץטלן נןץ קסחףילןנןיופבי ףפן //
// se_Doomutils.pas. //
procedure TD3DSectorCollection.MakeTheSurfaces;
const
  DEFTOLERANCE = 0.001;
var
  pInf: TD3DPolygonInfo;
  qInf: TD3DQuadrangleInfo;
  i: integer;
  lSectorsLines: PSectorCollectionLines;
  numSectorsLines: integer;
  ceilingPatch: PSingleArray;
{$IFNDEF ICONICSECTORCOLLECTIONS}
  TextureNames: TDXStringList;
{$ENDIF}

  function FindSectorDataOfSideDef(sd: word;
    var floorh1a, floorh1b, ceilh1a, ceilh1b,
        floorh2a, floorh2b, ceilh2a, ceilh2b: TD3DValue): boolean;
    { ֵניףפסצוי פב ‎רח פןץ נבפ‏לבפןע ךבי פןץ פבגבםין‎ בנ פב Sector
      נןץ בםפיףפןיקן‎ם ףפחם SideDef לו הוךפח sd }
  var
    local_i: integer;
    secnum: word;
    pld: PSectorLineDef;
  begin
    Result := False;
    if sd = $FFFF then
    begin
      floorh1a := 0.0;
      floorh1b := 0.0;
      ceilh1a := 0.0;
      ceilh1b := 0.0;
      floorh2a := 0.0;
      floorh2b := 0.0;
      ceilh2a := 0.0;
      ceilh2b := 0.0;
      Exit;
    end;
    local_i := Info2.SideDefs[sd].LineDef;
    if local_i < Info2.numLineDefs then
    begin
      pld := @Info2.LineDefs[local_i];
      if pld.SideDef1 = sd then // Found, check the other SideDef
      begin
        if pld.SideDef2 < Info2.numSideDefs then // ּםן בם קוי 2 SideDef ום‏םוי 2 Sectors
        begin
          // ֱם פן sector וםבי flat, פפו ץנןכןדזןץלו פב ‎רח בנ פיע פילע פןץ sector
          secnum := Info2.SideDefs[sd].Sector;
          if (secnum < Info2.numSectors) and Info2.Sectors[secnum].AbsoluteFlat then
          begin
            floorh1a := Info2.Sectors[secnum].floorh;
            floorh1b := floorh1a;
            ceilh1a  := Info2.Sectors[secnum].ceilh;
            ceilh1b  := ceilh1a;
          end
          // ֱם פן sector הום וםבי flat, פפו ץנןכןדזןץלו פב ‎רח בנ פיע פילע פשם ףחלושם
          else
          begin
            floorh1a := Info2.Points[pld.start].bottom;
            floorh1b := Info2.Points[pld._End].bottom;
            ceilh1a  := Info2.Points[pld.start].top;
            ceilh1b  := Info2.Points[pld._End].top;
          end;

          // ֱם פן sector וםבי flat, פפו ץנןכןדזןץלו פב ‎רח בנ פיע פילע פןץ sector
            secnum := Info2.SideDefs[pld.SideDef2].Sector;
          if (secnum < Info2.numSectors) and Info2.Sectors[secnum].AbsoluteFlat then
          begin
            floorh2a := Info2.Sectors[secnum].floorh;
            floorh2b := floorh2a;
            ceilh2a  := Info2.Sectors[secnum].ceilh;
            ceilh2b  := ceilh2a;
          end
          // ֱם פן sector הום וםבי flat, פפו ץנןכןדזןץלו פב ‎רח בנ פיע פילע פשם ףחלושם
          else
          begin
            floorh2a := Info2.Points[pld.start].bottom;
            floorh2b := Info2.Points[pld._End].bottom;
            ceilh2a  := Info2.Points[pld.start].top;
            ceilh2b  := Info2.Points[pld._End].top;
          end;
          Result := True;
        end;
      end
      else if pld.SideDef2 = sd then // Found, check the other
      begin
        if pld.SideDef1 < Info2.numSideDefs then
        begin
          // ֱם פן sector וםבי flat, פפו ץנןכןדזןץלו פב ‎רח בנ פיע פילע פןץ sector
          secnum := Info2.SideDefs[sd].Sector;
          if (secnum < Info2.numSectors) and Info2.Sectors[secnum].AbsoluteFlat then
          begin
            floorh1a := Info2.Sectors[secnum].floorh;
            floorh1b := floorh1a;
            ceilh1a  := Info2.Sectors[secnum].ceilh;
            ceilh1b  := ceilh1a;
          end
          // ֱם פן sector הום וםבי flat, פפו ץנןכןדזןץלו פב ‎רח בנ פיע פילע פשם ףחלושם
          else
          begin
            floorh1a := Info2.Points[pld.start].bottom;
            floorh1b := Info2.Points[pld._End].bottom;
            ceilh1a  := Info2.Points[pld.start].top;
            ceilh1b  := Info2.Points[pld._End].top;
          end;

          // ֱם פן sector וםבי flat, פפו ץנןכןדזןץלו פב ‎רח בנ פיע פילע פןץ sector
          secnum := Info2.SideDefs[pld.SideDef1].Sector;
          if (secnum < Info2.numSectors) and Info2.Sectors[secnum].AbsoluteFlat then
          begin
            floorh2a := Info2.Sectors[secnum].floorh;
            floorh2b := floorh2a;
            ceilh2a  := Info2.Sectors[secnum].ceilh;
            ceilh2b  := ceilh2a;
          end
          // ֱם פן sector הום וםבי flat, פפו ץנןכןדזןץלו פב ‎רח בנ פיע פילע פשם ףחלושם
          else
          begin
            floorh2a := Info2.Points[pld.start].bottom;
            floorh2b := Info2.Points[pld._End].bottom;
            ceilh2a  := Info2.Points[pld.start].top;
            ceilh2b  := Info2.Points[pld._End].top;
          end;
          Result := True;
        end;
      end;
    end;
  end;

  procedure MakeQInfUV(len, height, xofs, yofs: TD3DValue; wPerUnit, hPerUnit: TD3DValue);
  // ׁץטלזוי פחם ונבםבכחנפיךפחפב פןץ texture ףפן פופסדשםן
  begin
    if wPerUnit > 0 then
    begin
      qInf.u := len * wPerUnit;
      qInf.du := xofs * wPerUnit;
    end
    else
    begin
      qInf.u := 1;
      qInf.du := 0;
    end;
    if hPerUnit > 0 then
    begin
      qInf.v := height * hPerUnit;
      qInf.dv := yofs * hPerUnit;
    end
    else
    begin
      qInf.v := 1;
      qInf.dv := 0;
    end;
  end;

  procedure MakeSideDefInfoSpecific_tex12(ld, sd: integer; first: boolean);
    { first: True בם וםבי ח SideDef1, False דיב פחם SideDef2}
    { ִחליןץסדב Upper & Lower textures quadranges}
  var
    floorh1a, floorh1b,
    ceilh1a, ceilh1b,
    floorh2a, floorh2b,
    ceilh2a, ceilh2b: TD3DValue;
    len: TD3DValue;
    start1,
    end1: PSectorPoint;
    psd: PSectorSideDef;
  begin
    // ֵנויה ךםןץלו פב upper & lower פללב םב קןץם הינכ נכוץס, הום קסויזופבי
    // םב כגןץלו ץנרח פן נןיב SideDef קןץלו, נבס לםן דיב פןם קסשלבפיףל ףפב ףחלוב
    qInf.flags := flg_DoubleSided;
    start1 := @Info2.Points[Info2.LineDefs[ld].start];
    end1 := @Info2.Points[Info2.LineDefs[ld]._end];

    if first then
    begin
      qInf.C1 := start1.topColor;
      qInf.C2 := end1.topColor;
      qInf.C3 := start1.bottomColor;
      qInf.C4 := end1.bottomColor;
{        qInf.C1 := Info2.Points[Info2.LineDefs[ld].start].topColor;
        qInf.C2 := Info2.Points[Info2.LineDefs[ld]._end].topColor;
        qInf.C3 := Info2.Points[Info2.LineDefs[ld].start].bottomColor;
        qInf.C4 := Info2.Points[Info2.LineDefs[ld]._end].bottomColor;}
    end
    else
    begin
      qInf.C1 := end1.topColor;
      qInf.C2 := start1.topColor;
      qInf.C3 := end1.bottomColor;
      qInf.C4 := start1.bottomColor;
{        qInf.C1 := Info2.Points[Info2.LineDefs[ld]._end].topColor;
        qInf.C2 := Info2.Points[Info2.LineDefs[ld].start].topColor;
        qInf.C3 := Info2.Points[Info2.LineDefs[ld]._end].bottomColor;
        qInf.C4 := Info2.Points[Info2.LineDefs[ld].start].bottomColor;}
    end;

    len := LineDefLength(ld);
    if FindSectorDataOfSideDef(sd,
         floorh1a, floorh1b,
         ceilh1a, ceilh1b,
         floorh2a, floorh2b,
         ceilh2a, ceilh2b) then
    begin
      psd := @Info2.SideDefs[sd];
      if (ceilh1a > ceilh2a) or (ceilh1b > ceilh2b) then
      begin
        qInf.TextureName := psd.tex1; // Upper texture
       // Texture dimentions
        MakeQInfUV(
            len,
            ((ceilh1a - ceilh2a) + (ceilh1b - ceilh2b)) / 2, // ּףןע סןע היבצןסע פבגבםי‏ם
            psd.xoff,
            psd.yoff,
            psd.TexturePixelsPerUnit,
            psd.TexturePixelsPerUnit);

        qInf.x1 := start1.x;
        qInf.y1 := ceilh1a;
        qInf.z1 := start1.y;

        qInf.x2 := end1.x;
        qInf.y2 := ceilh1b;
        qInf.z2 := end1.y;

        qInf.x3 := start1.x;
        qInf.y3 := ceilh2a;
        qInf.z3 := start1.y;

        qInf.x4 := end1.x;
        qInf.y4 := ceilh2b;
        qInf.z4 := end1.y;


{        qInf.x1 := Info2.Points[Info2.LineDefs[ld].start].x;
        qInf.y1 := ceilh1a;
        qInf.z1 := Info2.Points[Info2.LineDefs[ld].start].y;

        qInf.x2 := Info2.Points[Info2.LineDefs[ld]._End].x;
        qInf.y2 := ceilh1b;
        qInf.z2 := Info2.Points[Info2.LineDefs[ld]._End].y;

        qInf.x3 := Info2.Points[Info2.LineDefs[ld].start].x;
        qInf.y3 := ceilh2a;
        qInf.z3 := Info2.Points[Info2.LineDefs[ld].start].y;

        qInf.x4 := Info2.Points[Info2.LineDefs[ld]._End].x;
        qInf.y4 := ceilh2b;
        qInf.z4 := Info2.Points[Info2.LineDefs[ld]._End].y;}

        // ֱם ח דסבלל וםבי היצבםח & הום ץנסקוי texture הום ךםןץלו פנןפו
        if not Info2.LineDefs[ld].Transparent or (psd.tex1 <> '') then
          MergePolygonData(ID3D_Quadrangle, @qInf);
      end;

      if (floorh1a < floorh2a) or (floorh1b < floorh2b) then
      begin
        qInf.TextureName := psd.tex2; // Upper texture
       // Texture dimentions
        MakeQInfUV(
            len,
            ((floorh2a - floorh1a) + (floorh2b - floorh1b))/2, // ּףןע סןע היבצןסע נבפשלפשם
            psd.xoff,
            psd.yoff,
            psd.TexturePixelsPerUnit,
            psd.TexturePixelsPerUnit);

        qInf.x1 := start1.x;
        qInf.y1 := floorh2a;
        qInf.z1 := start1.y;

        qInf.x2 := end1.x;
        qInf.y2 := floorh2b;
        qInf.z2 := end1.y;

        qInf.x3 := start1.x;
        qInf.y3 := floorh1a;
        qInf.z3 := start1.y;

        qInf.x4 := end1.x;
        qInf.y4 := floorh1b;
        qInf.z4 := end1.y;

{        qInf.x1 := Info2.Points[Info2.LineDefs[ld].start].x;
        qInf.y1 := floorh2a;
        qInf.z1 := Info2.Points[Info2.LineDefs[ld].start].y;

        qInf.x2 := Info2.Points[Info2.LineDefs[ld]._End].x;
        qInf.y2 := floorh2b;
        qInf.z2 := Info2.Points[Info2.LineDefs[ld]._End].y;

        qInf.x3 := Info2.Points[Info2.LineDefs[ld].start].x;
        qInf.y3 := floorh1a;
        qInf.z3 := Info2.Points[Info2.LineDefs[ld].start].y;

        qInf.x4 := Info2.Points[Info2.LineDefs[ld]._End].x;
        qInf.y4 := floorh1b;
        qInf.z4 := Info2.Points[Info2.LineDefs[ld]._End].y;}

        // ֱם ח דסבלל וםבי היצבםח & הום ץנסקוי texture הום ךםןץלו פנןפו
        if not Info2.LineDefs[ld].Transparent or (psd.tex2 <> '') then
          MergePolygonData(ID3D_Quadrangle, @qInf);
      end;
    end;
  end;

  procedure MakeSideDefInfoSpecific_tex3(ld, sd: integer; first: boolean);
  // Make Normal Texture
  { ld: LineDef index.
    sd: SideDef index. }
  var
    start1,
    end1: PSectorPoint;
    psd: PSectorSideDef;
    pld: PSectorLineDef;
    pss: PSector;
    fh, ch: TD3DValue;
  begin
    psd := @Info2.SideDefs[sd];
    pld := @Info2.LineDefs[ld];
    if (pld.Transparent) and (psd.tex3 = '') then
      Exit;

    if (pld.Transparent) or
       (pld.SideDef1 >= Info2.numSideDefs) or
       (pld.SideDef2 >= Info2.numSideDefs) then
    begin
      qInf.flags := flg_DoubleSided;
      qInf.Transparent := True;
    end
    else
    begin
      qInf.flags := 0;
      qInf.Transparent := False;
    end;

    start1 := @Info2.Points[pld.start];
    end1 := @Info2.Points[pld._end];

    if first then
    begin
      qInf.C1 := start1.topColor;
      qInf.C2 := end1.topColor;
      qInf.C3 := start1.bottomColor;
      qInf.C4 := end1.bottomColor;
{      qInf.C1 := Info2.Points[Info2.LineDefs[ld].start].topColor;
      qInf.C2 := Info2.Points[Info2.LineDefs[ld]._end].topColor;
      qInf.C3 := Info2.Points[Info2.LineDefs[ld].start].bottomColor;
      qInf.C4 := Info2.Points[Info2.LineDefs[ld]._end].bottomColor;}
    end
    else
    begin
      qInf.C1 := end1.topColor;
      qInf.C2 := start1.topColor;
      qInf.C3 := end1.bottomColor;
      qInf.C4 := start1.bottomColor;
{      qInf.C1 := Info2.Points[Info2.LineDefs[ld]._end].topColor;
      qInf.C2 := Info2.Points[Info2.LineDefs[ld].start].topColor;
      qInf.C3 := Info2.Points[Info2.LineDefs[ld]._end].bottomColor;
      qInf.C4 := Info2.Points[Info2.LineDefs[ld].start].bottomColor;}
    end;

    qInf.TextureName := psd.tex3; // Normal texture
    // ֱם ן פןלבע וםבי וננוהןע (AbsoluteFlat=True) פפו
    // קסחףילןנןין‎לו פב ‎רח פבגבםין‎ & נבפ‏לבפןע פןץ פןלב

    pss := @Info2.Sectors[psd.Sector];
    if pss.AbsoluteFlat then
    begin
      ch := pss.ceilh;
      qInf.x1 := start1.x;
      qInf.y1 := ch;
      qInf.z1 := start1.y;

      qInf.x2 := end1.x;
      qInf.y2 := ch;
      qInf.z2 := end1.y;

      fh := pss.floorh;
      qInf.x3 := start1.x;
      qInf.y3 := fh;
      qInf.z3 := start1.y;

      qInf.x4 := end1.x;
      qInf.y4 := fh;
      qInf.z4 := end1.y;

{      qInf.x1 := Info2.Points[Info2.LineDefs[ld].start].x;
      qInf.y1 := Info2.Sectors[Info2.SideDefs[sd].sector].ceilh;
      qInf.z1 := Info2.Points[Info2.LineDefs[ld].start].y;

      qInf.x2 := Info2.Points[Info2.LineDefs[ld]._End].x;
      qInf.y2 := Info2.Sectors[Info2.SideDefs[sd].sector].ceilh;
      qInf.z2 := Info2.Points[Info2.LineDefs[ld]._End].y;

      qInf.x3 := Info2.Points[Info2.LineDefs[ld].start].x;
      qInf.y3 := Info2.Sectors[Info2.SideDefs[sd].sector].floorh;
      qInf.z3 := Info2.Points[Info2.LineDefs[ld].start].y;

      qInf.x4 := Info2.Points[Info2.LineDefs[ld]._End].x;
      qInf.y4 := Info2.Sectors[Info2.SideDefs[sd].sector].floorh;
      qInf.z4 := Info2.Points[Info2.LineDefs[ld]._End].y;}
    end
    else
    // ִיבצןסופיך קסחףילןנןין‎לו פב ‎רח פבגבםין‎ & נבפ‏לבפןע פןץ ךטו ףחלוןץ
    begin
      qInf.x1 := start1.x;
      qInf.y1 := start1.top;
      qInf.z1 := start1.y;

      qInf.x2 := end1.x;
      qInf.y2 := end1.top;
      qInf.z2 := end1.y;

      qInf.x3 := start1.x;
      qInf.y3 := start1.bottom;
      qInf.z3 := start1.y;

      qInf.x4 := end1.x;
      qInf.y4 := end1.bottom;
      qInf.z4 := end1.y;

{      qInf.x1 := Info2.Points[Info2.LineDefs[ld].start].x;
      qInf.y1 := Info2.Points[Info2.LineDefs[ld].start].top;
      qInf.z1 := Info2.Points[Info2.LineDefs[ld].start].y;

      qInf.x2 := Info2.Points[Info2.LineDefs[ld]._End].x;
      qInf.y2 := Info2.Points[Info2.LineDefs[ld]._End].top;
      qInf.z2 := Info2.Points[Info2.LineDefs[ld]._End].y;

      qInf.x3 := Info2.Points[Info2.LineDefs[ld].start].x;
      qInf.y3 := Info2.Points[Info2.LineDefs[ld].start].bottom;
      qInf.z3 := Info2.Points[Info2.LineDefs[ld].start].y;

      qInf.x4 := Info2.Points[Info2.LineDefs[ld]._End].x;
      qInf.y4 := Info2.Points[Info2.LineDefs[ld]._End].bottom;
      qInf.z4 := Info2.Points[Info2.LineDefs[ld]._End].y;    }
    end;

    MakeQInfUV(
        LineDefLength(ld),
        SideDefHeight(sd),
        psd.xoff,
        psd.yoff,
        psd.TexturePixelsPerUnit,
        psd.TexturePixelsPerUnit);

    MergePolygonData(ID3D_Quadrangle, @qInf);
//      AddSurface(ID3D_Quadrangle, @qInf);
  end;

  function GetSectorsLines(
      lLineDefs: PSectorLineDefs; numLineDefs: integer;
      lSideDefs: PSectorSideDefs; numSideDefs: integer;
      var lSectorsLines: PSectorCollectionLines): integer;
  // ֵניףפסצוי לב כףפב לו פב PSectorCollectionLines כשם פשם Sectors
  var
    i: integer;
    tmp: PSectorCollectionLines; // ׀סקויסח לופבגכחפ דיב פחם כףפב פשם SectorLines
  begin
    system.new(tmp);
    Result := 0;
    for i := 0 to numLineDefs - 1 do
    begin
      if lLineDefs[i].SideDef1 < numSideDefs then
      begin
{        tmp[Result].start := lLineDefs[i].start;
        tmp[Result]._end := lLineDefs[i]._end;}
        tmp[Result].start_end := lLineDefs[i].start_end;
        tmp[Result].sector := lSideDefs[lLineDefs[i].SideDef1].sector;
    // ִום רקםןץלו וה‏ דיב פן segment פשם דסבלל‏ם, בככ ףפחם GetSectorLines נבסבךפש
        tmp[Result].segment := 0;
        inc(Result);
      end;
      if lLineDefs[i].SideDef2 < numSideDefs then
      begin
        tmp[Result].start := lLineDefs[i]._end;
        tmp[Result]._end := lLineDefs[i].start;
        tmp[Result].sector := lSideDefs[lLineDefs[i].SideDef2].sector;
        inc(Result);
      end;
    end;
{    GetMem(lSectorsLines, Result * SizeOf(TSectorCollectionLine));
    for i := 0 to Result - 1 do
      lSectorsLines[i] := tmp[i];
    dispose(tmp);}
    ReAllocMem(tmp, Result * SizeOf(TSectorCollectionLine));
    lSectorsLines := tmp;
  end;

  function GetSectorLines(
      SectorID: integer;
      lLines: PSectorCollectionLines; numLines: integer;
      var lSectorLines: PSectorCollectionLines): integer;
    { ֵניףפסצוי לב כףפב לו פב PSectorCollectionLines פןץ Sector SectorID.
      װבמיםןלו פחם כףפב פשם דסבלל‏ם בםכןדב לו פן segment ףפן ןנןן בםךוי
      ֱסקיך קןץלו ךבכףוי פחם GetSectorsLines דיב םב נסןץלו פןם
      נםבךב lLines נןץ נוסיקוי כב פב TSectorCollectionLine פןץ ונינהןץ}
  var
    i, j: integer;
    found: boolean;
    tmp: PSectorCollectionLines; // ׀סקויסח לופבגכחפ דיב פחם כףפב פשם SectorLines
    pass: PBoolArray;      // True בם קןץלו נוסףוי פחם בםפףפןיקח דסבלל (דיב בףץםקויוע)
    segment: word;     // װןלבע נןץ בםפיףפןיקו ח ךטו דסבלל
  begin
    GetMem(tmp, numLines * SizeOf(TSectorCollectionLine));
    Result := 0;
    // ׃בס‏םןץלו פחם כףפב לו כב פב lines ךבי וניכדןץלו בץפע נןץ בםךןץם ףפןם Sector
    for i := 0 to numLines - 1 do
      if lLines[i].sector = SectorID then
      begin
        tmp[Result] := lLines[i];
        inc(Result);
      end;

    GetMem(lSectorLines, Result * SizeOf(TSectorCollectionLine));
    GetMem(pass, Result * SizeOf(boolean));
    for i := 0 to Result - 1 do
      pass[i] := False;
    segment := 0;
    // םןץלו ףץםוקלוםח פחם כףפב
    for i := 0 to Result - 1 do
    begin
      if i = 0 then
      begin
        lSectorLines[0] := tmp[0];
        lSectorLines[0].segment := 0;
        pass[0] := True;
      end
      else
      begin
        if (lSectorLines[i - 1]._end = tmp[i].start) and not pass[i] then
        begin
          lSectorLines[i] := tmp[i];
          lSectorLines[i].segment := segment;
          pass[i] := True;
        end
        else // ֱףץםקויב! ״קםןץלו םב גסן‎לו פחם ףץםקויב
        begin
          j := 0;
          found := False;
          repeat
            if not pass[j] then
              if lSectorLines[i - 1]._end = tmp[j].start then
              begin
                lSectorLines[i] := tmp[j];
                lSectorLines[i].segment := segment;
                pass[j] := True;
                found := True;
              end;
            inc(j);
          until found or (j = Result);
          if not found then // ִום גסטחךו, קןץלו םן segment!
          begin
            j := 0;
            found := False;
            repeat
              if not pass[j] then // ֲסךבלו דסבלל נןץ הום קוי נוסבףפו ףפן sector ?
              begin
                inc(segment); // ֱץמםןץלו פן ID פןץ segment
                lSectorLines[i] := tmp[j];
                lSectorLines[i].segment := segment;
                pass[j] := True;
                found := True;
              end;
              inc(j);
            until found or (j = Result);
          end;
        end;
      end;
    end;
    FreeMem(tmp, numLines * SizeOf(TSectorCollectionLine));
    FreeMem(pass, Result * SizeOf(boolean));
  end;

  function GetVertexSqrDistance(lVertexes: PSectorPoints; v1, v2: integer): TD3DValue;
  { ֵניףפסצוי פן פופסדשםן פחע בנףפבףחע פשם Vertexes v1 & v2,
    דיב וכדקןץע, די'בץפ הום נבסםןץלו פחם פופסבדשםיך סזב }
  var
    pv1, pv2: PSectorPoint;
    dv1, dv2: TD3DValue;
  begin
    pv1 := @lVertexes[v1];
    pv2 := @lVertexes[v2];
    dv1 := pv1.x - pv2.x;
    dv2 := pv1.y - pv2.y;
    Result := (dv1 * dv1) + (dv2 * dv2);
  end;

  function GetAngle(const v1, v2: TSectorPoint): TD3DValue; overload;
  begin
    if v1.x = v2.x then
    begin
      if v2.y > v1.y then
        Result := g_PI_DIV_2
      else if v2.y < v1.y then
        Result := g_3_PI_DIV_2
      else
        Result := 0
    end
    else
    begin
      Result := ArcTan2S(v2.y - v1.y, v2.x - v1.x);
      if Result < 0 then
        Result := Result + g_2_PI;
    end;
  end;

  function GetAngle(const cx, cy: TD3DValue; const v2: TSectorPoint): TD3DValue; overload;
  begin
    if cx = v2.x then
      Result := 0
    else
    begin
      Result := ArcTan2S(v2.y - cy, v2.x - cx);
      if Result < 0 then
        Result := Result + g_2_PI;
    end;
  end;

  function GetAngle(const v1, v2, v3: TSectorPoint): TD3DValue; overload;
  begin
    Result := GetAngle(v2, v3) - GetAngle(v2, v1);
    if Result < 0 then
      Result := Result + g_2_PI
  end;

  { ֵניףפסצוי True בם פן v וםבי ףפחם דשםב נןץ ןסזןץם פב v1, v2, v3 }
  function IsVertexInAngle(const v, v1, v2, v3: TSectorPoint): boolean; overload;
  var
    ang1, ang2: TD3DValue;
  begin
    ang1 := GetAngle(v1, v2, v);
    ang2 := GetAngle(v1, v2, v3);
    Result := (ang1 + DEFTOLERANCE < ang2) and (ang1 > DEFTOLERANCE);
  end;

  { ֵניףפסצוי True בם פן v וםבי ףפחם דשםב לו נכוץס v1, v2 ךבי פיל angle }
  function IsVertexInAngle(const v, v1, v2: TSectorPoint; const angle: TD3DValue): boolean; overload;
  var
    ang: TD3DValue;
  begin
    ang := GetAngle(v1, v2, v);
    Result := (ang + DEFTOLERANCE < angle) and (ang > DEFTOLERANCE);
  end;

  procedure OrganizeSecondSectorSegment(
      lVertexes: PSectorPoints;  // װב קסויבזלבףפו דיב פןם ץנןכןדיףל פחע בנףפבףחע
      lLines: PSectorCollectionLines; const numLines: integer);
    { ױנןכןדזוי פן segment לו פחם ליךספוסח בנףפבףח בנ פן נס‏פן segment פןץ
      sector. ּופבצסוי פן segment בץפ ףפחם הו‎פוסח טףח (פן ךםוי הו‎פוסן) }
  var
    tmp: PSectorCollectionLines; // ׀סקויסח לופבגכחפ
    pos: integer;
    i, j: integer; // ּופסחפע
    v: integer;    // Index פשם lLines לו פחם ליךספוסח בנףפבףח
    min, dist: TD3DValue;
  begin
    if lLines[0].segment <> lLines[numLines - 1].segment then
    begin
      pos := 0;
      repeat
        inc(pos);
      until lLines[pos].segment <> lLines[0].segment;
      if lLines[pos].segment <> lLines[numLines - 1].segment then
      begin
        min := g_HUGE;
        v := 0;
        for i := 0 to pos - 1 do
          for j := pos to numLines - 1 do
          begin
            dist := GetVertexSqrDistance(lVertexes, lLines[i]._end, lLines[j].start);
            if dist < min then
              if IsVertexInAngle(lVertexes[lLines[j].start],
                                 lVertexes[lLines[i].start],
                                 lVertexes[lLines[i]._End],
                                 lVertexes[lLines[i + 1]._End]) then
              begin
                min := dist;
                v := j;  // ׃חלון לו ליךספוסח בנףפבףח
              end;
          end;
        GetMem(tmp, numLines * SizeOf(TSectorCollectionLine));
        j := 0;
        // ּופבצסןץלו פן segment לו פחם ליךספוסח בנףפבףח ףפן tmp
        for i := pos to numLines - 1 do
          if lLines[i].segment = lLines[v].segment then
          begin
            tmp[j] := lLines[i];
            inc(j);
          end;
        // ּופבצסןץלו פב ץנכןינב segment ףפן tmp
        for i := pos to numLines - 1 do
          if lLines[i].segment <> lLines[v].segment then
          begin
            tmp[j] := lLines[i];
            inc(j);
          end;
        // װכןע לופבצסןץלו פן tmp ףפן lLines
        for i := 0 to j - 1 do
          lLines[pos + i] := tmp[i];
        FreeMem(tmp, numLines * SizeOf(TSectorCollectionLine));
      end;
    end;
  end;

  function RemoveSectorIconicSegments(
    var lLines: PSectorCollectionLines; var numLines: integer): boolean;
  var
    curCount: integer;
    i, j: integer;
    oldSeg: word;
  begin
    // Aם הום קןץלו ךבלב דסבלל, פפו הום קסויזופבי םב ךםןץלו פנןפו!
    Result := False;
    if numlines = 0 then
      Exit
    // Aם פן פוכוץפבן segment וםבי 0, פפו הום קסויזופבי םב ךםןץלו פנןפו!
    else if lLines[numLines - 1].segment = 0 then
      Exit
    else
    begin
      curCount := 0;
      i := 0;
      oldSeg := 0;
      while i < numLines do
      begin
        if oldSeg = lLines[i].segment then
          inc(curCount)
        else
        begin
          if curCount = 1 then
          begin
            Result := True;
            dec(numLines);
            for j := i to numLines do
            begin
              lLines[j - 1] := lLines[j];
              dec(lLines[j - 1].segment);
            end;
          end
          else
            curCount := 1;
          oldSeg := lLines[i].segment;
        end;
        inc(i);
      end;
      if Result then
        ReAllocMem(lLines, numLines * SizeOf(TSectorCollectionLine));
    end;
  end;

  function MergeSectorSegments(
    lVertexes: PSectorPoints; // װב קסויבזלבףפו דיב פןם ץנןכןדיףל פחע בנףפבףחע
    var lLines: PSectorCollectionLines; var numLines: integer): boolean;
    { םוי ףץדק‏םוץףח פשם segments פןץ lLines
      ֿ בסיטלע פשם lines טב בככמוי (די'בץפ פן numLines וםבי var)
      ֱכדסיטלןע:
        ֳיב ךטו segment גסףךןץלו פן ךןםפיםפוסן ףחלון לו פןם נסןחדן‎לוםן segment
        ךבי ףו בץפ פן ףחלון פןץע ום‏םןץלו 'פסבג‏םפבע' דסבללע ףו בץפ פב ףחלוב
        וךבפסשטום (בנ פןם נסןחדן‎לוםן ףפןם ונלוםן ךבי בנ פןם ונלוםן ףפןם נסןחדן‎לוםן)
        ¼פבם ךםןץלו םב merge ךבכן‎לו נכי בםבהסןליך פחם ףץםספחףח.
      ֵניףפסצוי True בם ךםוי בככבדע, היבצןסופיך False
      ׃פן פכןע ףפחם כףפב lLines כב פב ףפןיקוב
      טב קןץם פן נוהן segment = 0 => ¸םבע פןלבע!
    }
  var
    tmp: PSectorCollectionLines; // ׀סקויסח לופבגכחפ
    oldLines, newLines: integer;
    pos: integer;     // ָףח ףפןם נםבךב lLines נןץ גסטחךו בככבד segment
    oldpos: integer;  // ָףח ףפןם נםבךב lLines נןץ גסטחךו ח נסןחדן‎לוםח בככד segment
    i, j: integer;    // ּופסחפע
    v1, v2: integer;  // Indexes פשם lLines לו פחם ליךספוסח בנףפבףח
    min, dist: TD3DValue;
    found: boolean;
  begin
    // Aם הום קןץלו ךבלב דסבלל, פפו הום קסויזופבי םב ךםןץלו פנןפו!
    if numlines < 3 then
      Result := False
    // Aם פן פוכוץפבן segment וםבי 0, פפו הום קסויזופבי םב ךםןץלו פנןפו!
    else if lLines[numLines - 1].segment = 0 then
      Result := False
    else
    begin
      // ּופבצסןץלו פן segment לו פחם ליךספוסח בנףפבףח בנ פן נס‏פן segment
      // ףפחם הו‎פוסח טףח:
      OrganizeSecondSectorSegment(lVertexes, lLines, numLines);
      Result := True; // םןץלו בככבדע, וניףפסצןץלו True
      oldLines := numLines;
      // ֲסףךןץלו פן ףחלון בככבדע segment
      oldpos := 0;
      repeat
        inc(oldPos);
        found := lLines[oldPos].segment <> lLines[0].segment;
      until (oldPos = oldLines - 1) or found;
      if oldPos = oldLines - 1 then
      begin
        numLines := numLines - 1;
        ReAllocMem(lLines, numLines * SizeOf(TSectorCollectionLine));
        Exit;
      end;

      // ָב נסןףטףןץלו ה‎ן דסבללע נןץ טב ום‏ףןץם ה‎ן segments
      newLines := numLines + 2;
      GetMem(tmp, newLines * SizeOf(TSectorCollectionLine));

      pos := oldPos;
      repeat
        inc(pos);
        found := lLines[pos].segment <> lLines[oldPos].segment;
      until (pos = oldLines - 1) or found;
      if (pos = oldLines - 1) then
        inc(pos);
      { ¼פבם גדן‎לו בנ פב נבסבנםש loop, טב נסנוי ףפחם לופבגכחפ pos םב וםבי ח
        טףח פןץ ךביםן‎סיןץ segment }
      { ֱךןכןץטו ח ו‎סוףח פחע ליךספוסחע בנףפבףחע בםלוףב ףפב ה‎ן segment:
        To נס‏פן segment וםבי בנ פן ףחלון 0 שע פן oldPos - 1 ךבי פן
        הו‎פוסן segment בנ oldPos שע pos }
      min := g_HUGE;
      v1 := 0;
      v2 := oldPos;
      for i := 0 to oldPos - 1 do
        for j := oldPos to pos - 1 do
        begin
          { ױנןכןדיףלע פחע בנףפבףחע: ׃פן נס‏פן segment נבסםןץלו פן ._end
            vertex & ףפן הו‎פוסן to .start (פףי טב דםוי ח םשףח! }
          dist := GetVertexSqrDistance(lVertexes, lLines[i]._end, lLines[j].start);
          if dist < min then
          begin
            min := dist;
            v1 := i;
            v2 := j;
           end;
         end;
      { ׃ו בץפ פן ףחלון טב נסנוי ףפב v1, v2 םב גסףךןםפבי בםפףפןיקב פב indexes פשם
        דסבלל‏ם לו פחם ליךספוסח בנףפבףח (ןץףיבףפיך פחם ליךספוסח בנףפבףח בנ
        פב פוכיך ףחלוב פןץ נס‏פןץ segment (._end) ךבי פב בסקיך ףחלוב פןץ
        הו‎פוסןץ segment (.start) }
      { ֱךןכןץטו ח ףץדק‏םוץףח פשם 2 segments: }
        // -> ׀ס‏פן פללב פןץ נס‏פןץ segment: ׀בסבלםוי שע קוי ףפן lLines
        // -> ׀ס‏פח דסבלל ףץדק‏םוץףחע:
      tmp[v1 + 1].start := lLines[v1]._end;
      tmp[v1 + 1]._end := lLines[v2].start;
      tmp[v1 + 1].sector := lLines[0].sector;
      tmp[v1 + 1].segment := 0;
      // -> ׀ס‏פן פללב פןץ הו‎פוסןץ segment
      for i := v2 to pos - 1 do
      begin
        tmp[v1 - v2 + i + 2] := lLines[i];
        tmp[v1 - v2 + i + 2].segment := 0;
      end;
      // -> ִו‎פוסן פללב פןץ הו‎פוסןץ segment
      for i := oldPos to v2 - 1 do
      begin
        tmp[v1 - v2 + pos - oldPos + i + 2] := lLines[i];
        tmp[v1 - v2 + pos - oldPos + i + 2].segment := 0;
      end;
      // -> ִו‎פוסח דסבלל ףץדק‏םוץףחע:
      tmp[v1 + pos - oldPos + 2].start := lLines[v2].start;
      tmp[v1 + pos - oldPos + 2]._end := lLines[v1]._end;
      tmp[v1 + pos - oldPos + 2].sector := lLines[0].sector;
      tmp[v1 + pos - oldPos + 2].segment := 0;
      // -> ִו‎פוסן פללב פןץ נס‏פןץ segment:
      for i := v1 + 1 to oldPos - 1 do
        tmp[pos - oldPos + i + 2] := lLines[i];
      // ֱםפידסצןץלו ףפן tmp פחם ץנכןינח כףפב
      for i := pos to oldLines - 1 do
        tmp[i + 2] := lLines[i];
{      for i := 1 to newLines - 1 do
      begin
        if tmp[i - 1].start - tmp[i]._end then
      end;}
      // װכןע בםפידסצןץלו פן tmp ףפן lLines
      ReallocMem(lLines, newLines * SizeOf(TSectorCollectionLine)); /////////////////// ?? ּנשע טכוי TSectorCollectionLine בםפ דיב TSectorCollectionLines ????
      for i := v1 + 1 to newLines - 1 do
        lLines[i] := tmp[i];

      FreeMem(tmp, newLines * SizeOf(TSectorCollectionLine));
      numLines := newLines;
      // ֱםבהסןליך ךכףח ->
      MergeSectorSegments(lVertexes, lLines, numLines);
    end;
  end;

  function RemoveNullVertexes(
    var lLines: PSectorCollectionLines; var numLines: integer): boolean;
  var
    i, j: integer;
    num1: integer;
    tmp1: PSectorCollectionLines;
  begin
    Result := False;
    if numLines > 3 then
    begin
      num1 := numLines;
      for i := num1 - 1 downto 0 do
        if lLines[i].start = lLines[i]._end then
        begin
          for j := i + 1 to num1 - 1 do
            lLines[j - 1] := lLines[j];
          dec(numLines);
        end;

      if num1 <> numLines then
      begin
        Result := True;
        GetMem(tmp1, numLines * SizeOf(TSectorCollectionLine));
        for i := 0 to numLines - 1 do
          tmp1[i] := lLines[i];
        FreeMem(lLines, num1 * SizeOf(TSectorCollectionLine));
        GetMem(lLines, numLines * SizeOf(TSectorCollectionLine));
        for i := 0 to numLines - 1 do
          lLines[i] := tmp1[i];
        FreeMem(tmp1, numLines * SizeOf(TSectorCollectionLine));
      end;
    end;
  end;

{  function RemoveReplicatedVertexes(
    var lLines: PSectorCollectionLines; var numLines: integer): boolean;
  var
    i, j, k: integer;
    tmp1: PSectorCollectionLines;
  begin
    Result := False;
    if numLines >= 5 then
    begin
      i := 0;
      repeat
        if lLines[(i - 1) mod numLines].start = lLines[i]._end then
        begin
          GetMem(tmp1, (numLines - 2) * SizeOf(TSectorCollectionLine));
          j := 0;
          k := 0;
          repeat
            if (k <> (i - 1) mod numLines) and (k <> i) then
            begin
              tmp1[j] := lLines[k];
              inc(j);
            end;
            inc(k);
          until k = numLines;
          Result := True;
          ReAllocMem(lLines, (numLines - 2) * SizeOf(TSectorCollectionLine));
          for k := 0 to numLines - 3 do lLines[k] := tmp1[k];
          FreeMem(tmp1, (numLines - 2) * SizeOf(TSectorCollectionLine));
          dec(numLines, 2);
          RemoveReplicatedVertexes(lLines, numLines);
        end;
        inc(i);
      until Result or (i = numLines);
    end;
  end;
}
  function ReduceSectorComplexity(
    lVertexes: PSectorPoints;
    var lLines: PSectorCollectionLines; var numLines: integer; tolerance: TD3DValue = DEFTOLERANCE): boolean;
    { ¼ףוע ףץםוקלוםוע דסבללע פןץ sector קןץם דשםב 180 לןסוע היבדסצןםפבי }
    { ׀סנוי פן sector םב וםבי ףץםוקלוםן! }
  var
    i: integer;
    angle: TD3DValue;
    tmp1: PSectorCollectionLines;
    num1: integer;
    lLi: PSectorCollectionLine;
  begin
    Result := False;
    if numLines > 3 then
    begin
      lLi := @lLines[0];
      for i := 0 to numLines - 1 do
      begin
        angle := GetAngle(
          lVertexes[lLines[(i + numLines - 1) mod numLines].start],
          lVertexes[lLi.start],
          lVertexes[lLi._End]);
        // ֱם ח דשםב וםבי = pi פפו ום‏םןץלו פיע דסבללע!
        if abs(angle - g_PI) <= tolerance then
          lLi.segment := $FFFF // ֲזןץלו ויךןםיך פיל ףפן segment!
        else if lLi.start = lLi._End then
          lLi.segment := $FFFF; // ֲזןץלו ויךןםיך פיל ףפן segment!
        inc(lLi);
      end;
      num1 := 0;
      GetMem(tmp1, numLines * SizeOf(TSectorCollectionLine));
      i := 0;
      repeat
        if lLines[i].segment < $FFFF then
        begin
          tmp1[num1] := lLines[i];
          if num1 > 0 then
            tmp1[num1 - 1]._End := tmp1[num1].start;
          inc(num1);
        end;
        inc(i);
      until i = numLines;
      // Close the sector
      tmp1[num1 - 1]._End := tmp1[0].start;

      Result := num1 <> numLines;
      if Result then
      begin
        FreeMem(lLines, numLines * SizeOf(TSectorCollectionLine));
        GetMem(lLines, num1 * SizeOf(TSectorCollectionLine));
        for i := 0 to num1 - 1 do
          lLines[i] := tmp1[i];
        numLines := num1;
      end;
      FreeMem(tmp1, numLines * SizeOf(TSectorCollectionLine));
    end;
  end;

  function SplitSectorConvexity(
    lVertexes: PSectorPoints;
    var lLines: PSectorCollectionLines; var numLines: integer;
    var hollow: PSectorCollectionLinesArray): boolean;
    { םוי היףנבףח פשם ךץפס‏ם sectors, וניףפסצוי False בם הום ךםוי היףנבףח }
    { ץספע sector: קוי דשםוע בםלוףב ףו ףץםוקלוםוע דסבללע > 180 לןיס‏ם }
  var
    i, j, pos: integer;
    angle: TD3DValue;
    tmp1: PSectorCollectionLines;
//    tmp2: PSectorCollectionLines;
    num1: integer;
    min, dist: TD3DValue;

{    procedure ReduceTmp1;
    var
      i: integer;
    begin
//      GetMem(tmp2, num1 * SizeOf(TSectorCollectionLine));
      num2 := 0;
      for i := 0 to num1 - 1 do
      begin
        if tmp1[i].start <> tmp1[i]._end then
        begin
          tmp2[num2] := tmp1[i];
          inc(num2);
        end;
      end;
      if num1 <> num2 then
      begin
//        ReAllocMem(tmp1, num2 * SizeOf(TSectorCollectionLine));
        for i := 0 to num2 - 1 do
        begin
          tmp1[i] := tmp2[i];
        end;
      end;
//      FreeMem(tmp2, num1 * SizeOf(TSectorCollectionLine));
      num1 := num2;
    end;}

    procedure ReduceTmp1;
    var
      i, j: integer;
    begin
      for i := 0 to num1 - 1 do
      begin
        if tmp1[i].start = tmp1[i]._end then
        begin
          for j := i to num1 - 2 do
            tmp1[j] := tmp1[j + 1];
          dec(num1);
        end;
      end;
    end;

  begin
    Result := False;

    { ֱם פן sector נןץ ןסזןץם פב lLines קוי 3 דסבללע פפו וםבי ךץספע }
    if (numLines = 3) and (lLines[1].start <> lLines[1]._End) then
    begin
      GetMem(hollow.Sectors[hollow.NumSectors], 3 * SizeOf(TSectorCollectionLine));
      hollow.Sectors[hollow.NumSectors][0] := lLines[0];
      hollow.Sectors[hollow.NumSectors][1] := lLines[1];
      hollow.Sectors[hollow.NumSectors][2] := lLines[2];
      hollow.NumSectorsLines[hollow.NumSectors] := 3;
      inc(hollow.NumSectors);
    end
    else if numLines > 3 then
    begin
      i := 0;
      repeat
        angle := GetAngle(
            lVertexes[lLines[(i + numLines - 1) mod numLines].start],
            lVertexes[lLines[i].start],
            lVertexes[lLines[i]._End]);
          // ֱם ח דשםב וםבי > pi פפו ךםןץלו בככבדע
          // ָב קשסףןץלו פן sector
        if angle > g_PI then
        begin
          Result := True; // װן sector וםבי ךץספ
          { ָב גסן‎לו פן ףחלון ףפן ןנןן טב קשסףןץלו פן sector,
            גסףךןץלו פן ךןםפיםפוסן ףחלון ףפחם ךןסץצ פחע דשםבע}
          min := g_HUGE;
          pos := 0; // ׃חלון לו פחם ליךספוסח בנףפבףח
          for j := 0 to numLines - 1 do
            if (j <> ((i + numLines - 1) mod numLines)) and
               (j <> i) and
               (j <> (i + numlines + 1) mod numlines) then // קי ףפב ףחלוב נןץ ןסזןץם פחם דשםב
            begin
            { ױנןכןדיףלע פחע בנףפבףחע }
              dist := GetVertexSqrDistance(lVertexes, lLines[i].start, lLines[j].start);
              if dist < min then
              begin
                if dist < g_EPSILON then
                begin
                  min := dist;
                  pos := j;
                end
                else if IsVertexInAngle(lVertexes[lLines[j].start],
                                        lVertexes[lLines[(i+numLines - 1) mod numLines].start],
                                        lVertexes[lLines[i].start],
                                        angle) then
                begin
                  min := dist;
                  pos := j; // ׃חלון לו פחם ךןםפיםפוסח בנףפבףח
                end;
              end;
            end;
          if (min < g_HUGE) and (pos <> i) then // ֱם גסטחךו ףחלון (היבצןסופיך פן sector וםבי invalid!)
          begin
            // ִחליןץסדב פןץ נס‏פןץ פללבפןע (נס‏פןע sector היבקשסיףלן‎)
            GetMem(tmp1, numLines * SizeOf(TSectorCollectionLine));
//            GetMem(tmp2, numLines * SizeOf(TSectorCollectionLine));
            tmp1[0].start := lLines[i].start;
            tmp1[0]._end := lLines[pos].start;
            tmp1[0].sector := lLines[0].sector;
            tmp1[0].segment := lLines[0].segment;
            if pos > i then
            begin
              for j := pos to numLines - 1 do
                tmp1[j - pos + 1] := lLines[j];
              for j := 0 to i - 1 do
                tmp1[numLines - pos + j + 1] := lLines[j];
              num1 := numLines - pos + i + 1;
            end
            else
            begin
              for j := pos to i - 1 do
                tmp1[j - pos + 1] := lLines[j];
              num1 := i - pos + 1
            end;
            ReduceTmp1;
            if num1 < numLines then //////////////
            begin
//              ReduceSectorComplexity(
//                lVertexes, tmp1, num1);
              SplitSectorConvexity(
                  lVertexes, tmp1, num1, hollow);
            end;
            // ִחליןץסדב פןץ הו‎פוסןץ פללבפןע (הו‎פוסןע sector היבקשסיףלן‎)
            tmp1[0].start := lLines[pos].start;
            tmp1[0]._end := lLines[i].start;
            if pos > i then
            begin
              for j := i to pos - 1 do
                tmp1[j - i + 1] := lLines[j];
              num1 := pos - i + 1;
            end
            else
            begin
              for j := i to numLines - 1 do
                tmp1[j - i + 1] := lLines[j];
              for j := 0 to pos - 1 do
                tmp1[numLines - i + j + 1] := lLines[j];
              num1 := numLines - i + pos + 1;
            end;
            ReduceTmp1;
            if num1 < numLines then //////////////
            begin
              SplitSectorConvexity(
                  lVertexes, tmp1, num1, hollow);
            end;
            FreeMem(tmp1, numLines * SizeOf(TSectorCollectionLine));
//            FreeMem(tmp2, numLines * SizeOf(TSectorCollectionLine));
          end; // if min < g_HUGE
        end;
        inc(i);
      until (i = numLines) or Result;
      // װכןע בם פן sector הום פבם ךץספ פן נסןףטפןץלו ףפחם כףפב hollow
      if not Result then
      begin
        GetMem(hollow.Sectors[hollow.NumSectors], numLines * SizeOf(TSectorCollectionLine));
        for i := 0 to numLines - 1 do
          hollow.Sectors[hollow.NumSectors][i] := lLines[i];
        hollow.NumSectorsLines[hollow.NumSectors] := numLines;
        inc(hollow.NumSectors);
      end;
    end;
  end;

  procedure AddTrianglesToNavigationInfo(
      var Triangles: PD3DFloatTriangleArray;
      var numTriangles: word);
    // ׀סןףטפוי ףפןם נםבךב Triangles פב פסדשםב נןץ בםפיףפןיקן‎ם ףפן נןכ‎דשםן pInf
  var
    p: TD3DPolygon;
    local_i, local_j: integer;
  begin
    p := TD3DPolygon.Create(DXDraw, AddTexturesToCollection(pInf.TextureNames), pInf);
    try
    // ּופבפסנןץלו פן נןכ‎דשםן ףו כףפב פסיד‏םשם
      p.ConvertToTriangleList;
    // ִוףלו‎ןץלו נבסבנםש לםלח ףפןם נםבךב לו פב פסדשםב
      ReAllocMem(Triangles, (numTriangles + p.fNumVertexes div 3) * SizeOf(TD3DFloatTriangle));
    // ֱםפידסצןץלו פב פסדשםב פןץ נןכץד‏םןץ ףפןם נםבךב פשם פסיד‏םשם
      for local_i := numTriangles to numTriangles + p.fNumVertexes div 3 - 1 do
        for local_j := 0 to 2 do
          Triangles[local_i][local_j] := p.Info2.Vertexes[3 * local_i + local_j];
    // ֱץמםןץלו בםפףפןיקב פןם בסיטל פשם פסיד‏םשם פןץ נןכץד‏םןץ
      numTriangles := numTriangles + p.fNumVertexes div 3;
    finally
      p.Free;
    end;
  end;

  procedure ArrangeDuplicatedVertexes(
      lLineDefs: PSectorLineDefs;
      numLineDefs: integer;
      lVertexes: PSectorPoints;
      numVertexes: integer);
  // ֱם ץנסקןץם ה‎ן היב vertexes (לו היוע ףץםפופבדלםוע בככ היבצןסופיך ךשהיך,
  // בככזןץלו פב references ףפב lLineDefs ‏ףפו םב הקםןץם כב ףפן נס‏פן.
  var
    i, j, k: integer;
    lvi, lvj: PSectorPoint;
    llk: PSectorLineDef;
  begin
    lvi := @lVertexes[0];
    for i := 0 to numVertexes - 2 do
    begin
      lvj := lvi;
      for j := i + 1 to numVertexes - 1 do
      begin
        inc(lvj);
        if (lvi.x = lvj.x) and (lvi.y = lvj.y) and
           (lvi.top = lvj.top) and (lvi.bottom = lvj.bottom) and
           (lvi.topColor = lvj.topColor) and (lvi.bottomColor = lvj.bottomColor) then
        begin
          llk := @lLineDefs[0];
          for k := 0 to numLineDefs - 1 do
          begin
            if llk.start = j then
              llk.start := i;
            if llk._End = j then
              llk._End := i;
            inc(llk);
          end;
        end;
      end;
      inc(lvi);
    end;
  end;

  function TryToCorrectOpenSector(
      lVertexes: PSectorPoints;
      var lLines: PSectorCollectionLines; var numLines: integer): boolean;
    // ׀סןףנבטו םב היןסט‏ףוי םבם בםןיךפ פןלב.
    // ֵניףפסצוי True בם וניףפסרוי ךכויףפ פןלב
  var
    i, j: integer;
    lL0: PSectorCollectionLine;
  begin
    lL0 := @lLines[0];
    if lL0.start <> lLines[numLines - 1]._end then
    begin
      Result := False;
      for i := numLines - 2 downto 2 do
        if lLines[i]._end = lL0.start then
        begin
          for j := i + 1 to numLines - 1 do
            lLines[j].segment := 1;
          MergeSectorSegments(lVertexes, lLines, numLines);
          Result := lL0.start = lLines[numLines - 1]._end;
          Exit;
        end;
    end
    else
      Result := True;
  end;

  procedure MakeSector(ss: integer);
  var
    lLines: PSectorCollectionLines;
    numLines, local_i, local_j, ofs: integer;
    hollow: PSectorCollectionLinesArray;
    start1,
    end1: integer;
    psp: PSectorPoint;
    psn: PSideNavigationInfo;
    pss: PSector;
    MinDistanceFromWalls2: TD3DValue;
    pssbc: PBoundingCube;
//    pss1: PSector;
    pscl: PSectorCollectionLines;
    psni: PSubSectorNavigationInfo;
    nsl: integer;
    tmpy: TD3DValue;
  begin
  // ֱסיך פן sector קוי BoundingCube לו פילע פפןיוע ‏ףפו ח VectorInCube
  // םב בנןפץדקםוי נםפב
    pss := @Info2.Sectors[ss];
    MinDistanceFromWalls2 := pss.MinDistanceFromWalls;
    pssbc := @pss.BoundingCube;

    MakeEmptyBoundingCube(pssbc^);
    pss.SideStart := fNumSides;
    pss.SideEnd := fNumSides - 1;
    pss.SubSectorStart := fNumSubSectors;
    pss.SubSectorEnd := fNumSubSectors - 1;

    numLines := GetSectorLines(ss, lSectorsLines, numSectorsLines, lLines);

    if numLines = 0 then
      Exit;

//    RemoveSectorIconicSegments(lLines, numLines);

    MergeSectorSegments(Info2.Points, lLines, numLines);

    RemoveNullVertexes(lLines, numLines);

    if numLines < 3 then
    begin
      FreeMem(lLines, numLines * SizeOf(TSectorCollectionLine));
      Exit;
    end;

    if lLines[0].start <> lLines[numLines - 1]._end then
    begin // To Sector הום וםבי ךכויףפ
      TryToCorrectOpenSector(Info2.Points, lLines, numLines);
      if lLines[0].start <> lLines[numLines - 1]._end then
      begin
        FreeMem(lLines, numLines * SizeOf(TSectorCollectionLine));
        Exit;
      end;
    end;

{    if lLines[0].start <> lLines[numLines - 1]._end then
    begin // To Sector הום וםבי ךכויףפ
      FreeMem(lLines, numLines * SizeOf(TSectorCollectionLine));
      Exit;
    end;}

    if pss.CheckWallsNavigation then
    begin
      for local_i := 0 to Info2.numSideDefs - 1 do
        if Info2.SideDefs[local_i].Sector = ss then
          if Info2.SideDefs[local_i].LineDef < Info2.numLineDefs then
            if (Info2.SideDefs[local_i].tex3 <> '') or
               (not Info2.LineDefs[Info2.SideDefs[local_i].LineDef].Transparent) then
// 31/5/2004
//               or (not Info2.Sectors[ss].AllowWalkThru) then
        begin
          if Info2.LineDefs[Info2.SideDefs[local_i].LineDef].SideDef1 = local_i then
          begin
            start1 := Info2.LineDefs[Info2.SideDefs[local_i].LineDef].start;
            end1 := Info2.LineDefs[Info2.SideDefs[local_i].LineDef]._end;

            inc(fNumSides);
            inc(pss.SideEnd);
            ReAllocMem(fSideNavigationInfos, fNumSides * SizeOf(TSideNavigationInfo));

            psn := @fSideNavigationInfos[fNumSides - 1];
            psn.sector := ss;
            psn.NavigationType :=
                Info2.SideDefs[local_i].NavigationType;
            psn.start.x :=
                Info2.Points[start1].x{$IFNDEF DOOMVIEWER} + Info2.x{$ENDIF};
            psn.start.y :=
                Info2.Points[start1].y{$IFNDEF DOOMVIEWER} + Info2.z{$ENDIF};
            psn._end.x :=
                Info2.Points[end1].x{$IFNDEF DOOMVIEWER} + Info2.x{$ENDIF};
            psn._end.y :=
                Info2.Points[end1].y{$IFNDEF DOOMVIEWER} + Info2.z{$ENDIF};


            psn.BoundingRect.Left :=
                Min(psn.start.x, psn._end.x) -
                  MinDistanceFromWalls2;
            psn.BoundingRect.Right :=
                Max(psn.start.x, psn._end.x) +
                  MinDistanceFromWalls2;
            psn.BoundingRect.Top :=
                Min(psn.start.y, psn._end.y) -
                  MinDistanceFromWalls2;
            psn.BoundingRect.Bottom :=
                Max(psn.start.y, psn._end.y) +
                  MinDistanceFromWalls2;
{            psn.BoundingRect.Left :=
                Min(psn.start.x, psn._end.x) -
                  Info2.Sectors[i].MinDistanceFromWalls / 2;
            psn.BoundingRect.Right :=
                Max(psn.start.x, psn._end.x) +
                  Info2.Sectors[i].MinDistanceFromWalls / 2;
            psn.BoundingRect.Top :=
                Min(psn.start.y, psn._end.y) -
                  Info2.Sectors[i].MinDistanceFromWalls / 2;
            psn.BoundingRect.Bottom :=
                Max(psn.start.y, psn._end.y) +
                  Info2.Sectors[i].MinDistanceFromWalls / 2;}
          end
          else if Info2.LineDefs[Info2.SideDefs[local_i].LineDef].SideDef2 = local_i then
          begin
            start1 := Info2.LineDefs[Info2.SideDefs[local_i].LineDef].start;
            end1 := Info2.LineDefs[Info2.SideDefs[local_i].LineDef]._end;

            inc(fNumSides);
            inc(pss.SideEnd);
            ReAllocMem(fSideNavigationInfos, fNumSides * SizeOf(TSideNavigationInfo));
            psn := @fSideNavigationInfos[fNumSides - 1];

            psn.sector := ss;
            psn._end.x :=
                Info2.Points[start1].x{$IFNDEF DOOMVIEWER} + Info2.x{$ENDIF};
            psn._end.y :=
                Info2.Points[start1].y{$IFNDEF DOOMVIEWER} + Info2.z{$ENDIF};
            psn.start.x :=
                Info2.Points[end1].x{$IFNDEF DOOMVIEWER} + Info2.x{$ENDIF};
            psn.start.y :=
                Info2.Points[end1].y{$IFNDEF DOOMVIEWER} + Info2.z{$ENDIF};

            psn.BoundingRect.Left :=
                Min(psn.start.x, psn._end.x) -
                  MinDistanceFromWalls2;
            psn.BoundingRect.Right :=
                Max(psn.start.x, psn._end.x) +
                  MinDistanceFromWalls2;
            psn.BoundingRect.Top :=
                Min(psn.start.y, psn._end.y) -
                  MinDistanceFromWalls2;
            psn.BoundingRect.Bottom :=
                Max(psn.start.y, psn._end.y) +
                  MinDistanceFromWalls2;

{            pss1 := @Info2.Sectors[i];
            psn.BoundingRect.Left :=
                Min(psn.start.x, psn._end.x) -
                  pss1.MinDistanceFromWalls / 2;
            psn.BoundingRect.Right :=
                Max(psn.start.x, psn._end.x) +
                  pss1.MinDistanceFromWalls / 2;
            psn.BoundingRect.Top :=
                Min(psn.start.y, psn._end.y) -
                  pss1.MinDistanceFromWalls / 2;
            psn.BoundingRect.Bottom :=
                Max(psn.start.y, psn._end.y) +
                  pss1.MinDistanceFromWalls / 2;}
          end;
        end;
    end;

{    if pss.AbsoluteFlat then
    begin
//      RemoveReplicatedVertexes(lLines, numLines);
      ReduceSectorComplexity(Info2.Points, lLines, numLines);
    end;}
    // ֱצן‎ לוי‏ףןץלו פחם נןכץנכןךפחפב פןץ פןלב, החליןץסדן‎לו פן
    // bounding cube
    for local_i := 0 to numLines - 1 do
    begin
      start1 := lLines[local_i].start;
      pssbc.minX :=
          Min(pssbc.minX,
            Info2.Points[start1].x);
      pssbc.maxX :=
          Max(pssbc.maxX,
            Info2.Points[start1].x);
      pssbc.minZ :=
          Min(pssbc.minZ,
            Info2.Points[start1].y);
      pssbc.maxZ :=
          Max(pssbc.maxZ,
            Info2.Points[start1].y);
    end;
    if pss.AbsoluteFlat then
    begin
      pssbc.minY :=
          Min(pss.floorh, pss.ceilh);
      pssbc.maxY :=
          Max(pss.floorh, pss.ceilh);
    end
    else
    begin
      for local_i := 0 to numLines - 1 do
      begin
        start1 := lLines[local_i].start;
        psp := @Info2.Points[start1];
        pssbc.minY :=
            Min(pssbc.minY,
              psp.top);
        pssbc.minY :=
            Min(pssbc.minY,
              psp.bottom);
        pssbc.maxY :=
            Max(pssbc.maxY,
              psp.top);
        pssbc.maxY :=
            Max(pssbc.maxY,
              psp.bottom);
      end;
    end;

    system.new(hollow);
    hollow.NumSectors := 0;
    SplitSectorConvexity(Info2.Points, lLines, numLines, hollow);

    pInf.UseFlatUV := True;
    pInf.NumTextures := 1;
    pInf.TextureNames[0, 1] := '';
    pInf.PrimitiveType := D3DPT_TRIANGLESTRIP;

    pInf.C := pss.floorC;
    pInf.v := pss.TexturePixelsPerUnit;
    pInf.u := pss.TexturePixelsPerUnit;

    for local_j := 0 to hollow.NumSectors - 1 do
    begin
      if pss.AbsoluteFlat then
        ReduceSectorComplexity(Info2.Points, hollow.Sectors[local_j], hollow.NumSectorsLines[local_j]);

      nsl := hollow.NumSectorsLines[local_j];
      pscl := hollow.Sectors[local_j];
      // ֱם קןץלו פןץכקיףפןם ה‎ן דסבללע ףפן subsector
      if nsl > 2 then
      begin
        // ¸קןץלו םב םן sub sector
        inc(fNumSubSectors);
        inc(pss.SubSectorEnd); // ֱץמםןץלו & פן index פןץ SubSectorEnd ףפן sector
        ReallocMem(fSubSectorNavigationInfos, fNumSubSectors * SizeOf(TSubSectorNavigationInfo));
        psni := @fSubSectorNavigationInfos[fnumSubSectors - 1];

        // ִיוץטופן‎לו פב fSubSectorNavigationInfos
        // ֱסיך פן subsector קוי BoundingCube לו פילע פפןיוע ‏ףפו ח VectorInCube
        // םב בנןפץדקםוי נםפב
        MakeEmptyBoundingCube(psni.BoundingCube);
        // ּחהוםיךע פילע ףפב פסדשםב וכדקןץ נבפ‏לבפןע ךבי פבגבםין‎
        psni.NumFloorTriangles := 0;
        psni.FloorTriangles := nil;
        psni.NumCeilingTriangles := 0;
        psni.CeilingTriangles := nil;
        // ֿ פןלבע פןץ subsector וםבי ן ss
        psni.Sector := ss;

        // ִיוץטופן‎לו פן BoundingCube
        if pss.AbsoluteFlat then
        begin
          psni.BoundingCube.minY :=
              Min(pss.floorh, pss.ceilh);
          psni.BoundingCube.maxY :=
              Max(pss.floorh, pss.ceilh);
        end
        else
        begin
          for local_i := 0 to nsl - 1 do
          begin
            start1 := pscl[local_i].start;
            psp := @Info2.Points[start1];
            psni.BoundingCube.minY :=
                Min(psni.BoundingCube.minY,
                  psp.bottom);
            psni.BoundingCube.minY :=
                Min(psni.BoundingCube.minY,
                  psp.top);
            psni.BoundingCube.maxY :=
                Max(psni.BoundingCube.maxY,
                  psp.bottom);
            psni.BoundingCube.maxY :=
                Max(psni.BoundingCube.maxY,
                  psp.top);
          end;
        end;
        for local_i := 0 to nsl - 1 do
        begin
          start1 := pscl[local_i].start;
          psp := @Info2.Points[start1];
          psni.BoundingCube.minX :=
              Min(psni.BoundingCube.minX,
                psp.x);
          psni.BoundingCube.maxX :=
              Max(psni.BoundingCube.maxX,
                psp.x);
          psni.BoundingCube.minZ :=
              Min(psni.BoundingCube.minZ,
                psp.y);
          psni.BoundingCube.maxZ :=
              Max(psni.BoundingCube.maxZ,
                psp.y);
        end;
        // װכןע החליןץסדבע פןץ bounding cube

        // ִחליןץסדן‎לו פחם נןכץדשםיך וניצםויב
        pInf.TextureNames[0, 0] := pss.floort;
        pInf.NumVertexes := nsl;
        ofs := 0;
        for local_i := 0 to nsl - 1 do
        begin
          if (local_i = 0) or odd(local_i) then
          begin
            if pss.AbsoluteFlat then
            begin
              start1 := pscl[local_i - ofs].start;
              psp := @Info2.Points[start1];
              pInf.Vertexes[local_i] :=
                  MakeD3DVector(
                    psp.x,
                    pss.floorh,
                    psp.y)
            end
            else
            begin
              start1 := pscl[local_i - ofs].start;
              psp := @Info2.Points[start1];
              pInf.Vertexes[local_i] :=
                  MakeD3DVector(
                    psp.x,
                    psp.bottom,
                    psp.y);
              // סבפלו נכחסןצןסוע דיב פן פבגםי דיב םב לחם מבםבפסמןץלו פן loop
              ceilingPatch[local_i] := psp.top;
            end
          end
          else
          begin
            if pss.AbsoluteFlat then
            begin
              psp := @Info2.Points[pscl[nsl - local_i + 1 + ofs].start];
              pInf.Vertexes[local_i] :=
                  MakeD3DVector(
                    psp.x,
                    pss.floorh,
                    psp.y)
            end
            else
            begin
              psp := @Info2.Points[pscl[nsl - local_i + 1 + ofs].start];
              pInf.Vertexes[local_i] :=
                  MakeD3DVector(
                    psp.x,
                    psp.bottom,
                    psp.y);
              // סבפלו נכחסןצןסוע דיב פן פבגםי דיב םב לחם מבםבפסמןץלו פן loop
              ceilingPatch[local_i] := psp.top;
            end;
            inc(ofs);
          end;
        end;
{$IFNDEF ICONICSECTORCOLLECTIONS}
        if pInf.TextureNames[0, 0] <> '' then
        begin
          MergePolygonData(ID3D_POLYGON, @pInf);
          (Surfaces.Objects[Surfaces.Count - 1] as TD3DObject).RunTimeOnly := True;
        end;
{$ENDIF}
        // ׀סןףטפןץלו פב פסדשםב פחע נןכץדשםיךע וניצםויבע ףפב פסדשםב וכדקןץ
        // פשם subsectors
        if pss.CheckFloorNavigation then // ֱם ן פןלבע וכדקוי פן floor navigation
          AddTrianglesToNavigationInfo(
              psni.FloorTriangles,
              psni.NumFloorTriangles);
        pInf.TextureNames[0, 0] := pss.ceilt;
        pInf.C := pss.ceilC;
        if pss.AbsoluteFlat then
        begin
          tmpy := pss.ceilh;
          for local_i := 0 to pInf.NumVertexes - 1 do
            pInf.Vertexes[local_i].y := tmpy;
        end
        else
        begin
          for local_i := 0 to pInf.NumVertexes - 1 do
            pInf.Vertexes[local_i].y := ceilingPatch[local_i]
        end;
{$IFNDEF ICONICSECTORCOLLECTIONS}
        if pInf.TextureNames[0, 0] <> '' then
        begin
          MergePolygonData(ID3D_POLYGON, @pInf);
          (Surfaces.Objects[Surfaces.Count - 1] as TD3DObject).RunTimeOnly := True;
        end;
{$ENDIF}
        if pss.CheckCeilingNavigation then // ֱם ן פןלבע וכדקוי פן ceiling navigation
          AddTrianglesToNavigationInfo(
            psni.CeilingTriangles,
            psni.NumCeilingTriangles);
      end;
    end;

    FreeMem(lLines, numLines * SizeOf(TSectorCollectionLine));
    for local_j := 0 to hollow.NumSectors - 1 do
      FreeMem(hollow.Sectors[local_j], hollow.NumSectorsLines[local_j] * SizeOf(TSectorCollectionLine));
    Dispose(hollow);
  end;

var
  ppoint: PSectorPoint;
  psect: PSector;
{$IFNDEF ICONICSECTORCOLLECTIONS}
  psdef: PSectorSideDef;
  pldef: PSectorLineDef;
  sdid: integer;
{$ENDIF}
begin
// ױנןכןדיףלע פןץ bounding cube פחע ףץככןדע
  MakeEmptyBoundingCube(fBoundingCube);

  ppoint := @Info2.Points[0];
  for i := 0 to Info2.numPoints - 1 do
  begin
    if ppoint.x < fBoundingCube.minX then
      fBoundingCube.minX := ppoint.x;
    if ppoint.x > fBoundingCube.maxX then
      fBoundingCube.maxX := ppoint.x;

    if ppoint.y < fBoundingCube.minZ then
      fBoundingCube.minZ := ppoint.y;
    if ppoint.y > fBoundingCube.maxZ then
      fBoundingCube.maxZ := ppoint.y;

    if ppoint.bottom < fBoundingCube.minY then
      fBoundingCube.minY := ppoint.bottom;
    if ppoint.bottom > fBoundingCube.maxY then
      fBoundingCube.maxY := ppoint.bottom;

    if ppoint.top < fBoundingCube.minY then
      fBoundingCube.minY := ppoint.top;
    if ppoint.top > fBoundingCube.maxY then
      fBoundingCube.maxY := ppoint.top;

    inc(ppoint);
  end;

  psect := @Info2.Sectors[0];
  for i := 0 to Info2.numSectors - 1 do
  begin
    if psect.AbsoluteFlat then
    begin
      if psect.floorh < fBoundingCube.minY then
        fBoundingCube.minY  := psect.floorh;
      if psect.ceilh > fBoundingCube.maxY then
        fBoundingCube.maxY  := psect.ceilh;
    end;
    inc(psect);
  end;

  ArrangeDuplicatedVertexes(Info2.LineDefs, Info2.numLinedefs, Info2.Points, Info2.numPoints);

{$IFNDEF ICONICSECTORCOLLECTIONS}
  TextureNames := TDXStringList.Create;
  try
    psdef := @Info2.SideDefs[0];
    for i := 0 to Info2.numSideDefs - 1 do
    begin
      if psdef.tex1 <> '' then
        if TextureNames.IndexOf(psdef.tex1) = -1 then
          TextureNames.Add(psdef.tex1);
      if psdef.tex2 <> '' then
        if TextureNames.IndexOf(psdef.tex2) = -1 then
          TextureNames.Add(psdef.tex2);
      if psdef.tex3 <> '' then
        if TextureNames.IndexOf(psdef.tex3) = -1 then
          TextureNames.Add(psdef.tex3);

      inc(psdef);

    end;
    PrepareRTLOptimizer(TextureNames, False, True, D3DCULL_NONE{$IFDEF DOOMVIEWER}, False {$ENDIF});
    PrepareRTLOptimizer(TextureNames, False, True, D3DCULL_CCW, False);

    TextureNames.Clear;
    psect := @Info2.Sectors[0];
    for i := 0 to Info2.numSectors - 1 do
    begin
      if psect.floort <> '' then
        if TextureNames.IndexOf(psect.floort) = -1 then
          TextureNames.Add(psect.floort);
      if psect.ceilt <> '' then
        if TextureNames.IndexOf(psect.ceilt) = -1 then
          TextureNames.Add(psect.ceilt);

      inc(psect);

    end;

    PrepareRTLOptimizer(TextureNames, True, False, D3DCULL_NONE{$IFDEF DOOMVIEWER}, False {$ENDIF});
  finally
    TextureNames.Free;
  end;
{$ENDIF}

{$IFNDEF ICONICSECTORCOLLECTIONS}
  FillChar(qInf, SizeOf(qInf), Chr(0));
  pldef := @Info2.LineDefs[0];
  for i := 0 to Info2.numLinedefs - 1 do
  begin
    if pldef.start <> pldef._End then
    begin
      sdid := pldef.SideDef1;
      if (sdid < Info2.numSideDefs) then
        if (Info2.SideDefs[sdid].Sector < Info2.NumSectors) then
          if Info2.Sectors[Info2.SideDefs[sdid].Sector].DrawSideDefs then
          begin
            MakeSideDefInfoSpecific_tex12(i, sdid, True); // Upper/Lower Textures
            MakeSideDefInfoSpecific_tex3(i, sdid, True);  // Normal texture
          end;
      sdid := pldef.SideDef2;
      if (sdid < Info2.numSideDefs) then
        if (Info2.SideDefs[sdid].Sector < Info2.NumSectors) then
          if Info2.Sectors[Info2.SideDefs[sdid].Sector].DrawSideDefs then
          begin
            MakeSideDefInfoSpecific_tex12(i, sdid, False); // Upper/Lower Textures
            MakeSideDefInfoSpecific_tex3(i, sdid, False);  // Normal texture
          end;
    end;
    inc(pldef);
  end;
{$ENDIF}

  numSectorsLines := GetSectorsLines(
    Info2.LineDefs, Info2.numLineDefs, Info2.SideDefs, Info2.numSideDefs, lSectorsLines);

  FillChar(pInf, SizeOf(pInf), Chr(0));
  pInf.NumTextures := 1;
  pInf.Transparency := 0;
  pInf.UseFlatUV := True;
  pInf.C := clWhite;
  pInf.Cull := D3DCULL_NONE;

  system.New(ceilingPatch);
  for i := 0 to Info2.numSectors - 1 do
    MakeSector(i);
  dispose(ceilingPatch);

  ReleaseUnusedObjects;
end;

const
  rsSectorCollection = '(Sector Collection)';

function TD3DSectorCollection.TextureName: string;
begin
  Result := rsSectorCollection;
end;

procedure TD3DSectorCollection.ReplaceImageEntry(const oldEntry, newEntry: TFileName);
var
  i: integer;

  function GetEntry(const Entry: string): string;
  begin
    Result := Entry;
    if UpperCase(TrimStr(GetExistedFileName(oldEntry))) =
       UpperCase(TrimStr(GetExistedFileName(Entry))) then
      Result := TrimStr(GetExistedFileName(newEntry));
  end;

begin
  for i := 0 to Info2.numSideDefs - 1 do
  begin
    Info2.SideDefs[i].Tex1 := GetEntry(Info2.SideDefs[i].Tex1);
    Info2.SideDefs[i].Tex2 := GetEntry(Info2.SideDefs[i].Tex2);
    Info2.SideDefs[i].Tex3 := GetEntry(Info2.SideDefs[i].Tex3);
  end;
  for i := 0 to Info2.numSectors - 1 do
  begin
    Info2.Sectors[i].floort := GetEntry(Info2.Sectors[i].floort);
    Info2.Sectors[i].ceilt := GetEntry(Info2.Sectors[i].ceilt);
  end;
end;

procedure TD3DSectorCollection.SaveToStream(s: TStream);
var
  len: integer;
  TNames: string;
  sTNames: TDXStringList;
  i: integer;

  procedure WriteTextureName(tn: string);
  var
    index: smallint;
  begin
    if tn = '' then
      index := -1
    else
      index := sTNames.IndexOf(tn);
    s.Write(index, SizeOf(index));
  end;

begin
  sTNames := TDXStringList.Create;
  try
    for i := 0 to Info2.numSideDefs - 1 do
    begin
      Info2.SideDefs[i].Tex1 := TrimStr(GetExistedFileName(Info2.SideDefs[i].Tex1));
      if Info2.SideDefs[i].tex1 <> '' then
        if sTNames.IndexOf(Info2.SideDefs[i].tex1) < 0 then
          sTNames.Add(Info2.SideDefs[i].tex1);
      Info2.SideDefs[i].Tex2 := TrimStr(GetExistedFileName(Info2.SideDefs[i].Tex2));
      if Info2.SideDefs[i].tex2 <> '' then
        if sTNames.IndexOf(Info2.SideDefs[i].tex2) < 0 then
          sTNames.Add(Info2.SideDefs[i].tex2);
      Info2.SideDefs[i].Tex3 := TrimStr(GetExistedFileName(Info2.SideDefs[i].Tex3));
      if Info2.SideDefs[i].tex3 <> '' then
        if sTNames.IndexOf(Info2.SideDefs[i].tex3) < 0 then
          sTNames.Add(Info2.SideDefs[i].tex3);
    end;
    for i := 0 to Info2.numSectors - 1 do
    begin
      Info2.Sectors[i].floort := TrimStr(GetExistedFileName(Info2.Sectors[i].floort));
      if Info2.Sectors[i].floort <> '' then
        if sTNames.IndexOf(Info2.Sectors[i].floort) < 0 then
          sTNames.Add(Info2.Sectors[i].floort);
      Info2.Sectors[i].ceilt := TrimStr(GetExistedFileName(Info2.Sectors[i].ceilt));
      if Info2.Sectors[i].ceilt <> '' then
        if sTNames.IndexOf(Info2.Sectors[i].ceilt) < 0 then
          sTNames.Add(Info2.Sectors[i].ceilt);
    end;
    TNames := sTNames.text;
    len := Length(TNames);
    s.Write(len, SizeOf(len));
    for i := 1 to len do
      s.Write(TNames[i], SizeOf(TNames[i]));
    TNames := '';

    with Info2 do
    begin
      s.Write(Key, SizeOf(key));
      s.Write(x, SizeOf(x));
      s.Write(y, SizeOf(y));
      s.Write(z, SizeOf(z));
      s.Write(dx, SizeOf(dx));
      s.Write(dy, SizeOf(dy));
      s.Write(dz, SizeOf(dz));
      s.Write(TexturePixelsPerUnit, SizeOf(TexturePixelsPerUnit));

      s.Write(InSideDrawStart, SizeOf(InSideDrawStart));
      s.Write(InSideDrawEnd, SizeOf(InSideDrawEnd));
      s.Write(OutSideDrawStart, SizeOf(OutSideDrawStart));
      s.Write(OutSideDrawEnd, SizeOf(OutSideDrawEnd));

      s.Write(Info2.CheckNavigation, SizeOf(Info2.CheckNavigation));
      s.Write(Info2.DrawTheObjects, SizeOf(Info2.DrawTheObjects));

      s.Write(numPoints, SizeOf(numPoints));
      for i := 0 to numPoints - 1 do
      begin
        s.Write(Points[i].x, SizeOf(Points[i].x));
        s.Write(Points[i].y, SizeOf(Points[i].y));
        s.Write(Points[i].top, SizeOf(Points[i].top));
        s.Write(Points[i].bottom, SizeOf(Points[i].bottom));
        s.Write(Points[i].topColor, SizeOf(Points[i].topColor));
        s.Write(Points[i].bottomColor, SizeOf(Points[i].bottomColor));
      end;

      s.Write(numLineDefs, SizeOf(numLineDefs));
      for i := 0 to numLineDefs - 1 do
      begin
        s.Write(LineDefs[i].start, SizeOf(LineDefs[i].start));
        s.Write(LineDefs[i]._end, SizeOf(LineDefs[i]._end));
        s.Write(LineDefs[i].SideDef1, SizeOf(LineDefs[i].SideDef1));
        s.Write(LineDefs[i].SideDef2, SizeOf(LineDefs[i].SideDef2));
        s.Write(LineDefs[i].Transparent, SizeOf(LineDefs[i].Transparent));
      end;

      s.Write(numSideDefs, SizeOf(numSideDefs));
      for i := 0 to numSideDefs - 1 do
      begin
        s.Write(SideDefs[i].xoff, SizeOf(SideDefs[i].xoff));
        s.Write(SideDefs[i].yoff, SizeOf(SideDefs[i].yoff));
        s.Write(SideDefs[i].LineDef, SizeOf(SideDefs[i].LineDef));
        s.Write(SideDefs[i].Sector, SizeOf(SideDefs[i].Sector));
        s.Write(SideDefs[i].NavigationType, SizeOf(SideDefs[i].NavigationType));
        s.Write(Info2.SideDefs[i].TexturePixelsPerUnit, SizeOf(Info2.SideDefs[i].TexturePixelsPerUnit));
        WriteTextureName(SideDefs[i].Tex1);
        WriteTextureName(SideDefs[i].Tex2);
        WriteTextureName(SideDefs[i].Tex3);
      end;

      s.Write(numSectors, SizeOf(numSectors));
      for i := 0 to numSectors - 1 do
      begin
        s.Write(Sectors[i].floorh, SizeOf(Sectors[i].floorh));
        s.Write(Sectors[i].ceilh, SizeOf(Sectors[i].ceilh));
        s.Write(Sectors[i].floorC, SizeOf(Sectors[i].floorC));
        s.Write(Sectors[i].ceilC, SizeOf(Sectors[i].ceilC));
        s.Write(Sectors[i].AbsoluteFlat, SizeOf(Sectors[i].AbsoluteFlat));
        s.Write(Sectors[i].DrawSideDefs, SizeOf(Info2.Sectors[i].DrawSideDefs));
        s.Write(Sectors[i].AllowWalkThru, SizeOf(Sectors[i].AllowWalkThru));
        s.Write(Sectors[i].ifInsideCullOtherCollections, SizeOf(Sectors[i].ifInsideCullOtherCollections));
        s.Write(Sectors[i].GravityBehaviour, SizeOf(Sectors[i].GravityBehaviour));
        s.Write(Sectors[i].CheckFloorNavigation, SizeOf(Sectors[i].CheckFloorNavigation));
        s.Write(Sectors[i].CheckCeilingNavigation, SizeOf(Sectors[i].CheckCeilingNavigation));
        s.Write(Sectors[i].CheckWallsNavigation, SizeOf(Sectors[i].CheckWallsNavigation));
        s.Write(Sectors[i].MinDistanceFromFloor, SizeOf(Sectors[i].MinDistanceFromFloor));
        s.Write(Sectors[i].MinDistanceFromCeiling, SizeOf(Sectors[i].MinDistanceFromCeiling));
        s.Write(Sectors[i].MinDistanceFromWalls, SizeOf(Sectors[i].MinDistanceFromWalls));
        s.Write(Sectors[i].TexturePixelsPerUnit, SizeOf(Sectors[i].TexturePixelsPerUnit));
        WriteTextureName(Sectors[i].floort);
        WriteTextureName(Sectors[i].ceilt);
      end;
    end;
  finally
    sTNames.Free;
  end;
end;

procedure TD3DSectorCollection.LoadFromStream(s: TStream; version: integer);
var
  len: integer;
  TNames: string;
  sTNames: TDXStringList;
  i: integer;

  function ReadTextureName: string;
  var
    index: smallint;
  begin
    s.Read(index, SizeOf(Index));
    if Index > -1 then
      Result := sTNames.Strings[index]
    else
      Result := '';
  end;

begin
{$IFNDEF NO_OLDSTREAMINGRUTINES}
  if version < FILEVERSION_117 then
    OldLoadFromStream2(s, version)
  else {$ENDIF}
  begin
    s.read(len, SizeOf(len));
    SetLength(TNames, len);
    for i := 1 to len do
      s.Read(TNames[i], SizeOf(TNames[i]));
    sTNames := TDXStringList.Create;
    try
      sTNames.Text := TNames;
      TNames := '';

      s.Read(Info2.Key, SizeOf(Info2.key));
      s.Read(Info2.x, SizeOf(Info2.x));
      s.Read(Info2.y, SizeOf(Info2.y));
      s.Read(Info2.z, SizeOf(Info2.z));
      s.Read(Info2.dx, SizeOf(Info2.dx));
      s.Read(Info2.dy, SizeOf(Info2.dy));
      s.Read(Info2.dz, SizeOf(Info2.dz));
      s.Read(Info2.TexturePixelsPerUnit, SizeOf(Info2.TexturePixelsPerUnit));

      s.Read(Info2.InSideDrawStart, SizeOf(Info2.InSideDrawStart));
      s.Read(Info2.InSideDrawEnd, SizeOf(Info2.InSideDrawEnd));
      s.Read(Info2.OutSideDrawStart, SizeOf(Info2.OutSideDrawStart));
      s.Read(Info2.OutSideDrawEnd, SizeOf(Info2.OutSideDrawEnd));

      s.Read(Info2.CheckNavigation, SizeOf(Info2.CheckNavigation));
      s.Read(Info2.DrawTheObjects, SizeOf(Info2.DrawTheObjects));

      s.Read(Info2.numPoints, SizeOf(Info2.numPoints));
      ReAllocMem(Info2.Points, Info2.numPoints * SizeOf(TSectorPoint));
      for i := 0 to Info2.numPoints - 1 do
      begin
        s.Read(Info2.Points[i].x, SizeOf(Info2.Points[i].x));
        s.Read(Info2.Points[i].y, SizeOf(Info2.Points[i].y));
        s.Read(Info2.Points[i].top, SizeOf(Info2.Points[i].top));
        s.Read(Info2.Points[i].bottom, SizeOf(Info2.Points[i].bottom));
        s.Read(Info2.Points[i].topColor, SizeOf(Info2.Points[i].topColor));
        s.Read(Info2.Points[i].bottomColor, SizeOf(Info2.Points[i].bottomColor));
      end;

      s.Read(Info2.numLineDefs, SizeOf(Info2.numLineDefs));
      ReAllocMem(Info2.LineDefs, Info2.numLineDefs * SizeOf(TSectorLineDef));
      for i := 0 to Info2.numLineDefs - 1 do
      begin
        s.Read(Info2.LineDefs[i].start, SizeOf(Info2.LineDefs[i].start));
        s.Read(Info2.LineDefs[i]._end, SizeOf(Info2.LineDefs[i]._end));
        s.Read(Info2.LineDefs[i].SideDef1, SizeOf(Info2.LineDefs[i].SideDef1));
        s.Read(Info2.LineDefs[i].SideDef2, SizeOf(Info2.LineDefs[i].SideDef2));
        s.Read(Info2.LineDefs[i].Transparent, SizeOf(Info2.LineDefs[i].Transparent));
      end;

      s.Read(Info2.numSideDefs, SizeOf(Info2.numSideDefs));
      ReAllocMem(Info2.SideDefs, Info2.numSideDefs * SizeOf(TSectorSideDef));
      for i := 0 to Info2.numSideDefs - 1 do
      begin
        s.Read(Info2.SideDefs[i].xoff, SizeOf(Info2.SideDefs[i].xoff));
        s.Read(Info2.SideDefs[i].yoff, SizeOf(Info2.SideDefs[i].yoff));
        s.Read(Info2.SideDefs[i].LineDef, SizeOf(Info2.SideDefs[i].LineDef));
        s.Read(Info2.SideDefs[i].Sector, SizeOf(Info2.SideDefs[i].Sector));
        s.Read(Info2.SideDefs[i].NavigationType, SizeOf(Info2.SideDefs[i].NavigationType));
        s.Read(Info2.SideDefs[i].TexturePixelsPerUnit, SizeOf(Info2.SideDefs[i].TexturePixelsPerUnit));
        Info2.SideDefs[i].Tex1 := ReadTextureName;
        Info2.SideDefs[i].Tex2 := ReadTextureName;
        Info2.SideDefs[i].Tex3 := ReadTextureName;
      end;

      s.Read(Info2.numSectors, SizeOf(Info2.numSectors));
      ReAllocMem(Info2.Sectors, Info2.numSectors * SizeOf(TSector));
      for i := 0 to Info2.numSectors - 1 do
      begin
        s.Read(Info2.Sectors[i].floorh, SizeOf(Info2.Sectors[i].floorh));
        s.Read(Info2.Sectors[i].ceilh, SizeOf(Info2.Sectors[i].ceilh));
        s.Read(Info2.Sectors[i].floorC, SizeOf(Info2.Sectors[i].floorC));
        s.Read(Info2.Sectors[i].ceilC, SizeOf(Info2.Sectors[i].ceilC));
        s.Read(Info2.Sectors[i].AbsoluteFlat, SizeOf(Info2.Sectors[i].AbsoluteFlat));
        s.Read(Info2.Sectors[i].DrawSideDefs, SizeOf(Info2.Sectors[i].DrawSideDefs));
        s.Read(Info2.Sectors[i].AllowWalkThru, SizeOf(Info2.Sectors[i].AllowWalkThru));
        s.Read(Info2.Sectors[i].ifInsideCullOtherCollections, SizeOf(Info2.Sectors[i].ifInsideCullOtherCollections));
        s.Read(Info2.Sectors[i].GravityBehaviour, SizeOf(Info2.Sectors[i].GravityBehaviour));
        s.Read(Info2.Sectors[i].CheckFloorNavigation, SizeOf(Info2.Sectors[i].CheckFloorNavigation));
        s.Read(Info2.Sectors[i].CheckCeilingNavigation, SizeOf(Info2.Sectors[i].CheckCeilingNavigation));
        s.Read(Info2.Sectors[i].CheckWallsNavigation, SizeOf(Info2.Sectors[i].CheckWallsNavigation));
        s.Read(Info2.Sectors[i].MinDistanceFromFloor, SizeOf(Info2.Sectors[i].MinDistanceFromFloor));
        s.Read(Info2.Sectors[i].MinDistanceFromCeiling, SizeOf(Info2.Sectors[i].MinDistanceFromCeiling));
        s.Read(Info2.Sectors[i].MinDistanceFromWalls, SizeOf(Info2.Sectors[i].MinDistanceFromWalls));
        s.Read(Info2.Sectors[i].TexturePixelsPerUnit, SizeOf(Info2.Sectors[i].TexturePixelsPerUnit));
        Info2.Sectors[i].floort := ReadTextureName;
        Info2.Sectors[i].ceilt := ReadTextureName;
      end;
    finally
      sTNames.Free;
    end;
  end;
end;

{$IFNDEF NO_OLDSTREAMINGRUTINES}
procedure TD3DSectorCollection.OldLoadFromStream2(s: TStream; version: integer);
var
  len: integer;
  TNames: string;
  sTNames: TDXStringList;
  i: integer;

  function ReadTextureName: string;
  var
    index: smallint;
  begin
    s.Read(index, SizeOf(Index));
    if Index > -1 then
      Result := sTNames.Strings[index]
    else
      Result := '';
  end;

begin
  if version < FILEVERSION_108 then
    OldLoadFromStream(s, version)
  else
  begin
    s.read(len, SizeOf(len));
    SetLength(TNames, len);
    for i := 1 to len do
      s.Read(TNames[i], SizeOf(TNames[i]));
    sTNames := TDXStringList.Create;
    try
      sTNames.Text := TNames;
      TNames := '';

      s.Read(Info2.Key, SizeOf(Info2.key));
      s.Read(Info2.x, SizeOf(Info2.x));
      s.Read(Info2.y, SizeOf(Info2.y));
      s.Read(Info2.z, SizeOf(Info2.z));
      s.Read(Info2.dx, SizeOf(Info2.dx));
      s.Read(Info2.dy, SizeOf(Info2.dy));
      s.Read(Info2.dz, SizeOf(Info2.dz));
      s.Read(Info2.TexturePixelsPerUnit, SizeOf(Info2.TexturePixelsPerUnit));

      if version > FILEVERSION_113 then
      begin
        s.Read(Info2.InSideDrawStart, SizeOf(Info2.InSideDrawStart));
        s.Read(Info2.InSideDrawEnd, SizeOf(Info2.InSideDrawEnd));
        s.Read(Info2.OutSideDrawStart, SizeOf(Info2.OutSideDrawStart));
        s.Read(Info2.OutSideDrawEnd, SizeOf(Info2.OutSideDrawEnd));
      end
      else
      begin
        Info2.InSideDrawStart := Low(integer);
        Info2.InSideDrawEnd := High(integer);
        Info2.OutSideDrawStart := 0;
        Info2.OutSideDrawEnd := -1;
      end;

      if FILEVERSION >= FILEVERSION_116 then
      begin
        s.Read(Info2.CheckNavigation, SizeOf(Info2.CheckNavigation));
        s.Read(Info2.DrawTheObjects, SizeOf(Info2.DrawTheObjects));
      end
      else
      begin
        Info2.CheckNavigation := True;
        Info2.DrawTheObjects := True;
      end;

      s.Read(Info2.numPoints, SizeOf(Info2.numPoints));
      ReAllocMem(Info2.Points, Info2.numPoints * SizeOf(TSectorPoint));
      for i := 0 to Info2.numPoints - 1 do
      begin
        s.Read(Info2.Points[i].x, SizeOf(Info2.Points[i].x));
        s.Read(Info2.Points[i].y, SizeOf(Info2.Points[i].y));
        s.Read(Info2.Points[i].top, SizeOf(Info2.Points[i].top));
        s.Read(Info2.Points[i].bottom, SizeOf(Info2.Points[i].bottom));
        s.Read(Info2.Points[i].topColor, SizeOf(Info2.Points[i].topColor));
        s.Read(Info2.Points[i].bottomColor, SizeOf(Info2.Points[i].bottomColor));
      end;

      s.Read(Info2.numLineDefs, SizeOf(Info2.numLineDefs));
      ReAllocMem(Info2.LineDefs, Info2.numLineDefs * SizeOf(TSectorLineDef));
      for i := 0 to Info2.numLineDefs - 1 do
      begin
        s.Read(Info2.LineDefs[i].start, SizeOf(Info2.LineDefs[i].start));
        s.Read(Info2.LineDefs[i]._end, SizeOf(Info2.LineDefs[i]._end));
        s.Read(Info2.LineDefs[i].SideDef1, SizeOf(Info2.LineDefs[i].SideDef1));
        s.Read(Info2.LineDefs[i].SideDef2, SizeOf(Info2.LineDefs[i].SideDef2));
        s.Read(Info2.LineDefs[i].Transparent, SizeOf(Info2.LineDefs[i].Transparent));
      end;

      s.Read(Info2.numSideDefs, SizeOf(Info2.numSideDefs));
      ReAllocMem(Info2.SideDefs, Info2.numSideDefs * SizeOf(TSectorSideDef));
      for i := 0 to Info2.numSideDefs - 1 do
      begin
        s.Read(Info2.SideDefs[i].xoff, SizeOf(Info2.SideDefs[i].xoff));
        s.Read(Info2.SideDefs[i].yoff, SizeOf(Info2.SideDefs[i].yoff));
        s.Read(Info2.SideDefs[i].LineDef, SizeOf(Info2.SideDefs[i].LineDef));
        s.Read(Info2.SideDefs[i].Sector, SizeOf(Info2.SideDefs[i].Sector));

        if version > FILEVERSION_116 then
          s.Read(Info2.SideDefs[i].NavigationType, SizeOf(Info2.SideDefs[i].NavigationType))
        else
          Info2.SideDefs[i].NavigationType := ntSlide;

        if version > FILEVERSION_114 then
          s.Read(Info2.SideDefs[i].TexturePixelsPerUnit, SizeOf(Info2.SideDefs[i].TexturePixelsPerUnit))
        else
          Info2.SideDefs[i].TexturePixelsPerUnit := Info2.TexturePixelsPerUnit;

        Info2.SideDefs[i].Tex1 := ReadTextureName;
        Info2.SideDefs[i].Tex2 := ReadTextureName;
        Info2.SideDefs[i].Tex3 := ReadTextureName;
      end;

      s.Read(Info2.numSectors, SizeOf(Info2.numSectors));
      ReAllocMem(Info2.Sectors, Info2.numSectors * SizeOf(TSector));
      for i := 0 to Info2.numSectors - 1 do
      begin
        s.Read(Info2.Sectors[i].floorh, SizeOf(Info2.Sectors[i].floorh));
        s.Read(Info2.Sectors[i].ceilh, SizeOf(Info2.Sectors[i].ceilh));
        s.Read(Info2.Sectors[i].floorC, SizeOf(Info2.Sectors[i].floorC));
        s.Read(Info2.Sectors[i].ceilC, SizeOf(Info2.Sectors[i].ceilC));
        s.Read(Info2.Sectors[i].AbsoluteFlat, SizeOf(Info2.Sectors[i].AbsoluteFlat));
        if version <= FILEVERSION_108 then
        begin
          Info2.Sectors[i].DrawSideDefs := True;
          Info2.Sectors[i].AllowWalkThru := True;
          Info2.Sectors[i].ifInsideCullOtherCollections := False;
          Info2.Sectors[i].GravityBehaviour := True;
          Info2.Sectors[i].CheckFloorNavigation := True;
          Info2.Sectors[i].CheckCeilingNavigation := True;
          Info2.Sectors[i].CheckWallsNavigation := True;
          Info2.Sectors[i].MinDistanceFromFloor := 1.0;
          Info2.Sectors[i].MinDistanceFromCeiling := 0.1;
          Info2.Sectors[i].MinDistanceFromWalls := 0.1;
          Info2.Sectors[i].TexturePixelsPerUnit := Info2.TexturePixelsPerUnit;
        end
        else
        begin
          if version > FILEVERSION_110 then
            s.Read(Info2.Sectors[i].DrawSideDefs, SizeOf(Info2.Sectors[i].DrawSideDefs))
          else
            Info2.Sectors[i].DrawSideDefs := True;
          s.Read(Info2.Sectors[i].AllowWalkThru, SizeOf(Info2.Sectors[i].AllowWalkThru));
          if version > FILEVERSION_112 then
            s.Read(Info2.Sectors[i].ifInsideCullOtherCollections, SizeOf(Info2.Sectors[i].ifInsideCullOtherCollections))
          else
            Info2.Sectors[i].ifInsideCullOtherCollections := False;
          if version > FILEVERSION_109 then
            s.Read(Info2.Sectors[i].GravityBehaviour, SizeOf(Info2.Sectors[i].GravityBehaviour))
          else
            Info2.Sectors[i].GravityBehaviour := True;
          s.Read(Info2.Sectors[i].CheckFloorNavigation, SizeOf(Info2.Sectors[i].CheckFloorNavigation));
          s.Read(Info2.Sectors[i].CheckCeilingNavigation, SizeOf(Info2.Sectors[i].CheckCeilingNavigation));
          if version > FILEVERSION_111 then
            s.Read(Info2.Sectors[i].CheckWallsNavigation, SizeOf(Info2.Sectors[i].CheckWallsNavigation))
          else
            Info2.Sectors[i].CheckWallsNavigation := True;
          s.Read(Info2.Sectors[i].MinDistanceFromFloor, SizeOf(Info2.Sectors[i].MinDistanceFromFloor));
          s.Read(Info2.Sectors[i].MinDistanceFromCeiling, SizeOf(Info2.Sectors[i].MinDistanceFromCeiling));
          if version > FILEVERSION_111 then
            s.Read(Info2.Sectors[i].MinDistanceFromWalls, SizeOf(Info2.Sectors[i].MinDistanceFromWalls))
          else
            Info2.Sectors[i].MinDistanceFromWalls := 0.1;
          if version > FILEVERSION_114 then
            s.Read(Info2.Sectors[i].TexturePixelsPerUnit, SizeOf(Info2.Sectors[i].TexturePixelsPerUnit))
          else
            Info2.Sectors[i].TexturePixelsPerUnit := Info2.TexturePixelsPerUnit;
        end;
        Info2.Sectors[i].floort := ReadTextureName;
        Info2.Sectors[i].ceilt := ReadTextureName;
      end;
    finally
      sTNames.Free;
    end;
  end;
end;
{$ENDIF}

{$IFNDEF NO_OLDSTREAMINGRUTINES}
procedure TD3DSectorCollection.OldLoadFromStream(s: TStream; version: integer);
var
  i: integer;
  c: char;
  w: word;
begin
  s.Read(Info2.Key, SizeOf(Info2.key));
  s.Read(Info2.x, SizeOf(Info2.x));
  s.Read(Info2.y, SizeOf(Info2.y));
  s.Read(Info2.z, SizeOf(Info2.z));
  s.Read(Info2.dx, SizeOf(Info2.dx));
  s.Read(Info2.dy, SizeOf(Info2.dy));
  s.Read(Info2.dz, SizeOf(Info2.dz));
  if version <= FILEVERSION_103 then
  begin
    s.Read(w, SizeOf(w));
    Info2.TexturePixelsPerUnit := w/128;
  end
  else
    s.Read(Info2.TexturePixelsPerUnit, SizeOf(Info2.TexturePixelsPerUnit));

  Info2.InSideDrawStart := Low(integer);
  Info2.InSideDrawEnd := High(integer);
  Info2.OutSideDrawStart := 0;
  Info2.OutSideDrawEnd := -1;

  s.Read(Info2.numPoints, SizeOf(Info2.numPoints));
  ReAllocMem(Info2.Points, Info2.numPoints * SizeOf(TSectorPoint));
  for i := 0 to Info2.numPoints - 1 do
  begin
    s.Read(Info2.Points[i].x, SizeOf(Info2.Points[i].x));
    s.Read(Info2.Points[i].y, SizeOf(Info2.Points[i].y));
    s.Read(Info2.Points[i].top, SizeOf(Info2.Points[i].top));
    s.Read(Info2.Points[i].bottom, SizeOf(Info2.Points[i].bottom));
    s.Read(Info2.Points[i].topColor, SizeOf(Info2.Points[i].topColor));
    s.Read(Info2.Points[i].bottomColor, SizeOf(Info2.Points[i].bottomColor));
  end;

  s.Read(Info2.numLineDefs, SizeOf(Info2.numLineDefs));
  ReAllocMem(Info2.LineDefs, Info2.numLineDefs * SizeOf(TSectorLineDef));
  for i := 0 to Info2.numLineDefs - 1 do
  begin
    s.Read(Info2.LineDefs[i].start, SizeOf(Info2.LineDefs[i].start));
    s.Read(Info2.LineDefs[i]._end, SizeOf(Info2.LineDefs[i]._end));
    s.Read(Info2.LineDefs[i].SideDef1, SizeOf(Info2.LineDefs[i].SideDef1));
    s.Read(Info2.LineDefs[i].SideDef2, SizeOf(Info2.LineDefs[i].SideDef2));
    s.Read(Info2.LineDefs[i].Transparent, SizeOf(Info2.LineDefs[i].Transparent));
  end;

  s.Read(Info2.numSideDefs, SizeOf(Info2.numSideDefs));
  ReAllocMem(Info2.SideDefs, Info2.numSideDefs * SizeOf(TSectorSideDef));
  for i := 0 to Info2.numSideDefs - 1 do
  begin
    s.Read(Info2.SideDefs[i].xoff, SizeOf(Info2.SideDefs[i].xoff));
    s.Read(Info2.SideDefs[i].yoff, SizeOf(Info2.SideDefs[i].yoff));
    s.Read(Info2.SideDefs[i].LineDef, SizeOf(Info2.SideDefs[i].LineDef));
    s.Read(Info2.SideDefs[i].Sector, SizeOf(Info2.SideDefs[i].Sector));
    Info2.SideDefs[i].TexturePixelsPerUnit := Info2.TexturePixelsPerUnit;
    Info2.SideDefs[i].Tex1 := '';
    repeat
      s.Read(c, SizeOf(c));
      if c <> #0 then
        Info2.SideDefs[i].Tex1 := Info2.SideDefs[i].Tex1 + c;
    until c = #0;
    Info2.SideDefs[i].Tex2 := '';
    repeat
      s.Read(c, SizeOf(c));
      if c <> #0 then
        Info2.SideDefs[i].Tex2 := Info2.SideDefs[i].Tex2 + c;
    until c = #0;
    Info2.SideDefs[i].Tex3 := '';
    repeat
      s.Read(c, SizeOf(c));
      if c <> #0 then
        Info2.SideDefs[i].Tex3 := Info2.SideDefs[i].Tex3 + c;
    until c = #0;
  end;

  s.Read(Info2.numSectors, SizeOf(Info2.numSectors));
  ReAllocMem(Info2.Sectors, Info2.numSectors * SizeOf(TSector));
  for i := 0 to Info2.numSectors - 1 do
  begin
    s.Read(Info2.Sectors[i].floorh, SizeOf(Info2.Sectors[i].floorh));
    s.Read(Info2.Sectors[i].ceilh, SizeOf(Info2.Sectors[i].ceilh));
  // ֱם ver <= FILEVERSION_102 וקבלו םב קס‏לב, פ‏סב קןץלו ה‎ן,
  // םב דיב פן נפשלב ךבי םב דיב פן פבגםי
    if version <= FILEVERSION_102 then
    begin
      s.Read(Info2.Sectors[i].floorC, SizeOf(Info2.Sectors[i].floorC));
      Info2.Sectors[i].ceilC := Info2.Sectors[i].floorC;
    end
    else
    begin
      s.Read(Info2.Sectors[i].floorC, SizeOf(Info2.Sectors[i].floorC));
      s.Read(Info2.Sectors[i].ceilC, SizeOf(Info2.Sectors[i].ceilC));
    end;

    s.Read(Info2.Sectors[i].AbsoluteFlat, SizeOf(Info2.Sectors[i].AbsoluteFlat));

    Info2.Sectors[i].AllowWalkThru := True;
    Info2.Sectors[i].ifInsideCullOtherCollections := False;
    Info2.Sectors[i].DrawSideDefs :=  True;
    Info2.Sectors[i].CheckFloorNavigation := True;
    Info2.Sectors[i].CheckCeilingNavigation := True;
    Info2.Sectors[i].CheckWallsNavigation := True;
    Info2.Sectors[i].MinDistanceFromFloor := 1.0;
    Info2.Sectors[i].MinDistanceFromCeiling := 0.1;
    Info2.Sectors[i].MinDistanceFromWalls := 0.1;

    Info2.Sectors[i].TexturePixelsPerUnit := Info2.TexturePixelsPerUnit;

    Info2.Sectors[i].floort := '';
    repeat
      s.Read(c, SizeOf(c));
      if c <> #0 then
        Info2.Sectors[i].floort := Info2.Sectors[i].floort + c;
    until c = #0;
    Info2.Sectors[i].ceilt := '';
    repeat
      s.Read(c, SizeOf(c));
      if c <> #0 then
        Info2.Sectors[i].ceilt := Info2.Sectors[i].ceilt + c;
    until c = #0;
  end;
end;
{$ENDIF}

{$ENDIF}

// ******* Script Engine ********

function GetLine(const text: string; pos: integer): integer;
var
  i: integer;
begin
  if pos > Length(text) then
    Result := -1
  else
  begin
    Result := 0;
    for i := 1 to pos do
      if text[i] = #10 then
        inc(Result);
  end;
end;

// ֵניףפסצוי פחם טףח פחע דסבללע ףפן ךולוםן
function GetPos(const text: string; line: integer): integer;
var
  currLine: integer;
begin
  Result := 0;
  if Length(text) > 0 then
  begin
    currLine := 1;
    repeat
      inc(Result);
      if text[Result] = #10 then
        inc(currLine);
    until (currLine = line) or (Result = Length(text));
  end;
end;

{$IFNDEF NO_SCRIPTS}
var
  YieldCount: integer;

function OnRunLineProc(id: Pointer; Sender: TIfPasScript; Position: Longint): TCs2Error;
{$IFDEF DESIGNER}
var
  i: integer;
{$ENDIF}
begin
  if (Sender as TD3DSceneScriptEngine).Yield <= YieldCount then
  begin
    YieldCount := 0;
    Application.ProcessMessages;
  end
  else
    inc(YieldCount);

  Result := ENoError;

  case (Sender as TD3DSceneScriptEngine).Scene.iStatus of
    iStopped: Result := EExitCommand;
{$IFDEF DESIGNER}
    iStepOver:
    begin
      i := GetLine((Sender as TD3DSceneScriptEngine).Script, Position);
      if i <> (Sender as TD3DSceneScriptEngine).LastLine then
      begin
        (Sender as TD3DSceneScriptEngine).Scene.iStatus := iStepOverWaiting;
        (Sender as TD3DSceneScriptEngine).LastLine := i;
        (Sender as TD3DSceneScriptEngine).Scene.DoRunLine(Sender, Position);
        while (Sender as TD3DSceneScriptEngine).Scene.iStatus = iStepOverWaiting do
          Application.ProcessMessages;
      end;
    end;
{$ENDIF}
  end;
end;

const
  rsString = 'String';
  rsInteger = 'Integer';
  rsCardinal = 'Cardinal';
  rsWord = 'Word';
  rsByte = 'Byte';
  rsSingle = 'Single';
  rsDouble = 'Double';
  rsExtended = 'Extended';
  rsComp = 'Comp';

function StdInOutRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if (proc^.Name = 'WRITELN') or (proc^.Name = 'WRITE') then
    (Sender as TD3DSceneScriptEngine).Scene.DoScriptMessage(Sender, GetString(Vm_Get(Params, 0)))
  else if (proc^.Name = 'READLN') then
    GetVarLink(Vm_Get(Params, 0))^.Cv_Str := InputBox(Application.Title, 'Readln:', '')
  else if (proc^.Name = 'READ') then
    GetVarLink(Vm_Get(Params, 0))^.Cv_Str := InputBox(Application.Title, 'Read:', '')
  else
    Result := EUnknownIdentifier;
end;

function StdRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = 'RANDOM' then
//    SetInteger(res, GetIntegerParam(Params, 0))
    SetInteger(res, random(GetInteger(Vm_Get(Params, 0))))
  else if proc^.Name = 'SLEEP' then
    Sleep(GetInteger(Vm_Get(Params, 0)))
{$IFNDEF NO_MESSAGESCAN}
  else if proc^.Name = 'MESSAGESCAN' then
    (Sender as TD3DSceneScriptEngine).Scene.MessageScan
{$ENDIF}
  else if proc^.Name = 'SCREENWIDTH' then
    SetInteger(res, Screen.Width)
  else if proc^.Name = 'SCREENHEIGHT' then
    SetInteger(res, Screen.Height)
  else if proc^.Name = 'RUNPROCEDURE' then
    (Sender as TD3DSceneScriptEngine).Scene.RunProcedure(GetString(Vm_Get(Params, 0)), True)
  else if proc^.Name = 'RUNUNIT' then
    (Sender as TD3DSceneScriptEngine).Scene.RunUnit(GetString(Vm_Get(Params, 0)))
  else
    Result := EUnknownIdentifier;
end;

function StdHaltProgramRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = 'CLOSEQUERY' then
    SetBoolean(res, Application.MainForm.CloseQuery)
  else if proc^.Name = 'HALT' then
    Halt(GetInteger(Vm_Get(Params, 0)))
  else if proc^.Name = 'HALT0' then
    Halt(0)
  else if proc^.Name = 'TERMINATE' then
    Application.Terminate
  else
    Result := EUnknownIdentifier;
end;

function StdVersionRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = 'VERSION' then
    SetString(res, rsVersion)
  else if proc^.Name = 'LONGVERSION' then
    SetString(res, Application.Title + ' ' + rsVersion)
  else
    Result := EUnknownIdentifier;
end;

function FutureProcsRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
var
  i, id, count: integer;
begin
  Result := ENoError;
  if proc^.Name = 'ADDFUTUREPROC' then
  begin
    id := GetInteger(Vm_Get(Params, 1));
    if id in [0..AttachedEventsCount - 1] then
      (Sender as TD3DSceneScriptEngine).Scene.AddFutureProc(
        GetString(Vm_Get(Params, 0)), id, GetReal(Vm_Get(Params, 2)))
    else
      Result := EParameterError
  end
  else if proc^.Name = 'GETNUMFUTUREPROCS' then
  begin
    id := GetInteger(Vm_Get(Params, 0));
    if id in [0..AttachedEventsCount - 1] then
      SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.FutureProcList[id].Count)
    else if id = -1 then
    begin
      count := 0;
      for i := 0 to AttachedEventsCount - 1 do
          count := count + (Sender as TD3DSceneScriptEngine).Scene.FutureProcList[i].Count;
      SetInteger(res, count)
    end
    else
      Result := EParameterError
  end
  else if proc^.Name = 'DELETEFUTUREPROCS' then
  begin
    id := GetInteger(Vm_Get(Params, 0));
    if id in [0..AttachedEventsCount - 1] then
      (Sender as TD3DSceneScriptEngine).Scene.FutureProcList[id].Clear
    else if id = -1 then
    begin
      for i := 0 to AttachedEventsCount - 1 do
        (Sender as TD3DSceneScriptEngine).Scene.FutureProcList[id].Clear
    end
    else
      Result := EParameterError
  end
  else
    Result := EUnknownIdentifier;
end;

function SceneGetPositionRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_GETPOSITIONX' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.Position.X)
  else if proc^.Name = '_SCENE_GETPOSITIONY' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.Position.Y)
  else if proc^.Name = '_SCENE_GETPOSITIONZ' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.Position.Z)
  else if proc^.Name = '_SCENE_GETPOSITION' then
  begin
    SetReal(Vm_Get(Params, 0), (Sender as TD3DSceneScriptEngine).Scene.Position.X);
    SetReal(Vm_Get(Params, 1), (Sender as TD3DSceneScriptEngine).Scene.Position.Y);
    SetReal(Vm_Get(Params, 2), (Sender as TD3DSceneScriptEngine).Scene.Position.Z);
  end
  else
    Result := EUnknownIdentifier;
end;

function SceneGetRotationRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_GETROTATIONX' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.Rotation.X)
  else if proc^.Name = '_SCENE_GETROTATIONY' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.Rotation.Y)
  else if proc^.Name = '_SCENE_GETROTATIONZ' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.Rotation.Z)
  else if proc^.Name = '_SCENE_GETROTATION' then
  begin
    SetReal(Vm_Get(Params, 0), (Sender as TD3DSceneScriptEngine).Scene.Rotation.X);
    SetReal(Vm_Get(Params, 1), (Sender as TD3DSceneScriptEngine).Scene.Rotation.Y);
    SetReal(Vm_Get(Params, 2), (Sender as TD3DSceneScriptEngine).Scene.Rotation.Z);
  end
  else
    Result := EUnknownIdentifier;
end;

function SceneStatisticsRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_GETNUMTRIANGLES' then
    SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.GetNumTriangles)
  else if proc^.Name = '_SCENE_GETNUMVERTEXES' then
    SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.GetNumVertexes)
  else if proc^.Name = '_SCENE_GETNUMDRAWNTRIANGLES' then
    SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.GetNumDrawnTriangles)
  else if proc^.Name = '_SCENE_GETNUMDRAWNVERTEXES' then
    SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.GetNumDrawnVertexes)
  else
    Result := EUnknownIdentifier;
end;

function SceneNearClippingPlaneRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_SETNEARCLIPPINGPLANE' then
    (Sender as TD3DSceneScriptEngine).Scene.NearClippingPlane :=
      GetReal(Vm_Get(Params, 0))
  else if proc^.Name = '_SCENE_GETNEARCLIPPINGPLANE' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.NearClippingPlane)
  else
    Result := EUnknownIdentifier;
end;

function SceneSetPositionRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_SETPOSITION' then
    (Sender as TD3DSceneScriptEngine).Scene.Position := MakeD3DVector(
      GetReal(Vm_Get(Params, 0)),
      GetReal(Vm_Get(Params, 1)),
      GetReal(Vm_Get(Params, 2)))
  else if proc^.Name = '_SCENE_SETPOSITIONX' then
    (Sender as TD3DSceneScriptEngine).Scene.Position := MakeD3DVector(
      GetReal(Vm_Get(Params, 0)),
      (Sender as TD3DSceneScriptEngine).Scene.Position.Y,
      (Sender as TD3DSceneScriptEngine).Scene.Position.Z)
  else if proc^.Name = '_SCENE_SETPOSITIONY' then
    (Sender as TD3DSceneScriptEngine).Scene.Position := MakeD3DVector(
      (Sender as TD3DSceneScriptEngine).Scene.Position.X,
      GetReal(Vm_Get(Params, 0)),
      (Sender as TD3DSceneScriptEngine).Scene.Position.Z)
  else if proc^.Name = '_SCENE_SETPOSITIONZ' then
    (Sender as TD3DSceneScriptEngine).Scene.Position := MakeD3DVector(
      (Sender as TD3DSceneScriptEngine).Scene.Position.X,
      (Sender as TD3DSceneScriptEngine).Scene.Position.Y,
      GetReal(Vm_Get(Params, 0)))
  else
    Result := EUnknownIdentifier;
end;

function SceneSetRotationRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_SETROTATION' then
    (Sender as TD3DSceneScriptEngine).Scene.Rotation := MakeD3DVector(
      GetReal(Vm_Get(Params, 0)),
      GetReal(Vm_Get(Params, 1)),
      GetReal(Vm_Get(Params, 2)))
  else if proc^.Name = '_SCENE_SETROTATIONX' then
    (Sender as TD3DSceneScriptEngine).Scene.Rotation := MakeD3DVector(
      GetReal(Vm_Get(Params, 0)),
      (Sender as TD3DSceneScriptEngine).Scene.Rotation.Y,
      (Sender as TD3DSceneScriptEngine).Scene.Rotation.Z)
  else if proc^.Name = '_SCENE_SETROTATIONY' then
    (Sender as TD3DSceneScriptEngine).Scene.Rotation := MakeD3DVector(
      (Sender as TD3DSceneScriptEngine).Scene.Rotation.X,
      GetReal(Vm_Get(Params, 0)),
      (Sender as TD3DSceneScriptEngine).Scene.Rotation.Z)
  else if proc^.Name = '_SCENE_SETROTATIONZ' then
    (Sender as TD3DSceneScriptEngine).Scene.Rotation := MakeD3DVector(
      (Sender as TD3DSceneScriptEngine).Scene.Rotation.X,
      (Sender as TD3DSceneScriptEngine).Scene.Rotation.Y,
      GetReal(Vm_Get(Params, 0)))
  else
    Result := EUnknownIdentifier;
end;

function SceneRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
var
  v: TD3DVector;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_GETDISTANCE' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.Distance)
  else if proc^.Name = '_SCENE_MOVE' then
    (Sender as TD3DSceneScriptEngine).Scene.InitialMove(
        GetReal(Vm_Get(Params, 0)),
        GetReal(Vm_Get(Params, 1)),
        GetReal(Vm_Get(Params, 2)))
  else if proc^.Name = '_SCENE_ROTATE' then  // לופ פן Parent נסנוי םב ךםוי recalc
  begin
    if (Sender as TD3DSceneScriptEngine).Scene.fParent <> nil then
    begin
      v := MakeD3DVector(
        (Sender as TD3DSceneScriptEngine).Scene.Info.x,
        (Sender as TD3DSceneScriptEngine).Scene.Info.y,
        (Sender as TD3DSceneScriptEngine).Scene.Info.z);
      (Sender as TD3DSceneScriptEngine).Scene.InitialMove(-v.x, -v.y, -v.z);

      (Sender as TD3DSceneScriptEngine).Scene.InitialRotate(
          GetReal(Vm_Get(Params, 0)),
          GetReal(Vm_Get(Params, 1)),
          GetReal(Vm_Get(Params, 2)));

      (Sender as TD3DSceneScriptEngine).Scene.InitialMove(v);
    end
    else
    begin
// InitialRotate ??? //ֳכץפ‏םןץלו םב function call & םב compare
//      (Sender as TD3DSceneScriptEngine).Scene.InitialRotate( // ? Rotate(
//      (Sender as TD3DSceneScriptEngine).Scene.InitialRotate( // ? Rotate(
      (Sender as TD3DSceneScriptEngine).Scene.Rotate( // ? Rotate(
          GetReal(Vm_Get(Params, 0)),
          GetReal(Vm_Get(Params, 1)),
          GetReal(Vm_Get(Params, 2)));
    end;
  end
  else if proc^.Name = '_SCENE_MOVEOBJECTS' then
    (Sender as TD3DSceneScriptEngine).Scene.MoveObjects(
      GetInteger(Vm_Get(Params, 0)), // ID
      GetInteger(Vm_Get(Params, 1)), // Key
      GetReal(Vm_Get(Params, 2)),    // x
      GetReal(Vm_Get(Params, 3)),    // y
      GetReal(Vm_Get(Params, 4)))    // z
  else if proc^.Name = '_SCENE_MOVEOBJECTSTO' then
    (Sender as TD3DSceneScriptEngine).Scene.MoveObjectsTO(
      GetInteger(Vm_Get(Params, 0)), // ID
      GetInteger(Vm_Get(Params, 1)), // Key
      GetReal(Vm_Get(Params, 2)),    // x
      GetReal(Vm_Get(Params, 3)),    // y
      GetReal(Vm_Get(Params, 4)))    // z
  else if proc^.Name = '_SCENE_ROTATEOBJECTS' then
    (Sender as TD3DSceneScriptEngine).Scene.RotateObjects(
      GetInteger(Vm_Get(Params, 0)), // ID
      GetInteger(Vm_Get(Params, 1)), // Key
      GetReal(Vm_Get(Params, 2)),    // dx
      GetReal(Vm_Get(Params, 3)),    // dy
      GetReal(Vm_Get(Params, 4)))    // dz
  else if proc^.Name = '_SCENE_ROTATEOBJECTSAROUND' then
    (Sender as TD3DSceneScriptEngine).Scene.RotateObjectsAround(
      GetInteger(Vm_Get(Params, 0)), // ID
      GetInteger(Vm_Get(Params, 1)), // Key
      GetReal(Vm_Get(Params, 2)),    // x
      GetReal(Vm_Get(Params, 3)),    // y
      GetReal(Vm_Get(Params, 4)),    // z
      GetReal(Vm_Get(Params, 5)),    // dx
      GetReal(Vm_Get(Params, 6)),    // dy
      GetReal(Vm_Get(Params, 7)))    // dz
  else if proc^.Name = '_SCENE_RECALC' then
    (Sender as TD3DSceneScriptEngine).Scene.Recalc
  else if proc^.Name = '_SCENE_GETSPEED' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.Speed)
  else if proc^.Name = '_SCENE_INVALIDATE' then
  begin
    if (Sender as TD3DSceneScriptEngine).Scene.DXDraw.CanDraw then
      (Sender as TD3DSceneScriptEngine).Scene.Draw
  end
  else if proc^.Name = '_SCENE_ISATTACHED' then
    SetBoolean(res, (Sender as TD3DSceneScriptEngine).Scene.Attached)
  else if proc^.Name = '_SCENE_CULLSURFACES' then
    (Sender as TD3DSceneScriptEngine).Scene.CullSurfaces(GetReal(Vm_Get(Params, 0)))
  else if proc^.Name = '_SCENE_ADDSEARCHPATH' then
    (Sender as TD3DSceneScriptEngine).Scene.AddSearchPath(GetString(Vm_Get(Params, 0)))
  else if proc^.Name = '_SCENE_SETMAXPOLYGONVERTEXES' then
    (Sender as TD3DSceneScriptEngine).Scene.SetMaxPolygonVertexes(GetiNTEGER(Vm_Get(Params, 0)))
  else
    Result := EUnknownIdentifier;
end;

function SceneDXDrawParamsRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_DXDRAWWIDTH' then
  begin
    if doFullScreen in (Sender as TD3DSceneScriptEngine).Scene.DXDraw.NowOptions then
      SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Display.Width)
    else
      SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Width);
    //SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.DXDraw.SurfaceWidth)
  end
  else if proc^.Name = '_SCENE_DXDRAWHEIGHT' then
  begin
    if doFullScreen in (Sender as TD3DSceneScriptEngine).Scene.DXDraw.NowOptions then
      SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Display.Height)
    else
      SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Height);
    //SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.DXDraw.SurfaceHeight)
  end
  else if proc^.Name = '_SCENE_DXDRAWBPP' then
    SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Display.BitCount)
  else
    Result := EUnknownIdentifier;
end;

function SceneAmbientRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
var
  tmp: Cardinal;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_SETAMBIENT' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.D3DDevice7.SetRenderState(D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
      GetInteger(Vm_Get(Params, 0)))
  else if proc^.Name = '_SCENE_GETAMBIENT' then
  begin
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.D3DDevice7.GetRenderState(D3DRENDERSTATE_AMBIENTMATERIALSOURCE, tmp);
    SetInteger(res, tmp);
  end
  else
    Result := EUnknownIdentifier;
end;

function SceneFogRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_STOPFOG' then
    (Sender as TD3DSceneScriptEngine).Scene.StopFog
  else if proc^.Name = '_SCENE_STARTVERTEXFOG' then
    SetBoolean(res,
      (Sender as TD3DSceneScriptEngine).Scene.StartVertexFog(
        GetInteger(Vm_Get(Params, 0)), // color
        GetInteger(Vm_Get(Params, 1)), // alfa
        GetReal(Vm_Get(Params, 2)),    // fStart
        GetReal(Vm_Get(Params, 3))     // fEnd
      )
    )
  else if proc^.Name = '_SCENE_STARTTABLEFOG' then
    SetBoolean(res,
      (Sender as TD3DSceneScriptEngine).Scene.StartTableFog(
        GetInteger(Vm_Get(Params, 0)), // color
        GetInteger(Vm_Get(Params, 1)), // alfa
        GetReal(Vm_Get(Params, 2)),    // fStart
        GetReal(Vm_Get(Params, 3)),    // fEnd
        GetReal(Vm_Get(Params, 4)),    // density
        TD3DFogMode(GetInteger(Vm_Get(Params, 5)))  // mode
      )
    )
  else if proc^.Name = '_SCENE_STARTFOG' then
    SetBoolean(res,
      (Sender as TD3DSceneScriptEngine).Scene.StartFog(
        GetInteger(Vm_Get(Params, 0)), // color
        GetInteger(Vm_Get(Params, 1)), // alfa
        GetReal(Vm_Get(Params, 2)),    // fStart
        GetReal(Vm_Get(Params, 3)),    // fEnd
        GetReal(Vm_Get(Params, 4))     // density
      )
    )
  else
    Result := EUnknownIdentifier;
end;

function SceneGetVerRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = 'FILEVERSIONOF' then
    SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.GetFileVersion(GetString(Vm_Get(Params, 0))))
  else if proc^.Name = 'FILEVERSIONSTROF' then
    SetString(res, IntToStr((Sender as TD3DSceneScriptEngine).Scene.GetFileVersion(GetString(Vm_Get(Params, 0)))))
  else
    Result := EUnknownIdentifier;
end;

function SceneTimeRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_GETTIME' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.Time)
  else if proc^.Name = '_SCENE_GETOLDTIME' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.OldTime)
  else if proc^.Name = '_SCENE_GETSTARTTIME' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.StartTime)
  else
    Result := EUnknownIdentifier;
end;

{$IFNDEF NO_AVI}
function SceneAVIRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_PLAYAVI' then
    SetBoolean(res, (Sender as TD3DSceneScriptEngine).Scene.PlayAVI(GetString(Vm_Get(Params, 0))))
  else if proc^.Name = '_SCENE_STOPAVI' then
    (Sender as TD3DSceneScriptEngine).Scene.StopAVI
  else if proc^.Name = '_SCENE_ISPLAYINGAVI' then
    SetBoolean(res, (Sender as TD3DSceneScriptEngine).Scene.IsPlayingAVI)
  else
    Result := EUnknownIdentifier;
end;
{$ENDIF}

{$IFNDEF NO_D3DTEXTS}
function Scene3DTextRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
var
  i, id: integer;
  s: string;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_SET3DTEXT' then
  begin
    id := GetInteger(Vm_Get(params, 0));
    s := GetString(Vm_Get(params, 1));
    for i := 0 to (Sender as TD3DSceneScriptEngine).Scene.Surfaces.Count - 1 do
      if ((Sender as TD3DSceneScriptEngine).Scene.Surfaces.Objects[i] as TD3DObject).GetTypeID = ID3D_Text then
        if ((Sender as TD3DSceneScriptEngine).Scene.Surfaces.Objects[i] as TD3DText).GetKeyID = id then
          ((Sender as TD3DSceneScriptEngine).Scene.Surfaces.Objects[i] as TD3DText).SetText(s);
  end
  else if proc^.Name = '_SCENE_GET3DTEXT' then
  begin
    id := GetInteger(Vm_Get(params, 0));
    s := '';
    for i := 0 to (Sender as TD3DSceneScriptEngine).Scene.Surfaces.Count - 1 do
      if ((Sender as TD3DSceneScriptEngine).Scene.Surfaces.Objects[i] as TD3DObject).GetTypeID = ID3D_Text then
        if ((Sender as TD3DSceneScriptEngine).Scene.Surfaces.Objects[i] as TD3DText).GetKeyID = id then
        begin
          s := ((Sender as TD3DSceneScriptEngine).Scene.Surfaces.Objects[i] as TD3DText).GetText;
          break;
        end;
    SetString(res, s);
  end
  else
    Result := EUnknownIdentifier;
end;
{$ENDIF}

function SceneGetDistanceFromRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_GETDISTANCEFROM' then
    SetReal(res,
      VectorMagnitude(VectorSub(
        (Sender as TD3DSceneScriptEngine).Scene.Position,
          MakeD3DVector(GetReal(Vm_Get(Params, 0)),
                        GetReal(Vm_Get(Params, 1)),
                        GetReal(Vm_Get(Params, 2))))))
  else
    Result := EUnknownIdentifier;
end;

{$IFNDEF NO_D3DSOUNDS}
function SceneSoundsRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_GETMUTE' then
    SetBoolean(res, (Sender as TD3DSceneScriptEngine).Scene.Muted)
  else if proc^.Name = '_SCENE_SETMUTE' then
    (Sender as TD3DSceneScriptEngine).Scene.Muted :=
      GetBoolean(Vm_Get(params, 0))
  else
    Result := EUnknownIdentifier;
end;
{$ENDIF}

{$IFNDEF NO_D3DSOUNDS}
function Scene3DSoundsRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_PLAYSOUNDS' then
    (Sender as TD3DSceneScriptEngine).Scene.PlaySounds(
      GetInteger(Vm_Get(params, 0)))
  else if proc^.Name = '_SCENE_PAUSESOUNDS' then
    (Sender as TD3DSceneScriptEngine).Scene.PauseSounds(
      GetInteger(Vm_Get(params, 0)))
  else if proc^.Name = '_SCENE_STOPSOUNDS' then
    (Sender as TD3DSceneScriptEngine).Scene.StopSounds(
      GetInteger(Vm_Get(params, 0)))
  else if proc^.Name = '_SCENE_REWINDSOUNDS' then
    (Sender as TD3DSceneScriptEngine).Scene.RewindSounds(
      GetInteger(Vm_Get(params, 0)))
  else
    Result := EUnknownIdentifier;
end;
{$ENDIF}

{$IFNDEF NO_D3DSOUNDS}
function Scene3DTonesRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_PLAYTONES' then
    (Sender as TD3DSceneScriptEngine).Scene.PlayTones(
      GetInteger(Vm_Get(params, 0)))
  else if proc^.Name = '_SCENE_PAUSETONES' then
    (Sender as TD3DSceneScriptEngine).Scene.PauseTones(
      GetInteger(Vm_Get(params, 0)))
  else if proc^.Name = '_SCENE_STOPTONES' then
    (Sender as TD3DSceneScriptEngine).Scene.StopTones(
      GetInteger(Vm_Get(params, 0)))
  else
    Result := EUnknownIdentifier;
end;
{$ENDIF}

function SceneGetOldPositionRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_GETOLDPOSITION' then
  begin
    SetReal(Vm_Get(Params, 0), (Sender as TD3DSceneScriptEngine).Scene.OldPosition.x);
    SetReal(Vm_Get(Params, 1), (Sender as TD3DSceneScriptEngine).Scene.OldPosition.y);
    SetReal(Vm_Get(Params, 2), (Sender as TD3DSceneScriptEngine).Scene.OldPosition.z);
  end
  else if proc^.Name = '_SCENE_GETOLDPOSITIONX' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.OldPosition.x)
  else if proc^.Name = '_SCENE_GETOLDPOSITIONY' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.OldPosition.y)
  else if proc^.Name = '_SCENE_GETOLDPOSITIONZ' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.OldPosition.z)
  else
    Result := EUnknownIdentifier;
end;

function SceneGetOldRotationRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_GETOLDROTATION' then
  begin
    SetReal(Vm_Get(Params, 0), (Sender as TD3DSceneScriptEngine).Scene.OldRotation.x);
    SetReal(Vm_Get(Params, 1), (Sender as TD3DSceneScriptEngine).Scene.OldRotation.y);
    SetReal(Vm_Get(Params, 2), (Sender as TD3DSceneScriptEngine).Scene.OldRotation.z);
  end
  else if proc^.Name = '_SCENE_GETOLDROTATIONX' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.OldRotation.x)
  else if proc^.Name = '_SCENE_GETOLDROTATIONY' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.OldRotation.y)
  else if proc^.Name = '_SCENE_GETOLDROTATIONZ' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.OldRotation.z)
  else
    Result := EUnknownIdentifier;
end;

function SceneReloadRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_RELOAD' then
    (Sender as TD3DSceneScriptEngine).Scene.Reload
  else
    Result := EUnknownIdentifier;
end;

function SceneDeleteNonSaveAbleObjectsRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_DELETENONSAVEABLEOBJECTS' then
    (Sender as TD3DSceneScriptEngine).Scene.DeleteNonSaveAbleObjects
  else
    Result := EUnknownIdentifier;
end;

function SceneLoadRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_LOADFROM' then
    SetBoolean(res, (Sender as TD3DSceneScriptEngine).Scene.LoadFrom(
      GetString(Vm_Get(Params, 0))))
  else
    Result := EUnknownIdentifier;
end;

function SceneThreadLevelRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_GETTHREADLEVEL' then
    SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.ThreadLevel)
  else
    Result := EUnknownIdentifier;
end;

function ScenePlacementRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_GETPLACEMENTPOSITIONX' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.Info.X)
  else if proc^.Name = '_SCENE_GETPLACEMENTPOSITIONY' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.Info.Y)
  else if proc^.Name = '_SCENE_GETPLACEMENTPOSITIONZ' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.Info.Z)
  else if proc^.Name = '_SCENE_GETPLACEMENTPOSITION' then
  begin
    SetReal(Vm_Get(Params, 0), (Sender as TD3DSceneScriptEngine).Scene.Info.X);
    SetReal(Vm_Get(Params, 1), (Sender as TD3DSceneScriptEngine).Scene.Info.Y);
    SetReal(Vm_Get(Params, 2), (Sender as TD3DSceneScriptEngine).Scene.Info.Z);
  end
  else if proc^.Name = '_SCENE_GETPLACEMENTROTATIONX' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.Info.dX)
  else if proc^.Name = '_SCENE_GETPLACEMENTROTATIONY' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.Info.dY)
  else if proc^.Name = '_SCENE_GETPLACEMENTROTATIONZ' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.Info.dZ)
  else if proc^.Name = '_SCENE_GETPLACEMENTROTATION' then
  begin
    SetReal(Vm_Get(Params, 0), (Sender as TD3DSceneScriptEngine).Scene.Info.dX);
    SetReal(Vm_Get(Params, 1), (Sender as TD3DSceneScriptEngine).Scene.Info.dY);
    SetReal(Vm_Get(Params, 2), (Sender as TD3DSceneScriptEngine).Scene.Info.dZ);
  end
  else
    Result := EUnknownIdentifier;
end;

function SceneShowHideRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_SHOWSURFACES' then
    (Sender as TD3DSceneScriptEngine).Scene.ShowSurfaces(
      GetInteger(Vm_Get(Params, 0)), GetInteger(Vm_Get(Params, 1)))
  else if proc^.Name = '_SCENE_HIDESURFACES' then
    (Sender as TD3DSceneScriptEngine).Scene.HideSurfaces(
      GetInteger(Vm_Get(Params, 0)), GetInteger(Vm_Get(Params, 1)))
  else
    Result := EUnknownIdentifier;
end;

function SceneCanvasFontRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_GETFONT' then
    SetString(res, (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Font.Name)
  else if proc^.Name = '_SCENE_SETFONT' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Font.Name :=
      GetString(Vm_Get(Params, 0))
  else if proc^.Name = '_SCENE_GETTEXTSIZE' then
    SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Font.Size)
  else if proc^.Name = '_SCENE_SETTEXTSIZE' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Font.Size :=
      GetInteger(Vm_Get(Params, 0))
  else if proc^.Name = '_SCENE_GETTEXTCOLOR' then
    SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Font.Color)
  else if proc^.Name = '_SCENE_SETTEXTCOLOR' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Font.Color :=
      GetInteger(Vm_Get(Params, 0))
  else if proc^.Name = '_SCENE_GETFONTCHARSET' then
    SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Font.Charset)
  else if proc^.Name = '_SCENE_SETFONTCHARSET' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Font.Charset :=
      GetInteger(Vm_Get(Params, 0))
  else
    Result := EUnknownIdentifier;
end;

function SceneCanvasPenRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_GETPENCOLOR' then
    SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Pen.Color)
  else if proc^.Name = '_SCENE_SETPENCOLOR' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Pen.Color :=
      GetInteger(Vm_Get(Params, 0))
  else if proc^.Name = '_SCENE_GETPENSTYLE' then
    SetInteger(res, ord((Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Pen.Style))
  else if proc^.Name = '_SCENE_SETPENSTYLE' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Pen.Style :=
      TPenStyle(GetInteger(Vm_Get(Params, 0)))
  else if proc^.Name = '_SCENE_GETPENMODE' then
    SetInteger(res, ord((Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Pen.Mode))
  else if proc^.Name = '_SCENE_SETPENMODE' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Pen.Mode :=
      TPenMode(GetInteger(Vm_Get(Params, 0)))
  else if proc^.Name = '_SCENE_GETPENWIDTH' then
    SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Pen.Width)
  else if proc^.Name = '_SCENE_SETPENWIDTH' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Pen.Width :=
      GetInteger(Vm_Get(Params, 0))
  else
    Result := EUnknownIdentifier;
end;

function SceneCanvasBrushRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_GETBRUSHCOLOR' then
    SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Brush.Color)
  else if proc^.Name = '_SCENE_SETBRUSHCOLOR' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Brush.Color :=
      GetInteger(Vm_Get(Params, 0))
  else if proc^.Name = '_SCENE_GETBRUSHSTYLE' then
    SetInteger(res, ord((Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Brush.Style))
  else if proc^.Name = '_SCENE_SETBRUSHSTYLE' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Brush.Style :=
      TBrushStyle(GetInteger(Vm_Get(Params, 0)))
  else
    Result := EUnknownIdentifier;
end;

function SceneCanvasRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_MOVETO' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.MoveTo(
      GetInteger(Vm_Get(Params, 0)), GetInteger(Vm_Get(Params, 1)))
  else if proc^.Name = '_SCENE_LINETO' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.LineTo(
      GetInteger(Vm_Get(Params, 0)), GetInteger(Vm_Get(Params, 1)))
  else if proc^.Name = '_SCENE_LINE' then
  begin
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.MoveTo(
      GetInteger(Vm_Get(Params, 0)), GetInteger(Vm_Get(Params, 1)));
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.LineTo(
      GetInteger(Vm_Get(Params, 2)), GetInteger(Vm_Get(Params, 3)));
  end
  else if proc^.Name = '_SCENE_RECTANGLE' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.RectAngle(
      GetInteger(Vm_Get(Params, 0)), GetInteger(Vm_Get(Params, 1)),
      GetInteger(Vm_Get(Params, 2)), GetInteger(Vm_Get(Params, 3)))
  else if proc^.Name = '_SCENE_INVERTRECT' then
    InvertRect(
      (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Handle,
      Rect(
        GetInteger(Vm_Get(Params, 0)), GetInteger(Vm_Get(Params, 1)),
        GetInteger(Vm_Get(Params, 2)), GetInteger(Vm_Get(Params, 3))))
  else if proc^.Name = '_SCENE_FILLRECT' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.FillRect(
      Rect(
        GetInteger(Vm_Get(Params, 0)), GetInteger(Vm_Get(Params, 1)),
        GetInteger(Vm_Get(Params, 2)), GetInteger(Vm_Get(Params, 3))))
  else if proc^.Name = '_SCENE_ROUNDRECT' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.RoundRect(
      GetInteger(Vm_Get(Params, 0)), GetInteger(Vm_Get(Params, 1)),
      GetInteger(Vm_Get(Params, 2)), GetInteger(Vm_Get(Params, 3)),
      GetInteger(Vm_Get(Params, 4)), GetInteger(Vm_Get(Params, 5)))
  else if proc^.Name = '_SCENE_ELLIPSE' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Ellipse(
      GetInteger(Vm_Get(Params, 0)), GetInteger(Vm_Get(Params, 1)),
      GetInteger(Vm_Get(Params, 2)), GetInteger(Vm_Get(Params, 3)))
  else if proc^.Name = '_SCENE_ARC' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Arc(
      GetInteger(Vm_Get(Params, 0)), GetInteger(Vm_Get(Params, 1)),
      GetInteger(Vm_Get(Params, 2)), GetInteger(Vm_Get(Params, 3)),
      GetInteger(Vm_Get(Params, 4)), GetInteger(Vm_Get(Params, 5)),
      GetInteger(Vm_Get(Params, 6)), GetInteger(Vm_Get(Params, 7)))
  else if proc^.Name = '_SCENE_CHORD' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Chord(
      GetInteger(Vm_Get(Params, 0)), GetInteger(Vm_Get(Params, 1)),
      GetInteger(Vm_Get(Params, 2)), GetInteger(Vm_Get(Params, 3)),
      GetInteger(Vm_Get(Params, 4)), GetInteger(Vm_Get(Params, 5)),
      GetInteger(Vm_Get(Params, 6)), GetInteger(Vm_Get(Params, 7)))
  else if proc^.Name = '_SCENE_TEXTOUT' then
  begin
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.TextOut(
      GetInteger(Vm_Get(Params, 0)),
      GetInteger(Vm_Get(Params, 1)),
      GetString(Vm_Get(Params, 2)));
  end
  else if proc^.Name = '_SCENE_RELEASECANVAS' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Release
  else if proc^.Name = '_SCENE_DRAWFOCUSRECT' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.DrawFocusRect(
      Rect(GetInteger(Vm_Get(params, 0)), GetInteger(Vm_Get(params, 1)),
           GetInteger(Vm_Get(params, 2)), GetInteger(Vm_Get(params, 3))))
  else
    Result := EUnknownIdentifier;
end;

function SceneTextAlignRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_SETTEXTALIGN' then
    SetTextAlign(
      (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Handle,
      GetInteger(Vm_Get(params, 0)))
  else if proc^.Name = '_SCENE_GETTEXTALIGN' then
    SetInteger(res,
      GetTextAlign(
        (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Canvas.Handle))
  else
    Result := EUnknownIdentifier;
end;

function SceneDrawRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
var
  tex: TDirect3DTexture2;
  oldIsTransparent: boolean;
  oldTransparentColor: TColorRef;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_DRAW' then
  begin
    tex := (Sender as TD3DSceneScriptEngine).Scene.AddTextureToCollectionConst(GetString(Vm_Get(Params, 2)));
    if Assigned(tex) then
      (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Draw(
        GetInteger(Vm_Get(Params, 0)), GetInteger(Vm_Get(Params, 1)),
        tex.Surface, False)
    else
      Result := EOutOfMemoryError
  end
  else if proc^.Name = '_SCENE_DRAWTRANSPARENT' then
  begin
    tex := (Sender as TD3DSceneScriptEngine).Scene.AddTextureToCollectionConst(GetString(Vm_Get(Params, 2)));
    if Assigned(tex) then
    begin
      oldIsTransparent := tex.Transparent;
      tex.Transparent := True;
      oldTransparentColor := tex.TransparentColor;
      tex.TransparentColor := GetInteger(Vm_Get(Params, 3));

      (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.Draw(
        GetInteger(Vm_Get(Params, 0)), GetInteger(Vm_Get(Params, 1)),
        tex.Surface, True);

      tex.Transparent := oldIsTransparent;
      tex.TransparentColor := oldTransparentColor;
    end
    else
      Result := EOutOfMemoryError
  end
  else if proc^.Name = '_SCENE_STRETCHDRAW' then
  begin
    tex := (Sender as TD3DSceneScriptEngine).Scene.AddTextureToCollectionConst(GetString(Vm_Get(Params, 4)));
    if Assigned(tex) then
      (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.StretchDraw(
        Rect(GetInteger(Vm_Get(Params, 0)), GetInteger(Vm_Get(Params, 1)),
             GetInteger(Vm_Get(Params, 2)), GetInteger(Vm_Get(Params, 3))),
        tex.Surface, False)
    else
      Result := EOutOfMemoryError
  end
  else if proc^.Name = '_SCENE_STRETCHDRAWTRANSPARENT' then
  begin
    tex := (Sender as TD3DSceneScriptEngine).Scene.AddTextureToCollectionConst(GetString(Vm_Get(Params, 4)));
    if Assigned(tex) then
    begin
      oldIsTransparent := tex.Transparent;
      tex.Transparent := True;
      oldTransparentColor := tex.TransparentColor;
      tex.TransparentColor := GetInteger(Vm_Get(Params, 5));

      (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Surface.StretchDraw(
        Rect(GetInteger(Vm_Get(Params, 0)), GetInteger(Vm_Get(Params, 1)),
             GetInteger(Vm_Get(Params, 2)), GetInteger(Vm_Get(Params, 3))),
        tex.Surface, True);

      tex.Transparent := oldIsTransparent;
      tex.TransparentColor := oldTransparentColor;
    end
    else
      Result := EOutOfMemoryError
  end
  else
    Result := EUnknownIdentifier;
end;

function ScenePerformanceRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_GETFPS' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.FPS)
  else if proc^.Name = '_SCENE_GETFPS_SMOOTH' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.FPS_Smooth)
  else if proc^.Name = '_SCENE_GETUPDATETOLERANCE' then
    SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.UpdateTolerance)
  else if proc^.Name = '_SCENE_SETUPDATETOLERANCE' then
    (Sender as TD3DSceneScriptEngine).Scene.UpdateTolerance := GetReal(Vm_Get(Params, 0))
  else
    Result := EUnknownIdentifier;
end;

{$IFNDEF NO_D3DSECTORCOLLECTIONS}
function SceneSectorsRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_GETCURRENTSECTORINDEX' then
  begin
    if (Sender as TD3DSceneScriptEngine).Scene._CurrentSectorIndex > -1 then
      SetInteger(res, ((Sender as TD3DSceneScriptEngine).Scene._CacheSectorCollections.Objects[(Sender as TD3DSceneScriptEngine).Scene._CurrentSectorIndex] as TD3DSectorCollection).CurrentSector)
    else
      SetInteger(res, -1);
  end
  else if proc^.Name = '_SCENE_GETCURRENTSECTORCOLLECTION' then
    SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene._CurrentSectorIndex)
  else
    Result := EUnknownIdentifier;
end;
{$ENDIF}

function SceneActionsRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
var
  Info: TD3DActionInfo;
begin
  Result := ENoError;
  if proc^.Name = '_SCENE_ADDMOVER' then
    with Info do
    begin
      ActionID := ID3D_MOVER;
      ActionKey := GenGlobalID;
      SetInteger(res, ActionKey);
      ID := GetInteger(Vm_Get(Params, 0));
      Key := GetInteger(Vm_Get(Params, 1));
      PositionVector.x := GetReal(Vm_Get(Params, 2));
      PositionVector.y := GetReal(Vm_Get(Params, 3));
      PositionVector.z := GetReal(Vm_Get(Params, 4));
      Secs := GetReal(Vm_Get(Params, 5));
      RunTimeOnly := True;
      (Sender as TD3DSceneScriptEngine).Scene.AddAction(@Info);
    end
  else if proc^.Name = '_SCENE_ADDROTATOR' then
    with Info do
    begin
      ActionID := ID3D_ROTATOR;
      ActionKey := GenGlobalID;
      SetInteger(res, ActionKey);
      ID := GetInteger(Vm_Get(Params, 0));
      Key := GetInteger(Vm_Get(Params, 1));
      RotationVector.x := GetReal(Vm_Get(Params, 2));
      RotationVector.y := GetReal(Vm_Get(Params, 3));
      RotationVector.z := GetReal(Vm_Get(Params, 4));
      Secs := GetReal(Vm_Get(Params, 5));
      RunTimeOnly := True;
      (Sender as TD3DSceneScriptEngine).Scene.AddAction(@Info);
    end
  else if proc^.Name = '_SCENE_ADDROTATORAROUND' then
    with Info do
    begin
      ActionID := ID3D_ROTATORAROUND;
      ActionKey := GenGlobalID;
      SetInteger(res, ActionKey);
      ID := GetInteger(Vm_Get(Params, 0));
      Key := GetInteger(Vm_Get(Params, 1));
      PositionVector.x := GetReal(Vm_Get(Params, 2));
      PositionVector.y := GetReal(Vm_Get(Params, 3));
      PositionVector.z := GetReal(Vm_Get(Params, 4));
      RotationVector.x := GetReal(Vm_Get(Params, 5));
      RotationVector.y := GetReal(Vm_Get(Params, 6));
      RotationVector.z := GetReal(Vm_Get(Params, 7));
      Secs := GetReal(Vm_Get(Params, 8));
      RunTimeOnly := True;
      (Sender as TD3DSceneScriptEngine).Scene.AddAction(@Info);
    end
  else if (proc^.Name = '_SCENE_DELETEACTION') then
    (Sender as TD3DSceneScriptEngine).Scene.DeleteActionByKey(GetInteger(Vm_Get(Params, 0)))
  else
    Result := EUnknownIdentifier;
end;

function WindowsRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = 'HINSTANCE' then
    SetReal(res, HInstance)
  else if proc^.Name = 'HANDLE' then
    SetReal(res, Application.MainForm.Handle)
  else if proc^.Name = 'ISKEYDOWN' then
    SetBoolean(res, HiWord(GetKeyState(GetInteger(Vm_Get(params, 0)))) <> 0)
  else if proc^.Name = 'ISKEYTOGGLED' then
    SetBoolean(res, LoWord(GetKeyState(GetInteger(Vm_Get(params, 0)))) <> 0)
  else if proc^.Name = 'MESSAGEBOX' then
    SetInteger(res, Windows.MessageBox(
      GetInteger(Vm_Get(params, 0)),
      PChar(GetString(Vm_Get(params, 1))),
      PChar(GetString(Vm_Get(params, 2))),
      GetInteger(Vm_Get(params, 3))))
  else
    Result := EUnknownIdentifier;
end;

function WindowsColorsRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = 'CLSCROLLBAR' then
    SetInteger(res, ColorToRGB(clScrollBar))
  else if proc^.Name = 'CLBACKGROUND' then
    SetInteger(res, ColorToRGB(clBackground))
  else if proc^.Name = 'CLACTIVECAPTION' then
    SetInteger(res, ColorToRGB(clActiveCaption))
  else if proc^.Name = 'CLINACTIVECAPTION' then
    SetInteger(res, ColorToRGB(clInactiveCaption))
  else if proc^.Name = 'CLMENU' then
    SetInteger(res, ColorToRGB(clMenu))
  else if proc^.Name = 'CLWINDOW' then
    SetInteger(res, ColorToRGB(clWindow))
  else if proc^.Name = 'CLWINDOWFRAME' then
    SetInteger(res, ColorToRGB(clWindowFrame))
  else if proc^.Name = 'CLMENUTEXT' then
    SetInteger(res, ColorToRGB(clMenuText))
  else if proc^.Name = 'CLWINDOWTEXT' then
    SetInteger(res, ColorToRGB(clWindowText))
  else if proc^.Name = 'CLCAPTIONTEXT' then
    SetInteger(res, ColorToRGB(clCaptionText))
  else if proc^.Name = 'CLACTIVEBORDER' then
    SetInteger(res, ColorToRGB(clActiveBorder))
  else if proc^.Name = 'CLINACTIVEBORDER' then
    SetInteger(res, ColorToRGB(clInactiveBorder))
  else if proc^.Name = 'CLAPPWORKSPACE' then
    SetInteger(res, ColorToRGB(clAppWorkSpace))
  else if proc^.Name = 'CLHIGHLIGHT' then
    SetInteger(res, ColorToRGB(clHighlight))
  else if proc^.Name = 'CLHIGHLIGHTTEXT' then
    SetInteger(res, ColorToRGB(clHighlightText))
  else if proc^.Name = 'CLBTNFACE' then
    SetInteger(res, ColorToRGB(clBtnFace))
  else if proc^.Name = 'CLBTNSHADOW' then
    SetInteger(res, ColorToRGB(clBtnShadow))
  else if proc^.Name = 'CLGRAYTEXT' then
    SetInteger(res, ColorToRGB(clGrayText))
  else if proc^.Name = 'CLBTNTEXT' then
    SetInteger(res, ColorToRGB(clBtnText))
  else if proc^.Name = 'CLINACTIVECAPTIONTEXT' then
    SetInteger(res, ColorToRGB(clInactiveCaptionText))
  else if proc^.Name = 'CLBTNHIGHLIGHT' then
    SetInteger(res, ColorToRGB(clBtnHighlight))
  else if proc^.Name = 'CL3DDKSHADOW' then
    SetInteger(res, ColorToRGB(cl3DDkShadow))
  else if proc^.Name = 'CL3DLIGHT' then
    SetInteger(res, ColorToRGB(cl3DLight))
  else if proc^.Name = 'CLINFOTEXT' then
    SetInteger(res, ColorToRGB(clInfoText))
  else if proc^.Name = 'CLINFOBK' then
    SetInteger(res, ColorToRGB(clInfoBk))
  else
    Result := EUnknownIdentifier;
end;

function WindowsCursorRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
var
  p: TPoint;
begin
  Result := ENoError;
  if proc^.Name = 'SETCURSOR' then
    (Sender as TD3DSceneScriptEngine).Scene.DXDraw.Cursor :=
      GetInteger(Vm_Get(params, 0))
  else if proc^.Name = 'GETCURSORPOS' then
  begin
    SetBoolean(res, GetCursorPos(p));
    SetInteger(Vm_Get(Params, 0), p.x);
    SetInteger(Vm_Get(Params, 1), p.y);
  end
  else if proc^.Name = 'SETCURSORPOS' then
    SetBoolean(res,
      SetCursorPos(GetInteger(Vm_Get(Params, 0)), GetInteger(Vm_Get(Params, 1))))
  else
    Result := EUnknownIdentifier;
end;

function _PostMessage(hWnd: integer; Msg: Integer; wParam: Integer; lParam: Integer): boolean;
begin
  Result := PostMessage(LongWord(hWnd), Msg, wParam, lParam);
end;

function _SendMessage(hWnd: integer; Msg: Integer; wParam: Integer; lParam: Integer): integer;
begin
  Result := SendMessage(LongWord(hWnd), Msg, wParam, lParam);
end;

function _MessageBeep(mType: integer): boolean;
begin
  if mType = -1 then
    Result := MessageBeep($FFFFFFFF)
  else
    Result := MessageBeep(mType)
end;

{$IFNDEF NO_D3DPROCEDURALOBJECTS}
function ProceduralObjectsDynamicManagmentProc(Sender: TIfPasScript; ScriptID: Pointer;
  proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
var
  info: TD3DProceduralObjectInfo;
  i, id: integer;
{$IFDEF DESIGNER}
  oldCanSaveUndo: boolean;
{$ENDIF}
begin
  Result := ENoError;
  if proc^.Name = 'PR_CREATE' then
  begin
    {$IFDEF DESIGNER}
    oldCanSaveUndo := (Sender as TD3DSceneScriptEngine).Scene.CanSaveUndo;
    (Sender as TD3DSceneScriptEngine).Scene.CanSaveUndo := False;
    {$ENDIF}
    FillChar(Info, SizeOf(info), Chr(0));
    id := GenGlobalID;
    Info.key := id;
    Info.x := GetReal(Vm_Get(Params, 0));
    Info.y := GetReal(Vm_Get(Params, 1));
    Info.z := GetReal(Vm_Get(Params, 2));
    Info.dx := GetReal(Vm_Get(Params, 3));
    Info.dy := GetReal(Vm_Get(Params, 4));
    Info.dz := GetReal(Vm_Get(Params, 5));
    Info.Transparency := MAXTRANSPARENCYREPLICATION;
    Info.Cull := D3DCULL_NONE;
    Info.PrimitiveType := D3DPT_TRIANGLESTRIP;
    if GetString(Vm_Get(Params, 6)) <> '' then
    begin
      Info.NumTextures := 1;
      Info.TextureNames[0, 0] := GetString(Vm_Get(Params, 6));
    end
    else
      Info.NumTextures := 0;
    Info.ModuleName := GetString(Vm_Get(Params, 7));

    (Sender as TD3DSceneScriptEngine).Scene.AddSurface(ID3D_ProceduralObject, @Info);
    SetInteger(res, id);
    (Sender as TD3DSceneScriptEngine).Scene.SetCurrentPrObject(id);
    (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.Saveable := False;
    {$IFDEF DESIGNER}
    (Sender as TD3DSceneScriptEngine).Scene.CanSaveUndo := oldCanSaveUndo;
    {$ENDIF}
  end
  else if proc^.Name = 'PR_DELETE' then
  begin
    {$IFDEF DESIGNER}
    oldCanSaveUndo := (Sender as TD3DSceneScriptEngine).Scene.CanSaveUndo;
    (Sender as TD3DSceneScriptEngine).Scene.CanSaveUndo := False;
    {$ENDIF}
    (Sender as TD3DSceneScriptEngine).Scene.SetCurrentPrObject(GetInteger(Vm_Get(Params, 0)));
    if (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject = nil then
      Result := EOutOfMemoryError
    else
    begin
      if not (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.Saveable then
      begin
        for i:= (Sender as TD3DSceneScriptEngine).Scene.Surfaces.Count - 1 downto 0 do
        begin
          if (Sender as TD3DSceneScriptEngine).Scene.Surfaces.Objects[i] =
            (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject then
            begin
              (Sender as TD3DSceneScriptEngine).Scene.DeleteSurface(i);
              break
            end;
        end;
      end
      else
        Result := EOutOfMemoryError;
    end;
    {$IFDEF DESIGNER}
    (Sender as TD3DSceneScriptEngine).Scene.CanSaveUndo := oldCanSaveUndo;
    {$ENDIF}
  end
  else if proc^.Name = 'PR_HIDE' then
  begin
    if (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject = nil then
      Result := EOutOfMemoryError
    else
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.Culled := True
  end
  else if proc^.Name = 'PR_SHOW' then
  begin
    if (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject = nil then
      Result := EOutOfMemoryError
    else
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.Culled := False
  end
  else if proc^.Name = 'PR_ISVISIBLE' then
  begin
    if (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject = nil then
      Result := EOutOfMemoryError
    else if (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.Culled then
      SetBoolean(res, False)
    else if (Sender as TD3DSceneScriptEngine).Scene.Culled then
      SetBoolean(res, False)
    else
      SetBoolean(res, True)
  end
 else
   Result := EUnknownIdentifier;
end;

function ProceduralObjectsStreamingProc(Sender: TIfPasScript; ScriptID: Pointer;
  proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject <> nil then
  begin
    if proc^.Name = 'PR_SAVEVERTEXES' then
    {$IFDEF DESIGNER}
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.SaveVertexes(
        GetString(Vm_Get(Params, 0)))
    {$ENDIF}
    else if proc^.Name = 'PR_LOADVERTEXES' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.LoadVertexes(
        GetString(Vm_Get(Params, 0)))
    else
      Result := EUnknownIdentifier;
  end
  else
    Result := EOutOfMemoryError;
end;

function ProceduralObjectsRegProc(Sender: TIfPasScript; ScriptID: Pointer;
  proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject <> nil then
  begin
    if proc^.Name = 'PR_SETNUMVERTEXES' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.SizeNumVertexes(
        GetInteger(Vm_Get(Params, 0)))
    else if proc^.Name = 'PR_SETVERTEX' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.TheVertexes[
        GetInteger(Vm_Get(Params, 0))] := MakeD3DLVERTEX(
          GetReal(Vm_Get(Params, 1)),
          GetReal(Vm_Get(Params, 2)),
          GetReal(Vm_Get(Params, 3)),
          GetInteger(Vm_Get(Params, 4)),
          GetInteger(Vm_Get(Params, 5)),
          GetReal(Vm_Get(Params, 6)),
          GetReal(Vm_Get(Params, 7)))
    else if proc^.Name = 'PR_STDSETVERTEX' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.TheVertexes[
        GetInteger(Vm_Get(Params, 0))] := MakeD3DLVERTEX(
          GetReal(Vm_Get(Params, 1)),
          GetReal(Vm_Get(Params, 2)),
          GetReal(Vm_Get(Params, 3)),
          $FFFFFF,
          $0,
          GetReal(Vm_Get(Params, 4)),
          GetReal(Vm_Get(Params, 5)))
    else if proc^.Name = 'PR_GETNUMVERTEXES' then
      SetInteger(res, ord(
        (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.fNumVertexes))
    else if proc^.Name = 'PR_SETPRIMITIVETYPE' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.Info.PrimitiveType :=
        TD3DPrimitiveType(GetInteger(Vm_Get(Params, 0)))
    else if proc^.Name = 'PR_GETPRIMITIVETYPE' then
      SetInteger(res, ord(
        (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.Info.PrimitiveType))
    else if proc^.Name = 'PR_SETCULL' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.Info.Cull :=
        TD3DCull(GetInteger(Vm_Get(Params, 0)))
    else if proc^.Name = 'PR_GETCULL' then
      SetInteger(res, ord(
        (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.Info.Cull))
    else if proc^.Name = 'PR_EXECUTE' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.Execute
    else if proc^.Name = 'PR_GETDISTANCE' then
      SetReal(res, (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.CalcDistance(
        (Sender as TD3DSceneScriptEngine).Scene.fPosition))
    else
      Result := EUnknownIdentifier;
  end
  else
    Result := EOutOfMemoryError;
end;

function ProceduralObjectsRegScaleProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject <> nil then
  begin
    if proc^.Name = 'PR_SCALEX' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.ScaleX(
        GetReal(Vm_Get(Params, 0)))
    else if proc^.Name = 'PR_SCALEY' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.ScaleY(
        GetReal(Vm_Get(Params, 0)))
    else if proc^.Name = 'PR_SCALEZ' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.ScaleZ(
        GetReal(Vm_Get(Params, 0)))
    else if proc^.Name = 'PR_SCALE' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.Scale(
        GetReal(Vm_Get(Params, 0)),
        GetReal(Vm_Get(Params, 1)),
        GetReal(Vm_Get(Params, 2)))
    else
      Result := EUnknownIdentifier;
  end
  else
    Result := EOutOfMemoryError;
end;

function ProceduralObjectsRegMoveProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject <> nil then
  begin
    if proc^.Name = 'PR_MOVEX' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.MoveX(
        GetReal(Vm_Get(Params, 0)))
    else if proc^.Name = 'PR_MOVEY' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.MoveY(
        GetReal(Vm_Get(Params, 0)))
    else if proc^.Name = 'PR_MOVEZ' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.MoveZ(
        GetReal(Vm_Get(Params, 0)))
    else if proc^.Name = 'PR_MOVE' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.Move(
        GetReal(Vm_Get(Params, 0)),
        GetReal(Vm_Get(Params, 1)),
        GetReal(Vm_Get(Params, 2)))
    else
      Result := EUnknownIdentifier;
  end
  else
    Result := EOutOfMemoryError;
end;

function ProceduralObjectsRegRotateProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject <> nil then
  begin
    if proc^.Name = 'PR_ROTATEX' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.RotateX(
        GetReal(Vm_Get(Params, 0)))
    else if proc^.Name = 'PR_ROTATEY' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.RotateY(
        GetReal(Vm_Get(Params, 0)))
    else if proc^.Name = 'PR_ROTATEZ' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.RotateZ(
        GetReal(Vm_Get(Params, 0)))
    else if proc^.Name = 'PR_ROTATE' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.Rotate(
        GetReal(Vm_Get(Params, 0)),
        GetReal(Vm_Get(Params, 1)),
        GetReal(Vm_Get(Params, 2)))
    else
      Result := EUnknownIdentifier;
  end
  else
    Result := EOutOfMemoryError;
end;

function ProceduralObjectsRegSpherePointsProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject <> nil then
  begin
    if proc^.Name = 'PR_ADDSPHEREPOINT' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.AddSpherePoint(
        Make2DVector(
          GetReal(Vm_Get(Params, 0)),
          GetReal(Vm_Get(Params, 1))))
    else if proc^.Name = 'PR_STARTSPHEREPOINTINDEX' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.StartSpherePointIndex(
        GetInteger(Vm_Get(Params, 0)))
    else if proc^.Name = 'PR_STOPSPHEREPOINTINDEX' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.StopSpherePointIndex
    else if proc^.Name = 'PR_SETNUMSPHEREPOINTS' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.SizeNumSpherePoints(
        GetInteger(Vm_Get(Params, 0)))
    else if proc^.Name = 'PR_GETNUMSPHEREPOINTS' then
      SetInteger(res,
        (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.fNumSpherePoints)
    else if proc^.Name = 'PR_SETFLATUVPARAM' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.flatUVParam :=
        GetString(Vm_Get(Params, 0))
    else if proc^.Name = 'PR_GETFLATUVPARAM' then
      SetString(res,
        (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.flatUVParam)
    else if proc^.Name = 'PR_SETSPHEREPOINTSCOMPLEXITY' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.SpherePointsComplexity :=
        GetInteger(Vm_Get(Params, 0))
    else if proc^.Name = 'PR_GETSPHEREPOINTSCOMPLEXITY' then
      SetInteger(res,
        (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.SpherePointsComplexity)
    else
      Result := EUnknownIdentifier;
  end
  else
    Result := EOutOfMemoryError;
end;

function ProceduralObjectsRegIdxProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject <> nil then
  begin
    if proc^.Name = 'PR_STDADDVERTEX' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.AddVertex(
        MakeD3DLVERTEX(
          GetReal(Vm_Get(Params, 0)),
          GetReal(Vm_Get(Params, 1)),
          GetReal(Vm_Get(Params, 2)),
          $FFFFFF,
          $0,
          GetReal(Vm_Get(Params, 3)),
          GetReal(Vm_Get(Params, 4))))
    else if proc^.Name = 'PR_ADDVERTEX' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.AddVertex(
        MakeD3DLVERTEX(
          GetReal(Vm_Get(Params, 0)),
          GetReal(Vm_Get(Params, 1)),
          GetReal(Vm_Get(Params, 2)),
          GetInteger(Vm_Get(Params, 3)),
          GetInteger(Vm_Get(Params, 4)),
          GetReal(Vm_Get(Params, 5)),
          GetReal(Vm_Get(Params, 6))))
    else if proc^.Name = 'PR_STARTVERTEXINDEX' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.StartVertexIndex(
        GetInteger(Vm_Get(Params, 0)))
    else if proc^.Name = 'PR_STOPVERTEXINDEX' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.StopVertexIndex
    else if proc^.Name = 'PR_VERTEXINDEX' then
      SetInteger(res, (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.VertexIndex)
    else
      Result := EUnknownIdentifier;
  end
  else
    Result := EOutOfMemoryError;
end;

function ProceduralObjectsRegExProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
var
  vrt: TD3DLVertex;
begin
  Result := ENoError;
  if proc^.Name = 'PR_SETCURRENTPROBJECT' then
    SetBoolean(res, (Sender as TD3DSceneScriptEngine).Scene.SetCurrentPrObject(
      GetInteger(Vm_Get(Params, 0))))
  else if proc^.Name = 'PR_GETCURRENTPROBJECT' then
    SetInteger(res,
      (Sender as TD3DSceneScriptEngine).Scene.GetCurrentPrObject)
  else if (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject <> nil then
  begin
    if proc^.Name = 'PR_GETVERTEX' then
    begin
      vrt := (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.TheVertexes[
          GetInteger(Vm_Get(Params, 0))];
      SetReal(Vm_Get(Params, 1), vrt.x);
      SetReal(Vm_Get(Params, 2), vrt.y);
      SetReal(Vm_Get(Params, 3), vrt.z);
      SetInteger(Vm_Get(Params, 4), vrt.Color);
      SetInteger(Vm_Get(Params, 5), vrt.Specular);
      SetReal(Vm_Get(Params, 6), vrt.tu);
      SetReal(Vm_Get(Params, 7), vrt.tv);
    end
    else if proc^.Name = 'PR_STDGETVERTEX' then
    begin
      vrt := (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.TheVertexes[
          GetInteger(Vm_Get(Params, 0))];
      SetReal(Vm_Get(Params, 1), vrt.x);
      SetReal(Vm_Get(Params, 2), vrt.y);
      SetReal(Vm_Get(Params, 3), vrt.z);
      SetReal(Vm_Get(Params, 4), vrt.tu);
      SetReal(Vm_Get(Params, 5), vrt.tv);
    end
    else
      Result := EUnknownIdentifier;
  end
  else
    Result := EOutOfMemoryError;
end;

function ProceduralObjectsRegSetExProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject <> nil then
  begin
    if proc^.Name = 'PR_SETVERTEXX' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.TheVertexes[
        GetInteger(Vm_Get(Params, 0))].x :=
          GetReal(Vm_Get(Params, 1))
    else if proc^.Name = 'PR_SETVERTEXY' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.TheVertexes[
        GetInteger(Vm_Get(Params, 0))].y :=
          GetReal(Vm_Get(Params, 1))
    else if proc^.Name = 'PR_SETVERTEXZ' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.TheVertexes[
        GetInteger(Vm_Get(Params, 0))].z :=
          GetReal(Vm_Get(Params, 1))
    else if proc^.Name = 'PR_SETVERTEXCOLOR' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.TheVertexes[
        GetInteger(Vm_Get(Params, 0))].color :=
          GetInteger(Vm_Get(Params, 1))
    else if proc^.Name = 'PR_SETVERTEXSPECULAR' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.TheVertexes[
        GetInteger(Vm_Get(Params, 0))].specular :=
          GetInteger(Vm_Get(Params, 1))
    else if proc^.Name = 'PR_SETVERTEXU' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.TheVertexes[
        GetInteger(Vm_Get(Params, 0))].tu :=
          GetReal(Vm_Get(Params, 1))
    else if proc^.Name = 'PR_SETVERTEXV' then
      (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.TheVertexes[
        GetInteger(Vm_Get(Params, 0))].tv :=
          GetReal(Vm_Get(Params, 1))
    else
      Result := EUnknownIdentifier;
  end
  else
    Result := EOutOfMemoryError
end;

function ProceduralObjectsRegGetExProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject <> nil then
  begin
    if proc^.Name = 'PR_GETVERTEXX' then
      SetReal(Res,
        (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.TheVertexes[
          GetInteger(Vm_Get(Params, 0))].x)
    else if proc^.Name = 'PR_GETVERTEXY' then
      SetReal(Res,
        (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.TheVertexes[
          GetInteger(Vm_Get(Params, 0))].y)
    else if proc^.Name = 'PR_GETVERTEXZ' then
      SetReal(Res,
        (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.TheVertexes[
          GetInteger(Vm_Get(Params, 0))].z)
    else if proc^.Name = 'PR_GETVERTEXCOLOR' then
      SetInteger(Res,
        (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.TheVertexes[
          GetInteger(Vm_Get(Params, 0))].color)
    else if proc^.Name = 'PR_GETVERTEXSPECULAR' then
      SetInteger(Res,
        (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.TheVertexes[
          GetInteger(Vm_Get(Params, 0))].specular)
    else if proc^.Name = 'PR_GETVERTEXU' then
      SetReal(Res,
        (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.TheVertexes[
          GetInteger(Vm_Get(Params, 0))].tu)
    else if proc^.Name = 'PR_GETVERTEXV' then
      SetReal(Res,
        (Sender as TD3DSceneScriptEngine).Scene.CurrentProceduralObject.TheVertexes[
          GetInteger(Vm_Get(Params, 0))].tv)
    else
      Result := EUnknownIdentifier;
  end
  else
    Result := EOutOfMemoryError
end;
{$ENDIF}

function ScriptStartStopRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = 'ISSCRIPTSTARTING' then
    SetBoolean(Res,
      (Sender as TD3DSceneScriptEngine).Scene.IsScriptStarting)
  else if proc^.Name = 'ISSCRIPTFINISHING' then
    SetBoolean(Res,
      (Sender as TD3DSceneScriptEngine).Scene.IsScriptFinishing)
  else
    Result := EUnknownIdentifier;
end;

function SysUtilsRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = 'GETEXISTEDFILENAME' then
    SetString(res, (Sender as TD3DSceneScriptEngine).Scene.GetExistedFileName(
      GetString(Vm_Get(params, 0))))
  else
    Result := EUnknownIdentifier;
end;

function StrCaseRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = 'UPPERCASE' then
    SetString(res, UpperCase(GetString(GetVarLink(Vm_Get(Params, 0)))))
  else if proc^.Name = 'LOWERCASE' then
    SetString(res, LowerCase(GetString(GetVarLink(Vm_Get(Params, 0)))))
  else
    Result := EUnknownIdentifier;
end;

function _FirstWord(S: string): string;
begin
  Result := FW(s);
end;

procedure _RemoveFirstWord(var s: string);
begin
  RFW(s);
end;

function MemManagerRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
var
  p: Pointer;
begin
  Result := ENoError;
  if proc^.Name = 'NEW' then
  begin
    GetMem(p, SizeOf(TCajVariant));
    SetInteger(Vm_Get(Params, 0), Integer(p))
  end
  else if proc^.Name = 'DISPOSE' then
  begin
    p := Pointer(GetInteger(Vm_Get(Params, 0)));
    FreeMem(p, SizeOf(TCajVariant));
    SetInteger(Vm_Get(Params, 0), 0);
  end
  else if proc^.Name = 'ADDR' then
    SetInteger(res, Integer(Vm_Get(Params, 0)))
  else if proc^.Name = 'DEREF' then
    res^ := Vm_Get(Params, 0)^
  else
    Result := EUnknownIdentifier;
end;

type
  TPointer = record
    TString: string;
    case byte of
      1: (TInteger: integer);
      2: (TExtended: extended);
      3: (TBoolean: boolean);
    end;

function MemManagerRegProc2(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
var
  p: Pointer;
begin
  Result := ENoError;
  if proc^.Name = 'NEWP' then
  begin
    GetMem(p, SizeOf(TPointer));
    SetInteger(Vm_Get(Params, 0), Integer(p))
  end
  else if proc^.Name = 'DISPOSEP' then
  begin
    p := Pointer(GetInteger(Vm_Get(Params, 0)));
    FreeMem(p, SizeOf(TPointer));
    SetInteger(Vm_Get(Params, 0), 0);
  end
  else
    Result := EUnknownIdentifier;
end;

function MemManagerGetRegProc2(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
var
  p: Pointer;
begin
  Result := ENoError;
  if proc^.Name = 'GETINTEGER' then
  begin
    p := Pointer(GetInteger(Vm_Get(Params, 0)));
    SetInteger(res, TPointer(p^).TInteger)
  end
  else if proc^.Name = 'GETREAL' then
  begin
    p := Pointer(GetInteger(Vm_Get(Params, 0)));
    SetReal(res, TPointer(p^).TExtended)
  end
  else if proc^.Name = 'GETBOOLEAN' then
  begin
    p := Pointer(GetInteger(Vm_Get(Params, 0)));
    SetBoolean(res, TPointer(p^).TBoolean)
  end
  else if proc^.Name = 'GETSTRING' then
  begin
    p := Pointer(GetInteger(Vm_Get(Params, 0)));
    SetString(res, TPointer(p^).TString)
  end
  else
    Result := EUnknownIdentifier;
end;

function MemManagerSetRegProc2(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
var
  p: Pointer;
begin
  Result := ENoError;
  if proc^.Name = 'SETINTEGER' then
  begin
    p := Pointer(GetInteger(Vm_Get(Params, 0)));
    TPointer(p^).TInteger := GetInteger(Vm_Get(Params, 1))
  end
  else if proc^.Name = 'SETREAL' then
  begin
    p := Pointer(GetInteger(Vm_Get(Params, 0)));
    TPointer(p^).TExtended := GetReal(Vm_Get(Params, 1))
  end
  else if proc^.Name = 'GETBOOLEAN' then
  begin
    p := Pointer(GetInteger(Vm_Get(Params, 0)));
    TPointer(p^).TBoolean := GetBoolean(Vm_Get(Params, 1))
  end
  else if proc^.Name = 'SETSTRING' then
  begin
    p := Pointer(GetInteger(Vm_Get(Params, 0)));
    TPointer(p^).TString := GetString(Vm_Get(Params, 1))
  end
  else
    Result := EUnknownIdentifier;
end;

function PlaySoundRegProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
begin
  Result := ENoError;
  if proc^.Name = 'PLAYSOUND' then
    (Sender as TD3DSceneScriptEngine).Scene.PlayOldStyleSound(GetString(Vm_Get(Params, 0)), False)
  else if proc^.Name = 'LOOPSOUND' then
    (Sender as TD3DSceneScriptEngine).Scene.PlayOldStyleSound(GetString(Vm_Get(Params, 0)), True)
  else if proc^.Name = 'STOPSOUND' then
    (Sender as TD3DSceneScriptEngine).Scene.PlayOldStyleSound('')
  else
    Result := EUnknownIdentifier;
end;

procedure RegisterMultimediaLibrary(Sender: TIfPasScript);
begin
// CDAudio Control
  RegisterDelphiFunction(Sender, 'procedure StopCDAudio;', @StopCDAudio);
  RegisterDelphiFunction(Sender, 'procedure PlayCDAudio(TrackFrom, TrackTo: byte);', @PlayCDAudio);
  RegisterDelphiFunction(Sender, 'procedure PauseCDAudio;', @PauseCDAudio);
  RegisterDelphiFunction(Sender, 'procedure ResumeCDAudio;', @ResumeCDAudio);
// Midi Files Control
  RegisterDelphiFunction(Sender, 'procedure PlayMidi(index: integer);', @PlayMidi);
  RegisterDelphiFunction(Sender, 'procedure StopMidi;', @StopMidi);
  RegisterDelphiFunction(Sender, 'procedure AddMidiFileToPlayList(MidiFile: string);', @AddMidiFileToPlayList);
  RegisterDelphiFunction(Sender, 'procedure DeleteMidiFileFromPlayList(MidiFile: string);', @DeleteMidiFileFromPlayList);
  RegisterDelphiFunction(Sender, 'procedure ClearMidiFilePlayList;', @ClearMidiFilePlayList);
// Mp3 audio Control
  RegisterDelphiFunction(Sender, 'procedure PlayMp3File(FileName: string);', @PlayMp3File);
  RegisterDelphiFunction(Sender, 'procedure PlayMp3(index: integer);', @PlayMp3);
  RegisterDelphiFunction(Sender, 'procedure StopMp3;', @StopMp3);
  RegisterDelphiFunction(Sender, 'procedure PauseMp3;', @PauseMp3);
  RegisterDelphiFunction(Sender, 'procedure ResumeMp3;', @ResumeMp3);
  RegisterDelphiFunction(Sender, 'procedure AddMp3ToPlayList(Mp3File: string);', @AddMp3ToPlayList);
  RegisterDelphiFunction(Sender, 'procedure DeleteMp3FromPlayList(Mp3File: string);', @DeleteMp3FromPlayList);
  RegisterDelphiFunction(Sender, 'procedure ClearMp3PlayList;', @ClearMp3PlayList);
// DirectShow Media
  RegisterDelphiFunction(Sender, 'procedure PlayMediaFile(FileName: string);', @PlayMediaFile);
  RegisterDelphiFunction(Sender, 'procedure PlayMedia(index: integer);', @PlayMedia);
  RegisterDelphiFunction(Sender, 'procedure StopMedia;', @StopMedia);
  RegisterDelphiFunction(Sender, 'procedure PauseMedia;', @PauseMedia);
  RegisterDelphiFunction(Sender, 'procedure ResumeMedia;', @ResumeMedia);
  RegisterDelphiFunction(Sender, 'procedure AddMediaToPlayList(MediaFile: string);', @AddMediaToPlayList);
  RegisterDelphiFunction(Sender, 'procedure DeleteMp3FromPlayList(MediaFile: string);', @DeleteMp3FromPlayList);
  RegisterDelphiFunction(Sender, 'procedure ClearMediaPlayList;', @ClearMediaPlayList);
  RegisterDelphiFunction(Sender, 'procedure KillMedia;', @KillMedia);
// Old style PlaySound
  Sender.AddFunction(@PlaySoundRegProc, 'procedure PlaySound(sName: string);', nil);
  Sender.AddFunction(@PlaySoundRegProc, 'procedure LoopSound(sName: string);', nil);
  Sender.AddFunction(@PlaySoundRegProc, 'procedure StopSound;', nil);
// TextToSpeech
  Sender.AddConstant('DEFAULTSPEECHSPEED', rsInteger)^.CV_SInt32 := DEFAULTSPEECHSPEED;
  RegisterDelphiFunction(Sender, 'procedure Speak(Text: string);', @Speak);
  RegisterDelphiFunction(Sender, 'procedure SpeakEx(Text: string; Speed: integer);', @SpeakEx);
  RegisterDelphiFunction(Sender, 'procedure SpeakStop;', @SpeakStop);
  RegisterDelphiFunction(Sender, 'procedure SpeakPause;', @SpeakPause);
  RegisterDelphiFunction(Sender, 'procedure SpeakResume;', @SpeakResume);
  RegisterDelphiFunction(Sender, 'procedure SpeakKill;', @SpeakKill);
  RegisterDelphiFunction(Sender, 'procedure SpeakPrepare;', @SpeakPrepare);
  RegisterDelphiFunction(Sender, 'procedure SpeakRewind;', @SpeakRewind);
  RegisterDelphiFunction(Sender, 'function IsSpeaking: boolean;', @IsSpeaking);
  RegisterDelphiFunction(Sender, 'procedure SpeakFastForward;', @SpeakFastForward);
end;

procedure _inc(var i: integer);
begin
  i := i + 1;
end;

procedure _dec(var i: integer);
begin
  i := i - 1;
end;

function _IntToHex(const Value: Integer; const Digits: Integer): string;
begin
  Result := IntToHex(Value, Digits);
end;

// ּופבפסןנ בסיטלן‎ ףו כבפיםיךן‎ע קבסבךפסוע
function _IntToRom(const Value: Integer): string;
const
  Nums : Array[1..13] of Integer =
    (1, 4, 5, 9, 10, 40, 50, 90, 100,
      400, 500, 900, 1000);
  RomanNums:  Array[1..13] of string =
    ('I', 'IV', 'V', 'IX', 'X', 'XL',
      'L', 'XC', 'C', 'CD', 'D', 'CM', 'M');
var
  Dec, i: Integer;
begin
  Result := '';
  Dec := Value;
  for i := 13 downto 1 do
    while (Dec >= Nums[i]) do
    begin
      Dec := Dec - Nums[i];
      Result  := Result + RomanNums[i];
    end;
end;

function IsDesigner: boolean;
begin
{$IFDEF DESIGNER}
  Result := True;
{$ELSE}
  Result := False;
{$ENDIF};
end;

procedure RegisterCPULibrary(Sender: TIfPasScript);
var
  cpuSpeed: TCPUFrequencyInfo;
begin
  if Sender <> nil then
  begin
    cpuSpeed := GetCPUSpeed;
    Sender.AddConstant('CPU_RawFrequency', rsCardinal)^.CV_UInt32 := cpuSpeed.RawFreq;
    Sender.AddConstant('CPU_NormFrequency', rsCardinal)^.CV_UInt32 := cpuSpeed.NormFreq;
    Sender.AddConstant('CPU_Frequency', rsCardinal)^.CV_UInt32 := cpuSpeed.NormFreq;
    Sender.AddConstant('CPU_InCycles', rsCardinal)^.CV_UInt32 := cpuSpeed.InCycles;
    Sender.AddConstant('CPU_ExTicks', rsCardinal)^.CV_UInt32 := cpuSpeed.ExTicks;
    Sender.AddConstant('CPU_Count', rsWord)^.CV_UInt16 := GetNumCPUs;
    Sender.AddConstant('CPU_TotalFrequency', rsCardinal)^.CV_UInt32 := GetNumCPUs * cpuSpeed.RawFreq;
  end;
end;

function _SelectDirectory(Caption: string; Root: String; var Directory: string): boolean;
begin
  Result := SelectDirectory(Caption, Root, Directory);
end;

function _GetDir(D: Byte): string;
var
  S: string;
begin
  GetDir(D, S);
  Result := S;
end;

procedure _ChDir(S: string);
begin
  ChDir(S);
end;

function _GetLastError: DWORD;
begin
  Result := GetLastError;
end;

procedure _SetLastError(dwErrCode: DWORD);
begin
  SetLastError(dwErrCode);
end;

function GetWin32Platform: integer;
begin
  Result := Win32Platform;
end;

function _WinExec(CmdLine: string; CmdShow: integer): LongWord;
begin
  Result := WinExec(PChar(CmdLine), UINT(CmdShow));
end;

function TDXImageProc(Sender: TIfPasScript; ScriptID: Pointer; proc: PProcedure; Params: PVariableManager; res: PIfVariant): TIfPasScriptError;
var
  Ctrl, Self: PIfVariant;
  bmp: TBitmap;
  s: string;
begin
  Self := Vm_Get(Params, 0);
  if (not GetClassVariable(Self, proc^.ClassType^.Ext, 'FCONTROL', Ctrl, True)) then
  begin
    TDXImageProc := ENotSupported; // internal error
    Exit;
  end;
  TDXImageProc := ENoError;
  if proc^.Name = '!SETPICTURE' then
  begin
    if Ctrl^.Cv_Int1 = nil then
    begin
      TDXImageProc := ENotSupported;
      Exit;
    end;
    s := GetString(Vm_Get(Params, 1));
{$IFNDEF NO_IDSOFTGAMESSUPPORT}
{$IFNDEF NO_DOOMSUPPORT}
    bmp := (Sender as TD3DSceneScriptEngine).Scene.GetIDWADTextureBmp(s);
    if not Assigned(bmp) then
{$ENDIF}
{$IFNDEF NO_QUAKESUPPORT}
      bmp := (Sender as TD3DSceneScriptEngine).Scene.GetIDPAKTextureBmp(s);
    if not Assigned(bmp) then
{$ENDIF}
{$ENDIF}
      bmp := (Sender as TD3DSceneScriptEngine).Scene.GetDLLTextureBmp(s);
    if not Assigned(bmp) then
      bmp := (Sender as TD3DSceneScriptEngine).Scene.GetTextureBmp(s);
    if Assigned(bmp) then
    begin
      TIFSImage(Ctrl^.Cv_Int1).FPictureFileName := s;
      TIFSImage(Ctrl^.Cv_Int1).Picture.Bitmap := bmp;
    end
    else
      TIFSImage(Ctrl^.Cv_Int1).SetPictureFileName(s);
  end
  else
    TDXImageProc := TImageProc(Sender, ScriptID, proc, params, res);
end;

procedure RegisterDXImage(p: TIfPasScript);
begin
  p.AddClass('TDXIMAGE', (p as TD3DSceneScriptEngine).Scene.GetScriptText('TDXImageClass') , @TDXImageProc);
end;

function _GetColorDialog(var c: Integer): boolean;
begin
  Result := False;
  with TColorDialog.Create(nil) do
  try
    Options := [];
    Color := c;
    if Execute then
    begin
      c := Color;
      Result := True;
    end;
  finally
    Free;
  end;
end;

function _GetColorDialogFullOpen(var c: Integer): boolean;
begin
  Result := False;
  with TColorDialog.Create(nil) do
  try
    Options := [cdFullOpen];
    Color := c;
    if Execute then
    begin
      c := Color;
      Result := True;
    end;
  finally
    Free;
  end;
end;

function _GetOpenFileDialog(aTitle, aFilter: string; var aFileName: string): boolean;
begin
  Result := False;
  with TOpenDialog.Create(nil) do
  try
    Title := aTitle;
    Filter := aFilter;
    FileName := aFileName;
    Options := [ofHideReadOnly, ofPathMustExist, ofFileMustExist, ofEnableSizing];
    if Execute then
    begin
      aFileName := FileName;
      Result := True;
    end;
  finally
    Free;
  end;
end;

function _GetSaveFileDialog(aTitle, aFilter: string; var aFileName: string): boolean;
begin
  Result := False;
  with TSaveDialog.Create(nil) do
  try
    Title := aTitle;
    Filter := aFilter;
    FileName := aFileName;
    Options := [ofOverwritePrompt, ofHideReadOnly, ofPathMustExist, ofEnableSizing];
    if Execute then
    begin
      aFileName := FileName;
      Result := True;
    end;
  finally
    Free;
  end;
end;

function OnUsesProc(id: Pointer; Sender: TIfPasScript; Name: string): TCs2Error;

  function AddUnit(const uName: string): TCs2Error;
  var
    f: TD3DSceneScriptEngine;
    s: string;
  begin
    F := TD3DSceneScriptEngine.Create(nil, (Sender as TD3DSceneScriptEngine).Scene);
    s := (Sender as TD3DSceneScriptEngine).Scene.GetScriptText(uName);
    if s <> EmptyStr then
    begin
      f.OnUses := OnUsesProc;
      f.SetText(s);
    end
    else
    begin
      s := (Sender as TD3DSceneScriptEngine).Scene.GetScriptPData(uName);
      if s <> EmptyStr then
      begin
        f.OnUses := OnUsesProc;
        f.SetPData(s);
      end
      else
      begin
        Result := EUnitNotFound;
        Exit;
      end;
    end;
    if f.ErrorCode <> ENoError then
    begin
      Sender.RunError2(f, f.ErrorCode, f.ErrorString);
      f.Free;
      Result := EUnitNotFound;
    end
    else
    begin
      if not Sender.Attach(F) then
      begin
        f.Free;
        Result := ECustomError;
      end
      else
        Result := ENoError;
    end;
  end;

var
  i: integer;
begin
  if Name = 'SYSTEM' then
  begin
    RegisterStdLib(Sender, False);
    RegisterTIfStringList(Sender);
    RegisterComLibrary(Sender);
    RegisterTransLibrary(Sender);
    RegisterDllCallLibrary(Sender);
    RegisterExceptionLib(Sender);
    RegisterDll2library(Sender);
    RegisterDateTimeLib(Sender);

    RegisterDelphiFunction(Sender, 'function IntToHex(Value: Integer; Digits: Integer): string;', @_IntToHex);
    RegisterDelphiFunction(Sender, 'function IntToRom(Value: Integer): string;', @_IntToRom);

    Sender.AddVariable('ENoError', rsInteger, True)^.Cv_SInt32 := 0;
    Sender.AddVariable('ECanNotReadProperty', rsInteger, True)^.Cv_SInt32 := 1;
    Sender.AddVariable('ECanNotWriteProperty', rsInteger, True)^.Cv_SInt32 := 2;
    Sender.AddVariable('EUnknownIdentifier', rsInteger, True)^.Cv_SInt32 := 3;
    Sender.AddVariable('EIdentifierExpected', rsInteger, True)^.Cv_SInt32 := 4;
    Sender.AddVariable('ESemicolonExpected', rsInteger, True)^.Cv_SInt32 := 5;
    Sender.AddVariable('EBeginExpected', rsInteger, True)^.Cv_SInt32 := 6;
    Sender.AddVariable('EDuplicateIdentifier', rsInteger, True)^.Cv_SInt32 := 7;
    Sender.AddVariable('EUnexpectedEndOfFile', rsInteger, True)^.Cv_SInt32 := 8;
    Sender.AddVariable('EColonExpected', rsInteger, True)^.Cv_SInt32 := 9;
    Sender.AddVariable('ESyntaxError', rsInteger, True)^.Cv_SInt32 := 10;
    Sender.AddVariable('EStringError', rsInteger, True)^.Cv_SInt32 := 11;
    Sender.AddVariable('EErrorInStatement', rsInteger, True)^.Cv_SInt32 := 12;
    Sender.AddVariable('EAssignmentExpected', rsInteger, True)^.Cv_SInt32 := 13;
    Sender.AddVariable('ETypeMismatch', rsInteger, True)^.Cv_SInt32 := 14;
    Sender.AddVariable('EErrorInExpression', rsInteger, True)^.Cv_SInt32 := 15;
    Sender.AddVariable('ERoundOpenExpected', rsInteger, True)^.Cv_SInt32 := 16;
    Sender.AddVariable('ERoundCloseExpected', rsInteger, True)^.Cv_SInt32 := 17;
    Sender.AddVariable('EVariableExpected', rsInteger, True)^.Cv_SInt32 := 18;
    Sender.AddVariable('ECommaExpected', rsInteger, True)^.Cv_SInt32 := 19;
    Sender.AddVariable('EThenExpected', rsInteger, True)^.Cv_SInt32 := 20;
    Sender.AddVariable('EPeriodExpected', rsInteger, True)^.Cv_SInt32 := 21;
    Sender.AddVariable('EParameterError', rsInteger, True)^.Cv_SInt32 := 22;
    Sender.AddVariable('EToExpected', rsInteger, True)^.Cv_SInt32 := 23;
    Sender.AddVariable('EDoExpected', rsInteger, True)^.Cv_SInt32 := 24;
    Sender.AddVariable('EOfExpected', rsInteger, True)^.Cv_SInt32 := 25;
    Sender.AddVariable('EEndExpected', rsInteger, True)^.Cv_SInt32 := 26;
    Sender.AddVariable('EOpenBlockExpected', rsInteger, True)^.Cv_SInt32 := 27;
    Sender.AddVariable('ECloseBlockExpected', rsInteger, True)^.Cv_SInt32 := 28;
    Sender.AddVariable('EConstantExpected', rsInteger, True)^.Cv_SInt32 := 29;
    Sender.AddVariable('EIsExpected', rsInteger, True)^.Cv_SInt32 := 30;
    Sender.AddVariable('EIntegerExpected', rsInteger, True)^.Cv_SInt32 := 31;
    Sender.AddVariable('ECloseRoundExpected', rsInteger, True)^.Cv_SInt32 := 32;
    Sender.AddVariable('EUntilExpected', rsInteger, True)^.Cv_SInt32 := 33;
    Sender.AddVariable('EClassNotAllowedHere', rsInteger, True)^.Cv_SInt32 := 34;
    Sender.AddVariable('EClassTypeExpected', rsInteger, True)^.Cv_SInt32 := 35;
    Sender.AddVariable('ECanNotOverride', rsInteger, True)^.Cv_SInt32 := 36;
    Sender.AddVariable('EConstructorExpected', rsInteger, True)^.Cv_SInt32 := 38;
    Sender.AddVariable('ENoInheritedAllowedHere', rsInteger, True)^.Cv_SInt32 := 39;
    Sender.AddVariable('ECanNotReadOrWriteProperty', rsInteger, True)^.Cv_SInt32 := 40;
    Sender.AddVariable('EObjectExpected', rsInteger, True)^.Cv_SInt32 := 41;
    Sender.AddVariable('EUnsatisfiedForward', rsInteger, True)^.Cv_SInt32 := 37;
    Sender.AddVariable('ECommentError', rsInteger, True)^.Cv_SInt32 := 42;
    Sender.AddVariable('ECharError', rsInteger, True)^.Cv_SInt32 := 43;
    Sender.AddVariable('EExceptExpected', rsInteger, True)^.Cv_SInt32 := 44;
    Sender.AddVariable('EStringExpected', rsInteger, True)^.Cv_SInt32 := 45;
    Sender.AddVariable('ETimesExpected', rsInteger, True)^.Cv_SInt32 := 46;

    Sender.AddVariable('ERuntimeError', rsInteger, True)^.Cv_SInt32 := 32768;
    Sender.AddVariable('EUnitNotFound', rsInteger, True)^.Cv_SInt32 := ERuntimeError + 0;
    Sender.AddVariable('EClassNotCreated', rsInteger, True)^.Cv_SInt32 := ERuntimeError + 1;
    Sender.AddVariable('EOutOfRange', rsInteger, True)^.Cv_SInt32 := ERuntimeError + 2;
    Sender.AddVariable('EDivideByZero', rsInteger, True)^.Cv_SInt32 := ERuntimeError + 3;
    Sender.AddVariable('ENotSupported', rsInteger, True)^.Cv_SInt32 := ERuntimeError + 4;
    Sender.AddVariable('EExitCommand', rsInteger, True)^.Cv_SInt32 := ERuntimeError + 5;
    Sender.AddVariable('EClassAlreadyFreed', rsInteger, True)^.Cv_SInt32 := ERuntimeError + 6;
    Sender.AddVariable('EClassReferenceNotAssigned', rsInteger, True)^.Cv_SInt32 := ERuntimeError + 7;
    Sender.AddVariable('EVariantIsNil', rsInteger, True)^.Cv_SInt32 := ERuntimeError + 8;
    Sender.AddVariable('ECustomError', rsInteger, True)^.Cv_SInt32 := ERuntimeError + 9;
    Sender.AddVariable('EOutOfMemoryError', rsInteger, True)^.Cv_SInt32 := ERuntimeError + 10;
    Sender.AddVariable('ERealExpressionExpected', rsInteger, True)^.Cv_SInt32 := ERuntimeError + 11;
    Sender.AddVariable('EElement0Inaccesible', rsInteger, True)^.Cv_SInt32 := ERuntimeError + 12;

    Sender.AddVariable('ID3D_EVENTNONE', rsInteger, True)^.Cv_SInt32 := 0;
    Sender.AddVariable('ID3D_EVENTMAIN', rsInteger, True)^.Cv_SInt32 := 1;
    Sender.AddVariable('ID3D_EVENTONCREATE', rsInteger, True)^.Cv_SInt32 := 2;
    Sender.AddVariable('ID3D_EVENTONEXIT', rsInteger, True)^.Cv_SInt32 := 3;
    Sender.AddVariable('ID3D_EVENTONBEFOREDRAW', rsInteger, True)^.Cv_SInt32 := 4;
    Sender.AddVariable('ID3D_EVENTONAFTERDRAW', rsInteger, True)^.Cv_SInt32 := 5;
    Sender.AddVariable('ID3D_EVENTONBEFOREBEGINSCENE', rsInteger, True)^.Cv_SInt32 := 6;
    Sender.AddVariable('ID3D_EVENTONAFTERENDSCENE', rsInteger, True)^.Cv_SInt32 := 7;
    Sender.AddVariable('ID3D_EVENTONPOSITIONCHANGE', rsInteger, True)^.Cv_SInt32 := 8;
    Sender.AddVariable('ID3D_EVENTONROTATIONCHANGE', rsInteger, True)^.Cv_SInt32 := 9;

    Sender.AddFunction(@StdInOutRegProc, 'procedure Writeln(s: string)', nil);
    Sender.AddFunction(@StdInOutRegProc, 'procedure Write(s: string)', nil);
    Sender.AddFunction(@StdInOutRegProc, 'procedure Readln(var s: string)', nil);
    Sender.AddFunction(@StdInOutRegProc, 'procedure Read(var s: string)', nil);

    Sender.AddFunction(@StdRegProc, 'procedure Sleep(I: Longint)', nil);
{$IFNDEF NO_MESSAGESCAN}
    Sender.AddFunction(@StdRegProc, 'procedure MessageScan', nil);
{$ENDIF}    
    Sender.AddFunction(@StdRegProc, 'function ScreenWidth: integer', nil);
    Sender.AddFunction(@StdRegProc, 'function ScreenHeight: integer', nil);

    Sender.AddFunction(@StdHaltProgramRegProc, 'function CloseQuery: boolean', nil);
    Sender.AddFunction(@StdHaltProgramRegProc, 'procedure Halt(ExitCode: integer)', nil);
    Sender.AddFunction(@StdHaltProgramRegProc, 'procedure Halt0', nil);
    Sender.AddFunction(@StdHaltProgramRegProc, 'procedure Terminate', nil);

    Sender.AddFunction(@StdRegProc, 'function Random(I: Longint): Longint', nil);
    Sender.AddFunction(@StdRegProc, 'procedure RunProcedure(procName: string)', nil);
    Sender.AddFunction(@StdRegProc, 'procedure RunUnit(unitName: string)', nil);

    Sender.AddFunction(@StdVersionRegProc, 'function Version: string', nil);
    Sender.AddFunction(@StdVersionRegProc, 'function LongVersion: string', nil);
    
    Sender.AddFunction(@FutureProcsRegProc, 'procedure AddFutureProc(procName: string; EventID: integer; TimeDelta: Double)', nil);
    Sender.AddFunction(@FutureProcsRegProc, 'function GetNumFutureProcs(EventID: integer): integer', nil);
    Sender.AddFunction(@FutureProcsRegProc, 'procedure DeleteFutureProcs(EventID: integer)', nil);

    RegisterDelphiFunction(Sender, 'function RandG(Mean, StdDev: Extended): Extended;', @RandG);
    RegisterDelphiFunction(Sender, 'procedure Randomize;', @Randomize);
    RegisterDelphiFunction(Sender, 'function IsDesigner: boolean;', @IsDesigner);
    RegisterDelphiFunction(Sender, 'procedure Beep;', @Beep);
    RegisterDelphiFunction(Sender, 'function ParamStr(Index: Integer): string;', @ParamStr);
    RegisterDelphiFunction(Sender, 'function ParamCount: Integer;', @ParamCount);

    Sender.AddVariable('MaxWord', rsWord, True)^.CV_UInt16 := $FFFF;
    Sender.AddVariable('MaxSmallInt', rsInteger, True)^.CV_SInt32 := 32767;
    Sender.AddVariable('MinSmallInt', rsInteger, True)^.CV_SInt32 := -32768;
    Sender.AddVariable('MaxInt', rsInteger, True)^.CV_SInt32 := MaxInt;
    Sender.AddVariable('MinInt', rsInteger, True)^.CV_SInt32 := -2147483647;
    Sender.AddVariable('MaxLongInt', rsInteger, True)^.CV_SInt32 := MaxLongInt;
    Sender.AddVariable('MinLongInt', rsInteger, True)^.CV_SInt32 := -2147483647;
    Sender.AddConstant('MinSingle', rsSingle)^.CV_Single := MinSingle;
    Sender.AddConstant('MaxSingle', rsSingle)^.CV_Single := MaxSingle;
    Sender.AddConstant('MinDouble', rsDouble)^.CV_Double := MinDouble;
    Sender.AddConstant('MaxDouble', rsDOuble)^.CV_Double := MaxDouble;
    Sender.AddConstant('MinExtended', rsExtended)^.CV_Extended := MinExtended;
    Sender.AddConstant('MaxExtended', rsExtended)^.CV_Extended := MaxExtended;
    Sender.AddConstant('MinComp', rsComp)^.CV_Comp := MinComp;
    Sender.AddConstant('MaxComp', rsComp)^.CV_Comp := MaxComp;

    RegisterDelphiFunction(Sender, 'function DirectoryExists(Name: string): boolean;', @DirectoryExists);
    RegisterDelphiFunction(Sender, 'function ForceDirectories(Dir: string): boolean;', @ForceDirectories);
    RegisterDelphiFunction(Sender, 'procedure ChDir(S: string);', @_ChDir);
    RegisterDelphiFunction(Sender, 'function CreateDir(Dir: string): boolean;', @CreateDir);
    RegisterDelphiFunction(Sender, 'function DeleteFile(FileName: string): boolean;', @DeleteFile);
    RegisterDelphiFunction(Sender, 'function DirectoryExists(Name: string): boolean;', @DirectoryExists);
    RegisterDelphiFunction(Sender, 'function FileExists(FileName: string): boolean;', @FileExists);
    RegisterDelphiFunction(Sender, 'function GetCurrentDir: string;', @GetCurrentDir);
    RegisterDelphiFunction(Sender, 'function GetDir(D: Byte): string;', @_GetDir);
    RegisterDelphiFunction(Sender, 'function RemoveDir(Dir: string): boolean;', @RemoveDir);
    RegisterDelphiFunction(Sender, 'function RenameFile(OldName, NewName: string): boolean;', @RenameFile);
    RegisterDelphiFunction(Sender, 'function SetCurrentDir(Dir: string): boolean;', @SetCurrentDir);

    Sender.AddType('Pointer', rsInteger);
    Sender.AddVariable('Null', rsInteger, True)^.Cv_SInt32 := 0;
    Sender.AddFunction(@MemManagerRegProc, 'procedure New(var p: Pointer)', nil);
    Sender.AddFunction(@MemManagerRegProc, 'procedure Dispose(var p: Pointer)', nil);
    Sender.AddFunction(@MemManagerRegProc, 'function Addr(v: Variant): Pointer', nil);
    Sender.AddFunction(@MemManagerRegProc, 'function DeRef(p: Pointer): Variant', nil);
    Sender.AddFunction(@MemManagerRegProc2, 'procedure NewP(var p: Pointer)', nil);
    Sender.AddFunction(@MemManagerRegProc2, 'procedure DisposeP(var p: Pointer)', nil);
    Sender.AddFunction(@MemManagerGetRegProc2, 'function GetInteger(p: Pointer): integer', nil);
    Sender.AddFunction(@MemManagerGetRegProc2, 'function GetReal(p: Pointer): extended', nil);
    Sender.AddFunction(@MemManagerGetRegProc2, 'function GetBoolean(p: Pointer): boolean', nil);
    Sender.AddFunction(@MemManagerGetRegProc2, 'function GetString(p: Pointer): string', nil);
    Sender.AddFunction(@MemManagerSetRegProc2, 'procedure SetInteger(p: Pointer; i: integer)', nil);
    Sender.AddFunction(@MemManagerSetRegProc2, 'procedure SetReal(p: Pointer; e: extended)', nil);
    Sender.AddFunction(@MemManagerSetRegProc2, 'procedure SetBoolean(p: Pointer; b: boolean)', nil);
    Sender.AddFunction(@MemManagerSetRegProc2, 'procedure SetString(p: Pointer; s: string)', nil);

    Sender.AddFunction(@ScriptStartStopRegProc, 'function IsScriptStarting: boolean', nil);
    Sender.AddFunction(@ScriptStartStopRegProc, 'function IsScriptFinishing: boolean', nil);

    Sender.AddFunction(@SysUtilsRegProc, 'function GetExistedFileName(fName: string): string;', nil);

    Sender.AddFunction(@StrCaseRegProc, 'function LowerCase(s: string): string', nil);
    Sender.AddFunction(@StrCaseRegProc, 'function Uppercase(s: string): string', nil);

    RegisterDelphiFunction(Sender, 'function FirstWord(S: string): string;', @_FirstWord);
    RegisterDelphiFunction(Sender, 'procedure RemoveFirstWord(var s: string);', @_RemoveFirstWord);

    RegisterDelphiFunction(Sender, 'function StrToRealDef(S: string; Def: Extended): Extended;', @StrToRealDef);
    RegisterDelphiFunction(Sender, 'function StrToFloatDef(S: string; Def: Extended): Extended;', @StrToRealDef);
    RegisterDelphiFunction(Sender, 'function StrToIntDef(S: string; Def: LongInt): LongInt;', @StrToIntDef);

    Sender.AddConstant('NL', rsString)^.CV_Str := NL;

    Result := ENoError;
  end
  else if Name = 'CPU' then
  begin
    RegisterCPULibrary(Sender);
    Result := ENoError;
  end
  else if Name = 'WINDOWS' then
  begin
    AddUnit(Name);

    Sender.AddFunction(@WindowsRegProc, 'function HInstance: integer;', nil);
    Sender.AddFunction(@WindowsRegProc, 'function Handle: integer;', nil);

    RegisterDelphiFunction(Sender, 'function GetFocus: integer;', @GetFocus);
    RegisterDelphiFunction(Sender, 'function SetFocus(HWND: integer): integer;', @SetFocus);

    RegisterDelphiFunction(Sender, 'function MessageBeep(mType: integer): boolean', @_MessageBeep);

    RegisterDelphiFunction(Sender, 'function CMYK(c, m, y, k: Byte): integer;', @CMYK);
    RegisterDelphiFunction(Sender, 'function GetKValue(cmyk: integer): Byte;', @GetKValue);
    RegisterDelphiFunction(Sender, 'function GetYValue(cmyk: integer): Byte;', @GetYValue);
    RegisterDelphiFunction(Sender, 'function GetMValue(cmyk: integer): Byte;', @GetMValue);
    RegisterDelphiFunction(Sender, 'function GetCValue(cmyk: integer): Byte;', @GetCValue);
    RegisterDelphiFunction(Sender, 'function RGB(r, g, b: byte): integer;', @RGB);
    RegisterDelphiFunction(Sender, 'function GetRValue(c: integer): Byte;', @GetRValue);
    RegisterDelphiFunction(Sender, 'function GetGValue(c: integer): Byte;', @GetGValue);
    RegisterDelphiFunction(Sender, 'function GetBValue(c: integer): Byte;', @GetBValue);
    Sender.AddVariable('clBlack', rsInteger, True)^.Cv_SInt32 := $000000;
    Sender.AddVariable('clMaroon', rsInteger, True)^.Cv_SInt32 := $000080;
    Sender.AddVariable('clGreen', rsInteger, True)^.Cv_SInt32 := $008000;
    Sender.AddVariable('clOlive', rsInteger, True)^.Cv_SInt32 := $008080;
    Sender.AddVariable('clNavy', rsInteger, True)^.Cv_SInt32 := $800000;
    Sender.AddVariable('clPurple', rsInteger, True)^.Cv_SInt32 := $800080;
    Sender.AddVariable('clTeal', rsInteger, True)^.Cv_SInt32 := $808000;
    Sender.AddVariable('clGray', rsInteger, True)^.Cv_SInt32 := $808080;
    Sender.AddVariable('clSilver', rsInteger, True)^.Cv_SInt32 := $C0C0C0;
    Sender.AddVariable('clRed', rsInteger, True)^.Cv_SInt32 := $0000FF;
    Sender.AddVariable('clLime', rsInteger, True)^.Cv_SInt32 := $00FF00;
    Sender.AddVariable('clYellow', rsInteger, True)^.Cv_SInt32 := $00FFFF;
    Sender.AddVariable('clBlue', rsInteger, True)^.Cv_SInt32 := $FF0000;
    Sender.AddVariable('clFuchsia', rsInteger, True)^.Cv_SInt32 := $FF00FF;
    Sender.AddVariable('clAqua', rsInteger, True)^.Cv_SInt32 := $FFFF00;
    Sender.AddVariable('clLtGray', rsInteger, True)^.Cv_SInt32 := $C0C0C0;
    Sender.AddVariable('clDkGray', rsInteger, True)^.Cv_SInt32 := $808080;
    Sender.AddVariable('clWhite', rsInteger, True)^.Cv_SInt32 := $FFFFFF;

    Sender.AddFunction(@WindowsColorsRegProc, 'function clScrollBar: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clBackground: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clActiveCaption: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clInactiveCaption: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clMenu: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clWindow: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clWindowFrame: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clMenuText: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clWindowText: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clCaptionText: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clActiveBorder: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clInactiveBorder: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clAppWorkSpace: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clHighlight: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clHighlightText: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clBtnFace: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clBtnShadow: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clGrayText: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clBtnText: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clInactiveCaptionText: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clBtnHighlight: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function cl3DDkShadow: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function cl3DLight: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clInfoText: integer', nil);
    Sender.AddFunction(@WindowsColorsRegProc, 'function clInfoBk: integer', nil);
                                  
// Keyboard input
    Sender.AddFunction(@WindowsRegProc, 'function IsKeyDown(Code: integer): boolean;', nil);
    Sender.AddFunction(@WindowsRegProc, 'function IsKeyToggled(Code: integer): boolean;', nil);
    Sender.AddVariable('VK_LBUTTON', rsInteger, True)^.Cv_SInt32 :=  1;
    Sender.AddVariable('VK_RBUTTON', rsInteger, True)^.Cv_SInt32 :=  2;
    Sender.AddVariable('VK_CANCEL', rsInteger, True)^.Cv_SInt32 :=  3;
    Sender.AddVariable('VK_MBUTTON', rsInteger, True)^.Cv_SInt32 :=  4;
    Sender.AddVariable('VK_BACK', rsInteger, True)^.Cv_SInt32 :=  8;
    Sender.AddVariable('VK_TAB', rsInteger, True)^.Cv_SInt32 :=  9;
    Sender.AddVariable('VK_CLEAR', rsInteger, True)^.Cv_SInt32 :=  12;
    Sender.AddVariable('VK_RETURN', rsInteger, True)^.Cv_SInt32 :=  13;
    Sender.AddVariable('VK_SHIFT', rsInteger, True)^.Cv_SInt32 :=  $10;
    Sender.AddVariable('VK_CONTROL', rsInteger, True)^.Cv_SInt32 :=  17;
    Sender.AddVariable('VK_MENU', rsInteger, True)^.Cv_SInt32 :=  18;
    Sender.AddVariable('VK_PAUSE', rsInteger, True)^.Cv_SInt32 :=  19;
    Sender.AddVariable('VK_CAPITAL', rsInteger, True)^.Cv_SInt32 :=  20;
    Sender.AddVariable('VK_KANA', rsInteger, True)^.Cv_SInt32 :=  21;
    Sender.AddVariable('VK_HANGUL', rsInteger, True)^.Cv_SInt32 :=  21;
    Sender.AddVariable('VK_JUNJA', rsInteger, True)^.Cv_SInt32 :=  23;
    Sender.AddVariable('VK_FINAL', rsInteger, True)^.Cv_SInt32 :=  24;
    Sender.AddVariable('VK_HANJA', rsInteger, True)^.Cv_SInt32 :=  25;
    Sender.AddVariable('VK_KANJI', rsInteger, True)^.Cv_SInt32 :=  25;
    Sender.AddVariable('VK_CONVERT', rsInteger, True)^.Cv_SInt32 :=  28;
    Sender.AddVariable('VK_NONCONVERT', rsInteger, True)^.Cv_SInt32 :=  29;
    Sender.AddVariable('VK_ACCEPT', rsInteger, True)^.Cv_SInt32 :=  30;
    Sender.AddVariable('VK_MODECHANGE', rsInteger, True)^.Cv_SInt32 :=  31;
    Sender.AddVariable('VK_ESCAPE', rsInteger, True)^.Cv_SInt32 :=  27;
    Sender.AddVariable('VK_SPACE', rsInteger, True)^.Cv_SInt32 :=  $20;
    Sender.AddVariable('VK_PRIOR', rsInteger, True)^.Cv_SInt32 :=  33;
    Sender.AddVariable('VK_NEXT', rsInteger, True)^.Cv_SInt32 :=  34;
    Sender.AddVariable('VK_END', rsInteger, True)^.Cv_SInt32 :=  35;
    Sender.AddVariable('VK_HOME', rsInteger, True)^.Cv_SInt32 :=  36;
    Sender.AddVariable('VK_LEFT', rsInteger, True)^.Cv_SInt32 :=  37;
    Sender.AddVariable('VK_UP', rsInteger, True)^.Cv_SInt32 :=  38;
    Sender.AddVariable('VK_RIGHT', rsInteger, True)^.Cv_SInt32 :=  39;
    Sender.AddVariable('VK_DOWN', rsInteger, True)^.Cv_SInt32 :=  40;
    Sender.AddVariable('VK_SELECT', rsInteger, True)^.Cv_SInt32 :=  41;
    Sender.AddVariable('VK_PRINT', rsInteger, True)^.Cv_SInt32 :=  42;
    Sender.AddVariable('VK_EXECUTE', rsInteger, True)^.Cv_SInt32 :=  43;
    Sender.AddVariable('VK_SNAPSHOT', rsInteger, True)^.Cv_SInt32 :=  44;
    Sender.AddVariable('VK_INSERT', rsInteger, True)^.Cv_SInt32 :=  45;
    Sender.AddVariable('VK_DELETE', rsInteger, True)^.Cv_SInt32 :=  46;
    Sender.AddVariable('VK_HELP', rsInteger, True)^.Cv_SInt32 :=  47;
    Sender.AddVariable('VK_0', rsInteger, True)^.Cv_SInt32 :=  $30;
    Sender.AddVariable('VK_1', rsInteger, True)^.Cv_SInt32 :=  $31;
    Sender.AddVariable('VK_2', rsInteger, True)^.Cv_SInt32 :=  $32;
    Sender.AddVariable('VK_3', rsInteger, True)^.Cv_SInt32 :=  $33;
    Sender.AddVariable('VK_4', rsInteger, True)^.Cv_SInt32 :=  $34;
    Sender.AddVariable('VK_5', rsInteger, True)^.Cv_SInt32 :=  $35;
    Sender.AddVariable('VK_6', rsInteger, True)^.Cv_SInt32 :=  $36;
    Sender.AddVariable('VK_7', rsInteger, True)^.Cv_SInt32 :=  $37;
    Sender.AddVariable('VK_8', rsInteger, True)^.Cv_SInt32 :=  $38;
    Sender.AddVariable('VK_9', rsInteger, True)^.Cv_SInt32 :=  $39;
    Sender.AddVariable('VK_A', rsInteger, True)^.Cv_SInt32 :=  $41;
    Sender.AddVariable('VK_B', rsInteger, True)^.Cv_SInt32 :=  $42;
    Sender.AddVariable('VK_C', rsInteger, True)^.Cv_SInt32 :=  $43;
    Sender.AddVariable('VK_D', rsInteger, True)^.Cv_SInt32 :=  $44;
    Sender.AddVariable('VK_E', rsInteger, True)^.Cv_SInt32 :=  $45;
    Sender.AddVariable('VK_F', rsInteger, True)^.Cv_SInt32 :=  $46;
    Sender.AddVariable('VK_G', rsInteger, True)^.Cv_SInt32 :=  $47;
    Sender.AddVariable('VK_H', rsInteger, True)^.Cv_SInt32 :=  $48;
    Sender.AddVariable('VK_I', rsInteger, True)^.Cv_SInt32 :=  $49;
    Sender.AddVariable('VK_J', rsInteger, True)^.Cv_SInt32 :=  $4A;
    Sender.AddVariable('VK_K', rsInteger, True)^.Cv_SInt32 :=  $4B;
    Sender.AddVariable('VK_L', rsInteger, True)^.Cv_SInt32 :=  $4C;
    Sender.AddVariable('VK_M', rsInteger, True)^.Cv_SInt32 :=  $4D;
    Sender.AddVariable('VK_N', rsInteger, True)^.Cv_SInt32 :=  $4E;
    Sender.AddVariable('VK_O', rsInteger, True)^.Cv_SInt32 :=  $4F;
    Sender.AddVariable('VK_P', rsInteger, True)^.Cv_SInt32 :=  $50;
    Sender.AddVariable('VK_Q', rsInteger, True)^.Cv_SInt32 :=  $51;
    Sender.AddVariable('VK_R', rsInteger, True)^.Cv_SInt32 :=  $52;
    Sender.AddVariable('VK_S', rsInteger, True)^.Cv_SInt32 :=  $53;
    Sender.AddVariable('VK_T', rsInteger, True)^.Cv_SInt32 :=  $54;
    Sender.AddVariable('VK_U', rsInteger, True)^.Cv_SInt32 :=  $55;
    Sender.AddVariable('VK_V', rsInteger, True)^.Cv_SInt32 :=  $56;
    Sender.AddVariable('VK_W', rsInteger, True)^.Cv_SInt32 :=  $57;
    Sender.AddVariable('VK_X', rsInteger, True)^.Cv_SInt32 :=  $58;
    Sender.AddVariable('VK_Y', rsInteger, True)^.Cv_SInt32 :=  $59;
    Sender.AddVariable('VK_Z', rsInteger, True)^.Cv_SInt32 :=  $5A;
    Sender.AddVariable('VK_LWIN', rsInteger, True)^.Cv_SInt32 :=  91;
    Sender.AddVariable('VK_RWIN', rsInteger, True)^.Cv_SInt32 :=  92;
    Sender.AddVariable('VK_APPS', rsInteger, True)^.Cv_SInt32 :=  93;
    Sender.AddVariable('VK_NUMPAD0', rsInteger, True)^.Cv_SInt32 :=  96;
    Sender.AddVariable('VK_NUMPAD1', rsInteger, True)^.Cv_SInt32 :=  97;
    Sender.AddVariable('VK_NUMPAD2', rsInteger, True)^.Cv_SInt32 :=  98;
    Sender.AddVariable('VK_NUMPAD3', rsInteger, True)^.Cv_SInt32 :=  99;
    Sender.AddVariable('VK_NUMPAD4', rsInteger, True)^.Cv_SInt32 :=  100;
    Sender.AddVariable('VK_NUMPAD5', rsInteger, True)^.Cv_SInt32 :=  101;
    Sender.AddVariable('VK_NUMPAD6', rsInteger, True)^.Cv_SInt32 :=  102;
    Sender.AddVariable('VK_NUMPAD7', rsInteger, True)^.Cv_SInt32 :=  103;
    Sender.AddVariable('VK_NUMPAD8', rsInteger, True)^.Cv_SInt32 :=  104;
    Sender.AddVariable('VK_NUMPAD9', rsInteger, True)^.Cv_SInt32 :=  105;
    Sender.AddVariable('VK_MULTIPLY', rsInteger, True)^.Cv_SInt32 :=  106;
    Sender.AddVariable('VK_ADD', rsInteger, True)^.Cv_SInt32 :=  107;
    Sender.AddVariable('VK_SEPARATOR', rsInteger, True)^.Cv_SInt32 :=  108;
    Sender.AddVariable('VK_SUBTRACT', rsInteger, True)^.Cv_SInt32 :=  109;
    Sender.AddVariable('VK_DECIMAL', rsInteger, True)^.Cv_SInt32 :=  110;
    Sender.AddVariable('VK_DIVIDE', rsInteger, True)^.Cv_SInt32 :=  111;
    Sender.AddVariable('VK_F1', rsInteger, True)^.Cv_SInt32 :=  112;
    Sender.AddVariable('VK_F2', rsInteger, True)^.Cv_SInt32 :=  113;
    Sender.AddVariable('VK_F3', rsInteger, True)^.Cv_SInt32 :=  114;
    Sender.AddVariable('VK_F4', rsInteger, True)^.Cv_SInt32 :=  115;
    Sender.AddVariable('VK_F5', rsInteger, True)^.Cv_SInt32 :=  116;
    Sender.AddVariable('VK_F6', rsInteger, True)^.Cv_SInt32 :=  117;
    Sender.AddVariable('VK_F7', rsInteger, True)^.Cv_SInt32 :=  118;
    Sender.AddVariable('VK_F8', rsInteger, True)^.Cv_SInt32 :=  119;
    Sender.AddVariable('VK_F9', rsInteger, True)^.Cv_SInt32 :=  120;
    Sender.AddVariable('VK_F10', rsInteger, True)^.Cv_SInt32 :=  121;
    Sender.AddVariable('VK_F11', rsInteger, True)^.Cv_SInt32 :=  122;
    Sender.AddVariable('VK_F12', rsInteger, True)^.Cv_SInt32 :=  123;
    Sender.AddVariable('VK_F13', rsInteger, True)^.Cv_SInt32 :=  124;
    Sender.AddVariable('VK_F14', rsInteger, True)^.Cv_SInt32 :=  125;
    Sender.AddVariable('VK_F15', rsInteger, True)^.Cv_SInt32 :=  126;
    Sender.AddVariable('VK_F16', rsInteger, True)^.Cv_SInt32 :=  127;
    Sender.AddVariable('VK_F17', rsInteger, True)^.Cv_SInt32 :=  128;
    Sender.AddVariable('VK_F18', rsInteger, True)^.Cv_SInt32 :=  129;
    Sender.AddVariable('VK_F19', rsInteger, True)^.Cv_SInt32 :=  130;
    Sender.AddVariable('VK_F20', rsInteger, True)^.Cv_SInt32 :=  131;
    Sender.AddVariable('VK_F21', rsInteger, True)^.Cv_SInt32 :=  132;
    Sender.AddVariable('VK_F22', rsInteger, True)^.Cv_SInt32 :=  133;
    Sender.AddVariable('VK_F23', rsInteger, True)^.Cv_SInt32 :=  134;
    Sender.AddVariable('VK_F24', rsInteger, True)^.Cv_SInt32 :=  135;
    Sender.AddVariable('VK_NUMLOCK', rsInteger, True)^.Cv_SInt32 :=  144;
    Sender.AddVariable('VK_SCROLL', rsInteger, True)^.Cv_SInt32 :=  145;
    Sender.AddVariable('VK_LSHIFT', rsInteger, True)^.Cv_SInt32 :=  160;
    Sender.AddVariable('VK_RSHIFT', rsInteger, True)^.Cv_SInt32 :=  161;
    Sender.AddVariable('VK_LCONTROL', rsInteger, True)^.Cv_SInt32 :=  162;
    Sender.AddVariable('VK_RCONTROL', rsInteger, True)^.Cv_SInt32 :=  163;
    Sender.AddVariable('VK_LMENU', rsInteger, True)^.Cv_SInt32 :=  164;
    Sender.AddVariable('VK_RMENU', rsInteger, True)^.Cv_SInt32 :=  165;
    Sender.AddVariable('VK_PROCESSKEY', rsInteger, True)^.Cv_SInt32 :=  229;
    Sender.AddVariable('VK_ATTN', rsInteger, True)^.Cv_SInt32 :=  246;
    Sender.AddVariable('VK_CRSEL', rsInteger, True)^.Cv_SInt32 :=  247;
    Sender.AddVariable('VK_EXSEL', rsInteger, True)^.Cv_SInt32 :=  248;
    Sender.AddVariable('VK_EREOF', rsInteger, True)^.Cv_SInt32 :=  249;
    Sender.AddVariable('VK_PLAY', rsInteger, True)^.Cv_SInt32 :=  250;
    Sender.AddVariable('VK_ZOOM', rsInteger, True)^.Cv_SInt32 :=  251;
    Sender.AddVariable('VK_NONAME', rsInteger, True)^.Cv_SInt32 :=  252;
    Sender.AddVariable('VK_PA1', rsInteger, True)^.Cv_SInt32 :=  253;
    Sender.AddVariable('VK_OEM_CLEAR', rsInteger, True)^.Cv_SInt32 :=  254;

//MessageBox
    Sender.AddFunction(@WindowsRegProc, 'function MessageBox(Wnd: Integer; Text, Caption: string; flags: integer): integer;', nil);
    Sender.AddVariable('MB_OK', rsInteger, True)^.Cv_SInt32 :=  $00000000;
    Sender.AddVariable('MB_OKCANCEL', rsInteger, True)^.Cv_SInt32 :=  $00000001;
    Sender.AddVariable('MB_ABORTRETRYIGNORE', rsInteger, True)^.Cv_SInt32 :=  $00000002;
    Sender.AddVariable('MB_YESNOCANCEL', rsInteger, True)^.Cv_SInt32 :=  $00000003;
    Sender.AddVariable('MB_YESNO', rsInteger, True)^.Cv_SInt32 :=  $00000004;
    Sender.AddVariable('MB_RETRYCANCEL', rsInteger, True)^.Cv_SInt32 :=  $00000005;
    Sender.AddVariable('MB_ICONHAND', rsInteger, True)^.Cv_SInt32 :=  $00000010;
    Sender.AddVariable('MB_ICONQUESTION', rsInteger, True)^.Cv_SInt32 :=  $00000020;
    Sender.AddVariable('MB_ICONEXCLAMATION', rsInteger, True)^.Cv_SInt32 :=  $00000030;
    Sender.AddVariable('MB_ICONASTERISK', rsInteger, True)^.Cv_SInt32 :=  $00000040;
    Sender.AddVariable('MB_USERICON', rsInteger, True)^.Cv_SInt32 :=  $00000080;
    Sender.AddVariable('MB_ICONWARNING', rsInteger, True)^.Cv_SInt32 :=  MB_ICONEXCLAMATION;
    Sender.AddVariable('MB_ICONERROR', rsInteger, True)^.Cv_SInt32 :=  MB_ICONHAND;
    Sender.AddVariable('MB_ICONINFORMATION', rsInteger, True)^.Cv_SInt32 :=  MB_ICONASTERISK;
    Sender.AddVariable('MB_ICONSTOP', rsInteger, True)^.Cv_SInt32 :=  MB_ICONHAND;
    Sender.AddVariable('MB_DEFBUTTON1', rsInteger, True)^.Cv_SInt32 :=  $00000000;
    Sender.AddVariable('MB_DEFBUTTON2', rsInteger, True)^.Cv_SInt32 :=  $00000100;
    Sender.AddVariable('MB_DEFBUTTON3', rsInteger, True)^.Cv_SInt32 :=  $00000200;
    Sender.AddVariable('MB_DEFBUTTON4', rsInteger, True)^.Cv_SInt32 :=  $00000300;
    Sender.AddVariable('MB_APPLMODAL', rsInteger, True)^.Cv_SInt32 :=  $00000000;
    Sender.AddVariable('MB_SYSTEMMODAL', rsInteger, True)^.Cv_SInt32 :=  $00001000;
    Sender.AddVariable('MB_TASKMODAL', rsInteger, True)^.Cv_SInt32 :=  $00002000;
    Sender.AddVariable('MB_HELP', rsInteger, True)^.Cv_SInt32 :=  $00004000;                          { Help Button }
    Sender.AddVariable('MB_NOFOCUS', rsInteger, True)^.Cv_SInt32 :=  $00008000;
    Sender.AddVariable('MB_SETFOREGROUND', rsInteger, True)^.Cv_SInt32 :=  $00010000;
    Sender.AddVariable('MB_DEFAULT_DESKTOP_ONLY', rsInteger, True)^.Cv_SInt32 :=  $00020000;
    Sender.AddVariable('MB_TOPMOST', rsInteger, True)^.Cv_SInt32 :=  $00040000;
    Sender.AddVariable('MB_RIGHT', rsInteger, True)^.Cv_SInt32 :=  $00080000;
    Sender.AddVariable('MB_RTLREADING', rsInteger, True)^.Cv_SInt32 :=  $00100000;
    Sender.AddVariable('MB_SERVICE_NOTIFICATION', rsInteger, True)^.Cv_SInt32 :=  $00200000;
    Sender.AddVariable('MB_SERVICE_NOTIFICATION_NT3X', rsInteger, True)^.Cv_SInt32 :=  $00040000;
    Sender.AddVariable('MB_TYPEMASK', rsInteger, True)^.Cv_SInt32 :=  $0000000F;
    Sender.AddVariable('MB_ICONMASK', rsInteger, True)^.Cv_SInt32 :=  $000000F0;
    Sender.AddVariable('MB_DEFMASK', rsInteger, True)^.Cv_SInt32 :=  $00000F00;
    Sender.AddVariable('MB_MODEMASK', rsInteger, True)^.Cv_SInt32 :=  $00003000;
    Sender.AddVariable('MB_MISCMASK', rsInteger, True)^.Cv_SInt32 :=  $0000C000;

    Sender.AddVariable('IDOK', rsInteger, True)^.Cv_SInt32 :=  1;
    Sender.AddVariable('ID_OK', rsInteger, True)^.Cv_SInt32 :=  IDOK;
    Sender.AddVariable('IDCANCEL', rsInteger, True)^.Cv_SInt32 :=  2;
    Sender.AddVariable('ID_CANCEL', rsInteger, True)^.Cv_SInt32 :=  IDCANCEL;
    Sender.AddVariable('IDABORT', rsInteger, True)^.Cv_SInt32 :=  3;
    Sender.AddVariable('ID_ABORT', rsInteger, True)^.Cv_SInt32 :=  IDABORT;
    Sender.AddVariable('IDRETRY', rsInteger, True)^.Cv_SInt32 :=  4;
    Sender.AddVariable('ID_RETRY', rsInteger, True)^.Cv_SInt32 :=  IDRETRY;
    Sender.AddVariable('IDIGNORE', rsInteger, True)^.Cv_SInt32 :=  5;
    Sender.AddVariable('ID_IGNORE', rsInteger, True)^.Cv_SInt32 :=  IDIGNORE;
    Sender.AddVariable('IDYES', rsInteger, True)^.Cv_SInt32 :=  6;
    Sender.AddVariable('ID_YES', rsInteger, True)^.Cv_SInt32 :=  IDYES;
    Sender.AddVariable('IDNO', rsInteger, True)^.Cv_SInt32 :=  7;
    Sender.AddVariable('ID_NO', rsInteger, True)^.Cv_SInt32 :=  IDNO;
    Sender.AddVariable('IDCLOSE', rsInteger, True)^.Cv_SInt32 :=  8;
    Sender.AddVariable('ID_CLOSE', rsInteger, True)^.Cv_SInt32 :=  IDCLOSE;
    Sender.AddVariable('IDHELP', rsInteger, True)^.Cv_SInt32 :=  9;
    Sender.AddVariable('ID_HELP', rsInteger, True)^.Cv_SInt32 :=  IDHELP;

//SetCursor
    Sender.AddFunction(@WindowsCursorRegProc, 'procedure SetCursor(cr: integer);', nil);
    Sender.AddVariable('crDefault', rsInteger, True)^.Cv_SInt32 :=  0;
    Sender.AddVariable('crNone', rsInteger, True)^.Cv_SInt32 :=  -1;
    Sender.AddVariable('crArrow', rsInteger, True)^.Cv_SInt32 :=  -2;
    Sender.AddVariable('crCross', rsInteger, True)^.Cv_SInt32 :=  -3;
    Sender.AddVariable('crIBeam', rsInteger, True)^.Cv_SInt32 :=  -4;
    Sender.AddVariable('crSize', rsInteger, True)^.Cv_SInt32 :=  -22;
    Sender.AddVariable('crSizeNESW', rsInteger, True)^.Cv_SInt32 :=  -6;
    Sender.AddVariable('crSizeNS', rsInteger, True)^.Cv_SInt32 :=  -7;
    Sender.AddVariable('crSizeNWSE', rsInteger, True)^.Cv_SInt32 :=  -8;
    Sender.AddVariable('crSizeWE', rsInteger, True)^.Cv_SInt32 :=  -9;
    Sender.AddVariable('crUpArrow', rsInteger, True)^.Cv_SInt32 :=  -10;
    Sender.AddVariable('crHourGlass', rsInteger, True)^.Cv_SInt32 :=  -11;
    Sender.AddVariable('crDrag', rsInteger, True)^.Cv_SInt32 :=  -12;
    Sender.AddVariable('crNoDrop', rsInteger, True)^.Cv_SInt32 :=  -13;
    Sender.AddVariable('crHSplit', rsInteger, True)^.Cv_SInt32 :=  -14;
    Sender.AddVariable('crVSplit', rsInteger, True)^.Cv_SInt32 :=  -15;
    Sender.AddVariable('crMultiDrag', rsInteger, True)^.Cv_SInt32 :=  -16;
    Sender.AddVariable('crSQLWait', rsInteger, True)^.Cv_SInt32 :=  -17;
    Sender.AddVariable('crNo', rsInteger, True)^.Cv_SInt32 :=  -18;
    Sender.AddVariable('crAppStart', rsInteger, True)^.Cv_SInt32 :=  -19;
    Sender.AddVariable('crHelp', rsInteger, True)^.Cv_SInt32 :=  -20;
    Sender.AddVariable('crHandPoint', rsInteger, True)^.Cv_SInt32 :=  -21;
    Sender.AddVariable('crSizeAll', rsInteger, True)^.Cv_SInt32 :=  -22;
    Sender.AddFunction(@WindowsCursorRegProc, 'function GetCursorPos(var x, y: integer): boolean;', nil);
    Sender.AddFunction(@WindowsCursorRegProc, 'function SetCursorPos(x, y: integer): boolean;', nil);

//Message Hangling
    RegisterDelphiFunction(Sender, 'function SendMessage(hWnd: integer; Msg: Integer; wParam: Integer; lParam: Integer): integer;', @_SendMessage);
    RegisterDelphiFunction(Sender, 'function PostMessage(hWnd: integer; Msg: Integer; wParam: Integer; lParam: Integer): boolean;', @_PostMessage);
    Sender.AddVariable('WM_NULL', rsInteger, True)^.Cv_SInt32 :=  $0000;
    Sender.AddVariable('WM_CREATE', rsInteger, True)^.Cv_SInt32 :=  $0001;
    Sender.AddVariable('WM_DESTROY', rsInteger, True)^.Cv_SInt32 :=  $0002;
    Sender.AddVariable('WM_MOVE', rsInteger, True)^.Cv_SInt32 :=  $0003;
    Sender.AddVariable('WM_SIZE', rsInteger, True)^.Cv_SInt32 :=  $0005;
    Sender.AddVariable('WM_ACTIVATE', rsInteger, True)^.Cv_SInt32 :=  $0006;
    Sender.AddVariable('WM_SETFOCUS', rsInteger, True)^.Cv_SInt32 :=  $0007;
    Sender.AddVariable('WM_KILLFOCUS', rsInteger, True)^.Cv_SInt32 :=  $0008;
    Sender.AddVariable('WM_ENABLE', rsInteger, True)^.Cv_SInt32 :=  $000A;
    Sender.AddVariable('WM_SETREDRAW', rsInteger, True)^.Cv_SInt32 :=  $000B;
    Sender.AddVariable('WM_SETTEXT', rsInteger, True)^.Cv_SInt32 :=  $000C;
    Sender.AddVariable('WM_GETTEXT', rsInteger, True)^.Cv_SInt32 :=  $000D;
    Sender.AddVariable('WM_GETTEXTLENGTH', rsInteger, True)^.Cv_SInt32 :=  $000E;
    Sender.AddVariable('WM_PAINT', rsInteger, True)^.Cv_SInt32 :=  $000F;
    Sender.AddVariable('WM_CLOSE', rsInteger, True)^.Cv_SInt32 :=  $0010;
    Sender.AddVariable('WM_QUERYENDSESSION', rsInteger, True)^.Cv_SInt32 :=  $0011;
    Sender.AddVariable('WM_QUIT', rsInteger, True)^.Cv_SInt32 :=  $0012;
    Sender.AddVariable('WM_QUERYOPEN', rsInteger, True)^.Cv_SInt32 :=  $0013;
    Sender.AddVariable('WM_ERASEBKGND', rsInteger, True)^.Cv_SInt32 :=  $0014;
    Sender.AddVariable('WM_SYSCOLORCHANGE', rsInteger, True)^.Cv_SInt32 :=  $0015;
    Sender.AddVariable('WM_ENDSESSION', rsInteger, True)^.Cv_SInt32 :=  $0016;
    Sender.AddVariable('WM_SYSTEMERROR', rsInteger, True)^.Cv_SInt32 :=  $0017;
    Sender.AddVariable('WM_SHOWWINDOW', rsInteger, True)^.Cv_SInt32 :=  $0018;
    Sender.AddVariable('WM_CTLCOLOR', rsInteger, True)^.Cv_SInt32 :=  $0019;
    Sender.AddVariable('WM_WININICHANGE', rsInteger, True)^.Cv_SInt32 :=  $001A;
    Sender.AddVariable('WM_SETTINGCHANGE', rsInteger, True)^.Cv_SInt32 :=  WM_WININICHANGE;
    Sender.AddVariable('WM_DEVMODECHANGE', rsInteger, True)^.Cv_SInt32 :=  $001B;
    Sender.AddVariable('WM_ACTIVATEAPP', rsInteger, True)^.Cv_SInt32 :=  $001C;
    Sender.AddVariable('WM_FONTCHANGE', rsInteger, True)^.Cv_SInt32 :=  $001D;
    Sender.AddVariable('WM_TIMECHANGE', rsInteger, True)^.Cv_SInt32 :=  $001E;
    Sender.AddVariable('WM_CANCELMODE', rsInteger, True)^.Cv_SInt32 :=  $001F;
    Sender.AddVariable('WM_SETCURSOR', rsInteger, True)^.Cv_SInt32 :=  $0020;
    Sender.AddVariable('WM_MOUSEACTIVATE', rsInteger, True)^.Cv_SInt32 :=  $0021;
    Sender.AddVariable('WM_CHILDACTIVATE', rsInteger, True)^.Cv_SInt32 :=  $0022;
    Sender.AddVariable('WM_QUEUESYNC', rsInteger, True)^.Cv_SInt32 :=  $0023;              
    Sender.AddVariable('WM_GETMINMAXINFO', rsInteger, True)^.Cv_SInt32 :=  $0024;
    Sender.AddVariable('WM_PAINTICON', rsInteger, True)^.Cv_SInt32 :=  $0026;
    Sender.AddVariable('WM_ICONERASEBKGND', rsInteger, True)^.Cv_SInt32 :=  $0027;
    Sender.AddVariable('WM_NEXTDLGCTL', rsInteger, True)^.Cv_SInt32 :=  $0028;
    Sender.AddVariable('WM_SPOOLERSTATUS', rsInteger, True)^.Cv_SInt32 :=  $002A;
    Sender.AddVariable('WM_DRAWITEM', rsInteger, True)^.Cv_SInt32 :=  $002B;
    Sender.AddVariable('WM_MEASUREITEM', rsInteger, True)^.Cv_SInt32 :=  $002C;
    Sender.AddVariable('WM_DELETEITEM', rsInteger, True)^.Cv_SInt32 :=  $002D;
    Sender.AddVariable('WM_VKEYTOITEM', rsInteger, True)^.Cv_SInt32 :=  $002E;
    Sender.AddVariable('WM_CHARTOITEM', rsInteger, True)^.Cv_SInt32 :=  $002F;
    Sender.AddVariable('WM_SETFONT', rsInteger, True)^.Cv_SInt32 :=  $0030;
    Sender.AddVariable('WM_GETFONT', rsInteger, True)^.Cv_SInt32 :=  $0031;
    Sender.AddVariable('WM_SETHOTKEY', rsInteger, True)^.Cv_SInt32 :=  $0032;
    Sender.AddVariable('WM_GETHOTKEY', rsInteger, True)^.Cv_SInt32 :=  $0033;
    Sender.AddVariable('WM_QUERYDRAGICON', rsInteger, True)^.Cv_SInt32 :=  $0037;
    Sender.AddVariable('WM_COMPAREITEM', rsInteger, True)^.Cv_SInt32 :=  $0039;
    Sender.AddVariable('WM_GETOBJECT', rsInteger, True)^.Cv_SInt32 :=  $003D;
    Sender.AddVariable('WM_COMPACTING', rsInteger, True)^.Cv_SInt32 :=  $0041;         
    Sender.AddVariable('WM_COMMNOTIFY', rsInteger, True)^.Cv_SInt32 :=  $0044;    { obsolete in Win32}
    Sender.AddVariable('WM_WINDOWPOSCHANGING', rsInteger, True)^.Cv_SInt32 :=  $0046;
    Sender.AddVariable('WM_WINDOWPOSCHANGED', rsInteger, True)^.Cv_SInt32 :=  $0047;
    Sender.AddVariable('WM_POWER', rsInteger, True)^.Cv_SInt32 :=  $0048;
    Sender.AddVariable('WM_COPYDATA', rsInteger, True)^.Cv_SInt32 :=  $004A;
    Sender.AddVariable('WM_CANCELJOURNAL', rsInteger, True)^.Cv_SInt32 :=  $004B;
    Sender.AddVariable('WM_NOTIFY', rsInteger, True)^.Cv_SInt32 :=  $004E;
    Sender.AddVariable('WM_INPUTLANGCHANGEREQUEST', rsInteger, True)^.Cv_SInt32 :=  $0050;
    Sender.AddVariable('WM_INPUTLANGCHANGE', rsInteger, True)^.Cv_SInt32 :=  $0051;
    Sender.AddVariable('WM_TCARD', rsInteger, True)^.Cv_SInt32 :=  $0052;
    Sender.AddVariable('WM_HELP', rsInteger, True)^.Cv_SInt32 :=  $0053;
    Sender.AddVariable('WM_USERCHANGED', rsInteger, True)^.Cv_SInt32 :=  $0054;
    Sender.AddVariable('WM_NOTIFYFORMAT', rsInteger, True)^.Cv_SInt32 :=  $0055;
    Sender.AddVariable('WM_CONTEXTMENU', rsInteger, True)^.Cv_SInt32 :=  $007B;
    Sender.AddVariable('WM_STYLECHANGING', rsInteger, True)^.Cv_SInt32 :=  $007C;
    Sender.AddVariable('WM_STYLECHANGED', rsInteger, True)^.Cv_SInt32 :=  $007D;
    Sender.AddVariable('WM_DISPLAYCHANGE', rsInteger, True)^.Cv_SInt32 :=  $007E;
    Sender.AddVariable('WM_GETICON', rsInteger, True)^.Cv_SInt32 :=  $007F;
    Sender.AddVariable('WM_SETICON', rsInteger, True)^.Cv_SInt32 :=  $0080;
    Sender.AddVariable('WM_NCCREATE', rsInteger, True)^.Cv_SInt32 :=  $0081;
    Sender.AddVariable('WM_NCDESTROY', rsInteger, True)^.Cv_SInt32 :=  $0082;
    Sender.AddVariable('WM_NCCALCSIZE', rsInteger, True)^.Cv_SInt32 :=  $0083;
    Sender.AddVariable('WM_NCHITTEST', rsInteger, True)^.Cv_SInt32 :=  $0084;
    Sender.AddVariable('WM_NCPAINT', rsInteger, True)^.Cv_SInt32 :=  $0085;
    Sender.AddVariable('WM_NCACTIVATE', rsInteger, True)^.Cv_SInt32 :=  $0086;
    Sender.AddVariable('WM_GETDLGCODE', rsInteger, True)^.Cv_SInt32 :=  $0087;
    Sender.AddVariable('WM_NCMOUSEMOVE', rsInteger, True)^.Cv_SInt32 :=  $00A0;
    Sender.AddVariable('WM_NCLBUTTONDOWN', rsInteger, True)^.Cv_SInt32 :=  $00A1;
    Sender.AddVariable('WM_NCLBUTTONUP', rsInteger, True)^.Cv_SInt32 :=  $00A2;
    Sender.AddVariable('WM_NCLBUTTONDBLCLK', rsInteger, True)^.Cv_SInt32 :=  $00A3;
    Sender.AddVariable('WM_NCRBUTTONDOWN', rsInteger, True)^.Cv_SInt32 :=  $00A4;
    Sender.AddVariable('WM_NCRBUTTONUP', rsInteger, True)^.Cv_SInt32 :=  $00A5;
    Sender.AddVariable('WM_NCRBUTTONDBLCLK', rsInteger, True)^.Cv_SInt32 :=  $00A6;
    Sender.AddVariable('WM_NCMBUTTONDOWN', rsInteger, True)^.Cv_SInt32 :=  $00A7;
    Sender.AddVariable('WM_NCMBUTTONUP', rsInteger, True)^.Cv_SInt32 :=  $00A8;
    Sender.AddVariable('WM_NCMBUTTONDBLCLK', rsInteger, True)^.Cv_SInt32 :=  $00A9;
    Sender.AddVariable('WM_KEYFIRST', rsInteger, True)^.Cv_SInt32 :=  $0100;
    Sender.AddVariable('WM_KEYDOWN', rsInteger, True)^.Cv_SInt32 :=  $0100;
    Sender.AddVariable('WM_KEYUP', rsInteger, True)^.Cv_SInt32 :=  $0101;
    Sender.AddVariable('WM_CHAR', rsInteger, True)^.Cv_SInt32 :=  $0102;
    Sender.AddVariable('WM_DEADCHAR', rsInteger, True)^.Cv_SInt32 :=  $0103;
    Sender.AddVariable('WM_SYSKEYDOWN', rsInteger, True)^.Cv_SInt32 :=  $0104;
    Sender.AddVariable('WM_SYSKEYUP', rsInteger, True)^.Cv_SInt32 :=  $0105;
    Sender.AddVariable('WM_SYSCHAR', rsInteger, True)^.Cv_SInt32 :=  $0106;
    Sender.AddVariable('WM_SYSDEADCHAR', rsInteger, True)^.Cv_SInt32 :=  $0107;
    Sender.AddVariable('WM_KEYLAST', rsInteger, True)^.Cv_SInt32 :=  $0108;
    Sender.AddVariable('WM_INITDIALOG', rsInteger, True)^.Cv_SInt32 :=  $0110;
    Sender.AddVariable('WM_COMMAND', rsInteger, True)^.Cv_SInt32 :=  $0111;
    Sender.AddVariable('WM_SYSCOMMAND', rsInteger, True)^.Cv_SInt32 :=  $0112;
    Sender.AddVariable('WM_TIMER', rsInteger, True)^.Cv_SInt32 :=  $0113;
    Sender.AddVariable('WM_HSCROLL', rsInteger, True)^.Cv_SInt32 :=  $0114;
    Sender.AddVariable('WM_VSCROLL', rsInteger, True)^.Cv_SInt32 :=  $0115;
    Sender.AddVariable('WM_INITMENU', rsInteger, True)^.Cv_SInt32 :=  $0116;
    Sender.AddVariable('WM_INITMENUPOPUP', rsInteger, True)^.Cv_SInt32 :=  $0117;
    Sender.AddVariable('WM_MENUSELECT', rsInteger, True)^.Cv_SInt32 :=  $011F;
    Sender.AddVariable('WM_MENUCHAR', rsInteger, True)^.Cv_SInt32 :=  $0120;
    Sender.AddVariable('WM_ENTERIDLE', rsInteger, True)^.Cv_SInt32 :=  $0121;
    Sender.AddVariable('WM_MENURBUTTONUP', rsInteger, True)^.Cv_SInt32 :=  $0122;
    Sender.AddVariable('WM_MENUDRAG', rsInteger, True)^.Cv_SInt32 :=  $0123;
    Sender.AddVariable('WM_MENUGETOBJECT', rsInteger, True)^.Cv_SInt32 :=  $0124;
    Sender.AddVariable('WM_UNINITMENUPOPUP', rsInteger, True)^.Cv_SInt32 :=  $0125;
    Sender.AddVariable('WM_MENUCOMMAND', rsInteger, True)^.Cv_SInt32 :=  $0126;
    Sender.AddVariable('WM_CHANGEUISTATE', rsInteger, True)^.Cv_SInt32 :=  $0127;
    Sender.AddVariable('WM_UPDATEUISTATE', rsInteger, True)^.Cv_SInt32 :=  $0128;
    Sender.AddVariable('WM_QUERYUISTATE', rsInteger, True)^.Cv_SInt32 :=  $0129;
    Sender.AddVariable('WM_CTLCOLORMSGBOX', rsInteger, True)^.Cv_SInt32 :=  $0132;
    Sender.AddVariable('WM_CTLCOLOREDIT', rsInteger, True)^.Cv_SInt32 :=  $0133;
    Sender.AddVariable('WM_CTLCOLORLISTBOX', rsInteger, True)^.Cv_SInt32 :=  $0134;
    Sender.AddVariable('WM_CTLCOLORBTN', rsInteger, True)^.Cv_SInt32 :=  $0135;
    Sender.AddVariable('WM_CTLCOLORDLG', rsInteger, True)^.Cv_SInt32 :=  $0136;
    Sender.AddVariable('WM_CTLCOLORSCROLLBAR', rsInteger, True)^.Cv_SInt32 :=  $0137;
    Sender.AddVariable('WM_CTLCOLORSTATIC', rsInteger, True)^.Cv_SInt32 :=  $0138;
    Sender.AddVariable('WM_MOUSEFIRST', rsInteger, True)^.Cv_SInt32 :=  $0200;
    Sender.AddVariable('WM_MOUSEMOVE', rsInteger, True)^.Cv_SInt32 :=  $0200;
    Sender.AddVariable('WM_LBUTTONDOWN', rsInteger, True)^.Cv_SInt32 :=  $0201;
    Sender.AddVariable('WM_LBUTTONUP', rsInteger, True)^.Cv_SInt32 :=  $0202;
    Sender.AddVariable('WM_LBUTTONDBLCLK', rsInteger, True)^.Cv_SInt32 :=  $0203;
    Sender.AddVariable('WM_RBUTTONDOWN', rsInteger, True)^.Cv_SInt32 :=  $0204;
    Sender.AddVariable('WM_RBUTTONUP', rsInteger, True)^.Cv_SInt32 :=  $0205;
    Sender.AddVariable('WM_RBUTTONDBLCLK', rsInteger, True)^.Cv_SInt32 :=  $0206;
    Sender.AddVariable('WM_MBUTTONDOWN', rsInteger, True)^.Cv_SInt32 :=  $0207;
    Sender.AddVariable('WM_MBUTTONUP', rsInteger, True)^.Cv_SInt32 :=  $0208;
    Sender.AddVariable('WM_MBUTTONDBLCLK', rsInteger, True)^.Cv_SInt32 :=  $0209;
    Sender.AddVariable('WM_MOUSEWHEEL', rsInteger, True)^.Cv_SInt32 :=  $020A;
    Sender.AddVariable('WM_MOUSELAST', rsInteger, True)^.Cv_SInt32 :=  $020A;
    Sender.AddVariable('WM_PARENTNOTIFY', rsInteger, True)^.Cv_SInt32 :=  $0210;
    Sender.AddVariable('WM_ENTERMENULOOP', rsInteger, True)^.Cv_SInt32 :=  $0211;
    Sender.AddVariable('WM_EXITMENULOOP', rsInteger, True)^.Cv_SInt32 :=  $0212;
    Sender.AddVariable('WM_NEXTMENU', rsInteger, True)^.Cv_SInt32 :=  $0213;
    Sender.AddVariable('WM_SIZING', rsInteger, True)^.Cv_SInt32 :=  532;
    Sender.AddVariable('WM_CAPTURECHANGED', rsInteger, True)^.Cv_SInt32 :=  533;
    Sender.AddVariable('WM_MOVING', rsInteger, True)^.Cv_SInt32 :=  534;
    Sender.AddVariable('WM_POWERBROADCAST', rsInteger, True)^.Cv_SInt32 :=  536;
    Sender.AddVariable('WM_DEVICECHANGE', rsInteger, True)^.Cv_SInt32 :=  537;
    Sender.AddVariable('WM_IME_STARTCOMPOSITION', rsInteger, True)^.Cv_SInt32 :=  $010D;
    Sender.AddVariable('WM_IME_ENDCOMPOSITION', rsInteger, True)^.Cv_SInt32 :=  $010E;
    Sender.AddVariable('WM_IME_COMPOSITION', rsInteger, True)^.Cv_SInt32 :=  $010F;
    Sender.AddVariable('WM_IME_KEYLAST', rsInteger, True)^.Cv_SInt32 :=  $010F;
    Sender.AddVariable('WM_IME_SETCONTEXT', rsInteger, True)^.Cv_SInt32 :=  $0281;
    Sender.AddVariable('WM_IME_NOTIFY', rsInteger, True)^.Cv_SInt32 :=  $0282;
    Sender.AddVariable('WM_IME_CONTROL', rsInteger, True)^.Cv_SInt32 :=  $0283;
    Sender.AddVariable('WM_IME_COMPOSITIONFULL', rsInteger, True)^.Cv_SInt32 :=  $0284;
    Sender.AddVariable('WM_IME_SELECT', rsInteger, True)^.Cv_SInt32 :=  $0285;
    Sender.AddVariable('WM_IME_CHAR', rsInteger, True)^.Cv_SInt32 :=  $0286;
    Sender.AddVariable('WM_IME_REQUEST', rsInteger, True)^.Cv_SInt32 :=  $0288;
    Sender.AddVariable('WM_IME_KEYDOWN', rsInteger, True)^.Cv_SInt32 :=  $0290;
    Sender.AddVariable('WM_IME_KEYUP', rsInteger, True)^.Cv_SInt32 :=  $0291;
    Sender.AddVariable('WM_MDICREATE', rsInteger, True)^.Cv_SInt32 :=  $0220;
    Sender.AddVariable('WM_MDIDESTROY', rsInteger, True)^.Cv_SInt32 :=  $0221;
    Sender.AddVariable('WM_MDIACTIVATE', rsInteger, True)^.Cv_SInt32 :=  $0222;
    Sender.AddVariable('WM_MDIRESTORE', rsInteger, True)^.Cv_SInt32 :=  $0223;
    Sender.AddVariable('WM_MDINEXT', rsInteger, True)^.Cv_SInt32 :=  $0224;
    Sender.AddVariable('WM_MDIMAXIMIZE', rsInteger, True)^.Cv_SInt32 :=  $0225;
    Sender.AddVariable('WM_MDITILE', rsInteger, True)^.Cv_SInt32 :=  $0226;
    Sender.AddVariable('WM_MDICASCADE', rsInteger, True)^.Cv_SInt32 :=  $0227;
    Sender.AddVariable('WM_MDIICONARRANGE', rsInteger, True)^.Cv_SInt32 :=  $0228;
    Sender.AddVariable('WM_MDIGETACTIVE', rsInteger, True)^.Cv_SInt32 :=  $0229;
    Sender.AddVariable('WM_MDISETMENU', rsInteger, True)^.Cv_SInt32 :=  $0230;
    Sender.AddVariable('WM_ENTERSIZEMOVE', rsInteger, True)^.Cv_SInt32 :=  $0231;
    Sender.AddVariable('WM_EXITSIZEMOVE', rsInteger, True)^.Cv_SInt32 :=  $0232;
    Sender.AddVariable('WM_DROPFILES', rsInteger, True)^.Cv_SInt32 :=  $0233;
    Sender.AddVariable('WM_MDIREFRESHMENU', rsInteger, True)^.Cv_SInt32 :=  $0234;
    Sender.AddVariable('WM_MOUSEHOVER', rsInteger, True)^.Cv_SInt32 :=  $02A1;
    Sender.AddVariable('WM_MOUSELEAVE', rsInteger, True)^.Cv_SInt32 :=  $02A3;
    Sender.AddVariable('WM_CUT', rsInteger, True)^.Cv_SInt32 :=  $0300;
    Sender.AddVariable('WM_COPY', rsInteger, True)^.Cv_SInt32 :=  $0301;
    Sender.AddVariable('WM_PASTE', rsInteger, True)^.Cv_SInt32 :=  $0302;
    Sender.AddVariable('WM_CLEAR', rsInteger, True)^.Cv_SInt32 :=  $0303;
    Sender.AddVariable('WM_UNDO', rsInteger, True)^.Cv_SInt32 :=  $0304;
    Sender.AddVariable('WM_RENDERFORMAT', rsInteger, True)^.Cv_SInt32 :=  $0305;
    Sender.AddVariable('WM_RENDERALLFORMATS', rsInteger, True)^.Cv_SInt32 :=  $0306;
    Sender.AddVariable('WM_DESTROYCLIPBOARD', rsInteger, True)^.Cv_SInt32 :=  $0307;
    Sender.AddVariable('WM_DRAWCLIPBOARD', rsInteger, True)^.Cv_SInt32 :=  $0308;
    Sender.AddVariable('WM_PAINTCLIPBOARD', rsInteger, True)^.Cv_SInt32 :=  $0309;
    Sender.AddVariable('WM_VSCROLLCLIPBOARD', rsInteger, True)^.Cv_SInt32 :=  $030A;
    Sender.AddVariable('WM_SIZECLIPBOARD', rsInteger, True)^.Cv_SInt32 :=  $030B;
    Sender.AddVariable('WM_ASKCBFORMATNAME', rsInteger, True)^.Cv_SInt32 :=  $030C;
    Sender.AddVariable('WM_CHANGECBCHAIN', rsInteger, True)^.Cv_SInt32 :=  $030D;
    Sender.AddVariable('WM_HSCROLLCLIPBOARD', rsInteger, True)^.Cv_SInt32 :=  $030E;
    Sender.AddVariable('WM_QUERYNEWPALETTE', rsInteger, True)^.Cv_SInt32 :=  $030F;
    Sender.AddVariable('WM_PALETTEISCHANGING', rsInteger, True)^.Cv_SInt32 :=  $0310;
    Sender.AddVariable('WM_PALETTECHANGED', rsInteger, True)^.Cv_SInt32 :=  $0311;
    Sender.AddVariable('WM_HOTKEY', rsInteger, True)^.Cv_SInt32 :=  $0312;
    Sender.AddVariable('WM_PRINT', rsInteger, True)^.Cv_SInt32 :=  791;
    Sender.AddVariable('WM_PRINTCLIENT', rsInteger, True)^.Cv_SInt32 :=  792;
    Sender.AddVariable('WM_HANDHELDFIRST', rsInteger, True)^.Cv_SInt32 :=  856;
    Sender.AddVariable('WM_HANDHELDLAST', rsInteger, True)^.Cv_SInt32 :=  863;
    Sender.AddVariable('WM_PENWINFIRST', rsInteger, True)^.Cv_SInt32 :=  $0380;
    Sender.AddVariable('WM_PENWINLAST', rsInteger, True)^.Cv_SInt32 :=  $038F;
    Sender.AddVariable('WM_COALESCE_FIRST', rsInteger, True)^.Cv_SInt32 :=  $0390;
    Sender.AddVariable('WM_COALESCE_LAST', rsInteger, True)^.Cv_SInt32 :=  $039F;
    Sender.AddVariable('WM_DDE_FIRST', rsInteger, True)^.Cv_SInt32 :=  $03E0;
    Sender.AddVariable('WM_DDE_INITIATE', rsInteger, True)^.Cv_SInt32 :=  WM_DDE_FIRST + 0;
    Sender.AddVariable('WM_DDE_TERMINATE', rsInteger, True)^.Cv_SInt32 :=  WM_DDE_FIRST + 1;
    Sender.AddVariable('WM_DDE_ADVISE', rsInteger, True)^.Cv_SInt32 :=  WM_DDE_FIRST + 2;
    Sender.AddVariable('WM_DDE_UNADVISE', rsInteger, True)^.Cv_SInt32 :=  WM_DDE_FIRST + 3;
    Sender.AddVariable('WM_DDE_ACK', rsInteger, True)^.Cv_SInt32 :=  WM_DDE_FIRST + 4;
    Sender.AddVariable('WM_DDE_DATA', rsInteger, True)^.Cv_SInt32 :=  WM_DDE_FIRST + 5;
    Sender.AddVariable('WM_DDE_REQUEST', rsInteger, True)^.Cv_SInt32 :=  WM_DDE_FIRST + 6;
    Sender.AddVariable('WM_DDE_POKE', rsInteger, True)^.Cv_SInt32 :=  WM_DDE_FIRST + 7;
    Sender.AddVariable('WM_DDE_EXECUTE', rsInteger, True)^.Cv_SInt32 :=  WM_DDE_FIRST + 8;
    Sender.AddVariable('WM_DDE_LAST', rsInteger, True)^.Cv_SInt32 :=  WM_DDE_FIRST + 8;
    Sender.AddVariable('WM_APP', rsInteger, True)^.Cv_SInt32 :=  $8000;
    Sender.AddVariable('WM_USER', rsInteger, True)^.Cv_SInt32 :=  $0400;

    RegisterDelphiFunction(Sender, 'function GetTickCount: Cardinal;', @GetTickCount);

    RegisterDelphiFunction(Sender, 'procedure DisableAltTab;', @WIN_DisableAltTab);
    RegisterDelphiFunction(Sender, 'procedure EnableAltTab;', @WIN_EnableAltTab);

    RegisterDelphiFunction(Sender, 'function Win32Platform: integer;', @GetWin32Platform);
    Sender.AddVariable('VER_PLATFORM_WIN32s', rsInteger, True)^.Cv_SInt32 :=  0;
    Sender.AddVariable('VER_PLATFORM_WIN32_WINDOWS', rsInteger, True)^.Cv_SInt32 :=  1;
    Sender.AddVariable('VER_PLATFORM_WIN32_NT', rsInteger, True)^.Cv_SInt32 :=  2;

    RegisterDelphiFunction(Sender, 'function WinExec(CmdLine: string; CmdShow: integer): LongWord;',@_WinExec);
    Sender.AddConstant('SW_HIDE', rsInteger)^.Cv_SInt32 :=  0;
    Sender.AddConstant('SW_SHOWNORMAL', rsInteger)^.Cv_SInt32 :=  1;
    Sender.AddConstant('SW_NORMAL', rsInteger)^.Cv_SInt32 :=  1;
    Sender.AddConstant('SW_SHOWMINIMIZED', rsInteger)^.Cv_SInt32 :=  2;
    Sender.AddConstant('SW_SHOWMAXIMIZED', rsInteger)^.Cv_SInt32 :=  3;
    Sender.AddConstant('SW_MAXIMIZE', rsInteger)^.Cv_SInt32 :=  3;
    Sender.AddConstant('SW_SHOWNOACTIVATE', rsInteger)^.Cv_SInt32 :=  4;
    Sender.AddConstant('SW_SHOW', rsInteger)^.Cv_SInt32 :=  5;
    Sender.AddConstant('SW_MINIMIZE', rsInteger)^.Cv_SInt32 :=  6;
    Sender.AddConstant('SW_SHOWMINNOACTIVE', rsInteger)^.Cv_SInt32 :=  7;
    Sender.AddConstant('SW_SHOWNA', rsInteger)^.Cv_SInt32 :=  8;
    Sender.AddConstant('SW_RESTORE', rsInteger)^.Cv_SInt32 :=  9;
    Sender.AddConstant('SW_SHOWDEFAULT', rsInteger)^.Cv_SInt32 :=  10;
    Sender.AddConstant('SW_MAX', rsInteger)^.Cv_SInt32 :=  10;

    RegisterDelphiFunction(Sender, 'function GetLastWin32Error: Cardinal;',@_GetLastError);
    RegisterDelphiFunction(Sender, 'function SetLastWin32Error(dwErrCode: Cardinal): Cardinal;',@_SetLastError);

    Sender.AddConstant('ERROR_SUCCESS', rsInteger)^.Cv_SInt32 :=  0;
    Sender.AddConstant('NO_ERROR', rsInteger)^.Cv_SInt32 :=  0;   { dderror }
    Sender.AddConstant('ERROR_INVALID_FUNCTION', rsInteger)^.Cv_SInt32 :=  1;   { dderror }
    Sender.AddConstant('ERROR_FILE_NOT_FOUND', rsInteger)^.Cv_SInt32 :=  2;
    Sender.AddConstant('ERROR_PATH_NOT_FOUND', rsInteger)^.Cv_SInt32 :=  3;
    Sender.AddConstant('ERROR_TOO_MANY_OPEN_FILES', rsInteger)^.Cv_SInt32 :=  4;
    Sender.AddConstant('ERROR_ACCESS_DENIED', rsInteger)^.Cv_SInt32 :=  5;
    Sender.AddConstant('ERROR_INVALID_HANDLE', rsInteger)^.Cv_SInt32 :=  6;
    Sender.AddConstant('ERROR_ARENA_TRASHED', rsInteger)^.Cv_SInt32 :=  7;
    Sender.AddConstant('ERROR_NOT_ENOUGH_MEMORY', rsInteger)^.Cv_SInt32 :=  8;   { dderror }
    Sender.AddConstant('ERROR_INVALID_BLOCK', rsInteger)^.Cv_SInt32 :=  9;
    Sender.AddConstant('ERROR_BAD_ENVIRONMENT', rsInteger)^.Cv_SInt32 :=  10;
    Sender.AddConstant('ERROR_BAD_FORMAT', rsInteger)^.Cv_SInt32 :=  11;
    Sender.AddConstant('ERROR_INVALID_ACCESS', rsInteger)^.Cv_SInt32 :=  12;
    Sender.AddConstant('ERROR_INVALID_DATA', rsInteger)^.Cv_SInt32 :=  13;
    Sender.AddConstant('ERROR_OUTOFMEMORY', rsInteger)^.Cv_SInt32 :=  14;
    Sender.AddConstant('ERROR_INVALID_DRIVE', rsInteger)^.Cv_SInt32 :=  15;
    Sender.AddConstant('ERROR_CURRENT_DIRECTORY', rsInteger)^.Cv_SInt32 :=  $10;
    Sender.AddConstant('ERROR_NOT_SAME_DEVICE', rsInteger)^.Cv_SInt32 :=  17;
    Sender.AddConstant('ERROR_NO_MORE_FILES', rsInteger)^.Cv_SInt32 :=  18;
    Sender.AddConstant('ERROR_WRITE_PROTECT', rsInteger)^.Cv_SInt32 :=  19;
    Sender.AddConstant('ERROR_BAD_UNIT', rsInteger)^.Cv_SInt32 :=  20;
    Sender.AddConstant('ERROR_NOT_READY', rsInteger)^.Cv_SInt32 :=  21;
    Sender.AddConstant('ERROR_BAD_COMMAND', rsInteger)^.Cv_SInt32 :=  22;
    Sender.AddConstant('ERROR_CRC', rsInteger)^.Cv_SInt32 :=  23;
    Sender.AddConstant('ERROR_BAD_LENGTH', rsInteger)^.Cv_SInt32 :=  24;
    Sender.AddConstant('ERROR_SEEK', rsInteger)^.Cv_SInt32 :=  25;
    Sender.AddConstant('ERROR_NOT_DOS_DISK', rsInteger)^.Cv_SInt32 :=  26;
    Sender.AddConstant('ERROR_SECTOR_NOT_FOUND', rsInteger)^.Cv_SInt32 :=  27;
    Sender.AddConstant('ERROR_OUT_OF_PAPER', rsInteger)^.Cv_SInt32 :=  28;
    Sender.AddConstant('ERROR_WRITE_FAULT', rsInteger)^.Cv_SInt32 :=  29;
    Sender.AddConstant('ERROR_READ_FAULT', rsInteger)^.Cv_SInt32 :=  30;
    Sender.AddConstant('ERROR_GEN_FAILURE', rsInteger)^.Cv_SInt32 :=  31;
    Sender.AddConstant('ERROR_SHARING_VIOLATION', rsInteger)^.Cv_SInt32 :=  $20;
    Sender.AddConstant('ERROR_LOCK_VIOLATION', rsInteger)^.Cv_SInt32 :=  33;
    Sender.AddConstant('ERROR_WRONG_DISK', rsInteger)^.Cv_SInt32 :=  34;
    Sender.AddConstant('ERROR_SHARING_BUFFER_EXCEEDED', rsInteger)^.Cv_SInt32 :=  36;
    Sender.AddConstant('ERROR_HANDLE_EOF', rsInteger)^.Cv_SInt32 :=  38;
    Sender.AddConstant('ERROR_HANDLE_DISK_FULL', rsInteger)^.Cv_SInt32 :=  39;
    Sender.AddConstant('ERROR_NOT_SUPPORTED', rsInteger)^.Cv_SInt32 :=  50;
    Sender.AddConstant('ERROR_REM_NOT_LIST', rsInteger)^.Cv_SInt32 :=  51;
    Sender.AddConstant('ERROR_DUP_NAME', rsInteger)^.Cv_SInt32 :=  52;
    Sender.AddConstant('ERROR_BAD_NETPATH', rsInteger)^.Cv_SInt32 :=  53;
    Sender.AddConstant('ERROR_NETWORK_BUSY', rsInteger)^.Cv_SInt32 :=  54;
    Sender.AddConstant('ERROR_DEV_NOT_EXIST', rsInteger)^.Cv_SInt32 :=  55;   { dderror }
    Sender.AddConstant('ERROR_TOO_MANY_CMDS', rsInteger)^.Cv_SInt32 :=  56;
    Sender.AddConstant('ERROR_ADAP_HDW_ERR', rsInteger)^.Cv_SInt32 :=  57;
    Sender.AddConstant('ERROR_BAD_NET_RESP', rsInteger)^.Cv_SInt32 :=  58;
    Sender.AddConstant('ERROR_UNEXP_NET_ERR', rsInteger)^.Cv_SInt32 :=  59;
    Sender.AddConstant('ERROR_BAD_REM_ADAP', rsInteger)^.Cv_SInt32 :=  60;
    Sender.AddConstant('ERROR_PRINTQ_FULL', rsInteger)^.Cv_SInt32 :=  61;
    Sender.AddConstant('ERROR_NO_SPOOL_SPACE', rsInteger)^.Cv_SInt32 :=  62;
    Sender.AddConstant('ERROR_PRINT_CANCELLED', rsInteger)^.Cv_SInt32 :=  63;
    Sender.AddConstant('ERROR_NETNAME_DELETED', rsInteger)^.Cv_SInt32 :=  $40;
    Sender.AddConstant('ERROR_NETWORK_ACCESS_DENIED', rsInteger)^.Cv_SInt32 :=  65;
    Sender.AddConstant('ERROR_BAD_DEV_TYPE', rsInteger)^.Cv_SInt32 :=  66;
    Sender.AddConstant('ERROR_BAD_NET_NAME', rsInteger)^.Cv_SInt32 :=  67;
    Sender.AddConstant('ERROR_TOO_MANY_NAMES', rsInteger)^.Cv_SInt32 :=  68;
    Sender.AddConstant('ERROR_TOO_MANY_SESS', rsInteger)^.Cv_SInt32 :=  69;
    Sender.AddConstant('ERROR_SHARING_PAUSED', rsInteger)^.Cv_SInt32 :=  70;
    Sender.AddConstant('ERROR_REQ_NOT_ACCEP', rsInteger)^.Cv_SInt32 :=  71;
    Sender.AddConstant('ERROR_REDIR_PAUSED', rsInteger)^.Cv_SInt32 :=  72;
    Sender.AddConstant('ERROR_FILE_EXISTS', rsInteger)^.Cv_SInt32 :=  80;
    Sender.AddConstant('ERROR_CANNOT_MAKE', rsInteger)^.Cv_SInt32 :=  82;
    Sender.AddConstant('ERROR_FAIL_I24', rsInteger)^.Cv_SInt32 :=  83;
    Sender.AddConstant('ERROR_OUT_OF_STRUCTURES', rsInteger)^.Cv_SInt32 :=  84;
    Sender.AddConstant('ERROR_ALREADY_ASSIGNED', rsInteger)^.Cv_SInt32 :=  85;
    Sender.AddConstant('ERROR_INVALID_PASSWORD', rsInteger)^.Cv_SInt32 :=  86;
    Sender.AddConstant('ERROR_INVALID_PARAMETER', rsInteger)^.Cv_SInt32 :=  87;   { dderror }
    Sender.AddConstant('ERROR_NET_WRITE_FAULT', rsInteger)^.Cv_SInt32 :=  88;
    Sender.AddConstant('ERROR_NO_PROC_SLOTS', rsInteger)^.Cv_SInt32 :=  89;
    Sender.AddConstant('ERROR_TOO_MANY_SEMAPHORES', rsInteger)^.Cv_SInt32 :=  100;
    Sender.AddConstant('ERROR_EXCL_SEM_ALREADY_OWNED', rsInteger)^.Cv_SInt32 :=  101;
    Sender.AddConstant('ERROR_SEM_IS_SET', rsInteger)^.Cv_SInt32 :=  102;
    Sender.AddConstant('ERROR_TOO_MANY_SEM_REQUESTS', rsInteger)^.Cv_SInt32 :=  103;
    Sender.AddConstant('ERROR_INVALID_AT_INTERRUPT_TIME', rsInteger)^.Cv_SInt32 :=  104;
    Sender.AddConstant('ERROR_SEM_OWNER_DIED', rsInteger)^.Cv_SInt32 :=  105;
    Sender.AddConstant('ERROR_SEM_USER_LIMIT', rsInteger)^.Cv_SInt32 :=  106;
    Sender.AddConstant('ERROR_DISK_CHANGE', rsInteger)^.Cv_SInt32 :=  107;
    Sender.AddConstant('ERROR_DRIVE_LOCKED', rsInteger)^.Cv_SInt32 :=  108;
    Sender.AddConstant('ERROR_BROKEN_PIPE', rsInteger)^.Cv_SInt32 :=  109;
    Sender.AddConstant('ERROR_OPEN_FAILED', rsInteger)^.Cv_SInt32 :=  110;
    Sender.AddConstant('ERROR_BUFFER_OVERFLOW', rsInteger)^.Cv_SInt32 :=  111;
    Sender.AddConstant('ERROR_DISK_FULL', rsInteger)^.Cv_SInt32 :=  112;
    Sender.AddConstant('ERROR_NO_MORE_SEARCH_HANDLES', rsInteger)^.Cv_SInt32 :=  113;
    Sender.AddConstant('ERROR_INVALID_TARGET_HANDLE', rsInteger)^.Cv_SInt32 :=  114;
    Sender.AddConstant('ERROR_INVALID_CATEGORY', rsInteger)^.Cv_SInt32 :=  117;
    Sender.AddConstant('ERROR_INVALID_VERIFY_SWITCH', rsInteger)^.Cv_SInt32 :=  118;
    Sender.AddConstant('ERROR_BAD_DRIVER_LEVEL', rsInteger)^.Cv_SInt32 :=  119;
    Sender.AddConstant('ERROR_CALL_NOT_IMPLEMENTED', rsInteger)^.Cv_SInt32 :=  120;
    Sender.AddConstant('ERROR_SEM_TIMEOUT', rsInteger)^.Cv_SInt32 :=  121;
    Sender.AddConstant('ERROR_INSUFFICIENT_BUFFER', rsInteger)^.Cv_SInt32 :=  122;   { dderror }
    Sender.AddConstant('ERROR_INVALID_NAME', rsInteger)^.Cv_SInt32 :=  123;
    Sender.AddConstant('ERROR_INVALID_LEVEL', rsInteger)^.Cv_SInt32 :=  124;
    Sender.AddConstant('ERROR_NO_VOLUME_LABEL', rsInteger)^.Cv_SInt32 :=  125;
    Sender.AddConstant('ERROR_MOD_NOT_FOUND', rsInteger)^.Cv_SInt32 :=  126;
    Sender.AddConstant('ERROR_PROC_NOT_FOUND', rsInteger)^.Cv_SInt32 :=  127;
    Sender.AddConstant('ERROR_WAIT_NO_CHILDREN', rsInteger)^.Cv_SInt32 :=  $80;
    Sender.AddConstant('ERROR_CHILD_NOT_COMPLETE', rsInteger)^.Cv_SInt32 :=  129;
    Sender.AddConstant('ERROR_DIRECT_ACCESS_HANDLE', rsInteger)^.Cv_SInt32 :=  130;
    Sender.AddConstant('ERROR_NEGATIVE_SEEK', rsInteger)^.Cv_SInt32 :=  131;
    Sender.AddConstant('ERROR_SEEK_ON_DEVICE', rsInteger)^.Cv_SInt32 :=  132;
    Sender.AddConstant('ERROR_IS_JOIN_TARGET', rsInteger)^.Cv_SInt32 :=  133;
    Sender.AddConstant('ERROR_IS_JOINED', rsInteger)^.Cv_SInt32 :=  134;
    Sender.AddConstant('ERROR_IS_SUBSTED', rsInteger)^.Cv_SInt32 :=  135;
    Sender.AddConstant('ERROR_NOT_JOINED', rsInteger)^.Cv_SInt32 :=  136;
    Sender.AddConstant('ERROR_NOT_SUBSTED', rsInteger)^.Cv_SInt32 :=  137;
    Sender.AddConstant('ERROR_JOIN_TO_JOIN', rsInteger)^.Cv_SInt32 :=  138;
    Sender.AddConstant('ERROR_SUBST_TO_SUBST', rsInteger)^.Cv_SInt32 :=  139;
    Sender.AddConstant('ERROR_JOIN_TO_SUBST', rsInteger)^.Cv_SInt32 :=  140;
    Sender.AddConstant('ERROR_SUBST_TO_JOIN', rsInteger)^.Cv_SInt32 :=  141;
    Sender.AddConstant('ERROR_BUSY_DRIVE', rsInteger)^.Cv_SInt32 :=  142;
    Sender.AddConstant('ERROR_SAME_DRIVE', rsInteger)^.Cv_SInt32 :=  143;
    Sender.AddConstant('ERROR_DIR_NOT_ROOT', rsInteger)^.Cv_SInt32 :=  144;
    Sender.AddConstant('ERROR_DIR_NOT_EMPTY', rsInteger)^.Cv_SInt32 :=  145;
    Sender.AddConstant('ERROR_IS_SUBST_PATH', rsInteger)^.Cv_SInt32 :=  146;
    Sender.AddConstant('ERROR_IS_JOIN_PATH', rsInteger)^.Cv_SInt32 :=  147;
    Sender.AddConstant('ERROR_PATH_BUSY', rsInteger)^.Cv_SInt32 :=  148;
    Sender.AddConstant('ERROR_IS_SUBST_TARGET', rsInteger)^.Cv_SInt32 :=  149;
    Sender.AddConstant('ERROR_SYSTEM_TRACE', rsInteger)^.Cv_SInt32 :=  150;
    Sender.AddConstant('ERROR_INVALID_EVENT_COUNT', rsInteger)^.Cv_SInt32 :=  151;
    Sender.AddConstant('ERROR_TOO_MANY_MUXWAITERS', rsInteger)^.Cv_SInt32 :=  152;
    Sender.AddConstant('ERROR_INVALID_LIST_FORMAT', rsInteger)^.Cv_SInt32 :=  153;
    Sender.AddConstant('ERROR_LABEL_TOO_LONG', rsInteger)^.Cv_SInt32 :=  154;
    Sender.AddConstant('ERROR_TOO_MANY_TCBS', rsInteger)^.Cv_SInt32 :=  155;
    Sender.AddConstant('ERROR_SIGNAL_REFUSED', rsInteger)^.Cv_SInt32 :=  156;
    Sender.AddConstant('ERROR_DISCARDED', rsInteger)^.Cv_SInt32 :=  157;
    Sender.AddConstant('ERROR_NOT_LOCKED', rsInteger)^.Cv_SInt32 :=  158;
    Sender.AddConstant('ERROR_BAD_THREADID_ADDR', rsInteger)^.Cv_SInt32 :=  159;
    Sender.AddConstant('ERROR_BAD_ARGUMENTS', rsInteger)^.Cv_SInt32 :=  160;
    Sender.AddConstant('ERROR_BAD_PATHNAME', rsInteger)^.Cv_SInt32 :=  161;
    Sender.AddConstant('ERROR_SIGNAL_PENDING', rsInteger)^.Cv_SInt32 :=  162;
    Sender.AddConstant('ERROR_MAX_THRDS_REACHED', rsInteger)^.Cv_SInt32 :=  164;
    Sender.AddConstant('ERROR_LOCK_FAILED', rsInteger)^.Cv_SInt32 :=  167;
    Sender.AddConstant('ERROR_BUSY', rsInteger)^.Cv_SInt32 :=  170;
    Sender.AddConstant('ERROR_CANCEL_VIOLATION', rsInteger)^.Cv_SInt32 :=  173;
    Sender.AddConstant('ERROR_ATOMIC_LOCKS_NOT_SUPPORTED', rsInteger)^.Cv_SInt32 :=  174;
    Sender.AddConstant('ERROR_INVALID_SEGMENT_NUMBER', rsInteger)^.Cv_SInt32 :=  180;
    Sender.AddConstant('ERROR_INVALID_ORDINAL', rsInteger)^.Cv_SInt32 :=  182;
    Sender.AddConstant('ERROR_ALREADY_EXISTS', rsInteger)^.Cv_SInt32 :=  183;
    Sender.AddConstant('ERROR_INVALID_FLAG_NUMBER', rsInteger)^.Cv_SInt32 :=  186;
    Sender.AddConstant('ERROR_SEM_NOT_FOUND', rsInteger)^.Cv_SInt32 :=  187;
    Sender.AddConstant('ERROR_INVALID_STARTING_CODESEG', rsInteger)^.Cv_SInt32 :=  188;
    Sender.AddConstant('ERROR_INVALID_STACKSEG', rsInteger)^.Cv_SInt32 :=  189;
    Sender.AddConstant('ERROR_INVALID_MODULETYPE', rsInteger)^.Cv_SInt32 :=  190;
    Sender.AddConstant('ERROR_INVALID_EXE_SIGNATURE', rsInteger)^.Cv_SInt32 :=  191;
    Sender.AddConstant('ERROR_EXE_MARKED_INVALID', rsInteger)^.Cv_SInt32 :=  192;
    Sender.AddConstant('ERROR_BAD_EXE_FORMAT', rsInteger)^.Cv_SInt32 :=  193;
    Sender.AddConstant('ERROR_ITERATED_DATA_EXCEEDS_64k', rsInteger)^.Cv_SInt32 :=  194;
    Sender.AddConstant('ERROR_INVALID_MINALLOCSIZE', rsInteger)^.Cv_SInt32 :=  195;
    Sender.AddConstant('ERROR_DYNLINK_FROM_INVALID_RING', rsInteger)^.Cv_SInt32 :=  196;
    Sender.AddConstant('ERROR_IOPL_NOT_ENABLED', rsInteger)^.Cv_SInt32 :=  197;
    Sender.AddConstant('ERROR_INVALID_SEGDPL', rsInteger)^.Cv_SInt32 :=  198;
    Sender.AddConstant('ERROR_AUTODATASEG_EXCEEDS_64k', rsInteger)^.Cv_SInt32 :=  199;
    Sender.AddConstant('ERROR_RING2SEG_MUST_BE_MOVABLE', rsInteger)^.Cv_SInt32 :=  200;
    Sender.AddConstant('ERROR_RELOC_CHAIN_XEEDS_SEGLIM', rsInteger)^.Cv_SInt32 :=  201;
    Sender.AddConstant('ERROR_INFLOOP_IN_RELOC_CHAIN', rsInteger)^.Cv_SInt32 :=  202;
    Sender.AddConstant('ERROR_ENVVAR_NOT_FOUND', rsInteger)^.Cv_SInt32 :=  203;
    Sender.AddConstant('ERROR_NO_SIGNAL_SENT', rsInteger)^.Cv_SInt32 :=  205;
    Sender.AddConstant('ERROR_FILENAME_EXCED_RANGE', rsInteger)^.Cv_SInt32 :=  206;
    Sender.AddConstant('ERROR_RING2_STACK_IN_USE', rsInteger)^.Cv_SInt32 :=  207;
    Sender.AddConstant('ERROR_META_EXPANSION_TOO_LONG', rsInteger)^.Cv_SInt32 :=  208;
    Sender.AddConstant('ERROR_INVALID_SIGNAL_NUMBER', rsInteger)^.Cv_SInt32 :=  209;
    Sender.AddConstant('ERROR_THREAD_1_INACTIVE', rsInteger)^.Cv_SInt32 :=  210;
    Sender.AddConstant('ERROR_LOCKED', rsInteger)^.Cv_SInt32 :=  212;
    Sender.AddConstant('ERROR_TOO_MANY_MODULES', rsInteger)^.Cv_SInt32 :=  214;
    Sender.AddConstant('ERROR_NESTING_NOT_ALLOWED', rsInteger)^.Cv_SInt32 :=  215;
    Sender.AddConstant('ERROR_EXE_MACHINE_TYPE_MISMATCH', rsInteger)^.Cv_SInt32 :=  216;
    Sender.AddConstant('ERROR_BAD_PIPE', rsInteger)^.Cv_SInt32 :=  230;
    Sender.AddConstant('ERROR_PIPE_BUSY', rsInteger)^.Cv_SInt32 :=  231;
    Sender.AddConstant('ERROR_NO_DATA', rsInteger)^.Cv_SInt32 :=  232;
    Sender.AddConstant('ERROR_PIPE_NOT_CONNECTED', rsInteger)^.Cv_SInt32 :=  233;
    Sender.AddConstant('ERROR_MORE_DATA', rsInteger)^.Cv_SInt32 :=  234;   { dderror }
    Sender.AddConstant('ERROR_VC_DISCONNECTED', rsInteger)^.Cv_SInt32 :=  240;
    Sender.AddConstant('ERROR_INVALID_EA_NAME', rsInteger)^.Cv_SInt32 :=  254;
    Sender.AddConstant('ERROR_EA_LIST_INCONSISTENT', rsInteger)^.Cv_SInt32 :=  255;
    Sender.AddConstant('ERROR_NO_MORE_ITEMS', rsInteger)^.Cv_SInt32 :=  259;
    Sender.AddConstant('ERROR_CANNOT_COPY', rsInteger)^.Cv_SInt32 :=  266;
    Sender.AddConstant('ERROR_DIRECTORY', rsInteger)^.Cv_SInt32 :=  267;
    Sender.AddConstant('ERROR_EAS_DIDNT_FIT', rsInteger)^.Cv_SInt32 :=  275;
    Sender.AddConstant('ERROR_EA_FILE_CORRUPT', rsInteger)^.Cv_SInt32 :=  276;
    Sender.AddConstant('ERROR_EA_TABLE_FULL', rsInteger)^.Cv_SInt32 :=  277;
    Sender.AddConstant('ERROR_INVALID_EA_HANDLE', rsInteger)^.Cv_SInt32 :=  278;
    Sender.AddConstant('ERROR_EAS_NOT_SUPPORTED', rsInteger)^.Cv_SInt32 :=  282;
    Sender.AddConstant('ERROR_NOT_OWNER', rsInteger)^.Cv_SInt32 :=  288;
    Sender.AddConstant('ERROR_TOO_MANY_POSTS', rsInteger)^.Cv_SInt32 :=  298;
    Sender.AddConstant('ERROR_PARTIAL_COPY', rsInteger)^.Cv_SInt32 :=  299;
    Sender.AddConstant('ERROR_MR_MID_NOT_FOUND', rsInteger)^.Cv_SInt32 :=  317;
    Sender.AddConstant('ERROR_INVALID_ADDRESS', rsInteger)^.Cv_SInt32 :=  487;
    Sender.AddConstant('ERROR_ARITHMETIC_OVERFLOW', rsInteger)^.Cv_SInt32 :=  534;
    Sender.AddConstant('ERROR_PIPE_CONNECTED', rsInteger)^.Cv_SInt32 :=  535;
    Sender.AddConstant('ERROR_PIPE_LISTENING', rsInteger)^.Cv_SInt32 :=  536;
    Sender.AddConstant('ERROR_EA_ACCESS_DENIED', rsInteger)^.Cv_SInt32 :=  994;
    Sender.AddConstant('ERROR_OPERATION_ABORTED', rsInteger)^.Cv_SInt32 :=  995;
    Sender.AddConstant('ERROR_IO_INCOMPLETE', rsInteger)^.Cv_SInt32 :=  996;
    Sender.AddConstant('ERROR_IO_PENDING', rsInteger)^.Cv_SInt32 :=  997;   { dderror }
    Sender.AddConstant('ERROR_NOACCESS', rsInteger)^.Cv_SInt32 :=  998;
    Sender.AddConstant('ERROR_SWAPERROR', rsInteger)^.Cv_SInt32 :=  999;
    Sender.AddConstant('ERROR_STACK_OVERFLOW', rsInteger)^.Cv_SInt32 :=  1001;
    Sender.AddConstant('ERROR_INVALID_MESSAGE', rsInteger)^.Cv_SInt32 :=  1002;
    Sender.AddConstant('ERROR_CAN_NOT_COMPLETE', rsInteger)^.Cv_SInt32 :=  1003;
    Sender.AddConstant('ERROR_INVALID_FLAGS', rsInteger)^.Cv_SInt32 :=  1004;
    Sender.AddConstant('ERROR_UNRECOGNIZED_VOLUME', rsInteger)^.Cv_SInt32 :=  1005;
    Sender.AddConstant('ERROR_FILE_INVALID', rsInteger)^.Cv_SInt32 :=  1006;
    Sender.AddConstant('ERROR_FULLSCREEN_MODE', rsInteger)^.Cv_SInt32 :=  1007;
    Sender.AddConstant('ERROR_NO_TOKEN', rsInteger)^.Cv_SInt32 :=  1008;
    Sender.AddConstant('ERROR_BADDB', rsInteger)^.Cv_SInt32 :=  1009;
    Sender.AddConstant('ERROR_BADKEY', rsInteger)^.Cv_SInt32 :=  1010;
    Sender.AddConstant('ERROR_CANTOPEN', rsInteger)^.Cv_SInt32 :=  1011;
    Sender.AddConstant('ERROR_CANTREAD', rsInteger)^.Cv_SInt32 :=  1012;
    Sender.AddConstant('ERROR_CANTWRITE', rsInteger)^.Cv_SInt32 :=  1013;
    Sender.AddConstant('ERROR_REGISTRY_RECOVERED', rsInteger)^.Cv_SInt32 :=  1014;
    Sender.AddConstant('ERROR_REGISTRY_CORRUPT', rsInteger)^.Cv_SInt32 :=  1015;
    Sender.AddConstant('ERROR_REGISTRY_IO_FAILED', rsInteger)^.Cv_SInt32 :=  1016;
    Sender.AddConstant('ERROR_NOT_REGISTRY_FILE', rsInteger)^.Cv_SInt32 :=  1017;
    Sender.AddConstant('ERROR_KEY_DELETED', rsInteger)^.Cv_SInt32 :=  1018;
    Sender.AddConstant('ERROR_NO_LOG_SPACE', rsInteger)^.Cv_SInt32 :=  1019;
    Sender.AddConstant('ERROR_KEY_HAS_CHILDREN', rsInteger)^.Cv_SInt32 :=  1020;
    Sender.AddConstant('ERROR_CHILD_MUST_BE_VOLATILE', rsInteger)^.Cv_SInt32 :=  1021;
    Sender.AddConstant('ERROR_NOTIFY_ENUM_DIR', rsInteger)^.Cv_SInt32 :=  1022;
    Sender.AddConstant('ERROR_DEPENDENT_SERVICES_RUNNING', rsInteger)^.Cv_SInt32 :=  1051;
    Sender.AddConstant('ERROR_INVALID_SERVICE_CONTROL', rsInteger)^.Cv_SInt32 :=  1052;
    Sender.AddConstant('ERROR_SERVICE_REQUEST_TIMEOUT', rsInteger)^.Cv_SInt32 :=  1053;
    Sender.AddConstant('ERROR_SERVICE_NO_THREAD', rsInteger)^.Cv_SInt32 :=  1054;
    Sender.AddConstant('ERROR_SERVICE_DATABASE_LOCKED', rsInteger)^.Cv_SInt32 :=  1055;
    Sender.AddConstant('ERROR_SERVICE_ALREADY_RUNNING', rsInteger)^.Cv_SInt32 :=  1056;
    Sender.AddConstant('ERROR_INVALID_SERVICE_ACCOUNT', rsInteger)^.Cv_SInt32 :=  1057;
    Sender.AddConstant('ERROR_SERVICE_DISABLED', rsInteger)^.Cv_SInt32 :=  1058;
    Sender.AddConstant('ERROR_CIRCULAR_DEPENDENCY', rsInteger)^.Cv_SInt32 :=  1059;
    Sender.AddConstant('ERROR_SERVICE_DOES_NOT_EXIST', rsInteger)^.Cv_SInt32 :=  1060;
    Sender.AddConstant('ERROR_SERVICE_CANNOT_ACCEPT_CTRL', rsInteger)^.Cv_SInt32 :=  1061;
    Sender.AddConstant('ERROR_SERVICE_NOT_ACTIVE', rsInteger)^.Cv_SInt32 :=  1062;
    Sender.AddConstant('ERROR_FAILED_SERVICE_CONTROLLER_', rsInteger)^.Cv_SInt32 :=  1063;
    Sender.AddConstant('ERROR_EXCEPTION_IN_SERVICE', rsInteger)^.Cv_SInt32 :=  1064;
    Sender.AddConstant('ERROR_DATABASE_DOES_NOT_EXIST', rsInteger)^.Cv_SInt32 :=  1065;
    Sender.AddConstant('ERROR_SERVICE_SPECIFIC_ERROR', rsInteger)^.Cv_SInt32 :=  1066;
    Sender.AddConstant('ERROR_PROCESS_ABORTED', rsInteger)^.Cv_SInt32 :=  1067;
    Sender.AddConstant('ERROR_SERVICE_DEPENDENCY_FAIL', rsInteger)^.Cv_SInt32 :=  1068;
    Sender.AddConstant('ERROR_SERVICE_LOGON_FAILED', rsInteger)^.Cv_SInt32 :=  1069;
    Sender.AddConstant('ERROR_SERVICE_START_HANG', rsInteger)^.Cv_SInt32 :=  1070;
    Sender.AddConstant('ERROR_INVALID_SERVICE_LOCK', rsInteger)^.Cv_SInt32 :=  1071;
    Sender.AddConstant('ERROR_SERVICE_MARKED_FOR_DELETE', rsInteger)^.Cv_SInt32 :=  1072;
    Sender.AddConstant('ERROR_SERVICE_EXISTS', rsInteger)^.Cv_SInt32 :=  1073;
    Sender.AddConstant('ERROR_ALREADY_RUNNING_LKG', rsInteger)^.Cv_SInt32 :=  1074;
    Sender.AddConstant('ERROR_SERVICE_DEPENDENCY_DELETED', rsInteger)^.Cv_SInt32 :=  1075;
    Sender.AddConstant('ERROR_BOOT_ALREADY_ACCEPTED', rsInteger)^.Cv_SInt32 :=  1076;
    Sender.AddConstant('ERROR_SERVICE_NEVER_STARTED', rsInteger)^.Cv_SInt32 :=  1077;
    Sender.AddConstant('ERROR_DUPLICATE_SERVICE_NAME', rsInteger)^.Cv_SInt32 :=  1078;
    Sender.AddConstant('ERROR_DIFFERENT_SERVICE_ACCOUNT', rsInteger)^.Cv_SInt32 :=  1079;
    Sender.AddConstant('ERROR_END_OF_MEDIA', rsInteger)^.Cv_SInt32 :=  1100;
    Sender.AddConstant('ERROR_FILEMARK_DETECTED', rsInteger)^.Cv_SInt32 :=  1101;
    Sender.AddConstant('ERROR_BEGINNING_OF_MEDIA', rsInteger)^.Cv_SInt32 :=  1102;
    Sender.AddConstant('ERROR_SETMARK_DETECTED', rsInteger)^.Cv_SInt32 :=  1103;
    Sender.AddConstant('ERROR_NO_DATA_DETECTED', rsInteger)^.Cv_SInt32 :=  1104;
    Sender.AddConstant('ERROR_PARTITION_FAILURE', rsInteger)^.Cv_SInt32 :=  1105;
    Sender.AddConstant('ERROR_INVALID_BLOCK_LENGTH', rsInteger)^.Cv_SInt32 :=  1106;
    Sender.AddConstant('ERROR_DEVICE_NOT_PARTITIONED', rsInteger)^.Cv_SInt32 :=  1107;
    Sender.AddConstant('ERROR_UNABLE_TO_LOCK_MEDIA', rsInteger)^.Cv_SInt32 :=  1108;
    Sender.AddConstant('ERROR_UNABLE_TO_UNLOAD_MEDIA', rsInteger)^.Cv_SInt32 :=  1109;
    Sender.AddConstant('ERROR_MEDIA_CHANGED', rsInteger)^.Cv_SInt32 :=  1110;
    Sender.AddConstant('ERROR_BUS_RESET', rsInteger)^.Cv_SInt32 :=  1111;
    Sender.AddConstant('ERROR_NO_MEDIA_IN_DRIVE', rsInteger)^.Cv_SInt32 :=  1112;
    Sender.AddConstant('ERROR_NO_UNICODE_TRANSLATION', rsInteger)^.Cv_SInt32 :=  1113;
    Sender.AddConstant('ERROR_DLL_INIT_FAILED', rsInteger)^.Cv_SInt32 :=  1114;
    Sender.AddConstant('ERROR_SHUTDOWN_IN_PROGRESS', rsInteger)^.Cv_SInt32 :=  1115;
    Sender.AddConstant('ERROR_NO_SHUTDOWN_IN_PROGRESS', rsInteger)^.Cv_SInt32 :=  1116;
    Sender.AddConstant('ERROR_IO_DEVICE', rsInteger)^.Cv_SInt32 :=  1117;
    Sender.AddConstant('ERROR_SERIAL_NO_DEVICE', rsInteger)^.Cv_SInt32 :=  1118;
    Sender.AddConstant('ERROR_IRQ_BUSY', rsInteger)^.Cv_SInt32 :=  1119;
    Sender.AddConstant('ERROR_MORE_WRITES', rsInteger)^.Cv_SInt32 :=  1120;
    Sender.AddConstant('ERROR_COUNTER_TIMEOUT', rsInteger)^.Cv_SInt32 :=  1121;
    Sender.AddConstant('ERROR_FLOPPY_ID_MARK_NOT_FOUND', rsInteger)^.Cv_SInt32 :=  1122;
    Sender.AddConstant('ERROR_FLOPPY_WRONG_CYLINDER', rsInteger)^.Cv_SInt32 :=  1123;
    Sender.AddConstant('ERROR_FLOPPY_UNKNOWN_ERROR', rsInteger)^.Cv_SInt32 :=  1124;
    Sender.AddConstant('ERROR_FLOPPY_BAD_REGISTERS', rsInteger)^.Cv_SInt32 :=  1125;
    Sender.AddConstant('ERROR_DISK_RECALIBRATE_FAILED', rsInteger)^.Cv_SInt32 :=  1126;
    Sender.AddConstant('ERROR_DISK_OPERATION_FAILED', rsInteger)^.Cv_SInt32 :=  1127;
    Sender.AddConstant('ERROR_DISK_RESET_FAILED', rsInteger)^.Cv_SInt32 :=  1128;
    Sender.AddConstant('ERROR_EOM_OVERFLOW', rsInteger)^.Cv_SInt32 :=  1129;
    Sender.AddConstant('ERROR_NOT_ENOUGH_SERVER_MEMORY', rsInteger)^.Cv_SInt32 :=  1130;
    Sender.AddConstant('ERROR_POSSIBLE_DEADLOCK', rsInteger)^.Cv_SInt32 :=  1131;
    Sender.AddConstant('ERROR_MAPPED_ALIGNMENT', rsInteger)^.Cv_SInt32 :=  1132;
    Sender.AddConstant('ERROR_SET_POWER_STATE_VETOED', rsInteger)^.Cv_SInt32 :=  1140;
    Sender.AddConstant('ERROR_SET_POWER_STATE_FAILED', rsInteger)^.Cv_SInt32 :=  1141;
    Sender.AddConstant('ERROR_TOO_MANY_LINKS', rsInteger)^.Cv_SInt32 :=  1142;
    Sender.AddConstant('ERROR_OLD_WIN_VERSION', rsInteger)^.Cv_SInt32 :=  1150;
    Sender.AddConstant('ERROR_APP_WRONG_OS', rsInteger)^.Cv_SInt32 :=  1151;
    Sender.AddConstant('ERROR_SINGLE_INSTANCE_APP', rsInteger)^.Cv_SInt32 :=  1152;
    Sender.AddConstant('ERROR_RMODE_APP', rsInteger)^.Cv_SInt32 :=  1153;
    Sender.AddConstant('ERROR_INVALID_DLL', rsInteger)^.Cv_SInt32 :=  1154;
    Sender.AddConstant('ERROR_NO_ASSOCIATION', rsInteger)^.Cv_SInt32 :=  1155;
    Sender.AddConstant('ERROR_DDE_FAIL', rsInteger)^.Cv_SInt32 :=  1156;
    Sender.AddConstant('ERROR_DLL_NOT_FOUND', rsInteger)^.Cv_SInt32 :=  1157;
    Sender.AddConstant('ERROR_BAD_USERNAME', rsInteger)^.Cv_SInt32 :=  2202;
    Sender.AddConstant('ERROR_NOT_CONNECTED', rsInteger)^.Cv_SInt32 :=  2250;
    Sender.AddConstant('ERROR_OPEN_FILES', rsInteger)^.Cv_SInt32 :=  2401;
    Sender.AddConstant('ERROR_ACTIVE_CONNECTIONS', rsInteger)^.Cv_SInt32 :=  2402;
    Sender.AddConstant('ERROR_DEVICE_IN_USE', rsInteger)^.Cv_SInt32 :=  2404;
    Sender.AddConstant('ERROR_BAD_DEVICE', rsInteger)^.Cv_SInt32 :=  1200;
    Sender.AddConstant('ERROR_CONNECTION_UNAVAIL', rsInteger)^.Cv_SInt32 :=  1201;
    Sender.AddConstant('ERROR_DEVICE_ALREADY_REMEMBERED', rsInteger)^.Cv_SInt32 :=  1202;
    Sender.AddConstant('ERROR_NO_NET_OR_BAD_PATH', rsInteger)^.Cv_SInt32 :=  1203;
    Sender.AddConstant('ERROR_BAD_PROVIDER', rsInteger)^.Cv_SInt32 :=  1204;
    Sender.AddConstant('ERROR_CANNOT_OPEN_PROFILE', rsInteger)^.Cv_SInt32 :=  1205;
    Sender.AddConstant('ERROR_BAD_PROFILE', rsInteger)^.Cv_SInt32 :=  1206;
    Sender.AddConstant('ERROR_NOT_CONTAINER', rsInteger)^.Cv_SInt32 :=  1207;
    Sender.AddConstant('ERROR_EXTENDED_ERROR', rsInteger)^.Cv_SInt32 :=  1208;
    Sender.AddConstant('ERROR_INVALID_GROUPNAME', rsInteger)^.Cv_SInt32 :=  1209;
    Sender.AddConstant('ERROR_INVALID_COMPUTERNAME', rsInteger)^.Cv_SInt32 :=  1210;
    Sender.AddConstant('ERROR_INVALID_EVENTNAME', rsInteger)^.Cv_SInt32 :=  1211;
    Sender.AddConstant('ERROR_INVALID_DOMAINNAME', rsInteger)^.Cv_SInt32 :=  1212;
    Sender.AddConstant('ERROR_INVALID_SERVICENAME', rsInteger)^.Cv_SInt32 :=  1213;
    Sender.AddConstant('ERROR_INVALID_NETNAME', rsInteger)^.Cv_SInt32 :=  1214;
    Sender.AddConstant('ERROR_INVALID_SHARENAME', rsInteger)^.Cv_SInt32 :=  1215;
    Sender.AddConstant('ERROR_INVALID_PASSWORDNAME', rsInteger)^.Cv_SInt32 :=  1216;
    Sender.AddConstant('ERROR_INVALID_MESSAGENAME', rsInteger)^.Cv_SInt32 :=  1217;
    Sender.AddConstant('ERROR_INVALID_MESSAGEDEST', rsInteger)^.Cv_SInt32 :=  1218;
    Sender.AddConstant('ERROR_SESSION_CREDENTIAL_CONFLICT', rsInteger)^.Cv_SInt32 :=  1219;
    Sender.AddConstant('ERROR_REMOTE_SESSION_LIMIT_EXCEEDED', rsInteger)^.Cv_SInt32 :=  1220;
    Sender.AddConstant('ERROR_DUP_DOMAINNAME', rsInteger)^.Cv_SInt32 :=  1221;
    Sender.AddConstant('ERROR_NO_NETWORK', rsInteger)^.Cv_SInt32 :=  1222;
    Sender.AddConstant('ERROR_CANCELLED', rsInteger)^.Cv_SInt32 :=  1223;
    Sender.AddConstant('ERROR_USER_MAPPED_FILE', rsInteger)^.Cv_SInt32 :=  1224;
    Sender.AddConstant('ERROR_CONNECTION_REFUSED', rsInteger)^.Cv_SInt32 :=  1225;
    Sender.AddConstant('ERROR_GRACEFUL_DISCONNECT', rsInteger)^.Cv_SInt32 :=  1226;
    Sender.AddConstant('ERROR_ADDRESS_ALREADY_ASSOCIATED', rsInteger)^.Cv_SInt32 :=  1227;
    Sender.AddConstant('ERROR_ADDRESS_NOT_ASSOCIATED', rsInteger)^.Cv_SInt32 :=  1228;
    Sender.AddConstant('ERROR_CONNECTION_INVALID', rsInteger)^.Cv_SInt32 :=  1229;
    Sender.AddConstant('ERROR_CONNECTION_ACTIVE', rsInteger)^.Cv_SInt32 :=  1230;
    Sender.AddConstant('ERROR_NETWORK_UNREACHABLE', rsInteger)^.Cv_SInt32 :=  1231;
    Sender.AddConstant('ERROR_HOST_UNREACHABLE', rsInteger)^.Cv_SInt32 :=  1232;
    Sender.AddConstant('ERROR_PROTOCOL_UNREACHABLE', rsInteger)^.Cv_SInt32 :=  1233;
    Sender.AddConstant('ERROR_PORT_UNREACHABLE', rsInteger)^.Cv_SInt32 :=  1234;
    Sender.AddConstant('ERROR_REQUEST_ABORTED', rsInteger)^.Cv_SInt32 :=  1235;
    Sender.AddConstant('ERROR_CONNECTION_ABORTED', rsInteger)^.Cv_SInt32 :=  1236;
    Sender.AddConstant('ERROR_RETRY', rsInteger)^.Cv_SInt32 :=  1237;
    Sender.AddConstant('ERROR_CONNECTION_COUNT_LIMIT', rsInteger)^.Cv_SInt32 :=  1238;
    Sender.AddConstant('ERROR_LOGIN_TIME_RESTRICTION', rsInteger)^.Cv_SInt32 :=  1239;
    Sender.AddConstant('ERROR_LOGIN_WKSTA_RESTRICTION', rsInteger)^.Cv_SInt32 :=  1240;
    Sender.AddConstant('ERROR_INCORRECT_ADDRESS', rsInteger)^.Cv_SInt32 :=  1241;
    Sender.AddConstant('ERROR_ALREADY_REGISTERED', rsInteger)^.Cv_SInt32 :=  1242;
    Sender.AddConstant('ERROR_SERVICE_NOT_FOUND', rsInteger)^.Cv_SInt32 :=  1243;
    Sender.AddConstant('ERROR_NOT_AUTHENTICATED', rsInteger)^.Cv_SInt32 :=  1244;
    Sender.AddConstant('ERROR_NOT_LOGGED_ON', rsInteger)^.Cv_SInt32 :=  1245;
    Sender.AddConstant('ERROR_CONTINUE', rsInteger)^.Cv_SInt32 :=  1246;
    Sender.AddConstant('ERROR_ALREADY_INITIALIZED', rsInteger)^.Cv_SInt32 :=  1247;
    Sender.AddConstant('ERROR_NO_MORE_DEVICES', rsInteger)^.Cv_SInt32 :=  1248;
    Sender.AddConstant('ERROR_NOT_ALL_ASSIGNED', rsInteger)^.Cv_SInt32 :=  1300;
    Sender.AddConstant('ERROR_SOME_NOT_MAPPED', rsInteger)^.Cv_SInt32 :=  1301;
    Sender.AddConstant('ERROR_NO_QUOTAS_FOR_ACCOUNT', rsInteger)^.Cv_SInt32 :=  1302;
    Sender.AddConstant('ERROR_LOCAL_USER_SESSION_KEY', rsInteger)^.Cv_SInt32 :=  1303;
    Sender.AddConstant('ERROR_NULL_LM_PASSWORD', rsInteger)^.Cv_SInt32 :=  1304;
    Sender.AddConstant('ERROR_UNKNOWN_REVISION', rsInteger)^.Cv_SInt32 :=  1305;
    Sender.AddConstant('ERROR_REVISION_MISMATCH', rsInteger)^.Cv_SInt32 :=  1306;
    Sender.AddConstant('ERROR_INVALID_OWNER', rsInteger)^.Cv_SInt32 :=  1307;
    Sender.AddConstant('ERROR_INVALID_PRIMARY_GROUP', rsInteger)^.Cv_SInt32 :=  1308;
    Sender.AddConstant('ERROR_NO_IMPERSONATION_TOKEN', rsInteger)^.Cv_SInt32 :=  1309;
    Sender.AddConstant('ERROR_CANT_DISABLE_MANDATORY', rsInteger)^.Cv_SInt32 :=  1310;
    Sender.AddConstant('ERROR_NO_LOGON_SERVERS', rsInteger)^.Cv_SInt32 :=  1311;
    Sender.AddConstant('ERROR_NO_SUCH_LOGON_SESSION', rsInteger)^.Cv_SInt32 :=  1312;
    Sender.AddConstant('ERROR_NO_SUCH_PRIVILEGE', rsInteger)^.Cv_SInt32 :=  1313;
    Sender.AddConstant('ERROR_PRIVILEGE_NOT_HELD', rsInteger)^.Cv_SInt32 :=  1314;
    Sender.AddConstant('ERROR_INVALID_ACCOUNT_NAME', rsInteger)^.Cv_SInt32 :=  1315;
    Sender.AddConstant('ERROR_USER_EXISTS', rsInteger)^.Cv_SInt32 :=  1316;
    Sender.AddConstant('ERROR_NO_SUCH_USER', rsInteger)^.Cv_SInt32 :=  1317;
    Sender.AddConstant('ERROR_GROUP_EXISTS', rsInteger)^.Cv_SInt32 :=  1318;
    Sender.AddConstant('ERROR_NO_SUCH_GROUP', rsInteger)^.Cv_SInt32 :=  1319;
    Sender.AddConstant('ERROR_MEMBER_IN_GROUP', rsInteger)^.Cv_SInt32 :=  1320;
    Sender.AddConstant('ERROR_MEMBER_NOT_IN_GROUP', rsInteger)^.Cv_SInt32 :=  1321;
    Sender.AddConstant('ERROR_LAST_ADMIN', rsInteger)^.Cv_SInt32 :=  1322;
    Sender.AddConstant('ERROR_WRONG_PASSWORD', rsInteger)^.Cv_SInt32 :=  1323;
    Sender.AddConstant('ERROR_ILL_FORMED_PASSWORD', rsInteger)^.Cv_SInt32 :=  1324;
    Sender.AddConstant('ERROR_PASSWORD_RESTRICTION', rsInteger)^.Cv_SInt32 :=  1325;
    Sender.AddConstant('ERROR_LOGON_FAILURE', rsInteger)^.Cv_SInt32 :=  1326;
    Sender.AddConstant('ERROR_ACCOUNT_RESTRICTION', rsInteger)^.Cv_SInt32 :=  1327;
    Sender.AddConstant('ERROR_INVALID_LOGON_HOURS', rsInteger)^.Cv_SInt32 :=  1328;
    Sender.AddConstant('ERROR_INVALID_WORKSTATION', rsInteger)^.Cv_SInt32 :=  1329;
    Sender.AddConstant('ERROR_PASSWORD_EXPIRED', rsInteger)^.Cv_SInt32 :=  1330;
    Sender.AddConstant('ERROR_ACCOUNT_DISABLED', rsInteger)^.Cv_SInt32 :=  1331;
    Sender.AddConstant('ERROR_NONE_MAPPED', rsInteger)^.Cv_SInt32 :=  1332;
    Sender.AddConstant('ERROR_TOO_MANY_LUIDS_REQUESTED', rsInteger)^.Cv_SInt32 :=  1333;
    Sender.AddConstant('ERROR_LUIDS_EXHAUSTED', rsInteger)^.Cv_SInt32 :=  1334;
    Sender.AddConstant('ERROR_INVALID_SUB_AUTHORITY', rsInteger)^.Cv_SInt32 :=  1335;
    Sender.AddConstant('ERROR_INVALID_ACL', rsInteger)^.Cv_SInt32 :=  1336;
    Sender.AddConstant('ERROR_INVALID_SID', rsInteger)^.Cv_SInt32 :=  1337;
    Sender.AddConstant('ERROR_INVALID_SECURITY_DESCR', rsInteger)^.Cv_SInt32 :=  1338;
    Sender.AddConstant('ERROR_BAD_INHERITANCE_ACL', rsInteger)^.Cv_SInt32 :=  1340;
    Sender.AddConstant('ERROR_SERVER_DISABLED', rsInteger)^.Cv_SInt32 :=  1341;
    Sender.AddConstant('ERROR_SERVER_NOT_DISABLED', rsInteger)^.Cv_SInt32 :=  1342;
    Sender.AddConstant('ERROR_INVALID_ID_AUTHORITY', rsInteger)^.Cv_SInt32 :=  1343;
    Sender.AddConstant('ERROR_ALLOTTED_SPACE_EXCEEDED', rsInteger)^.Cv_SInt32 :=  1344;
    Sender.AddConstant('ERROR_INVALID_GROUP_ATTRIBUTES', rsInteger)^.Cv_SInt32 :=  1345;
    Sender.AddConstant('ERROR_BAD_IMPERSONATION_LEVEL', rsInteger)^.Cv_SInt32 :=  1346;
    Sender.AddConstant('ERROR_CANT_OPEN_ANONYMOUS', rsInteger)^.Cv_SInt32 :=  1347;
    Sender.AddConstant('ERROR_BAD_VALIDATION_CLASS', rsInteger)^.Cv_SInt32 :=  1348;
    Sender.AddConstant('ERROR_BAD_TOKEN_TYPE', rsInteger)^.Cv_SInt32 :=  1349;
    Sender.AddConstant('ERROR_NO_SECURITY_ON_OBJECT', rsInteger)^.Cv_SInt32 :=  1350;
    Sender.AddConstant('ERROR_CANT_ACCESS_DOMAIN_INFO', rsInteger)^.Cv_SInt32 :=  1351;
    Sender.AddConstant('ERROR_INVALID_SERVER_STATE', rsInteger)^.Cv_SInt32 :=  1352;
    Sender.AddConstant('ERROR_INVALID_DOMAIN_STATE', rsInteger)^.Cv_SInt32 :=  1353;
    Sender.AddConstant('ERROR_INVALID_DOMAIN_ROLE', rsInteger)^.Cv_SInt32 :=  1354;
    Sender.AddConstant('ERROR_NO_SUCH_DOMAIN', rsInteger)^.Cv_SInt32 :=  1355;
    Sender.AddConstant('ERROR_DOMAIN_EXISTS', rsInteger)^.Cv_SInt32 :=  1356;
    Sender.AddConstant('ERROR_DOMAIN_LIMIT_EXCEEDED', rsInteger)^.Cv_SInt32 :=  1357;
    Sender.AddConstant('ERROR_INTERNAL_DB_CORRUPTION', rsInteger)^.Cv_SInt32 :=  1358;
    Sender.AddConstant('ERROR_INTERNAL_ERROR', rsInteger)^.Cv_SInt32 :=  1359;
    Sender.AddConstant('ERROR_GENERIC_NOT_MAPPED', rsInteger)^.Cv_SInt32 :=  1360;
    Sender.AddConstant('ERROR_BAD_DESCRIPTOR_FORMAT', rsInteger)^.Cv_SInt32 :=  1361;
    Sender.AddConstant('ERROR_NOT_LOGON_PROCESS', rsInteger)^.Cv_SInt32 :=  1362;
    Sender.AddConstant('ERROR_LOGON_SESSION_EXISTS', rsInteger)^.Cv_SInt32 :=  1363;
    Sender.AddConstant('ERROR_NO_SUCH_PACKAGE', rsInteger)^.Cv_SInt32 :=  1364;
    Sender.AddConstant('ERROR_BAD_LOGON_SESSION_STATE', rsInteger)^.Cv_SInt32 :=  1365;
    Sender.AddConstant('ERROR_LOGON_SESSION_COLLISION', rsInteger)^.Cv_SInt32 :=  1366;
    Sender.AddConstant('ERROR_INVALID_LOGON_TYPE', rsInteger)^.Cv_SInt32 :=  1367;
    Sender.AddConstant('ERROR_CANNOT_IMPERSONATE', rsInteger)^.Cv_SInt32 :=  1368;
    Sender.AddConstant('ERROR_RXACT_INVALID_STATE', rsInteger)^.Cv_SInt32 :=  1369;
    Sender.AddConstant('ERROR_RXACT_COMMIT_FAILURE', rsInteger)^.Cv_SInt32 :=  1370;
    Sender.AddConstant('ERROR_SPECIAL_ACCOUNT', rsInteger)^.Cv_SInt32 :=  1371;
    Sender.AddConstant('ERROR_SPECIAL_GROUP', rsInteger)^.Cv_SInt32 :=  1372;
    Sender.AddConstant('ERROR_SPECIAL_USER', rsInteger)^.Cv_SInt32 :=  1373;
    Sender.AddConstant('ERROR_MEMBERS_PRIMARY_GROUP', rsInteger)^.Cv_SInt32 :=  1374;
    Sender.AddConstant('ERROR_TOKEN_ALREADY_IN_USE', rsInteger)^.Cv_SInt32 :=  1375;
    Sender.AddConstant('ERROR_NO_SUCH_ALIAS', rsInteger)^.Cv_SInt32 :=  1376;
    Sender.AddConstant('ERROR_MEMBER_NOT_IN_ALIAS', rsInteger)^.Cv_SInt32 :=  1377;
    Sender.AddConstant('ERROR_MEMBER_IN_ALIAS', rsInteger)^.Cv_SInt32 :=  1378;
    Sender.AddConstant('ERROR_ALIAS_EXISTS', rsInteger)^.Cv_SInt32 :=  1379;
    Sender.AddConstant('ERROR_LOGON_NOT_GRANTED', rsInteger)^.Cv_SInt32 :=  1380;
    Sender.AddConstant('ERROR_TOO_MANY_SECRETS', rsInteger)^.Cv_SInt32 :=  1381;
    Sender.AddConstant('ERROR_SECRET_TOO_LONG', rsInteger)^.Cv_SInt32 :=  1382;
    Sender.AddConstant('ERROR_INTERNAL_DB_ERROR', rsInteger)^.Cv_SInt32 :=  1383;
    Sender.AddConstant('ERROR_TOO_MANY_CONTEXT_IDS', rsInteger)^.Cv_SInt32 :=  1384;
    Sender.AddConstant('ERROR_LOGON_TYPE_NOT_GRANTED', rsInteger)^.Cv_SInt32 :=  1385;
    Sender.AddConstant('ERROR_NT_CROSS_ENCRYPTION_REQUIRED', rsInteger)^.Cv_SInt32 :=  1386;
    Sender.AddConstant('ERROR_NO_SUCH_MEMBER', rsInteger)^.Cv_SInt32 :=  1387;
    Sender.AddConstant('ERROR_INVALID_MEMBER', rsInteger)^.Cv_SInt32 :=  1388;
    Sender.AddConstant('ERROR_TOO_MANY_SIDS', rsInteger)^.Cv_SInt32 :=  1389;
    Sender.AddConstant('ERROR_LM_CROSS_ENCRYPTION_REQUIRED', rsInteger)^.Cv_SInt32 :=  1390;
    Sender.AddConstant('ERROR_NO_INHERITANCE', rsInteger)^.Cv_SInt32 :=  1391;
    Sender.AddConstant('ERROR_FILE_CORRUPT', rsInteger)^.Cv_SInt32 :=  1392;
    Sender.AddConstant('ERROR_DISK_CORRUPT', rsInteger)^.Cv_SInt32 :=  1393;
    Sender.AddConstant('ERROR_NO_USER_SESSION_KEY', rsInteger)^.Cv_SInt32 :=  1394;
    Sender.AddConstant('ERROR_LICENSE_QUOTA_EXCEEDED', rsInteger)^.Cv_SInt32 :=  1395;
    Sender.AddConstant('ERROR_INVALID_WINDOW_HANDLE', rsInteger)^.Cv_SInt32 :=  1400;
    Sender.AddConstant('ERROR_INVALID_MENU_HANDLE', rsInteger)^.Cv_SInt32 :=  1401;
    Sender.AddConstant('ERROR_INVALID_CURSOR_HANDLE', rsInteger)^.Cv_SInt32 :=  1402;
    Sender.AddConstant('ERROR_INVALID_ACCEL_HANDLE', rsInteger)^.Cv_SInt32 :=  1403;
    Sender.AddConstant('ERROR_INVALID_HOOK_HANDLE', rsInteger)^.Cv_SInt32 :=  1404;
    Sender.AddConstant('ERROR_INVALID_DWP_HANDLE', rsInteger)^.Cv_SInt32 :=  1405;
    Sender.AddConstant('ERROR_TLW_WITH_WSCHILD', rsInteger)^.Cv_SInt32 :=  1406;
    Sender.AddConstant('ERROR_CANNOT_FIND_WND_CLASS', rsInteger)^.Cv_SInt32 :=  1407;
    Sender.AddConstant('ERROR_WINDOW_OF_OTHER_THREAD', rsInteger)^.Cv_SInt32 :=  1408;
    Sender.AddConstant('ERROR_HOTKEY_ALREADY_REGISTERED', rsInteger)^.Cv_SInt32 :=  1409;
    Sender.AddConstant('ERROR_CLASS_ALREADY_EXISTS', rsInteger)^.Cv_SInt32 :=  1410;
    Sender.AddConstant('ERROR_CLASS_DOES_NOT_EXIST', rsInteger)^.Cv_SInt32 :=  1411;
    Sender.AddConstant('ERROR_CLASS_HAS_WINDOWS', rsInteger)^.Cv_SInt32 :=  1412;
    Sender.AddConstant('ERROR_INVALID_INDEX', rsInteger)^.Cv_SInt32 :=  1413;
    Sender.AddConstant('ERROR_INVALID_ICON_HANDLE', rsInteger)^.Cv_SInt32 :=  1414;
    Sender.AddConstant('ERROR_PRIVATE_DIALOG_INDEX', rsInteger)^.Cv_SInt32 :=  1415;
    Sender.AddConstant('ERROR_LISTBOX_ID_NOT_FOUND', rsInteger)^.Cv_SInt32 :=  1416;
    Sender.AddConstant('ERROR_NO_WILDCARD_CHARACTERS', rsInteger)^.Cv_SInt32 :=  1417;
    Sender.AddConstant('ERROR_CLIPBOARD_NOT_OPEN', rsInteger)^.Cv_SInt32 :=  1418;
    Sender.AddConstant('ERROR_HOTKEY_NOT_REGISTERED', rsInteger)^.Cv_SInt32 :=  1419;
    Sender.AddConstant('ERROR_WINDOW_NOT_DIALOG', rsInteger)^.Cv_SInt32 :=  1420;
    Sender.AddConstant('ERROR_CONTROL_ID_NOT_FOUND', rsInteger)^.Cv_SInt32 :=  1421;
    Sender.AddConstant('ERROR_INVALID_COMBOBOX_MESSAGE', rsInteger)^.Cv_SInt32 :=  1422;
    Sender.AddConstant('ERROR_WINDOW_NOT_COMBOBOX', rsInteger)^.Cv_SInt32 :=  1423;
    Sender.AddConstant('ERROR_INVALID_EDIT_HEIGHT', rsInteger)^.Cv_SInt32 :=  1424;
    Sender.AddConstant('ERROR_DC_NOT_FOUND', rsInteger)^.Cv_SInt32 :=  1425;
    Sender.AddConstant('ERROR_INVALID_HOOK_FILTER', rsInteger)^.Cv_SInt32 :=  1426;
    Sender.AddConstant('ERROR_INVALID_FILTER_PROC', rsInteger)^.Cv_SInt32 :=  1427;
    Sender.AddConstant('ERROR_HOOK_NEEDS_HMOD', rsInteger)^.Cv_SInt32 :=  1428;
    Sender.AddConstant('ERROR_GLOBAL_ONLY_HOOK', rsInteger)^.Cv_SInt32 :=  1429;
    Sender.AddConstant('ERROR_JOURNAL_HOOK_SET', rsInteger)^.Cv_SInt32 :=  1430;
    Sender.AddConstant('ERROR_HOOK_NOT_INSTALLED', rsInteger)^.Cv_SInt32 :=  1431;
    Sender.AddConstant('ERROR_INVALID_LB_MESSAGE', rsInteger)^.Cv_SInt32 :=  1432;
    Sender.AddConstant('ERROR_SETCOUNT_ON_BAD_LB', rsInteger)^.Cv_SInt32 :=  1433;
    Sender.AddConstant('ERROR_LB_WITHOUT_TABSTOPS', rsInteger)^.Cv_SInt32 :=  1434;
    Sender.AddConstant('ERROR_DESTROY_OBJECT_OF_OTHER_THREAD', rsInteger)^.Cv_SInt32 :=  1435;
    Sender.AddConstant('ERROR_CHILD_WINDOW_MENU', rsInteger)^.Cv_SInt32 :=  1436;
    Sender.AddConstant('ERROR_NO_SYSTEM_MENU', rsInteger)^.Cv_SInt32 :=  1437;
    Sender.AddConstant('ERROR_INVALID_MSGBOX_STYLE', rsInteger)^.Cv_SInt32 :=  1438;
    Sender.AddConstant('ERROR_INVALID_SPI_VALUE', rsInteger)^.Cv_SInt32 :=  1439;
    Sender.AddConstant('ERROR_SCREEN_ALREADY_LOCKED', rsInteger)^.Cv_SInt32 :=  1440;
    Sender.AddConstant('ERROR_HWNDS_HAVE_DIFF_PARENT', rsInteger)^.Cv_SInt32 :=  1441;
    Sender.AddConstant('ERROR_NOT_CHILD_WINDOW', rsInteger)^.Cv_SInt32 :=  1442;
    Sender.AddConstant('ERROR_INVALID_GW_COMMAND', rsInteger)^.Cv_SInt32 :=  1443;
    Sender.AddConstant('ERROR_INVALID_THREAD_ID', rsInteger)^.Cv_SInt32 :=  1444;
    Sender.AddConstant('ERROR_NON_MDICHILD_WINDOW', rsInteger)^.Cv_SInt32 :=  1445;
    Sender.AddConstant('ERROR_POPUP_ALREADY_ACTIVE', rsInteger)^.Cv_SInt32 :=  1446;
    Sender.AddConstant('ERROR_NO_SCROLLBARS', rsInteger)^.Cv_SInt32 :=  1447;
    Sender.AddConstant('ERROR_INVALID_SCROLLBAR_RANGE', rsInteger)^.Cv_SInt32 :=  1448;
    Sender.AddConstant('ERROR_INVALID_SHOWWIN_COMMAND', rsInteger)^.Cv_SInt32 :=  1449;
    Sender.AddConstant('ERROR_NO_SYSTEM_RESOURCES', rsInteger)^.Cv_SInt32 :=  1450;
    Sender.AddConstant('ERROR_NONPAGED_SYSTEM_RESOURCES', rsInteger)^.Cv_SInt32 :=  1451;
    Sender.AddConstant('ERROR_PAGED_SYSTEM_RESOURCES', rsInteger)^.Cv_SInt32 :=  1452;
    Sender.AddConstant('ERROR_WORKING_SET_QUOTA', rsInteger)^.Cv_SInt32 :=  1453;
    Sender.AddConstant('ERROR_PAGEFILE_QUOTA', rsInteger)^.Cv_SInt32 :=  1454;
    Sender.AddConstant('ERROR_COMMITMENT_LIMIT', rsInteger)^.Cv_SInt32 :=  1455;
    Sender.AddConstant('ERROR_MENU_ITEM_NOT_FOUND', rsInteger)^.Cv_SInt32 :=  1456;
    Sender.AddConstant('ERROR_INVALID_KEYBOARD_HANDLE', rsInteger)^.Cv_SInt32 :=  1457;
    Sender.AddConstant('ERROR_HOOK_TYPE_NOT_ALLOWED', rsInteger)^.Cv_SInt32 :=  1458;
    Sender.AddConstant('ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION', rsInteger)^.Cv_SInt32 :=  1459;
    Sender.AddConstant('ERROR_TIMEOUT', rsInteger)^.Cv_SInt32 :=  1460;
    Sender.AddConstant('ERROR_EVENTLOG_FILE_CORRUPT', rsInteger)^.Cv_SInt32 :=  1500;
    Sender.AddConstant('ERROR_EVENTLOG_CANT_START', rsInteger)^.Cv_SInt32 :=  1501;
    Sender.AddConstant('ERROR_LOG_FILE_FULL', rsInteger)^.Cv_SInt32 :=  1502;
    Sender.AddConstant('ERROR_EVENTLOG_FILE_CHANGED', rsInteger)^.Cv_SInt32 :=  1503;


    Result := ENoError;
  end
  else if Name = 'MATH' then
  begin
    Sender.AddConstant('E', rsExtended)^.CV_Extended := exp(1.0);

    Sender.AddVariable('g_PI', rsExtended, True)^.CV_Extended         :=  3.14159265358979323846;  // Pi
    Sender.AddVariable('g_NEG_PI', rsExtended, True)^.CV_Extended     := -3.14159265358979323846;  // -Pi
    Sender.AddVariable('g_2_PI', rsExtended, True)^.CV_Extended       :=  6.28318530717958623200;  // 2 * Pi
    Sender.AddVariable('g_PI_DIV_2', rsExtended, True)^.CV_Extended   :=  1.57079632679489655800;  // Pi / 2
    Sender.AddVariable('g_PI_DIV_4', rsExtended, True)^.CV_Extended   :=  0.78539816339744827900;  // Pi / 4
    Sender.AddVariable('g_3_PI_DIV_2', rsExtended, True)^.CV_Extended :=  4.71238898038468985769;  // 3*pi/2
    Sender.AddVariable('g_INV_PI', rsExtended, True)^.CV_Extended     :=  0.31830988618379069122;  // 1 / Pi
    Sender.AddVariable('g_DEGTORAD', rsExtended, True)^.CV_Extended   :=  0.01745329251994329547;  // Degrees to Radians
    Sender.AddVariable('g_RADTODEG', rsExtended, True)^.CV_Extended   :=  57.29577951308232286465; // Radians to Degrees
    Sender.AddVariable('g_HUGE', rsExtended, True)^.CV_Extended       :=  1.0e+38;                 // Huge number for FLOAT
    Sender.AddVariable('g_MINHUGE', rsExtended, True)^.CV_Extended    :=  -1.0e+38;                // Minimum Huge number for FLOAT
    Sender.AddVariable('g_EPSILON', rsExtended, True)^.CV_Extended    :=  1.0e-5;                  // Tolerance for FLOATs

    for i := 0 to 359 do
      Sender.AddConstant('SIN' + {$IFNDEF NO_DXTABLES}TABLE_INTTOSTR3[i]{$ELSE}IntToStr3(i){$ENDIF}, rsExtended)^.CV_Extended := Sin(i * g_DEGTORAD);
    for i := 0 to 359 do
      Sender.AddConstant('COS' + {$IFNDEF NO_DXTABLES}TABLE_INTTOSTR3[i]{$ELSE}IntToStr3(i){$ENDIF}, rsExtended)^.CV_Extended := Cos(i * g_DEGTORAD);

    RegisterMathLib(Sender);
    Result := ENoError;
  end
  else if Name = 'SCENE' then
  begin
    if Sender.UsesExist('FORMS') then
      RegisterDXImage(Sender);

    Sender.AddVariable('ID3D_ALL', rsInteger, True)^.Cv_SInt32 := -1;
    Sender.AddVariable('ID3D_Abstract', rsInteger, True)^.Cv_SInt32 := 0;
{$IFNDEF NO_D3DTRIANGLES}
    Sender.AddVariable('ID3D_Triangle', rsInteger, True)^.Cv_SInt32 := 1;
{$ENDIF}
    Sender.AddVariable('ID3D_Quadrangle', rsInteger, True)^.Cv_SInt32 := 2;
{$IFNDEF NO_D3DSTUBOBJECTS}
    Sender.AddVariable('ID3D_StubObject', rsInteger, True)^.Cv_SInt32 := 3;
{$ENDIF}
    Sender.AddVariable('ID3D_Polygon', rsInteger, True)^.Cv_SInt32 := 4;
{$IFNDEF NO_D3DEXOBJECTS}
    Sender.AddVariable('ID3D_ExObject', rsInteger, True)^.Cv_SInt32 := 5;
{$ENDIF}
{$IFNDEF NO_D3DBILLBOARDS}
    Sender.AddVariable('ID3D_Billboard', rsInteger, True)^.Cv_SInt32 := 6;
{$ENDIF}
    Sender.AddVariable('ID3D_Scene', rsInteger, True)^.Cv_SInt32 := 7;
{$IFNDEF NO_D3DCUBES}
    Sender.AddVariable('ID3D_Cube', rsInteger, True)^.Cv_SInt32 := 8;
{$ENDIF}
{$IFNDEF NO_D3DSPHERES}
    Sender.AddVariable('ID3D_Sphere', rsInteger, True)^.Cv_SInt32 := 9;
{$ENDIF}
{$IFNDEF NO_D3DCONES}
    Sender.AddVariable('ID3D_Cone', rsInteger, True)^.Cv_SInt32 := 10;
{$ENDIF}
{$IFNDEF NO_D3DCYLINDERS}
    Sender.AddVariable('ID3D_Cylinder', rsInteger, True)^.Cv_SInt32 := 11;
{$ENDIF}
{$IFNDEF NO_D3DPLUGINS}
    Sender.AddVariable('ID3D_PlugIn', rsInteger, True)^.Cv_SInt32 := 12;
{$ENDIF}
{$IFNDEF NO_D3DRINGS}
    Sender.AddVariable('ID3D_Ring', rsInteger, True)^.Cv_SInt32 := 13;
{$ENDIF}
{$IFNDEF NO_D3DSECTORCOLLECTIONS}
    Sender.AddVariable('ID3D_SectorCollection', rsInteger, True)^.Cv_SInt32 := 14;
{$ENDIF}
{$IFNDEF NO_D3DTEXTS}
    Sender.AddVariable('ID3D_Text', rsInteger, True)^.Cv_SInt32 := 15;
{$ENDIF}
{$IFNDEF NO_D3DPROCEDURALOBJECTS}
    Sender.AddVariable('ID3D_ProceduralObject', rsInteger, True)^.Cv_SInt32 := 16;
{$ENDIF}
{$IFNDEF NO_D3DACTORS}
    Sender.AddVariable('ID3D_Actor', rsInteger, True)^.CV_SInt32 := 17;
{$ENDIF}

{$IFNDEF NO_D3DEXTRARTLPOLYGONS}
    Sender.AddVariable('ID3D_ExtraRTLPolygon', rsInteger, True)^.CV_SInt32 := 95;
{$ENDIF}

{$IFNDEF NO_D3DGENERICRTLPOLYGONS}
    Sender.AddVariable('ID3D_GenericRTLPolygon', rsInteger, True)^.Cv_SInt32 := 96;
{$ENDIF}
{$IFNDEF NO_D3DSTUBOBJECTS}
  {$IFNDEF NO_D3DEXOBJECTS}
    Sender.AddVariable('ID3D_ExObjectToStubObject', rsInteger, True)^.Cv_SInt32 := 97;
  {$ENDIF}
{$ENDIF}
    Sender.AddVariable('ID3D_GenericQuadrangle', rsInteger, True)^.Cv_SInt32 := 98;
    Sender.AddVariable('ID3D_GenericTriangle', rsInteger, True)^.Cv_SInt32 := 99;
    Sender.AddVariable('ID3D_MaxSurface', rsInteger, True)^.Cv_SInt32 := 100;
{$IFNDEF NO_D3DSOUNDS}
    Sender.AddVariable('ID3D_Sound', rsInteger, True)^.Cv_SInt32 := 101;
    Sender.AddVariable('ID3D_Tone', rsInteger, True)^.Cv_SInt32 := 102;
{$ENDIF}
    Sender.AddVariable('ID3D_Custom', rsInteger, True)^.Cv_SInt32 := 201;
    Sender.AddVariable('ID3D_Script', rsInteger, True)^.Cv_SInt32 := 202;
    Sender.AddVariable('ID3D_Rotator', rsInteger, True)^.Cv_SInt32 := 210;
    Sender.AddVariable('ID3D_Mover', rsInteger, True)^.Cv_SInt32 := 211;
    Sender.AddVariable('ID3D_RotatorAround', rsInteger, True)^.Cv_SInt32 := 212;

    Sender.AddConstant('pmBlack', rsInteger)^.Cv_SInt32 := 0;
    Sender.AddConstant('pmWhite', rsInteger)^.Cv_SInt32 := 1;
    Sender.AddConstant('pmNop', rsInteger)^.Cv_SInt32 := 2;
    Sender.AddConstant('pmNot', rsInteger)^.Cv_SInt32 := 3;
    Sender.AddConstant('pmCopy', rsInteger)^.Cv_SInt32 := 4;
    Sender.AddConstant('pmNotCopy', rsInteger)^.Cv_SInt32 := 5;
    Sender.AddConstant('pmMergePenNot', rsInteger)^.Cv_SInt32 := 6;
    Sender.AddConstant('pmMaskPenNot', rsInteger)^.Cv_SInt32 := 7;
    Sender.AddConstant('pmMergeNotPen', rsInteger)^.Cv_SInt32 := 8;
    Sender.AddConstant('pmMaskNotPen', rsInteger)^.Cv_SInt32 := 9;
    Sender.AddConstant('pmMerge', rsInteger)^.Cv_SInt32 := 10;
    Sender.AddConstant('pmNotMerge', rsInteger)^.Cv_SInt32 := 11;
    Sender.AddConstant('pmMask', rsInteger)^.Cv_SInt32 := 12;
    Sender.AddConstant('pmNotMask', rsInteger)^.Cv_SInt32 := 13;
    Sender.AddConstant('pmXor', rsInteger)^.Cv_SInt32 := 14;
    Sender.AddConstant('pmNotXor', rsInteger)^.Cv_SInt32 := 15;

    Sender.AddVariable('D3DPT_INVALID_0', rsInteger, True)^.Cv_SInt32 := 0;
    Sender.AddVariable('D3DPT_POINTLIST', rsInteger, True)^.Cv_SInt32 := 1;
    Sender.AddVariable('D3DPT_LINELIST', rsInteger, True)^.Cv_SInt32 := 2;
    Sender.AddVariable('D3DPT_LINESTRIP', rsInteger, True)^.Cv_SInt32 := 3;
    Sender.AddVariable('D3DPT_TRIANGLELIST', rsInteger, True)^.Cv_SInt32 := 4;
    Sender.AddVariable('D3DPT_TRIANGLESTRIP', rsInteger, True)^.Cv_SInt32 := 5;
    Sender.AddVariable('D3DPT_TRIANGLEFAN', rsInteger, True)^.Cv_SInt32 := 6;

    Sender.AddVariable('D3DCULL_INVALID_0', rsInteger, True)^.Cv_SInt32 := 0;
    Sender.AddVariable('D3DCULL_NONE', rsInteger, True)^.Cv_SInt32 := 1;
    Sender.AddVariable('D3DCULL_CW', rsInteger, True)^.Cv_SInt32 := 2;
    Sender.AddVariable('D3DCULL_CCW', rsInteger, True)^.Cv_SInt32 := 3;

    RegisterDelphiFunction(Sender, 'function IsMap(m: string): boolean;', @IsMap);
    RegisterDelphiFunction(Sender, 'function GenGlobalID: integer;', @GenGlobalID);
    Sender.AddFunction(@SceneRegProc, 'function _Scene_GetDistance: double', nil);
    Sender.AddFunction(@SceneRegProc, 'procedure _Scene_Move(x, y, z: double)', nil);
    Sender.AddFunction(@SceneRegProc, 'procedure _Scene_Rotate(x, y, z: double)', nil);
    Sender.AddFunction(@SceneRegProc, 'procedure _Scene_MoveObjects(ID, key: integer; x, y, z: double)', nil);
    Sender.AddFunction(@SceneRegProc, 'procedure _Scene_MoveObjectsTo(ID, key: integer; x, y, z: double)', nil);
    Sender.AddFunction(@SceneRegProc, 'procedure _Scene_RotateObjects(ID, key: integer; dx, dy, dz: double)', nil);
    Sender.AddFunction(@SceneRegProc, 'procedure _Scene_RotateObjectsAround(ID, key: integer; x, y, z: double; dx, dy, dz: double)', nil);
    Sender.AddFunction(@SceneRegProc, 'procedure _Scene_Recalc', nil);
    Sender.AddFunction(@SceneRegProc, 'function _Scene_GetSpeed: double', nil);
    Sender.AddFunction(@SceneRegProc, 'procedure _Scene_Invalidate', nil);
    Sender.AddFunction(@SceneRegProc, 'function _Scene_IsAttached: boolean', nil);
    Sender.AddFunction(@SceneRegProc, 'procedure _Scene_CullSurfaces(dist: double)', nil);
    Sender.AddFunction(@SceneRegProc, 'procedure _Scene_AddSearchPath(PathName: string)', nil);
    Sender.AddFunction(@SceneRegProc, 'procedure _Scene_SetMaxPolygonVertexes(i: integer)', nil);

    Sender.AddFunction(@SceneDXDrawParamsRegProc, 'function _Scene_DXDrawWidth: integer', nil);
    Sender.AddFunction(@SceneDXDrawParamsRegProc, 'function _Scene_DXDrawHeight: integer', nil);
    Sender.AddFunction(@SceneDXDrawParamsRegProc, 'function _Scene_DXDrawBpp: integer', nil);

    Sender.AddFunction(@SceneFogRegProc, 'procedure _Scene_StopFog', nil);
    Sender.AddFunction(@SceneFogRegProc, 'function _Scene_StartVertexFog(color: integer; Alfa: byte; fStart, fEnd: single): boolean', nil);
    Sender.AddFunction(@SceneFogRegProc, 'function _Scene_StartTableFog(color: integer; Alfa: byte; fStart, fEnd: single; density: single; mode: integer): boolean', nil);
    Sender.AddFunction(@SceneFogRegProc, 'function _Scene_StartFog(color: integer; Alfa: byte; fStart, fEnd: single; density: single): boolean', nil);

    Sender.AddConstant('D3DFOG_NONE', rsInteger)^.Cv_SInt32 := ord(D3DFOG_NONE);
    Sender.AddConstant('D3DFOG_EXP', rsInteger)^.Cv_SInt32 := ord(D3DFOG_EXP);
    Sender.AddConstant('D3DFOG_EXP2', rsInteger)^.Cv_SInt32 := ord(D3DFOG_EXP2);
    Sender.AddConstant('D3DFOG_LINEAR', rsInteger)^.Cv_SInt32 := ord(D3DFOG_LINEAR);

    Sender.AddFunction(@SceneGetPositionRegProc, 'function _Scene_GetPositionX: double', nil);
    Sender.AddFunction(@SceneGetPositionRegProc, 'function _Scene_GetPositionY: double', nil);
    Sender.AddFunction(@SceneGetPositionRegProc, 'function _Scene_GetPositionZ: double', nil);
    Sender.AddFunction(@SceneGetPositionRegProc, 'procedure _Scene_GetPosition(var x, y, z: double)', nil);

    Sender.AddFunction(@SceneGetRotationRegProc, 'function _Scene_GetRotationX: double', nil);
    Sender.AddFunction(@SceneGetRotationRegProc, 'function _Scene_GetRotationY: double', nil);
    Sender.AddFunction(@SceneGetRotationRegProc, 'function _Scene_GetRotationZ: double', nil);
    Sender.AddFunction(@SceneGetRotationRegProc, 'procedure _Scene_GetRotation(var x, y, z: double)', nil);

    Sender.AddFunction(@SceneSetPositionRegProc, 'procedure _Scene_SetPosition(x, y, z: double)', nil);
    Sender.AddFunction(@SceneSetPositionRegProc, 'procedure _Scene_SetPositionX(x: double)', nil);
    Sender.AddFunction(@SceneSetPositionRegProc, 'procedure _Scene_SetPositionY(y: double)', nil);
    Sender.AddFunction(@SceneSetPositionRegProc, 'procedure _Scene_SetPositionZ(z: double)', nil);

    Sender.AddFunction(@SceneStatisticsRegProc, 'function _Scene_GetNumTriangles: integer', nil);
    Sender.AddFunction(@SceneStatisticsRegProc, 'function _Scene_GetNumVertexes: integer', nil);
    Sender.AddFunction(@SceneStatisticsRegProc, 'function _Scene_GetNumDrawnTriangles: integer', nil);
    Sender.AddFunction(@SceneStatisticsRegProc, 'function _Scene_GetNumDrawnVertexes: integer', nil);

    Sender.AddFunction(@SceneNearClippingPlaneRegProc, 'procedure _Scene_SetNearClippingPlane(clp: double)', nil);
    Sender.AddFunction(@SceneNearClippingPlaneRegProc, 'function _Scene_GetNearClippingPlane: double', nil);

    Sender.AddFunction(@SceneAmbientRegProc, 'procedure _Scene_SetAmbient(Value: Cardinal)', nil);
    Sender.AddFunction(@SceneAmbientRegProc, 'function _Scene_GetAmbient: Cardinal', nil);

    Sender.AddFunction(@SceneSetRotationRegProc, 'procedure _Scene_SetRotation(x, y, z: double)', nil);
    Sender.AddFunction(@SceneSetRotationRegProc, 'procedure _Scene_SetRotationX(x: double)', nil);
    Sender.AddFunction(@SceneSetRotationRegProc, 'procedure _Scene_SetRotationY(y: double)', nil);
    Sender.AddFunction(@SceneSetRotationRegProc, 'procedure _Scene_SetRotationZ(z: double)', nil);

{$IFNDEF NO_AVI}
    Sender.AddFunction(@SceneAVIRegProc, 'function _Scene_PlayAVI(FileName: string): boolean', nil);
    Sender.AddFunction(@SceneAVIRegProc, 'procedure _Scene_StopAVI', nil);
    Sender.AddFunction(@SceneAVIRegProc, 'function _Scene_IsPlayingAVI: boolean', nil);
{$ENDIF}

{$IFNDEF NO_D3DTEXTS}
    Sender.AddFunction(@Scene3DTextRegProc, 'procedure _Scene_Set3DText(id: integer; s: string)', nil);
    Sender.AddFunction(@Scene3DTextRegProc, 'function _Scene_Get3DText(id: integer): string', nil);
{$ENDIF}

    Sender.AddFunction(@SceneGetDistanceFromRegProc, 'function _Scene_GetDistanceFrom(x, y, z: double): double', nil);

{$IFNDEF NO_D3DSOUNDS}
    Sender.AddFunction(@SceneSoundsRegProc, 'function _Scene_GetMute: boolean', nil);
    Sender.AddFunction(@SceneSoundsRegProc, 'procedure _Scene_SetMute(value: boolean)', nil);
    Sender.AddFunction(@Scene3DSoundsRegProc, 'procedure _Scene_PlaySounds(fKey: integer);', nil);
    Sender.AddFunction(@Scene3DSoundsRegProc, 'procedure _Scene_PauseSounds(fKey: integer);', nil);
    Sender.AddFunction(@Scene3DSoundsRegProc, 'procedure _Scene_StopSounds(fKey: integer);', nil);
    Sender.AddFunction(@Scene3DSoundsRegProc, 'procedure _Scene_RewindSounds(fKey: integer);', nil);
    Sender.AddFunction(@Scene3DTonesRegProc, 'procedure _Scene_PlayTones(fKey: integer);', nil);
    Sender.AddFunction(@Scene3DTonesRegProc, 'procedure _Scene_PauseTones(fKey: integer);', nil);
    Sender.AddFunction(@Scene3DTonesRegProc, 'procedure _Scene_StopTones(fKey: integer);', nil);
{$ENDIF}

    Sender.AddFunction(@SceneGetOldPositionRegProc, 'procedure _Scene_GetOldPosition(var x, y, z: double)', nil);
    Sender.AddFunction(@SceneGetOldPositionRegProc, 'function _Scene_GetOldPositionX: double', nil);
    Sender.AddFunction(@SceneGetOldPositionRegProc, 'function _Scene_GetOldPositionY: double', nil);
    Sender.AddFunction(@SceneGetOldPositionRegProc, 'function _Scene_GetOldPositionZ: double', nil);

    Sender.AddFunction(@SceneReloadRegProc, 'procedure _Scene_Reload', nil);

    Sender.AddFunction(@SceneDeleteNonSaveAbleObjectsRegProc, 'procedure _Scene_DeleteNonSaveAbleObjects', nil);

    Sender.AddFunction(@SceneGetOldRotationRegProc, 'procedure _Scene_GetOldRotation(var x, y, z: double)', nil);
    Sender.AddFunction(@SceneGetOldRotationRegProc, 'function _Scene_GetOldRotationX: double', nil);
    Sender.AddFunction(@SceneGetOldRotationRegProc, 'function _Scene_GetOldRotationY: double', nil);
    Sender.AddFunction(@SceneGetOldRotationRegProc, 'function _Scene_GetOldRotationZ: double', nil);
                
    Sender.AddFunction(@SceneTimeRegProc, 'function _Scene_GetTime: double', nil);
    Sender.AddFunction(@SceneTimeRegProc, 'function _Scene_GetOldTime: double', nil);
    Sender.AddFunction(@SceneTimeRegProc, 'function _Scene_GetStartTime: double', nil);

    Sender.AddFunction(@ScenePlacementRegProc, 'function _Scene_GetPlacementPositionX: double', nil);
    Sender.AddFunction(@ScenePlacementRegProc, 'function _Scene_GetPlacementPositionY: double', nil);
    Sender.AddFunction(@ScenePlacementRegProc, 'function _Scene_GetPlacementPositionZ: double', nil);
    Sender.AddFunction(@ScenePlacementRegProc, 'procedure _Scene_GetPlacementPosition(var x, y, z: double)', nil);
    Sender.AddFunction(@ScenePlacementRegProc, 'function _Scene_GetPlacementRotationX: double', nil);
    Sender.AddFunction(@ScenePlacementRegProc, 'function _Scene_GetPlacementRotationY: double', nil);
    Sender.AddFunction(@ScenePlacementRegProc, 'function _Scene_GetPlacementRotationZ: double', nil);
    Sender.AddFunction(@ScenePlacementRegProc, 'procedure _Scene_GetPlacementRotation(var x, y, z: double)', nil);

    Sender.AddFunction(@SceneThreadLevelRegProc, 'function _Scene_GetThreadLevel: byte', nil);

    Sender.AddFunction(@SceneLoadRegProc, 'function _Scene_LoadFrom(s: string): boolean', nil);

    Sender.AddFunction(@SceneShowHideRegProc, 'procedure _Scene_ShowSurfaces(ID: integer; key: integer)', nil);
    Sender.AddFunction(@SceneShowHideRegProc, 'procedure _Scene_HideSurfaces(ID: integer; key: integer)', nil);

    Sender.AddFunction(@SceneCanvasFontRegProc, 'function _Scene_GetFont: string', nil);
    Sender.AddFunction(@SceneCanvasFontRegProc, 'procedure _Scene_SetFont(f: string)', nil);
    Sender.AddFunction(@SceneCanvasFontRegProc, 'function _Scene_GetTextSize: integer', nil);
    Sender.AddFunction(@SceneCanvasFontRegProc, 'procedure _Scene_SetTextSize(x: integer)', nil);
    Sender.AddFunction(@SceneCanvasFontRegProc, 'function _Scene_GetTextColor: integer', nil);
    Sender.AddFunction(@SceneCanvasFontRegProc, 'procedure _Scene_SetTextColor(c: integer)', nil);
    Sender.AddFunction(@SceneCanvasFontRegProc, 'function _Scene_GetFontCharSet: byte', nil);
    Sender.AddFunction(@SceneCanvasFontRegProc, 'procedure _Scene_SetFontCharSet(cs: byte)', nil);

    Sender.AddConstant('ANSI_CHARSET', rsByte)^.CV_UByte :=  0;
    Sender.AddConstant('DEFAULT_CHARSET', rsByte)^.CV_UByte :=  1;
    Sender.AddConstant('SYMBOL_CHARSET', rsByte)^.CV_UByte :=  2;
    Sender.AddConstant('SHIFTJIS_CHARSET', rsByte)^.CV_UByte :=  $80;
    Sender.AddConstant('HANGEUL_CHARSET', rsByte)^.CV_UByte :=  129;
    Sender.AddConstant('GB2312_CHARSET', rsByte)^.CV_UByte :=  134;
    Sender.AddConstant('CHINESEBIG5_CHARSET', rsByte)^.CV_UByte :=  136;
    Sender.AddConstant('OEM_CHARSET', rsByte)^.CV_UByte :=  255;
    Sender.AddConstant('JOHAB_CHARSET', rsByte)^.CV_UByte :=  130;
    Sender.AddConstant('HEBREW_CHARSET', rsByte)^.CV_UByte :=  177;
    Sender.AddConstant('ARABIC_CHARSET', rsByte)^.CV_UByte :=  178;
    Sender.AddConstant('GREEK_CHARSET', rsByte)^.CV_UByte :=  161;
    Sender.AddConstant('TURKISH_CHARSET', rsByte)^.CV_UByte :=  162;
    Sender.AddConstant('VIETNAMESE_CHARSET', rsByte)^.CV_UByte :=  163;
    Sender.AddConstant('THAI_CHARSET', rsByte)^.CV_UByte :=  222;
    Sender.AddConstant('EASTEUROPE_CHARSET', rsByte)^.CV_UByte :=  238;
    Sender.AddConstant('RUSSIAN_CHARSET', rsByte)^.CV_UByte :=  204;

    Sender.AddFunction(@SceneCanvasPenRegProc, 'function _Scene_GetPenColor: integer', nil);
    Sender.AddFunction(@SceneCanvasPenRegProc, 'procedure _Scene_SetPenColor(c: integer)', nil);
    Sender.AddFunction(@SceneCanvasPenRegProc, 'function _Scene_GetPenStyle: integer', nil);
    Sender.AddFunction(@SceneCanvasPenRegProc, 'procedure _Scene_SetPenStyle(s: integer)', nil);
    Sender.AddFunction(@SceneCanvasPenRegProc, 'function _Scene_GetPenMode: integer', nil);
    Sender.AddFunction(@SceneCanvasPenRegProc, 'procedure _Scene_SetPenMode(m: integer)', nil);
    Sender.AddFunction(@SceneCanvasPenRegProc, 'function _Scene_GetPenWidth: integer', nil);
    Sender.AddFunction(@SceneCanvasPenRegProc, 'procedure _Scene_SetPenWidth(w: integer)', nil);

    Sender.AddVariable('psSolid', rsInteger, True)^.Cv_SInt32 := 0;
    Sender.AddVariable('psDash', rsInteger, True)^.Cv_SInt32 := 1;
    Sender.AddVariable('psDot', rsInteger, True)^.Cv_SInt32 := 2;
    Sender.AddVariable('psDashDot', rsInteger, True)^.Cv_SInt32 := 3;
    Sender.AddVariable('psDashDotDot', rsInteger, True)^.Cv_SInt32 := 4;
    Sender.AddVariable('psClear', rsInteger, True)^.Cv_SInt32 := 5;
    Sender.AddVariable('psInsideFrame', rsInteger, True)^.Cv_SInt32 := 6;

    Sender.AddFunction(@SceneCanvasBrushRegProc, 'function _Scene_GetBrushColor: integer', nil);
    Sender.AddFunction(@SceneCanvasBrushRegProc, 'procedure _Scene_SetBrushColor(c: integer)', nil);
    Sender.AddFunction(@SceneCanvasBrushRegProc, 'function _Scene_GetBrushStyle: integer', nil);
    Sender.AddFunction(@SceneCanvasBrushRegProc, 'procedure _Scene_SetBrushStyle(s: integer)', nil);

    Sender.AddVariable('bsSolid', rsInteger, True)^.Cv_SInt32 := 0;
    Sender.AddVariable('bsClear', rsInteger, True)^.Cv_SInt32 := 1;
    Sender.AddVariable('bsHorizontal', rsInteger, True)^.Cv_SInt32 := 2;
    Sender.AddVariable('bsVertical', rsInteger, True)^.Cv_SInt32 := 3;
    Sender.AddVariable('bsFDiagonal', rsInteger, True)^.Cv_SInt32 := 4;
    Sender.AddVariable('bsBDiagonal', rsInteger, True)^.Cv_SInt32 := 5;
    Sender.AddVariable('bsCross', rsInteger, True)^.Cv_SInt32 := 6;
    Sender.AddVariable('bsDiagCross', rsInteger, True)^.Cv_SInt32 := 7;

    Sender.AddFunction(@SceneCanvasRegProc, 'procedure _Scene_TextOut(x, y: integer; s: string)', nil);
    Sender.AddFunction(@SceneCanvasRegProc, 'procedure _Scene_MoveTo(x, y: integer)', nil);
    Sender.AddFunction(@SceneCanvasRegProc, 'procedure _Scene_LineTo(x, y: integer)', nil);
    Sender.AddFunction(@SceneCanvasRegProc, 'procedure _Scene_Line(X1, Y1, X2, Y2: integer)', nil);
    Sender.AddFunction(@SceneCanvasRegProc, 'procedure _Scene_Rectangle(left, top, right, bottom: integer)', nil);
    Sender.AddFunction(@SceneCanvasRegProc, 'procedure _Scene_InvertRect(aLeft, aTop, aRight, aBottom: integer)', nil);
    Sender.AddFunction(@SceneCanvasRegProc, 'procedure _Scene_FillRect(left, top, right, bottom: integer)', nil);
    Sender.AddFunction(@SceneCanvasRegProc, 'procedure _Scene_RoundRect(X1, Y1, X2, Y2, X3, Y3: integer)', nil);
    Sender.AddFunction(@SceneCanvasRegProc, 'procedure _Scene_Ellipse(left, top, right, bottom: integer)', nil);
    Sender.AddFunction(@SceneCanvasRegProc, 'procedure _Scene_Arc(X1, Y1, X2, Y2, X3, Y3, X4, Y4: integer)', nil);
    Sender.AddFunction(@SceneCanvasRegProc, 'procedure _Scene_Chord(X1, Y1, X2, Y2, X3, Y3, X4, Y4: integer)', nil);
    Sender.AddFunction(@SceneCanvasRegProc, 'procedure _Scene_ReleaseCanvas', nil);
    Sender.AddFunction(@SceneCanvasRegProc, 'procedure _Scene_DrawFocusRect(aLeft, aTop, aRight, aBottom: integer)', nil);

    Sender.AddFunction(@SceneTextAlignRegProc, 'procedure _Scene_SetTextAlign(fMode: integer)', nil);
    Sender.AddFunction(@SceneTextAlignRegProc, 'function _Scene_GetTextAlign: integer', nil);
    Sender.AddVariable('TA_NOUPDATECP', rsInteger, True)^.Cv_SInt32 :=  0;
    Sender.AddVariable('TA_UPDATECP', rsInteger, True)^.Cv_SInt32 :=  1;
    Sender.AddVariable('TA_LEFT', rsInteger, True)^.Cv_SInt32 :=  0;
    Sender.AddVariable('TA_RIGHT', rsInteger, True)^.Cv_SInt32 :=  2;
    Sender.AddVariable('TA_CENTER', rsInteger, True)^.Cv_SInt32 :=  6;
    Sender.AddVariable('TA_TOP', rsInteger, True)^.Cv_SInt32 :=  0;
    Sender.AddVariable('TA_BOTTOM', rsInteger, True)^.Cv_SInt32 :=  8;
    Sender.AddVariable('TA_BASELINE', rsInteger, True)^.Cv_SInt32 :=  24;
    Sender.AddVariable('TA_RTLREADING', rsInteger, True)^.Cv_SInt32 :=  $100;
    Sender.AddVariable('TA_MASK', rsInteger, True)^.Cv_SInt32 :=   (TA_BASELINE+TA_CENTER+TA_UPDATECP+TA_RTLREADING);
    Sender.AddVariable('TA_DEFAULT', rsInteger, True)^.Cv_SInt32 :=  (TA_LEFT + TA_TOP + TA_NOUPDATECP);

    Sender.AddFunction(@SceneActionsRegProc, 'function _Scene_AddMover(ID, key: integer; x, y, z: double; Secs: double): integer', nil);
    Sender.AddFunction(@SceneActionsRegProc, 'function _Scene_AddRotator(ID, key: integer; dx, dy, dz: double; Secs: double): integer', nil);
    Sender.AddFunction(@SceneActionsRegProc, 'function _Scene_AddRotatorAround(ID, key: integer; x, y, z, dx, dy, dz: double; Secs: double): integer', nil);
    Sender.AddFunction(@SceneActionsRegProc, 'procedure _Scene_DeleteAction(ActionID: integer)', nil);

    Sender.AddFunction(@SceneDrawRegProc, 'procedure _Scene_Draw(x, y: integer; Texture: string)', nil);
    Sender.AddFunction(@SceneDrawRegProc, 'procedure _Scene_DrawTransparent(x, y: integer; Texture: string; c: integer)', nil);
    Sender.AddFunction(@SceneDrawRegProc, 'procedure _Scene_StretchDraw(ALeft, ATop, ARight, ABottom: integer; Texture: string)', nil);
    Sender.AddFunction(@SceneDrawRegProc, 'procedure _Scene_StretchDrawTransparent(ALeft, ATop, ARight, ABottom: integer; Texture: string; c: integer)', nil);

    Sender.AddFunction(@ScenePerformanceRegProc, 'function _Scene_GetFPS: double', nil);
    Sender.AddFunction(@ScenePerformanceRegProc, 'function _Scene_GetFPS_Smooth: double', nil);
    Sender.AddFunction(@ScenePerformanceRegProc, 'function _Scene_GetUpdateTolerance: double', nil);
    Sender.AddFunction(@ScenePerformanceRegProc, 'procedure _Scene_SetUpdateTolerance(t: double)', nil);

{$IFNDEF NO_D3DSECTORCOLLECTIONS}
    Sender.AddFunction(@SceneSectorsRegProc, 'function _Scene_GetCurrentSectorIndex: integer', nil);
    Sender.AddFunction(@SceneSectorsRegProc, 'function _Scene_GetCurrentSectorCollection: integer', nil);
{$ENDIF}

    Sender.AddFunction(@SceneGetVerRegProc, 'function FileVersionOf(fName: string): integer', nil);
    Sender.AddFunction(@SceneGetVerRegProc, 'function FileVersionStrOf(fName: string): string', nil);
    Sender.AddConstant('FILEVERSION_000', rsInteger)^.Cv_SInt32 :=    0;
    for i := 100 to FILEVERSION do
      Sender.AddConstant('FILEVERSION_' + IntToStr(i), rsInteger)^.Cv_SInt32 := i;
    Sender.AddConstant('FILEVERSION', rsInteger)^.Cv_SInt32 :=  FILEVERSION;

    Result := ENoError;
  end
  else if Name = 'PROCEDURALOBJECTS' then
  begin
{$IFNDEF NO_D3DPROCEDURALOBJECTS}
    Sender.AddFunction(@ProceduralObjectsRegProc, 'procedure pr_SetNumVertexes(fNum: integer)',nil);
    Sender.AddFunction(@ProceduralObjectsRegProc, 'function pr_GetNumVertexes: integer',nil);
    Sender.AddFunction(@ProceduralObjectsRegProc, 'procedure pr_SetVertex(i: integer; x, y, z: double; color, Specular: integer; tu, tv: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegProc, 'procedure pr_StdSetVertex(i: integer; x, y, z: double; tu, tv: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegProc, 'procedure pr_SetPrimitiveType(pr: integer)', nil);
    Sender.AddFunction(@ProceduralObjectsRegProc, 'function pr_GetPrimitiveType: integer', nil);
    Sender.AddFunction(@ProceduralObjectsRegProc, 'procedure pr_SetCull(cl: integer)', nil);
    Sender.AddFunction(@ProceduralObjectsRegProc, 'function pr_GetCull: integer', nil);
    Sender.AddFunction(@ProceduralObjectsRegProc, 'procedure pr_Execute', nil);
    Sender.AddFunction(@ProceduralObjectsRegProc, 'function pr_GetDistance: double', nil);

    Sender.AddFunction(@ProceduralObjectsDynamicManagmentProc, 'function pr_Create(x, y, z: double; dx, dy, dz: double; TextureName: string; ModuleName: string): integer', nil);
    Sender.AddFunction(@ProceduralObjectsDynamicManagmentProc, 'procedure pr_Delete(id: integer)', nil);
    Sender.AddFunction(@ProceduralObjectsDynamicManagmentProc, 'procedure pr_Hide', nil);
    Sender.AddFunction(@ProceduralObjectsDynamicManagmentProc, 'procedure pr_Show', nil);
    Sender.AddFunction(@ProceduralObjectsDynamicManagmentProc, 'function pr_IsVisible: boolean', nil);

    Sender.AddFunction(@ProceduralObjectsRegIdxProc, 'procedure pr_StdAddVertex(x, y, z: double; tu, tv: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegIdxProc, 'procedure pr_AddVertex(x, y, z: double; color, Specular: integer; tu, tv: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegIdxProc, 'procedure pr_StartVertexIndex(index: integer)', nil);
    Sender.AddFunction(@ProceduralObjectsRegIdxProc, 'procedure pr_StopVertexIndex', nil);
    Sender.AddFunction(@ProceduralObjectsRegIdxProc, 'function pr_VertexIndex: integer', nil);

    Sender.AddFunction(@ProceduralObjectsRegExProc, 'function pr_SetCurrentPrObject(id: integer): boolean', nil);
    Sender.AddFunction(@ProceduralObjectsRegExProc, 'function pr_GetCurrentPrObject: integer', nil);
    Sender.AddFunction(@ProceduralObjectsRegExProc, 'procedure pr_GetVertex(i: integer; var x, y, z: double; var color, Specular: integer; var tu, tv: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegExProc, 'procedure pr_StdGetVertex(i: integer; var x, y, z: double; var tu, tv: double)', nil);

    Sender.AddFunction(@ProceduralObjectsRegSetExProc, 'procedure pr_SetVertexX(id: integer; x: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegSetExProc, 'procedure pr_SetVertexY(id: integer; y: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegSetExProc, 'procedure pr_SetVertexZ(id: integer; z: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegSetExProc, 'procedure pr_SetVertexColor(id: integer; color: integer)', nil);
    Sender.AddFunction(@ProceduralObjectsRegSetExProc, 'procedure pr_SetVertexSpecular(id: integer; specular: integer)', nil);
    Sender.AddFunction(@ProceduralObjectsRegSetExProc, 'procedure pr_SetVertexU(id: integer; u: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegSetExProc, 'procedure pr_SetVertexV(id: integer; v: double)', nil);

    Sender.AddFunction(@ProceduralObjectsStreamingProc, 'procedure pr_SaveVertexes(fName: string)', nil);
    Sender.AddFunction(@ProceduralObjectsStreamingProc, 'procedure pr_LoadVertexes(fName: string)', nil);

    Sender.AddFunction(@ProceduralObjectsRegSpherePointsProc, 'procedure pr_AddSpherePoint(x, y: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegSpherePointsProc, 'procedure pr_StartSpherePointIndex(index: integer)', nil);
    Sender.AddFunction(@ProceduralObjectsRegSpherePointsProc, 'procedure pr_StopSpherePointIndex', nil);
    Sender.AddFunction(@ProceduralObjectsRegSpherePointsProc, 'procedure pr_SetNumSpherePoints(num: integer)', nil);
    Sender.AddFunction(@ProceduralObjectsRegSpherePointsProc, 'function pr_GetNumSpherePoints: integer', nil);
    Sender.AddFunction(@ProceduralObjectsRegSpherePointsProc, 'procedure pr_SetFlatUVParam(param: string)', nil);
    Sender.AddFunction(@ProceduralObjectsRegSpherePointsProc, 'function pr_GetFlatUVParam: string', nil);
    Sender.AddFunction(@ProceduralObjectsRegSpherePointsProc, 'procedure pr_SetSpherePointsComplexity(c: integer)', nil);
    Sender.AddFunction(@ProceduralObjectsRegSpherePointsProc, 'function pr_GetSpherePointsComplexity: integer', nil);

    Sender.AddFunction(@ProceduralObjectsRegScaleProc, 'procedure pr_ScaleX(fx: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegScaleProc, 'procedure pr_ScaleY(fy: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegScaleProc, 'procedure pr_ScaleZ(fz: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegScaleProc, 'procedure pr_Scale(fx, fy, fz: double)', nil);

    Sender.AddFunction(@ProceduralObjectsRegMoveProc, 'procedure pr_MoveX(dx: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegMoveProc, 'procedure pr_MoveY(dy: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegMoveProc, 'procedure pr_MoveZ(dz: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegMoveProc, 'procedure pr_Move(dx, dy, dz: double)', nil);

    Sender.AddFunction(@ProceduralObjectsRegRotateProc, 'procedure pr_RotateX(dx: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegRotateProc, 'procedure pr_RotateY(dy: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegRotateProc, 'procedure pr_RotateZ(dz: double)', nil);
    Sender.AddFunction(@ProceduralObjectsRegRotateProc, 'procedure pr_Rotate(dx, dy, dz: double)', nil);

    Sender.AddFunction(@ProceduralObjectsRegGetExProc, 'function pr_GetVertexX(id: integer): double', nil);
    Sender.AddFunction(@ProceduralObjectsRegGetExProc, 'function pr_GetVertexY(id: integer): double', nil);
    Sender.AddFunction(@ProceduralObjectsRegGetExProc, 'function pr_GetVertexZ(id: integer): double', nil);
    Sender.AddFunction(@ProceduralObjectsRegGetExProc, 'function pr_GetVertexColor(id: integer): integer', nil);
    Sender.AddFunction(@ProceduralObjectsRegGetExProc, 'function pr_GetVertexSpecular(id: integer): integer', nil);
    Sender.AddFunction(@ProceduralObjectsRegGetExProc, 'function pr_GetVertexU(id: integer): double', nil);
    Sender.AddFunction(@ProceduralObjectsRegGetExProc, 'function pr_GetVertexV(id: integer): double', nil);
{$ENDIF}
    Result := ENoError;
  end
  else if Name = 'MULTIMEDIA' then
  begin
    RegisterMultimediaLibrary(Sender);
    Result := ENoError;
  end
  else if Name = 'FORMS' then
  begin
    RegisterFormsLibrary(Sender);
    RegisterStdControlsLibrary(Sender);

    if Sender.UsesExist('SCENE') then
      RegisterDXImage(Sender);

    Result := ENoError;
  end                             
  else if Name = 'DIALOGS' then
  begin
    RegisterDelphiFunction(Sender, 'procedure ShowMessage(Msg: string);', @ShowMessage);
    RegisterDelphiFunction(Sender, 'function SelectDirectory(Caption: string; Root: String; var Directory: string): boolean;', @_SelectDirectory);

    RegisterDelphiFunction(Sender, 'function GetColorDialog(var c: Integer): boolean;', @_GetColorDialog);
    RegisterDelphiFunction(Sender, 'function GetColorDialogFullOpen(var c: Integer): boolean;', @_GetColorDialogFullOpen);

    RegisterDelphiFunction(Sender, 'function GetOpenFileDialog(aTitle, aFilter: string; var aFileName: string): boolean;', @_GetOpenFileDialog);
    RegisterDelphiFunction(Sender, 'function GetSaveFileDialog(aTitle, aFilter: string; var aFileName: string): boolean;', @_GetSaveFileDialog);

    Result := ENoError;
  end
  else
    Result := AddUnit(Name);
end;

// *** TTextStringList ***

destructor TTextStringList.Destroy;
var
  i: integer;
begin
  for i := 0 to Count - 1 do
    Objects[i].Free;
  Inherited;
end;

function TTextStringList.AddText(s: string; t: string): boolean;
var
  i: integer;
begin
  Result := False;
// ׀סןףטפןץלו פן םן ףפןיקון לםן פבם הום ץנסקוי ףפחם כףפב.
  for i := 0 to Count - 1 do
    if UpperCase(Trim(s)) = UpperCase(Trim(Strings[i])) then
      Exit;
  Add(s);
  Objects[IndexOf(s)] := TDXStringList.Create;
  (Objects[IndexOf(s)] as TDXStringList).Text := t;
  Result := True;
end;

function TTextStringList.Text(i: integer): string;
begin
  Result := '';
  if (i < Count) and (i >=0) then
    if Assigned(Objects[i]) then
      if Objects[i] is TDXStringList then
        Result := (Objects[i] as TDXStringList).Text
end;

function TTextStringList.Text(s: string): string;
begin
  Result := Text(IndexOf(s));
end;

// *** TD3DSceneScriptEngine ***

constructor TD3DSceneScriptEngine.Create(id: Pointer; aScene: TD3DScene; aParent: TD3DSceneScriptEngine = nil);
begin
// ֱם וםבי fParent <> nil, פפו קוי החליןץסדחטו בנ םב ככן instance פןץ
// TD3DSceneScriptEngine, טב קסחףילןנןיחףןץלו פב TTextStringLists פןץ
// TD3DSceneScriptEngine נןץ לבע החלין‎סדחףו
  fParent := aParent;
  LastLine := 0;
  fScene := aScene;
  fRequiredUses := TDXStringList.Create;
{$IFDEF DESIGNER}
  if fParent = nil then
  begin
    fVariablesDeclarations := TTextStringList.Create;
    fConstantsDeclarations := TTextStringList.Create;
    fFunctionsDeclarations := TTextStringList.Create;
    fClassFunctionsDeclarations := TTextStringList.Create;
    fTypesDeclarations := TTextStringList.Create;
    fTypesExDeclarations := TTextStringList.Create;
    fClassesDeclarations := TTextStringList.Create;
  end
  else
  begin
    fVariablesDeclarations := fParent.fVariablesDeclarations;
    fConstantsDeclarations := fParent.fConstantsDeclarations;
    fFunctionsDeclarations := fParent.fFunctionsDeclarations;
    fClassFunctionsDeclarations := fParent.fClassFunctionsDeclarations;
    fTypesDeclarations := fParent.fTypesDeclarations;
    fTypesExDeclarations := fParent.fTypesExDeclarations;
    fClassesDeclarations := fParent.fClassesDeclarations;
  end;
{$ENDIF}
  Inherited Create(id);
  MaxBeginNesting := 1024;  // פי ףבם stack
{$IFDEF DESIGNER}
  Yield := 2048;  // Give background proccesing in Designer
{$ELSE}
  Yield := $FFFF;
{$ENDIF}
  OnExternal := DllExternalProc;
  OnUses := OnUsesProc;
  OnRunLine := OnRunLineProc;
end;

constructor TD3DSceneScriptEngine.CreateAttached(id: Pointer; aD3DSceneScriptEngine: TD3DSceneScriptEngine);
begin
  Create(id, aD3DSceneScriptEngine.Scene, aD3DSceneScriptEngine);
end;

destructor TD3DSceneScriptEngine.Destroy;
begin
  StopRun;
// ֱנוכוץטוס‏םןץלו פב TTextStringList לםן פבם fParent <> nil,
// היבצןסופיך טב פב בנוכוץטוס‏ףוי פן fParent
{$IFDEF DESIGNER}
  if fParent <> nil then
  begin
    fVariablesDeclarations.Free;
    fConstantsDeclarations.Free;
    fFunctionsDeclarations.Free;
    fClassFunctionsDeclarations.Free;
    fTypesDeclarations.Free;
    fTypesExDeclarations.Free;
    fClassesDeclarations.Free;
  end;
{$ENDIF}
  Inherited;
  fRequiredUses.Free;
end;

const
  rsPreprocessor = 'PREPROCESSOR';
  rsFmtRequiredPos = '%s=%d';
  rsInclude = '{$INCLUDE ';
  rsPCCCanNotFindInclude = '$INCLUDE: File [%s] not found';
  rsMaxBeginNesting = '{$MAXBEGINNESTING ';
  rsPCCInvalidMaxBeginNesting = '$MAXBEGINNESTING: [%s] is not a valid number in [%d..%d]';
  rsYIELD = '{$YIELD ';
  rsPCCInvalidYIELD = '$YIELD: [%s] is not a valid number in [%d..%d]';
  rsRequiredUses = '{$REQUIRES ';
  rsPCCRequiredUnitNotUsed = '$REQUIRES: Unit [%s] not found in declaration list';
  rsPCCBracketExpected = '"}" expected';
  rsSCENEX = 'SCENEX';

function TD3DSceneScriptEngine.PreProcessCode(var data: string): integer;
var
  s: TDXStringList;
  i, j: integer;
  token: string;
  line: string;
  tmp: integer;
begin
  Result := 0;
  s := TDXStringList.Create;
  try
    s.Text := data;
    for i := 0 to s.Count - 1 do
    begin
      token := UpperCase(Trim(s[i]));

      line := Copy(token, 1, Length(rsInclude));
      if line = rsInclude then
      begin
        if Token[Length(Token)] = '}' then
        begin
          token := Trim(Copy(token, Length(rsInclude) + 1, Length(token) - Length(rsInclude) - 1));

          // ֵיהיך לופבקוסחףח דיב פן SceneX, בצן‎ ככבמו בנ Include ךבי דיםו ךבםןםיך לןםהב.
          if UpperCase(token) = rsSCENEX then
            FUses.Add(token)
          else
          begin
            line := fScene.GetScriptText(token);

            if Line = '' then // ִום גסטחךו פן בסקון INCLUDE
            begin
              fScene.DoScriptWarning(self, ModuleName, GetPos(data, i) + Length(rsInclude) + 2,
                Format(rsPCCCanNotFindInclude, [token]));
            end
            else
            begin // װן בסקון INCLUDE גסטחךו, פן גזןץלו ףפן script
              inc(Result);
              PreProcessCode(line);
              for j := 1 to Length(line) do
                if line[j] in [#10, #13] then
                  line[j] := ' ';
              s[i] := line;
            end;

          end
        end
        else
          fScene.DoScriptWarning(self, ModuleName, GetPos(data, i + 1) - 1,
            Format(rsPCCBracketExpected, [token]));
      end;

      line := Copy(token, 1, Length(rsMaxBeginNesting));
      if line = rsMaxBeginNesting then
      begin
        if Token[Length(Token)] = '}' then
        begin
          token := Trim(Copy(token, Length(rsMaxBeginNesting) + 1, Length(token) - Length(rsMaxBeginNesting) - 1));
          tmp := StrToIntDef(token, -1);
          if (tmp > 0) then
            MaxBeginNesting := tmp
          else
            fScene.DoScriptWarning(self, ModuleName, GetPos(data, i) + Length(rsMaxBeginNesting) + 2,
              Format(rsPCCInvalidMaxBeginNesting, [token, 1, MaxInt]));
        end
        else
          fScene.DoScriptWarning(self, ModuleName, GetPos(data, i + 1) - 1,
            Format(rsPCCBracketExpected, [token]));
      end;

      line := Copy(token, 1, Length(rsYIELD));
      if line = rsYIELD then
      begin
        if Token[Length(Token)] = '}' then
        begin
          token := Trim(Copy(token, Length(rsYIELD) + 1, Length(token) - Length(rsYIELD) - 1));
          tmp := StrToIntDef(token, -1);
          if (tmp >= 0) and (tmp <= $FFFF) then
            Yield := tmp
          else
            fScene.DoScriptWarning(self, ModuleName, GetPos(data, i) + Length(rsYIELD) + 2,
              Format(rsPCCInvalidYIELD, [token, 0, $FFFF]));
        end
        else
          fScene.DoScriptWarning(self, ModuleName, GetPos(data, i + 1) - 1,
            Format(rsPCCBracketExpected, [token]));
      end;

      line := Copy(token, 1, Length(rsRequiredUses)); // Required Uses
      if line = rsRequiredUses then
      begin
        if Token[Length(Token)] = '}' then
        begin
          token := Trim(Copy(token, Length(rsRequiredUses) + 1, Length(token) - Length(rsRequiredUses) - 1));
          if fRequiredUses.IndexOfName(token) = -1 then
            fRequiredUses.Add(
            Format(rsFmtRequiredPos, [token, GetPos(data, i) + Length(rsRequiredUses) + 2]));
        end
        else
          fScene.DoScriptWarning(self, ModuleName, GetPos(data, i + 1) - 1,
            Format(rsPCCBracketExpected, [token]));
      end;

    end;
    if Result <> 0 then
      data := s.Text;
  finally
    s.Free;
  end;
end;

function TD3DSceneScriptEngine.ProcessUses: Boolean;
var
  i, j: integer;
  found: boolean;
begin
  Result := Inherited ProcessUses;
  for i := 0 to fRequiredUses.Count - 1 do
  begin
    found := False;
    for j := 0 to fUses.Count - 1 do
    begin
      if not found then
        if fRequiredUses.Names[i] = fUses.GetItem(j) then
          found := True;
    end;
    if not found then
      fScene.DoScriptWarning(self, ModuleName, StrToInt(fRequiredUses.Values[fRequiredUses.Names[i]]),
        Format(rsPCCRequiredUnitNotUsed, [fRequiredUses.Names[i]]));
  end;
end;

procedure TD3DSceneScriptEngine.SetText(const Data: string);
var
  pp: integer;
begin
  fRequiredUses.Clear;
  Script := Data;
  repeat
    pp := PreProcessCode(Script);
  until (pp = 0) or (pp = MaxBeginNesting);
  if pp <> 0 then
    RunError(Self, EOutOfMemoryError)
  else
    Inherited SetText(Script);
end;

const
  rsScriptIsRunning = 'Script is running.';
  rsScriptFinished = 'Script finished, no errors.';
  rsSyntaxCheckIsRunning = 'Starting syntax check.';
  rsSyntaxCheckFinished = 'Syntax check finished, no errors.';

procedure TD3DSceneScriptEngine.RunUnit(name: string);
begin
  RunCode(fScene.GetScriptText(name));
end;

procedure TD3DSceneScriptEngine.DoRunCode(code: string);
var
  se: TD3DSceneScriptEngine;
begin
  se := TD3DSceneScriptEngine.Create(nil, fScene);
  try
    if Assigned(fScene) then
      fScene.CurrentScriptEngine := se;
    se.SetText(code);
    if se.ErrorCode <= ENoError then
    begin
      if Assigned(fScene) then
        fScene.DoScriptMessage(self, rsScriptIsRunning);
      se.RunScript;
    end;
    if Assigned(fScene) then
    begin
      if se.ErrorCode <= ENoError then
        fScene.DoScriptMessage(self, rsScriptFinished)
      else
        fScene.DoScriptError(self, se.ErrorModule, se.ErrorPos,
          ErrorToString(se.ErrorCode, se.ErrorString));
    end;
  finally
    if Assigned(fScene) then
    begin
      fScene.iStatus := iStopped;
      fScene.CurrentScriptEngine := self;
    end;
    se.Cleanup;
    se.Free;
  end;
end;

procedure TD3DSceneScriptEngine.RunCode(code: string);
begin
  if fScene.iStatus = iStepOverWaiting then
    fScene.iStatus := IRunning;
  if fScene.iStatus = iStopped then
  begin
    fScene.iStatus := iRunning;
    DoRunCode(code);
  end;
end;

procedure TD3DSceneScriptEngine.RegisterIntegerConstants(const ModuleName: string);
var
  s: TDXStringList;
  i: integer;
begin
  s := TDXStringList.Create;
  try
    s.Text := fScene.GetScriptText(ModuleName);
    for i := 0 to s.Count - 1 do
      AddConstant(s.Names[i], rsInteger)^.CV_SInt32 := StrToInt(s.Values[s.Names[i]]);
  finally
    s.Free;
  end;
end;

procedure TD3DSceneScriptEngine.RunProcedure(procName: string; DispatchError: boolean);
var
  p: PProcedure;
  v: PVariableManager;
begin
  if (Script <> '') and (procName <> '') then
  begin
    p := GetFunction(procName);
    if p <> nil then
    begin
      v := VM_Create;
      DestroyCajVariant(RunScriptProc(p, v));
      VM_Destroy(v);
    end
    else
      if DispatchError then
        if Assigned(fScene) then
          fScene.DoScriptError(self, ErrorModule, ErrorPos,
            ErrorToString(ErrorCode, ErrorString));
  end;
end;

procedure TD3DSceneScriptEngine.SyntaxCheckUnit(name: string);
begin
  SyntaxCheckCode(fScene.GetScriptText(name));
end;

procedure TD3DSceneScriptEngine.SyntaxCheckCode(code: string);
var
  se: TD3DSceneScriptEngine;
begin
  se := TD3DSceneScriptEngine.Create(nil, fScene);
  try
    if Assigned(fScene) then
    begin
      fScene.CurrentScriptEngine := se;
      fScene.DoScriptMessage(self, rsSyntaxCheckIsRunning);
    end;
    se.SetText(code);
    if Assigned(fScene) then
    begin
      if se.ErrorCode <= ENoError then
        fScene.DoScriptMessage(self, rsSyntaxCheckFinished)
      else
        fScene.DoScriptError(self, se.ErrorModule, se.ErrorPos,
          ErrorToString(se.ErrorCode, se.ErrorString));
    end;
  finally
    if Assigned(fScene) then
    begin
      fScene.iStatus := iStopped;
      fScene.CurrentScriptEngine := self;
    end;
    se.Cleanup;
    se.Free;
  end;
end;

procedure TD3DSceneScriptEngine.StepOverUnit(name: string);
begin
  StepOverCode(fScene.GetScriptText(name));
end;

procedure TD3DSceneScriptEngine.StepOverCode(code: string);
begin
  if fScene.iStatus = iStepOverWaiting then
    fScene.iStatus := iStepOver;
  if fScene.iStatus = iStopped then
  begin
    fScene.iStatus := iStepOver;
    DoRunCode(code);
  end;
end;

procedure TD3DSceneScriptEngine.StopRun;
begin
  fScene.iStatus := iStopped;
end;

// *** Debuging & Documentation routines ****

{$IFDEF DESIGNER}
function IfVariantToStr(const iv: PIfVariant): string;
const
  BoolChars: array[Boolean] of string = ('False', 'True');
var
  i: integer;
begin
  Result := '';
  if IsIntegerType(iv) then
    Result := IntToStr(GetInteger(iv))
  else if IsRealType(iv) then
    Result := FloatToStr(GetReal(iv))
  else if IsStringType(iv) then
    Result := GetString(iv)
  else if iv.VType.atypeid = CSV_Bool then
    Result := BoolChars[GetBoolean(iv)]
  else if iv.VType.atypeid = CSV_Array then
  begin
    Result := '[';
    for i := 0 to Longint(iv.CV_ArrItems.Count) - 1 do
    begin
      Result := Result + IfVariantToStr(PIfVariant(iv.CV_ArrItems.GetItem(i)));
      if i < Longint(iv.CV_ArrItems.Count) - 1 then
        Result := Result + ', ';
    end;
    Result := Result + ']';
  end
  else if iv.VType.atypeid = CSV_Record then
  begin
    Result := '(';
    for i := 0 to Longint(iv.CV_RecItems.Count) - 1 do
    begin
      Result := Result + IfVariantToStr(PIfVariant(iv.CV_RecItems.GetItem(i)));
      if i < Longint(iv.CV_RecItems.Count) - 1 then
        Result := Result + ', ';
    end;
    Result := Result + ')';
  end
  else
    Result := '()';
end;

function TD3DSceneScriptEngine.GetVariableValue(VarName: string): string;
var
  i: integer;
  cVar: string;
begin
  Result := fVariablesDeclarations.Text(VarName);
  if Result = '' then
  begin
    cVar := UpperCase(Trim(VarName));
    for i := 0 to Variables.Count - 1 do
      if cVar = Trim(UpperCase(PIFNamedVariable(Variables.GetItem(i)).Name)) then
      begin
        Result := IfVariantToStr(PIFNamedVariable(Variables.GetItem(i)).FVar);
        Exit;
      end;
  end;
end;

function TD3DSceneScriptEngine.GetVariableType(VarName: string): string;
var
  i: integer;
  cVar: string;
begin
  Result := fVariablesDeclarations.Text(VarName);
  if Result = '' then
  begin
    cVar := UpperCase(Trim(VarName));
    for i := 0 to Variables.Count - 1 do
      if cVar = Trim(UpperCase(PIFNamedVariable(Variables.GetItem(i)).Name)) then
      begin
        Result := PIFNamedVariable(Variables.GetItem(i)).FVar.VType.Ident;
        if Result = '' then
        begin
          if PIFNamedVariable(Variables.GetItem(i)).FVar.VType.atypeid = CSV_Array then
            Result := 'ARRAY'
          else if PIFNamedVariable(Variables.GetItem(i)).FVar.VType.atypeid = CSV_Record then
            Result := 'RECORD'
          else if PIFNamedVariable(Variables.GetItem(i)).FVar.VType.atypeid = CSV_Class then
            Result := 'CLASS'
          else if PIFNamedVariable(Variables.GetItem(i)).FVar.VType.atypeid = CSV_ClassRef then
            Result := 'CLASS REFERENCE'
          else if PIFNamedVariable(Variables.GetItem(i)).FVar.VType.atypeid = CSV_ProcVariable then
            Result := 'PROCEDURE'
          else if PIFNamedVariable(Variables.GetItem(i)).FVar.VType.atypeid = CSV_ExternalObject then
            Result := 'EXTERNAL OBJECT';
        end;
        Exit;
      end;
  end;
end;

// ׀סןףטפוי ףפן s פיע החכ‏ףויע לופבגכחפ‏ם (var)
procedure TD3DSceneScriptEngine.GetVariablesDeclarations(s: TDXStringList);
var
  i: integer;
  cVar: string;

  procedure AddIt;
  var
    j: integer;
  begin
    cVar := Trim(UpperCase(PIFNamedVariable(Variables.GetItem(i)).Name));
    if cVar <> '' then
    begin
      for j := 0 to s.Count - 1 do
        if Trim(UpperCase(s.Strings[j])) = cVar then
          Exit;
        s.Add(Trim(PIFNamedVariable(Variables.GetItem(i)).Name));
    end;
  end;

begin
  s.AddStrings(fVariablesDeclarations);
  for i := 0 to Variables.Count - 1 do
    if (PIFNamedVariable(Variables.GetItem(i)).FVar.Flags = 0) then
      AddIt;
end;

// ֵניףפסצוי פחם הכשףח פחע לופבגכחפע s
function TD3DSceneScriptEngine.GetVariableDeclaration(s: string): string;
begin
  Result := fVariablesDeclarations.Text(s);
end;

function TD3DSceneScriptEngine.GetConstantValue(VarName: string): string;
var
  i: integer;
  cVar: string;
begin
  Result := fVariablesDeclarations.Text(VarName);
  if Result = '' then
  begin
    cVar := UpperCase(Trim(VarName));
    for i := 0 to Constants.Count - 1 do // ֱסקיך רקםוי ףפחם כףפב לו פיע ףפבטוסע
      if cVar = Trim(UpperCase(PIFNamedVariable(Constants.GetItem(i)).Name)) then
      begin
        Result := IfVariantToStr(PIFNamedVariable(Constants.GetItem(i)).FVar);
        Exit;
      end;

    for i := 0 to Variables.Count - 1 do
      if cVar = Trim(UpperCase(PIFNamedVariable(Variables.GetItem(i)).Name)) then
      begin
        Result := IfVariantToStr(PIFNamedVariable(Variables.GetItem(i)).FVar);
        Exit;
      end;
  end;
end;

function TD3DSceneScriptEngine.GetConstantType(VarName: string): string;
var
  i: integer;
  cVar: string;
begin
  Result := fVariablesDeclarations.Text(VarName);
  if Result = '' then
  begin
    cVar := UpperCase(Trim(VarName));
    for i := 0 to Constants.Count - 1 do
      if cVar = Trim(UpperCase(PIFNamedVariable(Constants.GetItem(i)).Name)) then
      begin
        Result := PIFNamedVariable(Constants.GetItem(i)).FVar.VType.Ident;
        Exit;
      end;

    for i := 0 to Variables.Count - 1 do
      if cVar = Trim(UpperCase(PIFNamedVariable(Variables.GetItem(i)).Name)) then
      begin
        Result := PIFNamedVariable(Variables.GetItem(i)).FVar.VType.Ident;
        Exit;
      end;
  end;
end;

// ׀סןףטפוי ףפן s פיע החכ‏ףויע ףפבטוס‏ם פיל‏ם (const)
procedure TD3DSceneScriptEngine.GetConstantsDeclarations(s: TDXStringList);
var
  i: integer;
  cConst: string;

  procedure AddIt;
  var
    j: integer;
  begin
    cConst := Trim(UpperCase(PIFNamedVariable(Variables.GetItem(i)).Name));
    if cConst <> '' then
    begin
      for j := 0 to s.Count - 1 do
        if Trim(UpperCase(s.Strings[j])) = cConst then
          Exit;
        s.Add(Trim(PIFNamedVariable(Variables.GetItem(i)).Name));
    end;
  end;

begin
  s.AddStrings(fConstantsDeclarations);
  for i := 0 to Variables.Count - 1 do
    if (PIFNamedVariable(Variables.GetItem(i)).FVar.Flags {and 1)} = 1) then
      AddIt;
end;

// ֵניףפסצוי פחם הכשףח פחע ףפבטוסע s
function TD3DSceneScriptEngine.GetConstantDeclaration(s: string): string;
begin
  Result := fConstantsDeclarations.Text(s);
end;

// ׀סןףטפוי ףפן s פיע החכ‏ףויע ףץםבספףושם (procedure / function)
procedure TD3DSceneScriptEngine.GetFunctionsDeclarations(s: TDXStringList);
begin
  s.AddStrings(fFunctionsDeclarations);
end;

const
  rsConstructor = 'Constructor';
  rsDestructor = 'Destructor';

// ֵניףפסצוי פחם הכשףח פחע ףץםספחףחע s
function TD3DSceneScriptEngine.GetFunctionDeclaration(s: string): string;
var
  p: PProcedure;
  tmp: string;
  i: integer;
begin
  Result := fFunctionsDeclarations.Text(s);
  tmp := Result;
  RFw(tmp);
  for i := 1 to Length(tmp) do
  begin
    if tmp[i] in ['(', ';', ':', #13, #10] then
    begin
      SetLength(tmp, i - 1);
      break;
    end;
  end;
  p := Procedures.GetItem(Procedures.Find('!' + FastUpperCase(tmp)));
  if p <> nil then
  begin
    if p^.Flags = p^.Flags or $40 then // constructor
    begin
      RFw(Result);
      Result := rsConstructor + ' ' + Result;
    end
    else if p^.Flags = p^.Flags or $80 then // destructor
    begin
      RFw(Result);
      Result := rsDestructor + ' ' + Result
    end
  end;
end;

procedure TD3DSceneScriptEngine.GetClassFunctionsDeclarations(s: TDXStringList);
begin
  s.AddStrings(fClassFunctionsDeclarations);
end;

// ׀סןףטפוי ףפן s פיע החכ‏ףויע ֱװִ (פ‎נשם הוהןלםשם) (type)
procedure TD3DSceneScriptEngine.GetTypesDeclarations(s: TDXStringList);
var
  i: integer;
  cType: string;

  procedure AddIt;
  var
    j: integer;
  begin
    cType := Trim(UpperCase(PTypeRec(Types.GetItem(i)).Ident));
    if cType <> '' then
    begin
      for j := 0 to s.Count - 1 do
        if Trim(UpperCase(s.Strings[j])) = cType then
          Exit;
      s.Add(Trim(PTypeRec(Types.GetItem(i)).Ident));
    end;
  end;

begin
  s.AddStrings(fTypesDeclarations);
  for i := 0 to Types.Count - 1 do
    if PTypeRec(Types.GetItem(i)).atypeid <> CSV_Class then
      AddIt;
//  s.AddStrings(fTypesExDeclarations); /////////// ????????????????????
end;

// ֵניףפסצוי פחם הכשףח פןץ פ‎נןץ הוהןלשם s
function TD3DSceneScriptEngine.GetTypeDeclaration(s: string): string;
begin
  Result := fTypesDeclarations.Text(s);
end;

procedure TD3DSceneScriptEngine.GetTypesExDeclarations(s: TDXStringList);
begin
  s.AddStrings(fTypesExDeclarations);
end;

// ׀סןףטפוי ףפן s פיע החכ‏ףויע ךכףושם (class)
procedure TD3DSceneScriptEngine.GetClassesDeclarations(s: TDXStringList);
var
  i: integer;
  cType: string;

  procedure AddIt;
  var
    j: integer;
  begin
    cType := Trim(UpperCase(PTypeRec(Types.GetItem(i)).Ident));
    if cType <> '' then
    begin
      for j := 0 to s.Count - 1 do
        if Trim(UpperCase(s.Strings[j])) = cType then
          Exit;
      s.Add(Trim(PTypeRec(Types.GetItem(i)).Ident));
    end;
  end;

begin
  s.AddStrings(fClassesDeclarations);
  for i := 0 to Types.Count - 1 do
    if PTypeRec(Types.GetItem(i)).atypeid = CSV_Class then
      AddIt;
end;

// ֵניףפסצוי פחם הכשףח פחע ךכףחע s
function TD3DSceneScriptEngine.GetClassDeclaration(s: string): string;
begin
  Result := fClassesDeclarations.Text(s);
end;

function TD3DSceneScriptEngine.AddVariable(Name, FType: string; Constant: Boolean): PIfVariant;
begin
  Result := Inherited AddVariable(Name, FType, Constant);
  if Result <> nil then
  begin
    if Constant then
      fConstantsDeclarations.AddText(Name, FType)
    else
      fVariablesDeclarations.AddText(Name, FType)
  end;
end;

function TD3DSceneScriptEngine.AddFunction(proc: Pointer; Decl: string; Ext: Pointer): PProcedure;
begin
  Result := Inherited AddFunction(proc, Decl, Ext);
  if Result <> nil then
  begin
{    if Ext <> nil then
      fClassFunctionsDeclarations.AddText(Result.Name, Decl)
    else}
      fFunctionsDeclarations.AddText(Result.Name, Decl)
  end;
end;

function TD3DSceneScriptEngine.AddClassFunction(Proc: TRegisteredProcObject; Decl: string; Ext: Pointer): PProcedure;
begin
  Result := Inherited AddClassFunction(Proc, Decl, Ext);
  if Result <> nil then
    fClassFunctionsDeclarations.AddText(Decl, '');
end;

function TD3DSceneScriptEngine.AddType(const Name, Decl: string): PTypeRec;
begin
  Result := Inherited AddType(Name, Decl);
  if Result <> nil then
    fTypesDeclarations.AddText(Name, Decl)
end;

function TD3DSceneScriptEngine.AddTypeEx(const Name: string): PTypeRec;
begin
  Result := Inherited AddTypeEx(Name);
  if Result <> nil then
    fTypesExDeclarations.AddText(Name, '');
end;

function TD3DSceneScriptEngine.AddClass(const Name, Decl: string; RegProc: Pointer): PTypeRec;
begin
  Result := Inherited AddClass(Name, Decl, RegProc);
  if Result <> nil then
    fClassesDeclarations.AddText(Name, Decl)
end;
{$ENDIF}
{$ENDIF}

{$IFNDEF NO_AVI}
exports
  FreeAviPlayer;
{$ENDIF}

initialization
{$IFNDEF NO_SCRIPTS}
  YieldCount := 0;
{$ENDIF}
  GlobalID := 0;
  ActiveScene := nil;
  D3DDXFVF_VERTEX := D3DFVF_LVERTEX;
//  D3DDXFVF_VERTEX := D3DFVF_VERTEX;

end.

